import { FileSystem } from "@effect/platform";
import { NodeFileSystem } from "@effect/platform-node";
import { Console, Effect } from "effect";
import type { Manifest } from "./manifest.ts";

// Helper to extract service name from shape ID
const extractShapeName = (shapeId: string): string => {
  const parts = shapeId.split("#");
  return parts[1] || "";
};

// Helper to convert shape name to TypeScript identifier
const toTypescriptIdentifier = (name: string): string => {
  // Remove any special characters and ensure valid TS identifier
  return name.replace(/[^a-zA-Z0-9]/g, "");
};

// Helper to convert to lowerCamelCase
const toLowerCamelCase = (name: string): string => {
  return name.charAt(0).toLowerCase() + name.slice(1);
};

// Generate TypeScript code for a service
const generateServiceCode = (serviceName: string, manifest: Manifest) =>
  Effect.gen(function* () {
    yield* Console.log(`üìù Generating code for ${serviceName}...`);

    // Find the service shape
    const serviceShapeEntry = Object.entries(manifest.shapes).find(
      ([_, shape]) => shape.type === "service",
    );

    if (!serviceShapeEntry) {
      yield* Effect.fail(`No service shape found for ${serviceName}`);
    }

    const serviceShape = serviceShapeEntry![1] as any;

    // Extract SDK ID and other metadata
    const sdkId =
      serviceShape.traits?.["aws.api#service"]?.sdkId || serviceName;
    const arnNamespace = serviceShape.traits?.["aws.api#service"]?.arnNamespace;
    const cloudFormationName =
      serviceShape.traits?.["aws.api#service"]?.cloudFormationName;
    const endpointPrefix =
      serviceShape.traits?.["aws.api#service"]?.endpointPrefix ||
      serviceName.toLowerCase();

    // Find the aws.protocols trait to determine the protocol
    const protocolTrait = Object.entries(serviceShape.traits || {}).find(
      ([key]) => key.startsWith("aws.protocols#"),
    );
    const protocol = protocolTrait
      ? protocolTrait[0].split("#")[1]
      : "awsJson1_0";

    // For JSON RPC protocols, we need the target prefix
    let targetPrefix = "";
    if (protocol.startsWith("awsJson")) {
      targetPrefix = (protocolTrait?.[1] as any)?.name || sdkId;
    }

    // Collect all operations
    const operations = Object.entries(manifest.shapes)
      .filter(([_, shape]) => shape.type === "operation")
      .map(([shapeId, shape]) => ({
        shapeId,
        name: extractShapeName(shapeId),
        shape: shape as any,
      }));

    // Collect all unique error shapes
    const errorShapeIds = new Set<string>();
    operations.forEach((op) => {
      (op.shape.errors || []).forEach((error: any) => {
        errorShapeIds.add(error.target);
      });
    });

    // Generate TypeScript code
    let code = `// Auto-generated by scripts/generate-clients.ts
// This file contains only TypeScript types and contributes zero runtime code
import type { Effect } from "effect";
import type { AwsErrorMeta, CommonAwsError } from "../client.ts";

// Type placeholder for inputs/outputs (to be replaced with actual types later)
type _opaque = Record<string, unknown>;

`;

    // Generate service interface first
    const serviceInterfaceName = toTypescriptIdentifier(sdkId);
    code += "// Service interface\n";
    code += `export interface ${serviceInterfaceName} {\n`;
    operations.forEach((op) => {
      const opName = toTypescriptIdentifier(op.name);
      const camelOpName = toLowerCamelCase(opName);
      code += `  ${camelOpName}(input: ${opName}.Input): Effect.Effect<${opName}.Output, ${opName}.Error>;\n`;
    });
    code += "}\n\n";

    // Generate error interfaces
    code += "// Error interfaces\n";
    errorShapeIds.forEach((errorId) => {
      const errorName = extractShapeName(errorId);
      const tsName = toTypescriptIdentifier(errorName);
      code += `export interface ${tsName} extends AwsErrorMeta { readonly _tag: "${tsName}" }\n`;
    });

    code += "\n// Operation namespaces\n";

    // Generate operation namespaces (PascalCase)
    operations.forEach((op) => {
      const opName = toTypescriptIdentifier(op.name);
      const errors = (op.shape.errors || []).map((e: any) =>
        toTypescriptIdentifier(extractShapeName(e.target)),
      );

      code += `export declare namespace ${opName} {\n`;
      code += "  export type Input = _opaque;\n";
      code += "  export type Output = _opaque;\n";
      code += "  export type Error =\n";

      if (errors.length > 0) {
        errors.forEach((err: string) => {
          code += `    | ${err}\n`;
        });
      }
      code += "    | CommonAwsError;\n";
      code += "}\n\n";
    });

    // Store metadata for the service
    const metadata = {
      sdkId,
      arnNamespace,
      cloudFormationName,
      endpointPrefix,
      protocol,
      targetPrefix,
    };

    return { code, metadata };
  });

// Generate metadata file
const generateMetadataFile = (servicesMetadata: Record<string, any>) => {
  let code = `// Auto-generated service metadata
export const serviceMetadata = {\n`;

  Object.entries(servicesMetadata).forEach(([service, meta]) => {
    code += `  "${service}": {\n`;
    code += `    sdkId: "${meta.sdkId}",\n`;
    code += `    endpointPrefix: "${meta.endpointPrefix}",\n`;
    code += `    protocol: "${meta.protocol}",\n`;
    code += `    targetPrefix: "${meta.targetPrefix}",\n`;
    code += "  },\n";
  });

  code += "} as const;\n";
  return code;
};

// Main program
const program = Effect.gen(function* () {
  yield* Console.log("üöÄ Starting AWS Client Generator...");

  const fs = yield* FileSystem.FileSystem;
  const servicesMetadata: Record<string, any> = {};

  // For now, just process DynamoDB
  const serviceName = "dynamodb";
  const manifestPath = `manifests/${serviceName}.json`;

  yield* Console.log(`üìñ Reading manifest for ${serviceName}...`);

  const manifestContent = yield* fs.readFileString(manifestPath);
  const manifest = JSON.parse(manifestContent) as Manifest;

  // Generate the code
  const { code, metadata } = yield* generateServiceCode(serviceName, manifest);
  servicesMetadata[serviceName] = metadata;

  // Create services directory
  yield* fs.makeDirectory("src/services", { recursive: true });

  // Write the generated file
  const outputPath = `src/services/${serviceName}.ts`;
  yield* fs.writeFileString(outputPath, code);

  yield* Console.log(`‚úÖ Generated ${outputPath}`);

  // Generate metadata file
  const metadataCode = generateMetadataFile(servicesMetadata);
  yield* fs.writeFileString("src/services/metadata.ts", metadataCode);
  yield* Console.log("‚úÖ Generated src/services/metadata.ts");

  yield* Console.log("‚ú® Done!");
});

// Run the program
const runnable = program.pipe(Effect.provide(NodeFileSystem.layer));

Effect.runPromise(runnable).then(
  () => console.log("‚úÖ Client generation complete"),
  (error) => console.error("‚ùå Error:", error),
);
