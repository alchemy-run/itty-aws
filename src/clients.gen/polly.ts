import { Schema} from "effect"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const LexiconNameList = Schema.Array(Schema.String);
export const SpeechMarkTypeList = Schema.Array(Schema.String);
export const DeleteLexiconInput = Schema.Struct({Name: Schema.String});
export const DeleteLexiconOutput = Schema.Struct({});
export const DescribeVoicesInput = Schema.Struct({Engine: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), IncludeAdditionalLanguageCodes: Schema.optional(Schema.Boolean), NextToken: Schema.optional(Schema.String)});
export const GetLexiconInput = Schema.Struct({Name: Schema.String});
export const GetSpeechSynthesisTaskInput = Schema.Struct({TaskId: Schema.String});
export const ListLexiconsInput = Schema.Struct({NextToken: Schema.optional(Schema.String)});
export const ListSpeechSynthesisTasksInput = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)});
export const PutLexiconInput = Schema.Struct({Name: Schema.String, Content: Schema.String});
export const PutLexiconOutput = Schema.Struct({});
export const StartSpeechSynthesisTaskInput = Schema.Struct({Engine: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), LexiconNames: Schema.optional(LexiconNameList), OutputFormat: Schema.String, OutputS3BucketName: Schema.String, OutputS3KeyPrefix: Schema.optional(Schema.String), SampleRate: Schema.optional(Schema.String), SnsTopicArn: Schema.optional(Schema.String), SpeechMarkTypes: Schema.optional(SpeechMarkTypeList), Text: Schema.String, TextType: Schema.optional(Schema.String), VoiceId: Schema.String});
export const SynthesizeSpeechInput = Schema.Struct({Engine: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), LexiconNames: Schema.optional(LexiconNameList), OutputFormat: Schema.String, SampleRate: Schema.optional(Schema.String), SpeechMarkTypes: Schema.optional(SpeechMarkTypeList), Text: Schema.String, TextType: Schema.optional(Schema.String), VoiceId: Schema.String});
export const SynthesisTask = Schema.Struct({Engine: Schema.optional(Schema.String), TaskId: Schema.optional(Schema.String), TaskStatus: Schema.optional(Schema.String), TaskStatusReason: Schema.optional(Schema.String), OutputUri: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), RequestCharacters: Schema.optional(Schema.Number), SnsTopicArn: Schema.optional(Schema.String), LexiconNames: Schema.optional(LexiconNameList), OutputFormat: Schema.optional(Schema.String), SampleRate: Schema.optional(Schema.String), SpeechMarkTypes: Schema.optional(SpeechMarkTypeList), TextType: Schema.optional(Schema.String), VoiceId: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String)});
export const SynthesisTasks = Schema.Array(SynthesisTask);
export const LexiconNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ListSpeechSynthesisTasksOutput = Schema.Struct({NextToken: Schema.optional(Schema.String), SynthesisTasks: Schema.optional(SynthesisTasks)});
export const InvalidLexiconException = Schema.Struct({message: Schema.optional(Schema.String)});
export const StartSpeechSynthesisTaskOutput = Schema.Struct({SynthesisTask: Schema.optional(SynthesisTask)});
export const SynthesizeSpeechOutput = Schema.Struct({AudioStream: Schema.optional(Body("undefined", StreamBody())), ContentType: Schema.optional(Header("Content-Type")), RequestCharacters: Schema.optional(Header("x-amzn-RequestCharacters", Schema.Number))});
export const LanguageCodeList = Schema.Array(Schema.String);
export const EngineList = Schema.Array(Schema.String);
export const Voice = Schema.Struct({Gender: Schema.optional(Schema.String), Id: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), LanguageName: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), AdditionalLanguageCodes: Schema.optional(LanguageCodeList), SupportedEngines: Schema.optional(EngineList)});
export const VoiceList = Schema.Array(Voice);
export const Lexicon = Schema.Struct({Content: Schema.optional(Schema.String), Name: Schema.optional(Schema.String)});
export const LexiconAttributes = Schema.Struct({Alphabet: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), LastModified: Schema.optional(Schema.Date), LexiconArn: Schema.optional(Schema.String), LexemesCount: Schema.optional(Schema.Number), Size: Schema.optional(Schema.Number)});
export const LexiconDescription = Schema.Struct({Name: Schema.optional(Schema.String), Attributes: Schema.optional(LexiconAttributes)});
export const LexiconDescriptionList = Schema.Array(LexiconDescription);
export const ServiceFailureException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeVoicesOutput = Schema.Struct({Voices: Schema.optional(VoiceList), NextToken: Schema.optional(Schema.String)});
export const GetLexiconOutput = Schema.Struct({Lexicon: Schema.optional(Lexicon), LexiconAttributes: Schema.optional(LexiconAttributes)});
export const GetSpeechSynthesisTaskOutput = Schema.Struct({SynthesisTask: Schema.optional(SynthesisTask)});
export const ListLexiconsOutput = Schema.Struct({Lexicons: Schema.optional(LexiconDescriptionList), NextToken: Schema.optional(Schema.String)});
export const InvalidNextTokenException = Schema.Struct({message: Schema.optional(Schema.String)});
export const LexiconSizeExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const EngineNotSupportedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidSampleRateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTaskIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaxLexemeLengthExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidS3BucketException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidSsmlException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SynthesisTaskNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaxLexiconsNumberExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidS3KeyException = Schema.Struct({message: Schema.optional(Schema.String)});
export const LanguageNotSupportedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UnsupportedPlsAlphabetException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidSnsTopicArnException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MarksNotSupportedForFormatException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UnsupportedPlsLanguageException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SsmlMarksNotSupportedForTextTypeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TextLengthExceededException = Schema.Struct({message: Schema.optional(Schema.String)});

//# Errors
export class LexiconNotFoundExceptionError extends Schema.TaggedError<LexiconNotFoundExceptionError>()("LexiconNotFoundException", LexiconNotFoundException) {};
export class InvalidLexiconExceptionError extends Schema.TaggedError<InvalidLexiconExceptionError>()("InvalidLexiconException", InvalidLexiconException) {};
export class EngineNotSupportedExceptionError extends Schema.TaggedError<EngineNotSupportedExceptionError>()("EngineNotSupportedException", EngineNotSupportedException) {};
export class ServiceFailureExceptionError extends Schema.TaggedError<ServiceFailureExceptionError>()("ServiceFailureException", ServiceFailureException) {};
export class InvalidNextTokenExceptionError extends Schema.TaggedError<InvalidNextTokenExceptionError>()("InvalidNextTokenException", InvalidNextTokenException) {};
export class LexiconSizeExceededExceptionError extends Schema.TaggedError<LexiconSizeExceededExceptionError>()("LexiconSizeExceededException", LexiconSizeExceededException) {};
export class InvalidSampleRateExceptionError extends Schema.TaggedError<InvalidSampleRateExceptionError>()("InvalidSampleRateException", InvalidSampleRateException) {};
export class InvalidTaskIdExceptionError extends Schema.TaggedError<InvalidTaskIdExceptionError>()("InvalidTaskIdException", InvalidTaskIdException) {};
export class MaxLexemeLengthExceededExceptionError extends Schema.TaggedError<MaxLexemeLengthExceededExceptionError>()("MaxLexemeLengthExceededException", MaxLexemeLengthExceededException) {};
export class InvalidS3BucketExceptionError extends Schema.TaggedError<InvalidS3BucketExceptionError>()("InvalidS3BucketException", InvalidS3BucketException) {};
export class InvalidSsmlExceptionError extends Schema.TaggedError<InvalidSsmlExceptionError>()("InvalidSsmlException", InvalidSsmlException) {};
export class SynthesisTaskNotFoundExceptionError extends Schema.TaggedError<SynthesisTaskNotFoundExceptionError>()("SynthesisTaskNotFoundException", SynthesisTaskNotFoundException) {};
export class MaxLexiconsNumberExceededExceptionError extends Schema.TaggedError<MaxLexiconsNumberExceededExceptionError>()("MaxLexiconsNumberExceededException", MaxLexiconsNumberExceededException) {};
export class InvalidS3KeyExceptionError extends Schema.TaggedError<InvalidS3KeyExceptionError>()("InvalidS3KeyException", InvalidS3KeyException) {};
export class LanguageNotSupportedExceptionError extends Schema.TaggedError<LanguageNotSupportedExceptionError>()("LanguageNotSupportedException", LanguageNotSupportedException) {};
export class UnsupportedPlsAlphabetExceptionError extends Schema.TaggedError<UnsupportedPlsAlphabetExceptionError>()("UnsupportedPlsAlphabetException", UnsupportedPlsAlphabetException) {};
export class InvalidSnsTopicArnExceptionError extends Schema.TaggedError<InvalidSnsTopicArnExceptionError>()("InvalidSnsTopicArnException", InvalidSnsTopicArnException) {};
export class MarksNotSupportedForFormatExceptionError extends Schema.TaggedError<MarksNotSupportedForFormatExceptionError>()("MarksNotSupportedForFormatException", MarksNotSupportedForFormatException) {};
export class SsmlMarksNotSupportedForTextTypeExceptionError extends Schema.TaggedError<SsmlMarksNotSupportedForTextTypeExceptionError>()("SsmlMarksNotSupportedForTextTypeException", SsmlMarksNotSupportedForTextTypeException) {};
export class UnsupportedPlsLanguageExceptionError extends Schema.TaggedError<UnsupportedPlsLanguageExceptionError>()("UnsupportedPlsLanguageException", UnsupportedPlsLanguageException) {};
export class TextLengthExceededExceptionError extends Schema.TaggedError<TextLengthExceededExceptionError>()("TextLengthExceededException", TextLengthExceededException) {};

//# Operations
export const deleteLexicon = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/lexicons/{Name}", method: "DELETE", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.DeleteLexicon" }, DeleteLexiconInput, DeleteLexiconOutput, [LexiconNotFoundExceptionError, ServiceFailureExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeVoices = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/voices", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.DescribeVoices" }, DescribeVoicesInput, DescribeVoicesOutput, [InvalidNextTokenExceptionError, ServiceFailureExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getLexicon = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/lexicons/{Name}", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.GetLexicon" }, GetLexiconInput, GetLexiconOutput, [LexiconNotFoundExceptionError, ServiceFailureExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listLexicons = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/lexicons", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.ListLexicons" }, ListLexiconsInput, ListLexiconsOutput, [InvalidNextTokenExceptionError, ServiceFailureExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listSpeechSynthesisTasks = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/synthesisTasks", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.ListSpeechSynthesisTasks" }, ListSpeechSynthesisTasksInput, ListSpeechSynthesisTasksOutput, [InvalidNextTokenExceptionError, ServiceFailureExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getSpeechSynthesisTask = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/synthesisTasks/{TaskId}", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.GetSpeechSynthesisTask" }, GetSpeechSynthesisTaskInput, GetSpeechSynthesisTaskOutput, [InvalidTaskIdExceptionError, ServiceFailureExceptionError, SynthesisTaskNotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const putLexicon = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/lexicons/{Name}", method: "PUT", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.PutLexicon" }, PutLexiconInput, PutLexiconOutput, [InvalidLexiconExceptionError, LexiconSizeExceededExceptionError, MaxLexemeLengthExceededExceptionError, MaxLexiconsNumberExceededExceptionError, ServiceFailureExceptionError, UnsupportedPlsAlphabetExceptionError, UnsupportedPlsLanguageExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const startSpeechSynthesisTask = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/synthesisTasks", method: "POST", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.StartSpeechSynthesisTask" }, StartSpeechSynthesisTaskInput, StartSpeechSynthesisTaskOutput, [EngineNotSupportedExceptionError, InvalidS3BucketExceptionError, InvalidS3KeyExceptionError, InvalidSampleRateExceptionError, InvalidSnsTopicArnExceptionError, InvalidSsmlExceptionError, LanguageNotSupportedExceptionError, LexiconNotFoundExceptionError, MarksNotSupportedForFormatExceptionError, ServiceFailureExceptionError, SsmlMarksNotSupportedForTextTypeExceptionError, TextLengthExceededExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const synthesizeSpeech = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/speech", method: "POST", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.SynthesizeSpeech" }, SynthesizeSpeechInput, SynthesizeSpeechOutput, [EngineNotSupportedExceptionError, InvalidSampleRateExceptionError, InvalidSsmlExceptionError, LanguageNotSupportedExceptionError, LexiconNotFoundExceptionError, MarksNotSupportedForFormatExceptionError, ServiceFailureExceptionError, SsmlMarksNotSupportedForTextTypeExceptionError, TextLengthExceededExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
