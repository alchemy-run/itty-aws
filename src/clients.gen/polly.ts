import { Schema} from "effect"
import { FormatXMLRequest, FormatXMLResponse, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
const LexiconNameList = Schema.Array(Schema.String)
const SpeechMarkTypeList = Schema.Array(Schema.String)
const DeleteLexiconInput = Schema.Struct({Name: Schema.String})
const DeleteLexiconOutput = Schema.Struct({})
const DescribeVoicesInput = Schema.Struct({Engine: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), IncludeAdditionalLanguageCodes: Schema.optional(Schema.Boolean), NextToken: Schema.optional(Schema.String)})
const GetLexiconInput = Schema.Struct({Name: Schema.String})
const GetSpeechSynthesisTaskInput = Schema.Struct({TaskId: Schema.String})
const ListLexiconsInput = Schema.Struct({NextToken: Schema.optional(Schema.String)})
const ListSpeechSynthesisTasksInput = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)})
const PutLexiconInput = Schema.Struct({Name: Schema.String, Content: Schema.String})
const PutLexiconOutput = Schema.Struct({})
const StartSpeechSynthesisTaskInput = Schema.Struct({Engine: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), LexiconNames: Schema.optional(LexiconNameList), OutputFormat: Schema.String, OutputS3BucketName: Schema.String, OutputS3KeyPrefix: Schema.optional(Schema.String), SampleRate: Schema.optional(Schema.String), SnsTopicArn: Schema.optional(Schema.String), SpeechMarkTypes: Schema.optional(SpeechMarkTypeList), Text: Schema.String, TextType: Schema.optional(Schema.String), VoiceId: Schema.String})
const SynthesizeSpeechInput = Schema.Struct({Engine: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), LexiconNames: Schema.optional(LexiconNameList), OutputFormat: Schema.String, SampleRate: Schema.optional(Schema.String), SpeechMarkTypes: Schema.optional(SpeechMarkTypeList), Text: Schema.String, TextType: Schema.optional(Schema.String), VoiceId: Schema.String})
const SynthesisTasks = Schema.Array(SynthesisTask)
const LexiconNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)})
const ListSpeechSynthesisTasksOutput = Schema.Struct({NextToken: Schema.optional(Schema.String), SynthesisTasks: Schema.optional(SynthesisTasks)})
const InvalidLexiconException = Schema.Struct({message: Schema.optional(Schema.String)})
const StartSpeechSynthesisTaskOutput = Schema.Struct({SynthesisTask: Schema.optional(SynthesisTask)})
const SynthesizeSpeechOutput = Schema.Struct({AudioStream: Schema.optional(Body("undefined", StreamBody())), ContentType: Schema.optional(Header("Content-Type")), RequestCharacters: Schema.optional(Header("x-amzn-RequestCharacters", Schema.Number))})
const LanguageCodeList = Schema.Array(Schema.String)
const EngineList = Schema.Array(Schema.String)
const Voice = Schema.Struct({Gender: Schema.optional(Schema.String), Id: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), LanguageName: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), AdditionalLanguageCodes: Schema.optional(LanguageCodeList), SupportedEngines: Schema.optional(EngineList)})
const VoiceList = Schema.Array(Voice)
const Lexicon = Schema.Struct({Content: Schema.optional(Schema.String), Name: Schema.optional(Schema.String)})
const LexiconAttributes = Schema.Struct({Alphabet: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), LastModified: Schema.optional(Schema.Date), LexiconArn: Schema.optional(Schema.String), LexemesCount: Schema.optional(Schema.Number), Size: Schema.optional(Schema.Number)})
const SynthesisTask = Schema.Struct({Engine: Schema.optional(Schema.String), TaskId: Schema.optional(Schema.String), TaskStatus: Schema.optional(Schema.String), TaskStatusReason: Schema.optional(Schema.String), OutputUri: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), RequestCharacters: Schema.optional(Schema.Number), SnsTopicArn: Schema.optional(Schema.String), LexiconNames: Schema.optional(LexiconNameList), OutputFormat: Schema.optional(Schema.String), SampleRate: Schema.optional(Schema.String), SpeechMarkTypes: Schema.optional(SpeechMarkTypeList), TextType: Schema.optional(Schema.String), VoiceId: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String)})
const LexiconDescription = Schema.Struct({Name: Schema.optional(Schema.String), Attributes: Schema.optional(LexiconAttributes)})
const LexiconDescriptionList = Schema.Array(LexiconDescription)
const ServiceFailureException = Schema.Struct({message: Schema.optional(Schema.String)})
export const DeleteLexicon = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/lexicons/{Name}", method: "DELETE", sdkId: "Polly", sigV4ServiceName: "polly", name: "DeleteLexicon" }, DeleteLexiconInput, DeleteLexiconOutput, Schema.Union(ErrorAnnotation("LexiconNotFoundException", LexiconNotFoundException), ErrorAnnotation("ServiceFailureException", ServiceFailureException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeVoicesOutput = Schema.Struct({Voices: Schema.optional(VoiceList), NextToken: Schema.optional(Schema.String)})
export const DescribeVoices = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/voices", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "DescribeVoices" }, DescribeVoicesInput, DescribeVoicesOutput, Schema.Union(ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("ServiceFailureException", ServiceFailureException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetLexiconOutput = Schema.Struct({Lexicon: Schema.optional(Lexicon), LexiconAttributes: Schema.optional(LexiconAttributes)})
export const GetLexicon = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/lexicons/{Name}", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "GetLexicon" }, GetLexiconInput, GetLexiconOutput, Schema.Union(ErrorAnnotation("LexiconNotFoundException", LexiconNotFoundException), ErrorAnnotation("ServiceFailureException", ServiceFailureException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetSpeechSynthesisTaskOutput = Schema.Struct({SynthesisTask: Schema.optional(SynthesisTask)})
const ListLexiconsOutput = Schema.Struct({Lexicons: Schema.optional(LexiconDescriptionList), NextToken: Schema.optional(Schema.String)})
export const ListLexicons = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/lexicons", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "ListLexicons" }, ListLexiconsInput, ListLexiconsOutput, Schema.Union(ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("ServiceFailureException", ServiceFailureException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidNextTokenException = Schema.Struct({message: Schema.optional(Schema.String)})
export const ListSpeechSynthesisTasks = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/synthesisTasks", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "ListSpeechSynthesisTasks" }, ListSpeechSynthesisTasksInput, ListSpeechSynthesisTasksOutput, Schema.Union(ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("ServiceFailureException", ServiceFailureException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const LexiconSizeExceededException = Schema.Struct({message: Schema.optional(Schema.String)})
const EngineNotSupportedException = Schema.Struct({message: Schema.optional(Schema.String)})
const InvalidSampleRateException = Schema.Struct({message: Schema.optional(Schema.String)})
const InvalidTaskIdException = Schema.Struct({message: Schema.optional(Schema.String)})
const MaxLexemeLengthExceededException = Schema.Struct({message: Schema.optional(Schema.String)})
const InvalidS3BucketException = Schema.Struct({message: Schema.optional(Schema.String)})
const InvalidSsmlException = Schema.Struct({message: Schema.optional(Schema.String)})
const SynthesisTaskNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)})
export const GetSpeechSynthesisTask = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/synthesisTasks/{TaskId}", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "GetSpeechSynthesisTask" }, GetSpeechSynthesisTaskInput, GetSpeechSynthesisTaskOutput, Schema.Union(ErrorAnnotation("InvalidTaskIdException", InvalidTaskIdException), ErrorAnnotation("ServiceFailureException", ServiceFailureException), ErrorAnnotation("SynthesisTaskNotFoundException", SynthesisTaskNotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const MaxLexiconsNumberExceededException = Schema.Struct({message: Schema.optional(Schema.String)})
const InvalidS3KeyException = Schema.Struct({message: Schema.optional(Schema.String)})
const LanguageNotSupportedException = Schema.Struct({message: Schema.optional(Schema.String)})
const UnsupportedPlsAlphabetException = Schema.Struct({message: Schema.optional(Schema.String)})
const InvalidSnsTopicArnException = Schema.Struct({message: Schema.optional(Schema.String)})
const MarksNotSupportedForFormatException = Schema.Struct({message: Schema.optional(Schema.String)})
const UnsupportedPlsLanguageException = Schema.Struct({message: Schema.optional(Schema.String)})
export const PutLexicon = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/lexicons/{Name}", method: "PUT", sdkId: "Polly", sigV4ServiceName: "polly", name: "PutLexicon" }, PutLexiconInput, PutLexiconOutput, Schema.Union(ErrorAnnotation("InvalidLexiconException", InvalidLexiconException), ErrorAnnotation("LexiconSizeExceededException", LexiconSizeExceededException), ErrorAnnotation("MaxLexemeLengthExceededException", MaxLexemeLengthExceededException), ErrorAnnotation("MaxLexiconsNumberExceededException", MaxLexiconsNumberExceededException), ErrorAnnotation("ServiceFailureException", ServiceFailureException), ErrorAnnotation("UnsupportedPlsAlphabetException", UnsupportedPlsAlphabetException), ErrorAnnotation("UnsupportedPlsLanguageException", UnsupportedPlsLanguageException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const SsmlMarksNotSupportedForTextTypeException = Schema.Struct({message: Schema.optional(Schema.String)})
export const StartSpeechSynthesisTask = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/synthesisTasks", method: "POST", sdkId: "Polly", sigV4ServiceName: "polly", name: "StartSpeechSynthesisTask" }, StartSpeechSynthesisTaskInput, StartSpeechSynthesisTaskOutput, Schema.Union(ErrorAnnotation("EngineNotSupportedException", EngineNotSupportedException), ErrorAnnotation("InvalidS3BucketException", InvalidS3BucketException), ErrorAnnotation("InvalidS3KeyException", InvalidS3KeyException), ErrorAnnotation("InvalidSampleRateException", InvalidSampleRateException), ErrorAnnotation("InvalidSnsTopicArnException", InvalidSnsTopicArnException), ErrorAnnotation("InvalidSsmlException", InvalidSsmlException), ErrorAnnotation("LanguageNotSupportedException", LanguageNotSupportedException), ErrorAnnotation("LexiconNotFoundException", LexiconNotFoundException), ErrorAnnotation("MarksNotSupportedForFormatException", MarksNotSupportedForFormatException), ErrorAnnotation("ServiceFailureException", ServiceFailureException), ErrorAnnotation("SsmlMarksNotSupportedForTextTypeException", SsmlMarksNotSupportedForTextTypeException), ErrorAnnotation("TextLengthExceededException", TextLengthExceededException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TextLengthExceededException = Schema.Struct({message: Schema.optional(Schema.String)})
export const SynthesizeSpeech = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/speech", method: "POST", sdkId: "Polly", sigV4ServiceName: "polly", name: "SynthesizeSpeech" }, SynthesizeSpeechInput, SynthesizeSpeechOutput, Schema.Union(ErrorAnnotation("EngineNotSupportedException", EngineNotSupportedException), ErrorAnnotation("InvalidSampleRateException", InvalidSampleRateException), ErrorAnnotation("InvalidSsmlException", InvalidSsmlException), ErrorAnnotation("LanguageNotSupportedException", LanguageNotSupportedException), ErrorAnnotation("LexiconNotFoundException", LexiconNotFoundException), ErrorAnnotation("MarksNotSupportedForFormatException", MarksNotSupportedForFormatException), ErrorAnnotation("ServiceFailureException", ServiceFailureException), ErrorAnnotation("SsmlMarksNotSupportedForTextTypeException", SsmlMarksNotSupportedForTextTypeException), ErrorAnnotation("TextLengthExceededException", TextLengthExceededException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
