import { Schema} from "effect"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
export const LexiconNameList = Schema.Array(Schema.String);
export const SpeechMarkTypeList = Schema.Array(Schema.String);
export const DeleteLexiconInput = Schema.Struct({Name: Schema.String});
export const DeleteLexiconOutput = Schema.Struct({});
export const DescribeVoicesInput = Schema.Struct({Engine: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), IncludeAdditionalLanguageCodes: Schema.optional(Schema.Boolean), NextToken: Schema.optional(Schema.String)});
export const GetLexiconInput = Schema.Struct({Name: Schema.String});
export const GetSpeechSynthesisTaskInput = Schema.Struct({TaskId: Schema.String});
export const ListLexiconsInput = Schema.Struct({NextToken: Schema.optional(Schema.String)});
export const ListSpeechSynthesisTasksInput = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)});
export const PutLexiconInput = Schema.Struct({Name: Schema.String, Content: Schema.String});
export const PutLexiconOutput = Schema.Struct({});
export const StartSpeechSynthesisTaskInput = Schema.Struct({Engine: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), LexiconNames: Schema.optional(LexiconNameList), OutputFormat: Schema.String, OutputS3BucketName: Schema.String, OutputS3KeyPrefix: Schema.optional(Schema.String), SampleRate: Schema.optional(Schema.String), SnsTopicArn: Schema.optional(Schema.String), SpeechMarkTypes: Schema.optional(SpeechMarkTypeList), Text: Schema.String, TextType: Schema.optional(Schema.String), VoiceId: Schema.String});
export const SynthesizeSpeechInput = Schema.Struct({Engine: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), LexiconNames: Schema.optional(LexiconNameList), OutputFormat: Schema.String, SampleRate: Schema.optional(Schema.String), SpeechMarkTypes: Schema.optional(SpeechMarkTypeList), Text: Schema.String, TextType: Schema.optional(Schema.String), VoiceId: Schema.String});
export const SynthesisTask = Schema.Struct({Engine: Schema.optional(Schema.String), TaskId: Schema.optional(Schema.String), TaskStatus: Schema.optional(Schema.String), TaskStatusReason: Schema.optional(Schema.String), OutputUri: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), RequestCharacters: Schema.optional(Schema.Number), SnsTopicArn: Schema.optional(Schema.String), LexiconNames: Schema.optional(LexiconNameList), OutputFormat: Schema.optional(Schema.String), SampleRate: Schema.optional(Schema.String), SpeechMarkTypes: Schema.optional(SpeechMarkTypeList), TextType: Schema.optional(Schema.String), VoiceId: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String)});
export const SynthesisTasks = Schema.Array(SynthesisTask);
export const LexiconNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ListSpeechSynthesisTasksOutput = Schema.Struct({NextToken: Schema.optional(Schema.String), SynthesisTasks: Schema.optional(SynthesisTasks)});
export const InvalidLexiconException = Schema.Struct({message: Schema.optional(Schema.String)});
export const StartSpeechSynthesisTaskOutput = Schema.Struct({SynthesisTask: Schema.optional(SynthesisTask)});
export const SynthesizeSpeechOutput = Schema.Struct({AudioStream: Schema.optional(Body("undefined", StreamBody())), ContentType: Schema.optional(Header("Content-Type")), RequestCharacters: Schema.optional(Header("x-amzn-RequestCharacters", Schema.Number))});
export const LanguageCodeList = Schema.Array(Schema.String);
export const EngineList = Schema.Array(Schema.String);
export const Voice = Schema.Struct({Gender: Schema.optional(Schema.String), Id: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), LanguageName: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), AdditionalLanguageCodes: Schema.optional(LanguageCodeList), SupportedEngines: Schema.optional(EngineList)});
export const VoiceList = Schema.Array(Voice);
export const Lexicon = Schema.Struct({Content: Schema.optional(Schema.String), Name: Schema.optional(Schema.String)});
export const LexiconAttributes = Schema.Struct({Alphabet: Schema.optional(Schema.String), LanguageCode: Schema.optional(Schema.String), LastModified: Schema.optional(Schema.Date), LexiconArn: Schema.optional(Schema.String), LexemesCount: Schema.optional(Schema.Number), Size: Schema.optional(Schema.Number)});
export const LexiconDescription = Schema.Struct({Name: Schema.optional(Schema.String), Attributes: Schema.optional(LexiconAttributes)});
export const LexiconDescriptionList = Schema.Array(LexiconDescription);
export const ServiceFailureException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeVoicesOutput = Schema.Struct({Voices: Schema.optional(VoiceList), NextToken: Schema.optional(Schema.String)});
export const GetLexiconOutput = Schema.Struct({Lexicon: Schema.optional(Lexicon), LexiconAttributes: Schema.optional(LexiconAttributes)});
export const GetSpeechSynthesisTaskOutput = Schema.Struct({SynthesisTask: Schema.optional(SynthesisTask)});
export const ListLexiconsOutput = Schema.Struct({Lexicons: Schema.optional(LexiconDescriptionList), NextToken: Schema.optional(Schema.String)});
export const InvalidNextTokenException = Schema.Struct({message: Schema.optional(Schema.String)});
export const LexiconSizeExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const EngineNotSupportedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidSampleRateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTaskIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaxLexemeLengthExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidS3BucketException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidSsmlException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SynthesisTaskNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaxLexiconsNumberExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidS3KeyException = Schema.Struct({message: Schema.optional(Schema.String)});
export const LanguageNotSupportedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UnsupportedPlsAlphabetException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidSnsTopicArnException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MarksNotSupportedForFormatException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UnsupportedPlsLanguageException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SsmlMarksNotSupportedForTextTypeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TextLengthExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DeleteLexicon = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/lexicons/{Name}", method: "DELETE", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.DeleteLexicon" }, DeleteLexiconInput, DeleteLexiconOutput, Schema.Union(ErrorAnnotation("LexiconNotFoundException", LexiconNotFoundException), ErrorAnnotation("ServiceFailureException", ServiceFailureException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeVoices = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/voices", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.DescribeVoices" }, DescribeVoicesInput, DescribeVoicesOutput, Schema.Union(ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("ServiceFailureException", ServiceFailureException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const GetLexicon = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/lexicons/{Name}", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.GetLexicon" }, GetLexiconInput, GetLexiconOutput, Schema.Union(ErrorAnnotation("LexiconNotFoundException", LexiconNotFoundException), ErrorAnnotation("ServiceFailureException", ServiceFailureException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListLexicons = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/lexicons", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.ListLexicons" }, ListLexiconsInput, ListLexiconsOutput, Schema.Union(ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("ServiceFailureException", ServiceFailureException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListSpeechSynthesisTasks = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/synthesisTasks", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.ListSpeechSynthesisTasks" }, ListSpeechSynthesisTasksInput, ListSpeechSynthesisTasksOutput, Schema.Union(ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("ServiceFailureException", ServiceFailureException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const GetSpeechSynthesisTask = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/synthesisTasks/{TaskId}", method: "GET", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.GetSpeechSynthesisTask" }, GetSpeechSynthesisTaskInput, GetSpeechSynthesisTaskOutput, Schema.Union(ErrorAnnotation("InvalidTaskIdException", InvalidTaskIdException), ErrorAnnotation("ServiceFailureException", ServiceFailureException), ErrorAnnotation("SynthesisTaskNotFoundException", SynthesisTaskNotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const PutLexicon = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/lexicons/{Name}", method: "PUT", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.PutLexicon" }, PutLexiconInput, PutLexiconOutput, Schema.Union(ErrorAnnotation("InvalidLexiconException", InvalidLexiconException), ErrorAnnotation("LexiconSizeExceededException", LexiconSizeExceededException), ErrorAnnotation("MaxLexemeLengthExceededException", MaxLexemeLengthExceededException), ErrorAnnotation("MaxLexiconsNumberExceededException", MaxLexiconsNumberExceededException), ErrorAnnotation("ServiceFailureException", ServiceFailureException), ErrorAnnotation("UnsupportedPlsAlphabetException", UnsupportedPlsAlphabetException), ErrorAnnotation("UnsupportedPlsLanguageException", UnsupportedPlsLanguageException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const StartSpeechSynthesisTask = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/synthesisTasks", method: "POST", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.StartSpeechSynthesisTask" }, StartSpeechSynthesisTaskInput, StartSpeechSynthesisTaskOutput, Schema.Union(ErrorAnnotation("EngineNotSupportedException", EngineNotSupportedException), ErrorAnnotation("InvalidS3BucketException", InvalidS3BucketException), ErrorAnnotation("InvalidS3KeyException", InvalidS3KeyException), ErrorAnnotation("InvalidSampleRateException", InvalidSampleRateException), ErrorAnnotation("InvalidSnsTopicArnException", InvalidSnsTopicArnException), ErrorAnnotation("InvalidSsmlException", InvalidSsmlException), ErrorAnnotation("LanguageNotSupportedException", LanguageNotSupportedException), ErrorAnnotation("LexiconNotFoundException", LexiconNotFoundException), ErrorAnnotation("MarksNotSupportedForFormatException", MarksNotSupportedForFormatException), ErrorAnnotation("ServiceFailureException", ServiceFailureException), ErrorAnnotation("SsmlMarksNotSupportedForTextTypeException", SsmlMarksNotSupportedForTextTypeException), ErrorAnnotation("TextLengthExceededException", TextLengthExceededException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const SynthesizeSpeech = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-06-10", uri: "/v1/speech", method: "POST", sdkId: "Polly", sigV4ServiceName: "polly", name: "Parrot_v1.SynthesizeSpeech" }, SynthesizeSpeechInput, SynthesizeSpeechOutput, Schema.Union(ErrorAnnotation("EngineNotSupportedException", EngineNotSupportedException), ErrorAnnotation("InvalidSampleRateException", InvalidSampleRateException), ErrorAnnotation("InvalidSsmlException", InvalidSsmlException), ErrorAnnotation("LanguageNotSupportedException", LanguageNotSupportedException), ErrorAnnotation("LexiconNotFoundException", LexiconNotFoundException), ErrorAnnotation("MarksNotSupportedForFormatException", MarksNotSupportedForFormatException), ErrorAnnotation("ServiceFailureException", ServiceFailureException), ErrorAnnotation("SsmlMarksNotSupportedForTextTypeException", SsmlMarksNotSupportedForTextTypeException), ErrorAnnotation("TextLengthExceededException", TextLengthExceededException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
