import { Schema} from "effect"
import { FormatXMLRequest, FormatXMLResponse, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
const ObjectAttributesList = Schema.Array(Schema.String)
const OptionalObjectAttributesList = Schema.Array(Schema.String)
const AbortMultipartUploadRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Path("Key", Schema.String), UploadId: Schema.String, RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), IfMatchInitiatedTime: Schema.optional(Header("x-amz-if-match-initiated-time", Schema.Date))})
const CreateMultipartUploadRequest = Schema.Struct({ACL: Schema.optional(Header("x-amz-acl")), Bucket: Path("Bucket", Schema.String), CacheControl: Schema.optional(Header("Cache-Control")), ContentDisposition: Schema.optional(Header("Content-Disposition")), ContentEncoding: Schema.optional(Header("Content-Encoding")), ContentLanguage: Schema.optional(Header("Content-Language")), ContentType: Schema.optional(Header("Content-Type")), Expires: Schema.optional(Header("Expires")), GrantFullControl: Schema.optional(Header("x-amz-grant-full-control")), GrantRead: Schema.optional(Header("x-amz-grant-read")), GrantReadACP: Schema.optional(Header("x-amz-grant-read-acp")), GrantWriteACP: Schema.optional(Header("x-amz-grant-write-acp")), Key: Path("Key", Schema.String), Metadata: Schema.optional(Metadata), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), StorageClass: Schema.optional(Header("x-amz-storage-class")), WebsiteRedirectLocation: Schema.optional(Header("x-amz-website-redirect-location")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), Tagging: Schema.optional(Header("x-amz-tagging")), ObjectLockMode: Schema.optional(Header("x-amz-object-lock-mode")), ObjectLockRetainUntilDate: Schema.optional(Header("x-amz-object-lock-retain-until-date", Schema.Date)), ObjectLockLegalHoldStatus: Schema.optional(Header("x-amz-object-lock-legal-hold")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ChecksumAlgorithm: Schema.optional(Header("x-amz-checksum-algorithm")), ChecksumType: Schema.optional(Header("x-amz-checksum-type"))})
const CreateSessionRequest = Schema.Struct({SessionMode: Schema.optional(Header("x-amz-create-session-mode")), Bucket: Path("Bucket", Schema.String), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean))})
const DeleteBucketRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucket = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucket" }, DeleteBucketRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketAnalyticsConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketAnalyticsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?analytics", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketAnalyticsConfiguration" }, DeleteBucketAnalyticsConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketCorsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketCors = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?cors", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketCors" }, DeleteBucketCorsRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketEncryptionRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketEncryption = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?encryption", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketEncryption" }, DeleteBucketEncryptionRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketIntelligentTieringConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketIntelligentTieringConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?intelligent-tiering", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketIntelligentTieringConfiguration" }, DeleteBucketIntelligentTieringConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketInventoryConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketInventoryConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?inventory", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketInventoryConfiguration" }, DeleteBucketInventoryConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketLifecycleRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketLifecycle = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?lifecycle", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketLifecycle" }, DeleteBucketLifecycleRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketMetadataConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketMetadataConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?metadataConfiguration", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketMetadataConfiguration" }, DeleteBucketMetadataConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketMetadataTableConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketMetadataTableConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?metadataTable", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketMetadataTableConfiguration" }, DeleteBucketMetadataTableConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketMetricsConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketMetricsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?metrics", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketMetricsConfiguration" }, DeleteBucketMetricsConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketOwnershipControlsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketOwnershipControls = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?ownershipControls", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketOwnershipControls" }, DeleteBucketOwnershipControlsRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketPolicyRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?policy", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketPolicy" }, DeleteBucketPolicyRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketReplicationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketReplication = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?replication", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketReplication" }, DeleteBucketReplicationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketTaggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketTagging = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?tagging", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketTagging" }, DeleteBucketTaggingRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteBucketWebsiteRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeleteBucketWebsite = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?website", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteBucketWebsite" }, DeleteBucketWebsiteRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteObjectRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Path("Key", Schema.String), MFA: Schema.optional(Header("x-amz-mfa")), VersionId: Schema.optional(Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), BypassGovernanceRetention: Schema.optional(Header("x-amz-bypass-governance-retention", Schema.Boolean)), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), IfMatch: Schema.optional(Header("If-Match")), IfMatchLastModifiedTime: Schema.optional(Header("x-amz-if-match-last-modified-time", Schema.Date)), IfMatchSize: Schema.optional(Header("x-amz-if-match-size", Schema.Number))})
const DeleteObjectTaggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const DeletePublicAccessBlockRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const DeletePublicAccessBlock = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?publicAccessBlock", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeletePublicAccessBlock" }, DeletePublicAccessBlockRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketAccelerateConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), RequestPayer: Schema.optional(Header("x-amz-request-payer"))})
const GetBucketAclRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketAnalyticsConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketCorsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketEncryptionRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketIntelligentTieringConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketInventoryConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketLifecycleConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketLocationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketLoggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketMetadataConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketMetadataTableConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketMetricsConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketNotificationConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const GetBucketNotificationConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?notification", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketNotificationConfiguration" }, GetBucketNotificationConfigurationRequest, NotificationConfiguration, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketOwnershipControlsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketPolicyRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketPolicyStatusRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketReplicationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketRequestPaymentRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketTaggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketVersioningRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetBucketWebsiteRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetObjectRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), IfMatch: Schema.optional(Header("If-Match")), IfModifiedSince: Schema.optional(Header("If-Modified-Since", Schema.Date)), IfNoneMatch: Schema.optional(Header("If-None-Match")), IfUnmodifiedSince: Schema.optional(Header("If-Unmodified-Since", Schema.Date)), Key: Path("Key", Schema.String), Range: Schema.optional(Header("Range")), ResponseCacheControl: Schema.optional(Schema.String), ResponseContentDisposition: Schema.optional(Schema.String), ResponseContentEncoding: Schema.optional(Schema.String), ResponseContentLanguage: Schema.optional(Schema.String), ResponseContentType: Schema.optional(Schema.String), ResponseExpires: Schema.optional(Schema.Date), VersionId: Schema.optional(Schema.String), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), PartNumber: Schema.optional(Schema.Number), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ChecksumMode: Schema.optional(Header("x-amz-checksum-mode"))})
const GetObjectAclRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Path("Key", Schema.String), VersionId: Schema.optional(Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetObjectAttributesRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), MaxParts: Schema.optional(Header("x-amz-max-parts", Schema.Number)), PartNumberMarker: Schema.optional(Header("x-amz-part-number-marker")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ObjectAttributes: Header("x-amz-object-attributes", ObjectAttributesList)})
const GetObjectLegalHoldRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetObjectLockConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetObjectRetentionRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetObjectTaggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), RequestPayer: Schema.optional(Header("x-amz-request-payer"))})
const GetObjectTorrentRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const GetPublicAccessBlockRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const HeadBucketRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const HeadObjectRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), IfMatch: Schema.optional(Header("If-Match")), IfModifiedSince: Schema.optional(Header("If-Modified-Since", Schema.Date)), IfNoneMatch: Schema.optional(Header("If-None-Match")), IfUnmodifiedSince: Schema.optional(Header("If-Unmodified-Since", Schema.Date)), Key: Path("Key", Schema.String), Range: Schema.optional(Header("Range")), ResponseCacheControl: Schema.optional(Schema.String), ResponseContentDisposition: Schema.optional(Schema.String), ResponseContentEncoding: Schema.optional(Schema.String), ResponseContentLanguage: Schema.optional(Schema.String), ResponseContentType: Schema.optional(Schema.String), ResponseExpires: Schema.optional(Schema.Date), VersionId: Schema.optional(Schema.String), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), PartNumber: Schema.optional(Schema.Number), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ChecksumMode: Schema.optional(Header("x-amz-checksum-mode"))})
const ListBucketAnalyticsConfigurationsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContinuationToken: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const ListBucketIntelligentTieringConfigurationsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContinuationToken: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const ListBucketInventoryConfigurationsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContinuationToken: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const ListBucketMetricsConfigurationsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContinuationToken: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const ListBucketsRequest = Schema.Struct({MaxBuckets: Schema.optional(Schema.Number), ContinuationToken: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), BucketRegion: Schema.optional(Schema.String)})
const ListDirectoryBucketsRequest = Schema.Struct({ContinuationToken: Schema.optional(Schema.String), MaxDirectoryBuckets: Schema.optional(Schema.Number)})
const ListMultipartUploadsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Delimiter: Schema.optional(Schema.String), EncodingType: Schema.optional(Schema.String), KeyMarker: Schema.optional(Schema.String), MaxUploads: Schema.optional(Schema.Number), Prefix: Schema.optional(Schema.String), UploadIdMarker: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), RequestPayer: Schema.optional(Header("x-amz-request-payer"))})
const ListObjectsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Delimiter: Schema.optional(Schema.String), EncodingType: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxKeys: Schema.optional(Schema.Number), Prefix: Schema.optional(Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), OptionalObjectAttributes: Schema.optional(Header("x-amz-optional-object-attributes", OptionalObjectAttributesList))})
const ListObjectsV2Request = Schema.Struct({Bucket: Path("Bucket", Schema.String), Delimiter: Schema.optional(Schema.String), EncodingType: Schema.optional(Schema.String), MaxKeys: Schema.optional(Schema.Number), Prefix: Schema.optional(Schema.String), ContinuationToken: Schema.optional(Schema.String), FetchOwner: Schema.optional(Schema.Boolean), StartAfter: Schema.optional(Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), OptionalObjectAttributes: Schema.optional(Header("x-amz-optional-object-attributes", OptionalObjectAttributesList))})
const ListObjectVersionsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Delimiter: Schema.optional(Schema.String), EncodingType: Schema.optional(Schema.String), KeyMarker: Schema.optional(Schema.String), MaxKeys: Schema.optional(Schema.Number), Prefix: Schema.optional(Schema.String), VersionIdMarker: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), OptionalObjectAttributes: Schema.optional(Header("x-amz-optional-object-attributes", OptionalObjectAttributesList))})
const ListPartsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Path("Key", Schema.String), MaxParts: Schema.optional(Schema.Number), PartNumberMarker: Schema.optional(Schema.String), UploadId: Schema.String, RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5"))})
const PutBucketPolicyRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ConfirmRemoveSelfBucketAccess: Schema.optional(Header("x-amz-confirm-remove-self-bucket-access", Schema.Boolean)), Policy: Body("undefined", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutBucketPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?policy", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketPolicy" }, PutBucketPolicyRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutObjectRequest = Schema.Struct({ACL: Schema.optional(Header("x-amz-acl")), Body: Schema.optional(Body("undefined", StreamBody())), Bucket: Path("Bucket", Schema.String), CacheControl: Schema.optional(Header("Cache-Control")), ContentDisposition: Schema.optional(Header("Content-Disposition")), ContentEncoding: Schema.optional(Header("Content-Encoding")), ContentLanguage: Schema.optional(Header("Content-Language")), ContentLength: Schema.optional(Header("Content-Length", Schema.Number)), ContentMD5: Schema.optional(Header("Content-MD5")), ContentType: Schema.optional(Header("Content-Type")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), Expires: Schema.optional(Header("Expires")), IfMatch: Schema.optional(Header("If-Match")), IfNoneMatch: Schema.optional(Header("If-None-Match")), GrantFullControl: Schema.optional(Header("x-amz-grant-full-control")), GrantRead: Schema.optional(Header("x-amz-grant-read")), GrantReadACP: Schema.optional(Header("x-amz-grant-read-acp")), GrantWriteACP: Schema.optional(Header("x-amz-grant-write-acp")), Key: Path("Key", Schema.String), WriteOffsetBytes: Schema.optional(Header("x-amz-write-offset-bytes", Schema.Number)), Metadata: Schema.optional(Metadata), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), StorageClass: Schema.optional(Header("x-amz-storage-class")), WebsiteRedirectLocation: Schema.optional(Header("x-amz-website-redirect-location")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), Tagging: Schema.optional(Header("x-amz-tagging")), ObjectLockMode: Schema.optional(Header("x-amz-object-lock-mode")), ObjectLockRetainUntilDate: Schema.optional(Header("x-amz-object-lock-retain-until-date", Schema.Date)), ObjectLockLegalHoldStatus: Schema.optional(Header("x-amz-object-lock-legal-hold")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const PutObjectAclRequest = Schema.Struct({ACL: Schema.optional(Header("x-amz-acl")), AccessControlPolicy: Schema.optional(Body("AccessControlPolicy", AccessControlPolicy)), Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), GrantFullControl: Schema.optional(Header("x-amz-grant-full-control")), GrantRead: Schema.optional(Header("x-amz-grant-read")), GrantReadACP: Schema.optional(Header("x-amz-grant-read-acp")), GrantWrite: Schema.optional(Header("x-amz-grant-write")), GrantWriteACP: Schema.optional(Header("x-amz-grant-write-acp")), Key: Path("Key", Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), VersionId: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const PutObjectTaggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), Tagging: Body("Tagging", Tagging), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), RequestPayer: Schema.optional(Header("x-amz-request-payer"))})
const RenameObjectRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Path("Key", Schema.String), RenameSource: Header("x-amz-rename-source"), DestinationIfMatch: Schema.optional(Header("If-Match")), DestinationIfNoneMatch: Schema.optional(Header("If-None-Match")), DestinationIfModifiedSince: Schema.optional(Header("If-Modified-Since", Schema.Date)), DestinationIfUnmodifiedSince: Schema.optional(Header("If-Unmodified-Since", Schema.Date)), SourceIfMatch: Schema.optional(Header("x-amz-rename-source-if-match")), SourceIfNoneMatch: Schema.optional(Header("x-amz-rename-source-if-none-match")), SourceIfModifiedSince: Schema.optional(Header("x-amz-rename-source-if-modified-since", Schema.Date)), SourceIfUnmodifiedSince: Schema.optional(Header("x-amz-rename-source-if-unmodified-since", Schema.Date)), ClientToken: Schema.optional(Header("x-amz-client-token"))})
const RenameObjectOutput = Schema.Struct({})
const IdempotencyParameterMismatch = Schema.Struct({})
export const RenameObject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?renameObject", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "RenameObject" }, RenameObjectRequest, RenameObjectOutput, ErrorAnnotation("IdempotencyParameterMismatch", IdempotencyParameterMismatch)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UploadPartRequest = Schema.Struct({Body: Schema.optional(Body("undefined", StreamBody())), Bucket: Path("Bucket", Schema.String), ContentLength: Schema.optional(Header("Content-Length", Schema.Number)), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), Key: Path("Key", Schema.String), PartNumber: Schema.Number, UploadId: Schema.String, SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const UploadPartCopyRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), CopySource: Header("x-amz-copy-source"), CopySourceIfMatch: Schema.optional(Header("x-amz-copy-source-if-match")), CopySourceIfModifiedSince: Schema.optional(Header("x-amz-copy-source-if-modified-since", Schema.Date)), CopySourceIfNoneMatch: Schema.optional(Header("x-amz-copy-source-if-none-match")), CopySourceIfUnmodifiedSince: Schema.optional(Header("x-amz-copy-source-if-unmodified-since", Schema.Date)), CopySourceRange: Schema.optional(Header("x-amz-copy-source-range")), Key: Schema.String, PartNumber: Schema.Number, UploadId: Schema.String, SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), CopySourceSSECustomerAlgorithm: Schema.optional(Header("x-amz-copy-source-server-side-encryption-customer-algorithm")), CopySourceSSECustomerKey: Schema.optional(Header("x-amz-copy-source-server-side-encryption-customer-key")), CopySourceSSECustomerKeyMD5: Schema.optional(Header("x-amz-copy-source-server-side-encryption-customer-key-MD5")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ExpectedSourceBucketOwner: Schema.optional(Header("x-amz-source-expected-bucket-owner"))})
const WriteGetObjectResponseRequest = Schema.Struct({RequestRoute: Header("x-amz-request-route"), RequestToken: Header("x-amz-request-token"), Body: Schema.optional(Body("undefined", StreamBody())), StatusCode: Schema.optional(Header("x-amz-fwd-status", Schema.Number)), ErrorCode: Schema.optional(Header("x-amz-fwd-error-code")), ErrorMessage: Schema.optional(Header("x-amz-fwd-error-message")), AcceptRanges: Schema.optional(Header("x-amz-fwd-header-accept-ranges")), CacheControl: Schema.optional(Header("x-amz-fwd-header-Cache-Control")), ContentDisposition: Schema.optional(Header("x-amz-fwd-header-Content-Disposition")), ContentEncoding: Schema.optional(Header("x-amz-fwd-header-Content-Encoding")), ContentLanguage: Schema.optional(Header("x-amz-fwd-header-Content-Language")), ContentLength: Schema.optional(Header("Content-Length", Schema.Number)), ContentRange: Schema.optional(Header("x-amz-fwd-header-Content-Range")), ContentType: Schema.optional(Header("x-amz-fwd-header-Content-Type")), ChecksumCRC32: Schema.optional(Header("x-amz-fwd-header-x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-fwd-header-x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-fwd-header-x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-fwd-header-x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-fwd-header-x-amz-checksum-sha256")), DeleteMarker: Schema.optional(Header("x-amz-fwd-header-x-amz-delete-marker", Schema.Boolean)), ETag: Schema.optional(Header("x-amz-fwd-header-ETag")), Expires: Schema.optional(Header("x-amz-fwd-header-Expires")), Expiration: Schema.optional(Header("x-amz-fwd-header-x-amz-expiration")), LastModified: Schema.optional(Header("x-amz-fwd-header-Last-Modified", Schema.Date)), MissingMeta: Schema.optional(Header("x-amz-fwd-header-x-amz-missing-meta", Schema.Number)), Metadata: Schema.optional(Metadata), ObjectLockMode: Schema.optional(Header("x-amz-fwd-header-x-amz-object-lock-mode")), ObjectLockLegalHoldStatus: Schema.optional(Header("x-amz-fwd-header-x-amz-object-lock-legal-hold")), ObjectLockRetainUntilDate: Schema.optional(Header("x-amz-fwd-header-x-amz-object-lock-retain-until-date", Schema.Date)), PartsCount: Schema.optional(Header("x-amz-fwd-header-x-amz-mp-parts-count", Schema.Number)), ReplicationStatus: Schema.optional(Header("x-amz-fwd-header-x-amz-replication-status")), RequestCharged: Schema.optional(Header("x-amz-fwd-header-x-amz-request-charged")), Restore: Schema.optional(Header("x-amz-fwd-header-x-amz-restore")), ServerSideEncryption: Schema.optional(Header("x-amz-fwd-header-x-amz-server-side-encryption")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm")), SSEKMSKeyId: Schema.optional(Header("x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-fwd-header-x-amz-server-side-encryption-customer-key-MD5")), StorageClass: Schema.optional(Header("x-amz-fwd-header-x-amz-storage-class")), TagCount: Schema.optional(Header("x-amz-fwd-header-x-amz-tagging-count", Schema.Number)), VersionId: Schema.optional(Header("x-amz-fwd-header-x-amz-version-id")), BucketKeyEnabled: Schema.optional(Header("x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean))})
export const WriteGetObjectResponse = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/WriteGetObjectResponse", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "WriteGetObjectResponse" }, WriteGetObjectResponseRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InventoryOptionalFields = Schema.Array(Schema.String)
const EventBridgeConfiguration = Schema.Struct({})
const ParquetInput = Schema.Struct({})
const Metadata = Schema.Record({key: Schema.String, value: Schema.String})
const AnalyticsConfigurationList = Schema.Array(AnalyticsConfiguration)
const IntelligentTieringConfigurationList = Schema.Array(IntelligentTieringConfiguration)
const InventoryConfigurationList = Schema.Array(InventoryConfiguration)
const MetricsConfigurationList = Schema.Array(MetricsConfiguration)
const AccelerateConfiguration = Schema.Struct({Status: Schema.optional(Schema.String)})
const RequestPaymentConfiguration = Schema.Struct({Payer: Schema.String})
const Tagging = Schema.Struct({TagSet: TagSet})
const VersioningConfiguration = Schema.Struct({MFADelete: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)})
const ObjectLockLegalHold = Schema.Struct({Status: Schema.optional(Schema.String)})
const ObjectLockRetention = Schema.Struct({Mode: Schema.optional(Schema.String), RetainUntilDate: Schema.optional(Schema.Date)})
const PublicAccessBlockConfiguration = Schema.Struct({BlockPublicAcls: Schema.optional(Schema.Boolean), IgnorePublicAcls: Schema.optional(Schema.Boolean), BlockPublicPolicy: Schema.optional(Schema.Boolean), RestrictPublicBuckets: Schema.optional(Schema.Boolean)})
const RequestProgress = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)})
const ScanRange = Schema.Struct({Start: Schema.optional(Schema.Number), End: Schema.optional(Schema.Number)})
const AllowedHeaders = Schema.Array(Schema.String)
const AllowedMethods = Schema.Array(Schema.String)
const AllowedOrigins = Schema.Array(Schema.String)
const ExposeHeaders = Schema.Array(Schema.String)
const EventList = Schema.Array(Schema.String)
const AbortMultipartUploadOutput = Schema.Struct({RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
const NoSuchUpload = Schema.Struct({})
export const AbortMultipartUpload = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?x-id=AbortMultipartUpload", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AbortMultipartUpload" }, AbortMultipartUploadRequest, AbortMultipartUploadOutput, ErrorAnnotation("NoSuchUpload", NoSuchUpload)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CopyObjectRequest = Schema.Struct({ACL: Schema.optional(Header("x-amz-acl")), Bucket: Path("Bucket", Schema.String), CacheControl: Schema.optional(Header("Cache-Control")), ChecksumAlgorithm: Schema.optional(Header("x-amz-checksum-algorithm")), ContentDisposition: Schema.optional(Header("Content-Disposition")), ContentEncoding: Schema.optional(Header("Content-Encoding")), ContentLanguage: Schema.optional(Header("Content-Language")), ContentType: Schema.optional(Header("Content-Type")), CopySource: Header("x-amz-copy-source"), CopySourceIfMatch: Schema.optional(Header("x-amz-copy-source-if-match")), CopySourceIfModifiedSince: Schema.optional(Header("x-amz-copy-source-if-modified-since", Schema.Date)), CopySourceIfNoneMatch: Schema.optional(Header("x-amz-copy-source-if-none-match")), CopySourceIfUnmodifiedSince: Schema.optional(Header("x-amz-copy-source-if-unmodified-since", Schema.Date)), Expires: Schema.optional(Header("Expires")), GrantFullControl: Schema.optional(Header("x-amz-grant-full-control")), GrantRead: Schema.optional(Header("x-amz-grant-read")), GrantReadACP: Schema.optional(Header("x-amz-grant-read-acp")), GrantWriteACP: Schema.optional(Header("x-amz-grant-write-acp")), IfMatch: Schema.optional(Header("If-Match")), IfNoneMatch: Schema.optional(Header("If-None-Match")), Key: Path("Key", Schema.String), Metadata: Schema.optional(Metadata), MetadataDirective: Schema.optional(Header("x-amz-metadata-directive")), TaggingDirective: Schema.optional(Header("x-amz-tagging-directive")), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), StorageClass: Schema.optional(Header("x-amz-storage-class")), WebsiteRedirectLocation: Schema.optional(Header("x-amz-website-redirect-location")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), CopySourceSSECustomerAlgorithm: Schema.optional(Header("x-amz-copy-source-server-side-encryption-customer-algorithm")), CopySourceSSECustomerKey: Schema.optional(Header("x-amz-copy-source-server-side-encryption-customer-key")), CopySourceSSECustomerKeyMD5: Schema.optional(Header("x-amz-copy-source-server-side-encryption-customer-key-MD5")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), Tagging: Schema.optional(Header("x-amz-tagging")), ObjectLockMode: Schema.optional(Header("x-amz-object-lock-mode")), ObjectLockRetainUntilDate: Schema.optional(Header("x-amz-object-lock-retain-until-date", Schema.Date)), ObjectLockLegalHoldStatus: Schema.optional(Header("x-amz-object-lock-legal-hold")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ExpectedSourceBucketOwner: Schema.optional(Header("x-amz-source-expected-bucket-owner"))})
const CreateMultipartUploadOutput = Schema.Struct({AbortDate: Schema.optional(Header("x-amz-abort-date", Schema.Date)), AbortRuleId: Schema.optional(Header("x-amz-abort-rule-id")), Bucket: Schema.optional(Schema.String), Key: Schema.optional(Schema.String), UploadId: Schema.optional(Schema.String), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestCharged: Schema.optional(Header("x-amz-request-charged")), ChecksumAlgorithm: Schema.optional(Header("x-amz-checksum-algorithm")), ChecksumType: Schema.optional(Header("x-amz-checksum-type"))})
export const CreateMultipartUpload = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?uploads", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "CreateMultipartUpload" }, CreateMultipartUploadRequest, CreateMultipartUploadOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteObjectOutput = Schema.Struct({DeleteMarker: Schema.optional(Header("x-amz-delete-marker", Schema.Boolean)), VersionId: Schema.optional(Header("x-amz-version-id")), RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
export const DeleteObject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?x-id=DeleteObject", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteObject" }, DeleteObjectRequest, DeleteObjectOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteObjectTaggingOutput = Schema.Struct({VersionId: Schema.optional(Header("x-amz-version-id"))})
export const DeleteObjectTagging = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?tagging", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteObjectTagging" }, DeleteObjectTaggingRequest, DeleteObjectTaggingOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketAccelerateConfigurationOutput = Schema.Struct({Status: Schema.optional(Schema.String), RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
export const GetBucketAccelerateConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?accelerate", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketAccelerateConfiguration" }, GetBucketAccelerateConfigurationRequest, GetBucketAccelerateConfigurationOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketAclOutput = Schema.Struct({Owner: Schema.optional(Owner), Grants: Schema.optional(Grants)})
export const GetBucketAcl = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?acl", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketAcl" }, GetBucketAclRequest, GetBucketAclOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketAnalyticsConfigurationOutput = Schema.Struct({AnalyticsConfiguration: Schema.optional(Body("undefined", AnalyticsConfiguration))})
export const GetBucketAnalyticsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?analytics&x-id=GetBucketAnalyticsConfiguration", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketAnalyticsConfiguration" }, GetBucketAnalyticsConfigurationRequest, GetBucketAnalyticsConfigurationOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketCorsOutput = Schema.Struct({CORSRules: Schema.optional(CORSRules)})
export const GetBucketCors = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?cors", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketCors" }, GetBucketCorsRequest, GetBucketCorsOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketEncryptionOutput = Schema.Struct({ServerSideEncryptionConfiguration: Schema.optional(Body("undefined", ServerSideEncryptionConfiguration))})
export const GetBucketEncryption = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?encryption", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketEncryption" }, GetBucketEncryptionRequest, GetBucketEncryptionOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketIntelligentTieringConfigurationOutput = Schema.Struct({IntelligentTieringConfiguration: Schema.optional(Body("undefined", IntelligentTieringConfiguration))})
export const GetBucketIntelligentTieringConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?intelligent-tiering&x-id=GetBucketIntelligentTieringConfiguration", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketIntelligentTieringConfiguration" }, GetBucketIntelligentTieringConfigurationRequest, GetBucketIntelligentTieringConfigurationOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketInventoryConfigurationOutput = Schema.Struct({InventoryConfiguration: Schema.optional(Body("undefined", InventoryConfiguration))})
export const GetBucketInventoryConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?inventory&x-id=GetBucketInventoryConfiguration", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketInventoryConfiguration" }, GetBucketInventoryConfigurationRequest, GetBucketInventoryConfigurationOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketLifecycleConfigurationOutput = Schema.Struct({Rules: Schema.optional(LifecycleRules), TransitionDefaultMinimumObjectSize: Schema.optional(Header("x-amz-transition-default-minimum-object-size"))})
export const GetBucketLifecycleConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?lifecycle", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketLifecycleConfiguration" }, GetBucketLifecycleConfigurationRequest, GetBucketLifecycleConfigurationOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketLocationOutput = Schema.Struct({LocationConstraint: Schema.optional(Schema.String)})
export const GetBucketLocation = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?location", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketLocation" }, GetBucketLocationRequest, GetBucketLocationOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketLoggingOutput = Schema.Struct({LoggingEnabled: Schema.optional(LoggingEnabled)})
export const GetBucketLogging = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?logging", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketLogging" }, GetBucketLoggingRequest, GetBucketLoggingOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketMetricsConfigurationOutput = Schema.Struct({MetricsConfiguration: Schema.optional(Body("undefined", MetricsConfiguration))})
export const GetBucketMetricsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?metrics&x-id=GetBucketMetricsConfiguration", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketMetricsConfiguration" }, GetBucketMetricsConfigurationRequest, GetBucketMetricsConfigurationOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketOwnershipControlsOutput = Schema.Struct({OwnershipControls: Schema.optional(Body("undefined", OwnershipControls))})
export const GetBucketOwnershipControls = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?ownershipControls", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketOwnershipControls" }, GetBucketOwnershipControlsRequest, GetBucketOwnershipControlsOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketPolicyOutput = Schema.Struct({Policy: Schema.optional(Body("undefined", Schema.String))})
export const GetBucketPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?policy", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketPolicy" }, GetBucketPolicyRequest, GetBucketPolicyOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketReplicationOutput = Schema.Struct({ReplicationConfiguration: Schema.optional(Body("undefined", ReplicationConfiguration))})
export const GetBucketReplication = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?replication", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketReplication" }, GetBucketReplicationRequest, GetBucketReplicationOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketRequestPaymentOutput = Schema.Struct({Payer: Schema.optional(Schema.String)})
export const GetBucketRequestPayment = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?requestPayment", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketRequestPayment" }, GetBucketRequestPaymentRequest, GetBucketRequestPaymentOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketTaggingOutput = Schema.Struct({TagSet: TagSet})
export const GetBucketTagging = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?tagging", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketTagging" }, GetBucketTaggingRequest, GetBucketTaggingOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketVersioningOutput = Schema.Struct({Status: Schema.optional(Schema.String), MFADelete: Schema.optional(Schema.String)})
export const GetBucketVersioning = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?versioning", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketVersioning" }, GetBucketVersioningRequest, GetBucketVersioningOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketWebsiteOutput = Schema.Struct({RedirectAllRequestsTo: Schema.optional(RedirectAllRequestsTo), IndexDocument: Schema.optional(IndexDocument), ErrorDocument: Schema.optional(ErrorDocument), RoutingRules: Schema.optional(RoutingRules)})
export const GetBucketWebsite = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?website", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketWebsite" }, GetBucketWebsiteRequest, GetBucketWebsiteOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetObjectOutput = Schema.Struct({Body: Schema.optional(Body("undefined", StreamBody())), DeleteMarker: Schema.optional(Header("x-amz-delete-marker", Schema.Boolean)), AcceptRanges: Schema.optional(Header("accept-ranges")), Expiration: Schema.optional(Header("x-amz-expiration")), Restore: Schema.optional(Header("x-amz-restore")), LastModified: Schema.optional(Header("Last-Modified", Schema.Date)), ContentLength: Schema.optional(Header("Content-Length", Schema.Number)), ETag: Schema.optional(Header("ETag")), ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), ChecksumType: Schema.optional(Header("x-amz-checksum-type")), MissingMeta: Schema.optional(Header("x-amz-missing-meta", Schema.Number)), VersionId: Schema.optional(Header("x-amz-version-id")), CacheControl: Schema.optional(Header("Cache-Control")), ContentDisposition: Schema.optional(Header("Content-Disposition")), ContentEncoding: Schema.optional(Header("Content-Encoding")), ContentLanguage: Schema.optional(Header("Content-Language")), ContentRange: Schema.optional(Header("Content-Range")), ContentType: Schema.optional(Header("Content-Type")), Expires: Schema.optional(Header("Expires")), WebsiteRedirectLocation: Schema.optional(Header("x-amz-website-redirect-location")), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), Metadata: Schema.optional(Metadata), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), StorageClass: Schema.optional(Header("x-amz-storage-class")), RequestCharged: Schema.optional(Header("x-amz-request-charged")), ReplicationStatus: Schema.optional(Header("x-amz-replication-status")), PartsCount: Schema.optional(Header("x-amz-mp-parts-count", Schema.Number)), TagCount: Schema.optional(Header("x-amz-tagging-count", Schema.Number)), ObjectLockMode: Schema.optional(Header("x-amz-object-lock-mode")), ObjectLockRetainUntilDate: Schema.optional(Header("x-amz-object-lock-retain-until-date", Schema.Date)), ObjectLockLegalHoldStatus: Schema.optional(Header("x-amz-object-lock-legal-hold"))})
const GetObjectAclOutput = Schema.Struct({Owner: Schema.optional(Owner), Grants: Schema.optional(Grants), RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
const NoSuchKey = Schema.Struct({})
export const GetObjectAcl = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?acl", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetObjectAcl" }, GetObjectAclRequest, GetObjectAclOutput, ErrorAnnotation("NoSuchKey", NoSuchKey)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetObjectLegalHoldOutput = Schema.Struct({LegalHold: Schema.optional(Body("LegalHold", ObjectLockLegalHold))})
export const GetObjectLegalHold = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?legal-hold", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetObjectLegalHold" }, GetObjectLegalHoldRequest, GetObjectLegalHoldOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetObjectLockConfigurationOutput = Schema.Struct({ObjectLockConfiguration: Schema.optional(Body("undefined", ObjectLockConfiguration))})
export const GetObjectLockConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?object-lock", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetObjectLockConfiguration" }, GetObjectLockConfigurationRequest, GetObjectLockConfigurationOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetObjectRetentionOutput = Schema.Struct({Retention: Schema.optional(Body("Retention", ObjectLockRetention))})
export const GetObjectRetention = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?retention", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetObjectRetention" }, GetObjectRetentionRequest, GetObjectRetentionOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetObjectTaggingOutput = Schema.Struct({VersionId: Schema.optional(Header("x-amz-version-id")), TagSet: TagSet})
export const GetObjectTagging = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?tagging", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetObjectTagging" }, GetObjectTaggingRequest, GetObjectTaggingOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetObjectTorrentOutput = Schema.Struct({Body: Schema.optional(Body("undefined", StreamBody())), RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
export const GetObjectTorrent = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?torrent", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetObjectTorrent" }, GetObjectTorrentRequest, GetObjectTorrentOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetPublicAccessBlockOutput = Schema.Struct({PublicAccessBlockConfiguration: Schema.optional(Body("undefined", PublicAccessBlockConfiguration))})
export const GetPublicAccessBlock = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?publicAccessBlock", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetPublicAccessBlock" }, GetPublicAccessBlockRequest, GetPublicAccessBlockOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const HeadBucketOutput = Schema.Struct({BucketArn: Schema.optional(Header("x-amz-bucket-arn")), BucketLocationType: Schema.optional(Header("x-amz-bucket-location-type")), BucketLocationName: Schema.optional(Header("x-amz-bucket-location-name")), BucketRegion: Schema.optional(Header("x-amz-bucket-region")), AccessPointAlias: Schema.optional(Header("x-amz-access-point-alias", Schema.Boolean))})
const NotFound = Schema.Struct({})
export const HeadBucket = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}", method: "HEAD", sdkId: "S3", sigV4ServiceName: "s3", name: "HeadBucket" }, HeadBucketRequest, HeadBucketOutput, ErrorAnnotation("NotFound", NotFound)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const HeadObjectOutput = Schema.Struct({DeleteMarker: Schema.optional(Header("x-amz-delete-marker", Schema.Boolean)), AcceptRanges: Schema.optional(Header("accept-ranges")), Expiration: Schema.optional(Header("x-amz-expiration")), Restore: Schema.optional(Header("x-amz-restore")), ArchiveStatus: Schema.optional(Header("x-amz-archive-status")), LastModified: Schema.optional(Header("Last-Modified", Schema.Date)), ContentLength: Schema.optional(Header("Content-Length", Schema.Number)), ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), ChecksumType: Schema.optional(Header("x-amz-checksum-type")), ETag: Schema.optional(Header("ETag")), MissingMeta: Schema.optional(Header("x-amz-missing-meta", Schema.Number)), VersionId: Schema.optional(Header("x-amz-version-id")), CacheControl: Schema.optional(Header("Cache-Control")), ContentDisposition: Schema.optional(Header("Content-Disposition")), ContentEncoding: Schema.optional(Header("Content-Encoding")), ContentLanguage: Schema.optional(Header("Content-Language")), ContentType: Schema.optional(Header("Content-Type")), ContentRange: Schema.optional(Header("Content-Range")), Expires: Schema.optional(Header("Expires")), WebsiteRedirectLocation: Schema.optional(Header("x-amz-website-redirect-location")), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), Metadata: Schema.optional(Metadata), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), StorageClass: Schema.optional(Header("x-amz-storage-class")), RequestCharged: Schema.optional(Header("x-amz-request-charged")), ReplicationStatus: Schema.optional(Header("x-amz-replication-status")), PartsCount: Schema.optional(Header("x-amz-mp-parts-count", Schema.Number)), TagCount: Schema.optional(Header("x-amz-tagging-count", Schema.Number)), ObjectLockMode: Schema.optional(Header("x-amz-object-lock-mode")), ObjectLockRetainUntilDate: Schema.optional(Header("x-amz-object-lock-retain-until-date", Schema.Date)), ObjectLockLegalHoldStatus: Schema.optional(Header("x-amz-object-lock-legal-hold"))})
export const HeadObject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}", method: "HEAD", sdkId: "S3", sigV4ServiceName: "s3", name: "HeadObject" }, HeadObjectRequest, HeadObjectOutput, ErrorAnnotation("NotFound", NotFound)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListBucketAnalyticsConfigurationsOutput = Schema.Struct({IsTruncated: Schema.optional(Schema.Boolean), ContinuationToken: Schema.optional(Schema.String), NextContinuationToken: Schema.optional(Schema.String), AnalyticsConfigurationList: Schema.optional(AnalyticsConfigurationList)})
export const ListBucketAnalyticsConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?analytics&x-id=ListBucketAnalyticsConfigurations", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "ListBucketAnalyticsConfigurations" }, ListBucketAnalyticsConfigurationsRequest, ListBucketAnalyticsConfigurationsOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListBucketIntelligentTieringConfigurationsOutput = Schema.Struct({IsTruncated: Schema.optional(Schema.Boolean), ContinuationToken: Schema.optional(Schema.String), NextContinuationToken: Schema.optional(Schema.String), IntelligentTieringConfigurationList: Schema.optional(IntelligentTieringConfigurationList)})
export const ListBucketIntelligentTieringConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?intelligent-tiering&x-id=ListBucketIntelligentTieringConfigurations", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "ListBucketIntelligentTieringConfigurations" }, ListBucketIntelligentTieringConfigurationsRequest, ListBucketIntelligentTieringConfigurationsOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListBucketInventoryConfigurationsOutput = Schema.Struct({ContinuationToken: Schema.optional(Schema.String), InventoryConfigurationList: Schema.optional(InventoryConfigurationList), IsTruncated: Schema.optional(Schema.Boolean), NextContinuationToken: Schema.optional(Schema.String)})
export const ListBucketInventoryConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?inventory&x-id=ListBucketInventoryConfigurations", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "ListBucketInventoryConfigurations" }, ListBucketInventoryConfigurationsRequest, ListBucketInventoryConfigurationsOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListBucketMetricsConfigurationsOutput = Schema.Struct({IsTruncated: Schema.optional(Schema.Boolean), ContinuationToken: Schema.optional(Schema.String), NextContinuationToken: Schema.optional(Schema.String), MetricsConfigurationList: Schema.optional(MetricsConfigurationList)})
export const ListBucketMetricsConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?metrics&x-id=ListBucketMetricsConfigurations", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "ListBucketMetricsConfigurations" }, ListBucketMetricsConfigurationsRequest, ListBucketMetricsConfigurationsOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDirectoryBucketsOutput = Schema.Struct({Buckets: Schema.optional(Buckets), ContinuationToken: Schema.optional(Schema.String)})
export const ListDirectoryBuckets = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/?x-id=ListDirectoryBuckets", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "ListDirectoryBuckets" }, ListDirectoryBucketsRequest, ListDirectoryBucketsOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListObjectsV2Output = Schema.Struct({IsTruncated: Schema.optional(Schema.Boolean), Contents: Schema.optional(ObjectList), Name: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), Delimiter: Schema.optional(Schema.String), MaxKeys: Schema.optional(Schema.Number), CommonPrefixes: Schema.optional(CommonPrefixList), EncodingType: Schema.optional(Schema.String), KeyCount: Schema.optional(Schema.Number), ContinuationToken: Schema.optional(Schema.String), NextContinuationToken: Schema.optional(Schema.String), StartAfter: Schema.optional(Schema.String), RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
const NoSuchBucket = Schema.Struct({})
export const ListObjectsV2 = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?list-type=2", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "ListObjectsV2" }, ListObjectsV2Request, ListObjectsV2Output, ErrorAnnotation("NoSuchBucket", NoSuchBucket)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutBucketAccelerateConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), AccelerateConfiguration: Body("AccelerateConfiguration", AccelerateConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm"))})
export const PutBucketAccelerateConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?accelerate", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketAccelerateConfiguration" }, PutBucketAccelerateConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutBucketRequestPaymentRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), RequestPaymentConfiguration: Body("RequestPaymentConfiguration", RequestPaymentConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutBucketRequestPayment = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?requestPayment", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketRequestPayment" }, PutBucketRequestPaymentRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutBucketTaggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), Tagging: Body("Tagging", Tagging), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutBucketTagging = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?tagging", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketTagging" }, PutBucketTaggingRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutBucketVersioningRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), MFA: Schema.optional(Header("x-amz-mfa")), VersioningConfiguration: Body("VersioningConfiguration", VersioningConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutBucketVersioning = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?versioning", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketVersioning" }, PutBucketVersioningRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutObjectOutput = Schema.Struct({Expiration: Schema.optional(Header("x-amz-expiration")), ETag: Schema.optional(Header("ETag")), ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), ChecksumType: Schema.optional(Header("x-amz-checksum-type")), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), VersionId: Schema.optional(Header("x-amz-version-id")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), Size: Schema.optional(Header("x-amz-object-size", Schema.Number)), RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
const EncryptionTypeMismatch = Schema.Struct({})
const InvalidRequest = Schema.Struct({})
const InvalidWriteOffset = Schema.Struct({})
const TooManyParts = Schema.Struct({})
export const PutObject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?x-id=PutObject", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutObject" }, PutObjectRequest, PutObjectOutput, Schema.Union(ErrorAnnotation("EncryptionTypeMismatch", EncryptionTypeMismatch), ErrorAnnotation("InvalidRequest", InvalidRequest), ErrorAnnotation("InvalidWriteOffset", InvalidWriteOffset), ErrorAnnotation("TooManyParts", TooManyParts))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutObjectAclOutput = Schema.Struct({RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
export const PutObjectAcl = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?acl", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutObjectAcl" }, PutObjectAclRequest, PutObjectAclOutput, ErrorAnnotation("NoSuchKey", NoSuchKey)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutObjectLegalHoldRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, LegalHold: Schema.optional(Body("LegalHold", ObjectLockLegalHold)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), VersionId: Schema.optional(Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const PutObjectRetentionRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, Retention: Schema.optional(Body("Retention", ObjectLockRetention)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), VersionId: Schema.optional(Schema.String), BypassGovernanceRetention: Schema.optional(Header("x-amz-bypass-governance-retention", Schema.Boolean)), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const PutObjectTaggingOutput = Schema.Struct({VersionId: Schema.optional(Header("x-amz-version-id"))})
export const PutObjectTagging = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?tagging", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutObjectTagging" }, PutObjectTaggingRequest, PutObjectTaggingOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutPublicAccessBlockRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), PublicAccessBlockConfiguration: Body("PublicAccessBlockConfiguration", PublicAccessBlockConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutPublicAccessBlock = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?publicAccessBlock", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutPublicAccessBlock" }, PutPublicAccessBlockRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UploadPartOutput = Schema.Struct({ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), ETag: Schema.optional(Header("ETag")), ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
export const UploadPart = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?x-id=UploadPart", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "UploadPart" }, UploadPartRequest, UploadPartOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CompletedPart = Schema.Struct({ETag: Schema.optional(Schema.String), ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String), PartNumber: Schema.optional(Schema.Number)})
const CompletedPartList = Schema.Array(CompletedPart)
const LocationInfo = Schema.Struct({Type: Schema.optional(Schema.String), Name: Schema.optional(Schema.String)})
const BucketInfo = Schema.Struct({DataRedundancy: Schema.optional(Schema.String), Type: Schema.optional(Schema.String)})
const Tag = Schema.Struct({Key: Schema.String, Value: Schema.String})
const TagSet = Schema.Array(Tag)
const JournalTableConfiguration = Schema.Struct({RecordExpiration: RecordExpiration, EncryptionConfiguration: Schema.optional(MetadataTableEncryptionConfiguration)})
const InventoryTableConfiguration = Schema.Struct({ConfigurationState: Schema.String, EncryptionConfiguration: Schema.optional(MetadataTableEncryptionConfiguration)})
const S3TablesDestination = Schema.Struct({TableBucketArn: Schema.String, TableName: Schema.String})
const ObjectIdentifier = Schema.Struct({Key: Schema.String, VersionId: Schema.optional(Schema.String), ETag: Schema.optional(Schema.String), LastModifiedTime: Schema.optional(Schema.Date), Size: Schema.optional(Schema.Number)})
const ObjectIdentifierList = Schema.Array(ObjectIdentifier)
const ChecksumAlgorithmList = Schema.Array(Schema.String)
const Owner = Schema.Struct({DisplayName: Schema.optional(Schema.String), ID: Schema.optional(Schema.String)})
const CORSRule = Schema.Struct({ID: Schema.optional(Schema.String), AllowedHeaders: Schema.optional(AllowedHeaders), AllowedMethods: AllowedMethods, AllowedOrigins: AllowedOrigins, ExposeHeaders: Schema.optional(ExposeHeaders), MaxAgeSeconds: Schema.optional(Schema.Number)})
const CORSRules = Schema.Array(CORSRule)
const Tiering = Schema.Struct({Days: Schema.Number, AccessTier: Schema.String})
const TieringList = Schema.Array(Tiering)
const InventoryFilter = Schema.Struct({Prefix: Schema.String})
const InventorySchedule = Schema.Struct({Frequency: Schema.String})
const QueueConfiguration = Schema.Struct({Id: Schema.optional(Schema.String), QueueArn: Schema.String, Events: EventList, Filter: Schema.optional(NotificationConfigurationFilter)})
const QueueConfigurationList = Schema.Array(QueueConfiguration)
const LambdaFunctionConfiguration = Schema.Struct({Id: Schema.optional(Schema.String), LambdaFunctionArn: Schema.String, Events: EventList, Filter: Schema.optional(NotificationConfigurationFilter)})
const LambdaFunctionConfigurationList = Schema.Array(LambdaFunctionConfiguration)
const OwnershipControlsRule = Schema.Struct({ObjectOwnership: Schema.String})
const OwnershipControlsRules = Schema.Array(OwnershipControlsRule)
const ErrorDocument = Schema.Struct({Key: Schema.String})
const IndexDocument = Schema.Struct({Suffix: Schema.String})
const RedirectAllRequestsTo = Schema.Struct({HostName: Schema.String, Protocol: Schema.optional(Schema.String)})
const GlacierJobParameters = Schema.Struct({Tier: Schema.String})
const SelectParameters = Schema.Struct({InputSerialization: InputSerialization, ExpressionType: Schema.String, Expression: Schema.String, OutputSerialization: OutputSerialization})
const CSVInput = Schema.Struct({FileHeaderInfo: Schema.optional(Schema.String), Comments: Schema.optional(Schema.String), QuoteEscapeCharacter: Schema.optional(Schema.String), RecordDelimiter: Schema.optional(Schema.String), FieldDelimiter: Schema.optional(Schema.String), QuoteCharacter: Schema.optional(Schema.String), AllowQuotedRecordDelimiter: Schema.optional(Schema.Boolean)})
const JSONInput = Schema.Struct({Type: Schema.optional(Schema.String)})
const CSVOutput = Schema.Struct({QuoteFields: Schema.optional(Schema.String), QuoteEscapeCharacter: Schema.optional(Schema.String), RecordDelimiter: Schema.optional(Schema.String), FieldDelimiter: Schema.optional(Schema.String), QuoteCharacter: Schema.optional(Schema.String)})
const JSONOutput = Schema.Struct({RecordDelimiter: Schema.optional(Schema.String)})
const MetadataTableEncryptionConfiguration = Schema.Struct({SseAlgorithm: Schema.String, KmsKeyArn: Schema.optional(Schema.String)})
const RecordExpiration = Schema.Struct({Expiration: Schema.String, Days: Schema.optional(Schema.Number)})
const SimplePrefix = Schema.Struct({})
const CompletedMultipartUpload = Schema.Struct({Parts: Schema.optional(CompletedPartList)})
const CreateBucketConfiguration = Schema.Struct({LocationConstraint: Schema.optional(Schema.String), Location: Schema.optional(LocationInfo), Bucket: Schema.optional(BucketInfo), Tags: Schema.optional(TagSet)})
const MetadataConfiguration = Schema.Struct({JournalTableConfiguration: JournalTableConfiguration, InventoryTableConfiguration: Schema.optional(InventoryTableConfiguration)})
const MetadataTableConfiguration = Schema.Struct({S3TablesDestination: S3TablesDestination})
const SessionCredentials = Schema.Struct({AccessKeyId: Schema.String, SecretAccessKey: Schema.String, SessionToken: Schema.String, Expiration: Schema.Date})
const Delete = Schema.Struct({Objects: ObjectIdentifierList, Quiet: Schema.optional(Schema.Boolean)})
const PolicyStatus = Schema.Struct({IsPublic: Schema.optional(Schema.Boolean)})
const Checksum = Schema.Struct({ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String), ChecksumType: Schema.optional(Schema.String)})
const Bucket = Schema.Struct({Name: Schema.optional(Schema.String), CreationDate: Schema.optional(Schema.Date), BucketRegion: Schema.optional(Schema.String), BucketArn: Schema.optional(Schema.String)})
const Buckets = Schema.Array(Bucket)
const MultipartUpload = Schema.Struct({UploadId: Schema.optional(Schema.String), Key: Schema.optional(Schema.String), Initiated: Schema.optional(Schema.Date), StorageClass: Schema.optional(Schema.String), Owner: Schema.optional(Owner), Initiator: Schema.optional(Initiator), ChecksumAlgorithm: Schema.optional(Schema.String), ChecksumType: Schema.optional(Schema.String)})
const MultipartUploadList = Schema.Array(MultipartUpload)
const CommonPrefix = Schema.Struct({Prefix: Schema.optional(Schema.String)})
const CommonPrefixList = Schema.Array(CommonPrefix)
const ObjectVersion = Schema.Struct({ETag: Schema.optional(Schema.String), ChecksumAlgorithm: Schema.optional(ChecksumAlgorithmList), ChecksumType: Schema.optional(Schema.String), Size: Schema.optional(Schema.Number), StorageClass: Schema.optional(Schema.String), Key: Schema.optional(Schema.String), VersionId: Schema.optional(Schema.String), IsLatest: Schema.optional(Schema.Boolean), LastModified: Schema.optional(Schema.Date), Owner: Schema.optional(Owner), RestoreStatus: Schema.optional(RestoreStatus)})
const ObjectVersionList = Schema.Array(ObjectVersion)
const DeleteMarkerEntry = Schema.Struct({Owner: Schema.optional(Owner), Key: Schema.optional(Schema.String), VersionId: Schema.optional(Schema.String), IsLatest: Schema.optional(Schema.Boolean), LastModified: Schema.optional(Schema.Date)})
const DeleteMarkers = Schema.Array(DeleteMarkerEntry)
const Part = Schema.Struct({PartNumber: Schema.optional(Schema.Number), LastModified: Schema.optional(Schema.Date), ETag: Schema.optional(Schema.String), Size: Schema.optional(Schema.Number), ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String)})
const Parts = Schema.Array(Part)
const Initiator = Schema.Struct({ID: Schema.optional(Schema.String), DisplayName: Schema.optional(Schema.String)})
const CORSConfiguration = Schema.Struct({CORSRules: CORSRules})
const OwnershipControls = Schema.Struct({Rules: OwnershipControlsRules})
const InputSerialization = Schema.Struct({CSV: Schema.optional(CSVInput), CompressionType: Schema.optional(Schema.String), JSON: Schema.optional(JSONInput), Parquet: Schema.optional(ParquetInput)})
const OutputSerialization = Schema.Struct({CSV: Schema.optional(CSVOutput), JSON: Schema.optional(JSONOutput)})
const InventoryTableConfigurationUpdates = Schema.Struct({ConfigurationState: Schema.String, EncryptionConfiguration: Schema.optional(MetadataTableEncryptionConfiguration)})
const JournalTableConfigurationUpdates = Schema.Struct({RecordExpiration: RecordExpiration})
const CopyPartResult = Schema.Struct({ETag: Schema.optional(Schema.String), LastModified: Schema.optional(Schema.Date), ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String)})
const Grantee = Schema.Struct({DisplayName: Schema.optional(Schema.String), EmailAddress: Schema.optional(Schema.String), ID: Schema.optional(Schema.String), URI: Schema.optional(Schema.String), Type: Schema.String})
const AnalyticsAndOperator = Schema.Struct({Prefix: Schema.optional(Schema.String), Tags: Schema.optional(TagSet)})
const ServerSideEncryptionByDefault = Schema.Struct({SSEAlgorithm: Schema.String, KMSMasterKeyID: Schema.optional(Schema.String)})
const IntelligentTieringAndOperator = Schema.Struct({Prefix: Schema.optional(Schema.String), Tags: Schema.optional(TagSet)})
const LifecycleExpiration = Schema.Struct({Date: Schema.optional(Schema.Date), Days: Schema.optional(Schema.Number), ExpiredObjectDeleteMarker: Schema.optional(Schema.Boolean)})
const Transition = Schema.Struct({Date: Schema.optional(Schema.Date), Days: Schema.optional(Schema.Number), StorageClass: Schema.optional(Schema.String)})
const TransitionList = Schema.Array(Transition)
const NoncurrentVersionTransition = Schema.Struct({NoncurrentDays: Schema.optional(Schema.Number), StorageClass: Schema.optional(Schema.String), NewerNoncurrentVersions: Schema.optional(Schema.Number)})
const NoncurrentVersionTransitionList = Schema.Array(NoncurrentVersionTransition)
const NoncurrentVersionExpiration = Schema.Struct({NoncurrentDays: Schema.optional(Schema.Number), NewerNoncurrentVersions: Schema.optional(Schema.Number)})
const AbortIncompleteMultipartUpload = Schema.Struct({DaysAfterInitiation: Schema.optional(Schema.Number)})
const TargetGrant = Schema.Struct({Grantee: Schema.optional(Grantee), Permission: Schema.optional(Schema.String)})
const TargetGrants = Schema.Array(TargetGrant)
const MetricsAndOperator = Schema.Struct({Prefix: Schema.optional(Schema.String), Tags: Schema.optional(TagSet), AccessPointArn: Schema.optional(Schema.String)})
const ExistingObjectReplication = Schema.Struct({Status: Schema.String})
const DeleteMarkerReplication = Schema.Struct({Status: Schema.optional(Schema.String)})
const Condition = Schema.Struct({HttpErrorCodeReturnedEquals: Schema.optional(Schema.String), KeyPrefixEquals: Schema.optional(Schema.String)})
const Redirect = Schema.Struct({HostName: Schema.optional(Schema.String), HttpRedirectCode: Schema.optional(Schema.String), Protocol: Schema.optional(Schema.String), ReplaceKeyPrefixWith: Schema.optional(Schema.String), ReplaceKeyWith: Schema.optional(Schema.String)})
const DefaultRetention = Schema.Struct({Mode: Schema.optional(Schema.String), Days: Schema.optional(Schema.Number), Years: Schema.optional(Schema.Number)})
const CompleteMultipartUploadRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Path("Key", Schema.String), MultipartUpload: Schema.optional(Body("CompleteMultipartUpload", CompletedMultipartUpload)), UploadId: Schema.String, ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), ChecksumType: Schema.optional(Header("x-amz-checksum-type")), MpuObjectSize: Schema.optional(Header("x-amz-mp-object-size", Schema.Number)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), IfMatch: Schema.optional(Header("If-Match")), IfNoneMatch: Schema.optional(Header("If-None-Match")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5"))})
const CreateBucketRequest = Schema.Struct({ACL: Schema.optional(Header("x-amz-acl")), Bucket: Path("Bucket", Schema.String), CreateBucketConfiguration: Schema.optional(Body("CreateBucketConfiguration", CreateBucketConfiguration)), GrantFullControl: Schema.optional(Header("x-amz-grant-full-control")), GrantRead: Schema.optional(Header("x-amz-grant-read")), GrantReadACP: Schema.optional(Header("x-amz-grant-read-acp")), GrantWrite: Schema.optional(Header("x-amz-grant-write")), GrantWriteACP: Schema.optional(Header("x-amz-grant-write-acp")), ObjectLockEnabledForBucket: Schema.optional(Header("x-amz-bucket-object-lock-enabled", Schema.Boolean)), ObjectOwnership: Schema.optional(Header("x-amz-object-ownership"))})
const CreateBucketMetadataConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), MetadataConfiguration: Body("MetadataConfiguration", MetadataConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const CreateBucketMetadataConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?metadataConfiguration", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "CreateBucketMetadataConfiguration" }, CreateBucketMetadataConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateBucketMetadataTableConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), MetadataTableConfiguration: Body("MetadataTableConfiguration", MetadataTableConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const CreateBucketMetadataTableConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?metadataTable", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "CreateBucketMetadataTableConfiguration" }, CreateBucketMetadataTableConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateSessionOutput = Schema.Struct({ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), Credentials: SessionCredentials})
export const CreateSession = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?session", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "CreateSession" }, CreateSessionRequest, CreateSessionOutput, ErrorAnnotation("NoSuchBucket", NoSuchBucket)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteObjectsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Delete: Body("Delete", Delete), MFA: Schema.optional(Header("x-amz-mfa")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), BypassGovernanceRetention: Schema.optional(Header("x-amz-bypass-governance-retention", Schema.Boolean)), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm"))})
const GetBucketPolicyStatusOutput = Schema.Struct({PolicyStatus: Schema.optional(Body("undefined", PolicyStatus))})
export const GetBucketPolicyStatus = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?policyStatus", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketPolicyStatus" }, GetBucketPolicyStatusRequest, GetBucketPolicyStatusOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidObjectState = Schema.Struct({StorageClass: Schema.optional(Schema.String), AccessTier: Schema.optional(Schema.String)})
export const GetObject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?x-id=GetObject", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetObject" }, GetObjectRequest, GetObjectOutput, Schema.Union(ErrorAnnotation("InvalidObjectState", InvalidObjectState), ErrorAnnotation("NoSuchKey", NoSuchKey))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListBucketsOutput = Schema.Struct({Buckets: Schema.optional(Buckets), Owner: Schema.optional(Owner), ContinuationToken: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String)})
export const ListBuckets = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/?x-id=ListBuckets", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "ListBuckets" }, ListBucketsRequest, ListBucketsOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListMultipartUploadsOutput = Schema.Struct({Bucket: Schema.optional(Schema.String), KeyMarker: Schema.optional(Schema.String), UploadIdMarker: Schema.optional(Schema.String), NextKeyMarker: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), Delimiter: Schema.optional(Schema.String), NextUploadIdMarker: Schema.optional(Schema.String), MaxUploads: Schema.optional(Schema.Number), IsTruncated: Schema.optional(Schema.Boolean), Uploads: Schema.optional(MultipartUploadList), CommonPrefixes: Schema.optional(CommonPrefixList), EncodingType: Schema.optional(Schema.String), RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
export const ListMultipartUploads = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?uploads", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "ListMultipartUploads" }, ListMultipartUploadsRequest, ListMultipartUploadsOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListObjectVersionsOutput = Schema.Struct({IsTruncated: Schema.optional(Schema.Boolean), KeyMarker: Schema.optional(Schema.String), VersionIdMarker: Schema.optional(Schema.String), NextKeyMarker: Schema.optional(Schema.String), NextVersionIdMarker: Schema.optional(Schema.String), Versions: Schema.optional(ObjectVersionList), DeleteMarkers: Schema.optional(DeleteMarkers), Name: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), Delimiter: Schema.optional(Schema.String), MaxKeys: Schema.optional(Schema.Number), CommonPrefixes: Schema.optional(CommonPrefixList), EncodingType: Schema.optional(Schema.String), RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
export const ListObjectVersions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?versions", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "ListObjectVersions" }, ListObjectVersionsRequest, ListObjectVersionsOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListPartsOutput = Schema.Struct({AbortDate: Schema.optional(Header("x-amz-abort-date", Schema.Date)), AbortRuleId: Schema.optional(Header("x-amz-abort-rule-id")), Bucket: Schema.optional(Schema.String), Key: Schema.optional(Schema.String), UploadId: Schema.optional(Schema.String), PartNumberMarker: Schema.optional(Schema.String), NextPartNumberMarker: Schema.optional(Schema.String), MaxParts: Schema.optional(Schema.Number), IsTruncated: Schema.optional(Schema.Boolean), Parts: Schema.optional(Parts), Initiator: Schema.optional(Initiator), Owner: Schema.optional(Owner), StorageClass: Schema.optional(Schema.String), RequestCharged: Schema.optional(Header("x-amz-request-charged")), ChecksumAlgorithm: Schema.optional(Schema.String), ChecksumType: Schema.optional(Schema.String)})
export const ListParts = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?x-id=ListParts", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "ListParts" }, ListPartsRequest, ListPartsOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutBucketCorsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), CORSConfiguration: Body("CORSConfiguration", CORSConfiguration), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutBucketCors = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?cors", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketCors" }, PutBucketCorsRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const SSES3 = Schema.Struct({})
const PutBucketOwnershipControlsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), OwnershipControls: Body("OwnershipControls", OwnershipControls), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm"))})
export const PutBucketOwnershipControls = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?ownershipControls", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketOwnershipControls" }, PutBucketOwnershipControlsRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutObjectLegalHoldOutput = Schema.Struct({RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
export const PutObjectLegalHold = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?legal-hold", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutObjectLegalHold" }, PutObjectLegalHoldRequest, PutObjectLegalHoldOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutObjectRetentionOutput = Schema.Struct({RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
export const PutObjectRetention = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?retention", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutObjectRetention" }, PutObjectRetentionRequest, PutObjectRetentionOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const SelectObjectContentRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), Expression: Schema.String, ExpressionType: Schema.String, RequestProgress: Schema.optional(RequestProgress), InputSerialization: InputSerialization, OutputSerialization: OutputSerialization, ScanRange: Schema.optional(ScanRange), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const UpdateBucketMetadataInventoryTableConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), InventoryTableConfiguration: Body("InventoryTableConfiguration", InventoryTableConfigurationUpdates), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const UpdateBucketMetadataInventoryTableConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?metadataInventoryTable", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "UpdateBucketMetadataInventoryTableConfiguration" }, UpdateBucketMetadataInventoryTableConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateBucketMetadataJournalTableConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), JournalTableConfiguration: Body("JournalTableConfiguration", JournalTableConfigurationUpdates), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const UpdateBucketMetadataJournalTableConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?metadataJournalTable", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "UpdateBucketMetadataJournalTableConfiguration" }, UpdateBucketMetadataJournalTableConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UploadPartCopyOutput = Schema.Struct({CopySourceVersionId: Schema.optional(Header("x-amz-copy-source-version-id")), CopyPartResult: Schema.optional(Body("undefined", CopyPartResult)), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
export const UploadPartCopy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?x-id=UploadPartCopy", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "UploadPartCopy" }, UploadPartCopyRequest, UploadPartCopyOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ErrorDetails = Schema.Struct({ErrorCode: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String)})
const ObjectPart = Schema.Struct({PartNumber: Schema.optional(Schema.Number), Size: Schema.optional(Schema.Number), ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String)})
const PartsList = Schema.Array(ObjectPart)
const RestoreStatus = Schema.Struct({IsRestoreInProgress: Schema.optional(Schema.Boolean), RestoreExpiryDate: Schema.optional(Schema.Date)})
const Grant = Schema.Struct({Grantee: Schema.optional(Grantee), Permission: Schema.optional(Schema.String)})
const Grants = Schema.Array(Grant)
const AnalyticsFilter = Schema.Union(Schema.String, Tag, AnalyticsAndOperator)
const ServerSideEncryptionRule = Schema.Struct({ApplyServerSideEncryptionByDefault: Schema.optional(ServerSideEncryptionByDefault), BucketKeyEnabled: Schema.optional(Schema.Boolean)})
const ServerSideEncryptionRules = Schema.Array(ServerSideEncryptionRule)
const IntelligentTieringFilter = Schema.Struct({Prefix: Schema.optional(Schema.String), Tag: Schema.optional(Tag), And: Schema.optional(IntelligentTieringAndOperator)})
const MetricsFilter = Schema.Union(Schema.String, Tag, Schema.String, MetricsAndOperator)
const RoutingRule = Schema.Struct({Condition: Schema.optional(Condition), Redirect: Redirect})
const RoutingRules = Schema.Array(RoutingRule)
const ObjectLockRule = Schema.Struct({DefaultRetention: Schema.optional(DefaultRetention)})
const LifecycleRuleAndOperator = Schema.Struct({Prefix: Schema.optional(Schema.String), Tags: Schema.optional(TagSet), ObjectSizeGreaterThan: Schema.optional(Schema.Number), ObjectSizeLessThan: Schema.optional(Schema.Number)})
const PartitionedPrefix = Schema.Struct({PartitionDateSource: Schema.optional(Schema.String)})
const ReplicationRuleAndOperator = Schema.Struct({Prefix: Schema.optional(Schema.String), Tags: Schema.optional(TagSet)})
const SseKmsEncryptedObjects = Schema.Struct({Status: Schema.String})
const ReplicaModifications = Schema.Struct({Status: Schema.String})
const AccessControlTranslation = Schema.Struct({Owner: Schema.String})
const EncryptionConfiguration = Schema.Struct({ReplicaKmsKeyID: Schema.optional(Schema.String)})
const Metrics = Schema.Struct({Status: Schema.String, EventThreshold: Schema.optional(ReplicationTimeValue)})
const Encryption = Schema.Struct({EncryptionType: Schema.String, KMSKeyId: Schema.optional(Schema.String), KMSContext: Schema.optional(Schema.String)})
const MetadataEntry = Schema.Struct({Name: Schema.optional(Schema.String), Value: Schema.optional(Schema.String)})
const UserMetadata = Schema.Array(MetadataEntry)
const CopyObjectResult = Schema.Struct({ETag: Schema.optional(Schema.String), LastModified: Schema.optional(Schema.Date), ChecksumType: Schema.optional(Schema.String), ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String)})
const GetObjectAttributesParts = Schema.Struct({TotalPartsCount: Schema.optional(Schema.Number), PartNumberMarker: Schema.optional(Schema.String), NextPartNumberMarker: Schema.optional(Schema.String), MaxParts: Schema.optional(Schema.Number), IsTruncated: Schema.optional(Schema.Boolean), Parts: Schema.optional(PartsList)})
const Object = Schema.Struct({Key: Schema.optional(Schema.String), LastModified: Schema.optional(Schema.Date), ETag: Schema.optional(Schema.String), ChecksumAlgorithm: Schema.optional(ChecksumAlgorithmList), ChecksumType: Schema.optional(Schema.String), Size: Schema.optional(Schema.Number), StorageClass: Schema.optional(Schema.String), Owner: Schema.optional(Owner), RestoreStatus: Schema.optional(RestoreStatus)})
const ObjectList = Schema.Array(Object)
const AccessControlPolicy = Schema.Struct({Grants: Schema.optional(Grants), Owner: Schema.optional(Owner)})
const ServerSideEncryptionConfiguration = Schema.Struct({Rules: ServerSideEncryptionRules})
const IntelligentTieringConfiguration = Schema.Struct({Id: Schema.String, Filter: Schema.optional(IntelligentTieringFilter), Status: Schema.String, Tierings: TieringList})
const MetricsConfiguration = Schema.Struct({Id: Schema.String, Filter: Schema.optional(MetricsFilter)})
const WebsiteConfiguration = Schema.Struct({ErrorDocument: Schema.optional(ErrorDocument), IndexDocument: Schema.optional(IndexDocument), RedirectAllRequestsTo: Schema.optional(RedirectAllRequestsTo), RoutingRules: Schema.optional(RoutingRules)})
const ObjectLockConfiguration = Schema.Struct({ObjectLockEnabled: Schema.optional(Schema.String), Rule: Schema.optional(ObjectLockRule)})
const DestinationResult = Schema.Struct({TableBucketType: Schema.optional(Schema.String), TableBucketArn: Schema.optional(Schema.String), TableNamespace: Schema.optional(Schema.String)})
const JournalTableConfigurationResult = Schema.Struct({TableStatus: Schema.String, Error: Schema.optional(ErrorDetails), TableName: Schema.String, TableArn: Schema.optional(Schema.String), RecordExpiration: RecordExpiration})
const InventoryTableConfigurationResult = Schema.Struct({ConfigurationState: Schema.String, TableStatus: Schema.optional(Schema.String), Error: Schema.optional(ErrorDetails), TableName: Schema.optional(Schema.String), TableArn: Schema.optional(Schema.String)})
const S3TablesDestinationResult = Schema.Struct({TableBucketArn: Schema.String, TableName: Schema.String, TableArn: Schema.String, TableNamespace: Schema.String})
const LifecycleRuleFilter = Schema.Struct({Prefix: Schema.optional(Schema.String), Tag: Schema.optional(Tag), ObjectSizeGreaterThan: Schema.optional(Schema.Number), ObjectSizeLessThan: Schema.optional(Schema.Number), And: Schema.optional(LifecycleRuleAndOperator)})
const TargetObjectKeyFormat = Schema.Struct({SimplePrefix: Schema.optional(SimplePrefix), PartitionedPrefix: Schema.optional(PartitionedPrefix)})
const ReplicationRuleFilter = Schema.Struct({Prefix: Schema.optional(Schema.String), Tag: Schema.optional(Tag), And: Schema.optional(ReplicationRuleAndOperator)})
const SourceSelectionCriteria = Schema.Struct({SseKmsEncryptedObjects: Schema.optional(SseKmsEncryptedObjects), ReplicaModifications: Schema.optional(ReplicaModifications)})
const S3Location = Schema.Struct({BucketName: Schema.String, Prefix: Schema.String, Encryption: Schema.optional(Encryption), CannedACL: Schema.optional(Schema.String), AccessControlList: Schema.optional(Grants), Tagging: Schema.optional(Tagging), UserMetadata: Schema.optional(UserMetadata), StorageClass: Schema.optional(Schema.String)})
const CompleteMultipartUploadOutput = Schema.Struct({Location: Schema.optional(Schema.String), Bucket: Schema.optional(Schema.String), Key: Schema.optional(Schema.String), Expiration: Schema.optional(Header("x-amz-expiration")), ETag: Schema.optional(Schema.String), ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String), ChecksumType: Schema.optional(Schema.String), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), VersionId: Schema.optional(Header("x-amz-version-id")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
export const CompleteMultipartUpload = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "CompleteMultipartUpload" }, CompleteMultipartUploadRequest, CompleteMultipartUploadOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CopyObjectOutput = Schema.Struct({CopyObjectResult: Schema.optional(Body("undefined", CopyObjectResult)), Expiration: Schema.optional(Header("x-amz-expiration")), CopySourceVersionId: Schema.optional(Header("x-amz-copy-source-version-id")), VersionId: Schema.optional(Header("x-amz-version-id")), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
const ObjectNotInActiveTierError = Schema.Struct({})
export const CopyObject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?x-id=CopyObject", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "CopyObject" }, CopyObjectRequest, CopyObjectOutput, ErrorAnnotation("ObjectNotInActiveTierError", ObjectNotInActiveTierError)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateBucketOutput = Schema.Struct({Location: Schema.optional(Header("Location")), BucketArn: Schema.optional(Header("x-amz-bucket-arn"))})
const BucketAlreadyExists = Schema.Struct({})
const BucketAlreadyOwnedByYou = Schema.Struct({})
export const CreateBucket = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "CreateBucket" }, CreateBucketRequest, CreateBucketOutput, Schema.Union(ErrorAnnotation("BucketAlreadyExists", BucketAlreadyExists), ErrorAnnotation("BucketAlreadyOwnedByYou", BucketAlreadyOwnedByYou))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetObjectAttributesOutput = Schema.Struct({DeleteMarker: Schema.optional(Header("x-amz-delete-marker", Schema.Boolean)), LastModified: Schema.optional(Header("Last-Modified", Schema.Date)), VersionId: Schema.optional(Header("x-amz-version-id")), RequestCharged: Schema.optional(Header("x-amz-request-charged")), ETag: Schema.optional(Schema.String), Checksum: Schema.optional(Checksum), ObjectParts: Schema.optional(GetObjectAttributesParts), StorageClass: Schema.optional(Schema.String), ObjectSize: Schema.optional(Schema.Number)})
export const GetObjectAttributes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?attributes", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetObjectAttributes" }, GetObjectAttributesRequest, GetObjectAttributesOutput, ErrorAnnotation("NoSuchKey", NoSuchKey)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListObjectsOutput = Schema.Struct({IsTruncated: Schema.optional(Schema.Boolean), Marker: Schema.optional(Schema.String), NextMarker: Schema.optional(Schema.String), Contents: Schema.optional(ObjectList), Name: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), Delimiter: Schema.optional(Schema.String), MaxKeys: Schema.optional(Schema.Number), CommonPrefixes: Schema.optional(CommonPrefixList), EncodingType: Schema.optional(Schema.String), RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
export const ListObjects = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "ListObjects" }, ListObjectsRequest, ListObjectsOutput, ErrorAnnotation("NoSuchBucket", NoSuchBucket)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutBucketAclRequest = Schema.Struct({ACL: Schema.optional(Header("x-amz-acl")), AccessControlPolicy: Schema.optional(Body("AccessControlPolicy", AccessControlPolicy)), Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), GrantFullControl: Schema.optional(Header("x-amz-grant-full-control")), GrantRead: Schema.optional(Header("x-amz-grant-read")), GrantReadACP: Schema.optional(Header("x-amz-grant-read-acp")), GrantWrite: Schema.optional(Header("x-amz-grant-write")), GrantWriteACP: Schema.optional(Header("x-amz-grant-write-acp")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutBucketAcl = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?acl", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketAcl" }, PutBucketAclRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const AnalyticsS3BucketDestination = Schema.Struct({Format: Schema.String, BucketAccountId: Schema.optional(Schema.String), Bucket: Schema.String, Prefix: Schema.optional(Schema.String)})
const PutBucketEncryptionRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ServerSideEncryptionConfiguration: Body("ServerSideEncryptionConfiguration", ServerSideEncryptionConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutBucketEncryption = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?encryption", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketEncryption" }, PutBucketEncryptionRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutBucketIntelligentTieringConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), IntelligentTieringConfiguration: Body("IntelligentTieringConfiguration", IntelligentTieringConfiguration)})
export const PutBucketIntelligentTieringConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?intelligent-tiering", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketIntelligentTieringConfiguration" }, PutBucketIntelligentTieringConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const SSEKMS = Schema.Struct({KeyId: Schema.String})
const PutBucketMetricsConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, MetricsConfiguration: Body("MetricsConfiguration", MetricsConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutBucketMetricsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?metrics", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketMetricsConfiguration" }, PutBucketMetricsConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const FilterRule = Schema.Struct({Name: Schema.optional(Schema.String), Value: Schema.optional(Schema.String)})
const FilterRuleList = Schema.Array(FilterRule)
const ReplicationTimeValue = Schema.Struct({Minutes: Schema.optional(Schema.Number)})
const PutBucketWebsiteRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), WebsiteConfiguration: Body("WebsiteConfiguration", WebsiteConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutBucketWebsite = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?website", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketWebsite" }, PutBucketWebsiteRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutObjectLockConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ObjectLockConfiguration: Schema.optional(Body("ObjectLockConfiguration", ObjectLockConfiguration)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), Token: Schema.optional(Header("x-amz-bucket-object-lock-token")), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const MetadataConfigurationResult = Schema.Struct({DestinationResult: DestinationResult, JournalTableConfigurationResult: Schema.optional(JournalTableConfigurationResult), InventoryTableConfigurationResult: Schema.optional(InventoryTableConfigurationResult)})
const MetadataTableConfigurationResult = Schema.Struct({S3TablesDestinationResult: S3TablesDestinationResult})
const LifecycleRule = Schema.Struct({Expiration: Schema.optional(LifecycleExpiration), ID: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), Filter: Schema.optional(LifecycleRuleFilter), Status: Schema.String, Transitions: Schema.optional(TransitionList), NoncurrentVersionTransitions: Schema.optional(NoncurrentVersionTransitionList), NoncurrentVersionExpiration: Schema.optional(NoncurrentVersionExpiration), AbortIncompleteMultipartUpload: Schema.optional(AbortIncompleteMultipartUpload)})
const LifecycleRules = Schema.Array(LifecycleRule)
const LoggingEnabled = Schema.Struct({TargetBucket: Schema.String, TargetGrants: Schema.optional(TargetGrants), TargetPrefix: Schema.String, TargetObjectKeyFormat: Schema.optional(TargetObjectKeyFormat)})
const OutputLocation = Schema.Struct({S3: Schema.optional(S3Location)})
const ContinuationEvent = Schema.Struct({})
const EndEvent = Schema.Struct({})
const AnalyticsExportDestination = Schema.Struct({S3BucketDestination: AnalyticsS3BucketDestination})
const InventoryEncryption = Schema.Struct({SSES3: Schema.optional(SSES3), SSEKMS: Schema.optional(SSEKMS)})
const S3KeyFilter = Schema.Struct({FilterRules: Schema.optional(FilterRuleList)})
const ReplicationTime = Schema.Struct({Status: Schema.String, Time: ReplicationTimeValue})
const DeletedObject = Schema.Struct({Key: Schema.optional(Schema.String), VersionId: Schema.optional(Schema.String), DeleteMarker: Schema.optional(Schema.Boolean), DeleteMarkerVersionId: Schema.optional(Schema.String)})
const DeletedObjects = Schema.Array(DeletedObject)
const Error = Schema.Struct({Key: Schema.optional(Schema.String), VersionId: Schema.optional(Schema.String), Code: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
const Errors = Schema.Array(Error)
const GetBucketMetadataConfigurationResult = Schema.Struct({MetadataConfigurationResult: MetadataConfigurationResult})
const GetBucketMetadataTableConfigurationResult = Schema.Struct({MetadataTableConfigurationResult: MetadataTableConfigurationResult, Status: Schema.String, Error: Schema.optional(ErrorDetails)})
const BucketLifecycleConfiguration = Schema.Struct({Rules: LifecycleRules})
const BucketLoggingStatus = Schema.Struct({LoggingEnabled: Schema.optional(LoggingEnabled)})
const RestoreRequest = Schema.Struct({Days: Schema.optional(Schema.Number), GlacierJobParameters: Schema.optional(GlacierJobParameters), Type: Schema.optional(Schema.String), Tier: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), SelectParameters: Schema.optional(SelectParameters), OutputLocation: Schema.optional(OutputLocation)})
const StorageClassAnalysisDataExport = Schema.Struct({OutputSchemaVersion: Schema.String, Destination: AnalyticsExportDestination})
const InventoryS3BucketDestination = Schema.Struct({AccountId: Schema.optional(Schema.String), Bucket: Schema.String, Format: Schema.String, Prefix: Schema.optional(Schema.String), Encryption: Schema.optional(InventoryEncryption)})
const NotificationConfigurationFilter = Schema.Struct({Key: Schema.optional(S3KeyFilter)})
const Destination = Schema.Struct({Bucket: Schema.String, Account: Schema.optional(Schema.String), StorageClass: Schema.optional(Schema.String), AccessControlTranslation: Schema.optional(AccessControlTranslation), EncryptionConfiguration: Schema.optional(EncryptionConfiguration), ReplicationTime: Schema.optional(ReplicationTime), Metrics: Schema.optional(Metrics)})
const DeleteObjectsOutput = Schema.Struct({Deleted: Schema.optional(DeletedObjects), RequestCharged: Schema.optional(Header("x-amz-request-charged")), Errors: Schema.optional(Errors)})
export const DeleteObjects = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?delete", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "DeleteObjects" }, DeleteObjectsRequest, DeleteObjectsOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketMetadataConfigurationOutput = Schema.Struct({GetBucketMetadataConfigurationResult: Schema.optional(Body("undefined", GetBucketMetadataConfigurationResult))})
export const GetBucketMetadataConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?metadataConfiguration", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketMetadataConfiguration" }, GetBucketMetadataConfigurationRequest, GetBucketMetadataConfigurationOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBucketMetadataTableConfigurationOutput = Schema.Struct({GetBucketMetadataTableConfigurationResult: Schema.optional(Body("undefined", GetBucketMetadataTableConfigurationResult))})
export const GetBucketMetadataTableConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?metadataTable", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "GetBucketMetadataTableConfiguration" }, GetBucketMetadataTableConfigurationRequest, GetBucketMetadataTableConfigurationOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutBucketLifecycleConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), LifecycleConfiguration: Schema.optional(Body("LifecycleConfiguration", BucketLifecycleConfiguration)), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), TransitionDefaultMinimumObjectSize: Schema.optional(Header("x-amz-transition-default-minimum-object-size"))})
const PutBucketLoggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), BucketLoggingStatus: Body("BucketLoggingStatus", BucketLoggingStatus), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutBucketLogging = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?logging", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketLogging" }, PutBucketLoggingRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutObjectLockConfigurationOutput = Schema.Struct({RequestCharged: Schema.optional(Header("x-amz-request-charged"))})
export const PutObjectLockConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?object-lock", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutObjectLockConfiguration" }, PutObjectLockConfigurationRequest, PutObjectLockConfigurationOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const RestoreObjectRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), RestoreRequest: Schema.optional(Body("RestoreRequest", RestoreRequest)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
const StorageClassAnalysis = Schema.Struct({DataExport: Schema.optional(StorageClassAnalysisDataExport)})
const InventoryDestination = Schema.Struct({S3BucketDestination: InventoryS3BucketDestination})
const TopicConfiguration = Schema.Struct({Id: Schema.optional(Schema.String), TopicArn: Schema.String, Events: EventList, Filter: Schema.optional(NotificationConfigurationFilter)})
const TopicConfigurationList = Schema.Array(TopicConfiguration)
const ReplicationRule = Schema.Struct({ID: Schema.optional(Schema.String), Priority: Schema.optional(Schema.Number), Prefix: Schema.optional(Schema.String), Filter: Schema.optional(ReplicationRuleFilter), Status: Schema.String, SourceSelectionCriteria: Schema.optional(SourceSelectionCriteria), ExistingObjectReplication: Schema.optional(ExistingObjectReplication), Destination: Destination, DeleteMarkerReplication: Schema.optional(DeleteMarkerReplication)})
const ReplicationRules = Schema.Array(ReplicationRule)
const RecordsEvent = Schema.Struct({Payload: Schema.optional(StreamBody())})
const AnalyticsConfiguration = Schema.Struct({Id: Schema.String, Filter: Schema.optional(AnalyticsFilter), StorageClassAnalysis: StorageClassAnalysis})
const InventoryConfiguration = Schema.Struct({Destination: InventoryDestination, IsEnabled: Schema.Boolean, Filter: Schema.optional(InventoryFilter), Id: Schema.String, IncludedObjectVersions: Schema.String, OptionalFields: Schema.optional(InventoryOptionalFields), Schedule: InventorySchedule})
const NotificationConfiguration = Schema.Struct({TopicConfigurations: Schema.optional(TopicConfigurationList), QueueConfigurations: Schema.optional(QueueConfigurationList), LambdaFunctionConfigurations: Schema.optional(LambdaFunctionConfigurationList), EventBridgeConfiguration: Schema.optional(EventBridgeConfiguration)})
const ReplicationConfiguration = Schema.Struct({Role: Schema.String, Rules: ReplicationRules})
const Stats = Schema.Struct({BytesScanned: Schema.optional(Schema.Number), BytesProcessed: Schema.optional(Schema.Number), BytesReturned: Schema.optional(Schema.Number)})
const Progress = Schema.Struct({BytesScanned: Schema.optional(Schema.Number), BytesProcessed: Schema.optional(Schema.Number), BytesReturned: Schema.optional(Schema.Number)})
const PutBucketAnalyticsConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, AnalyticsConfiguration: Body("AnalyticsConfiguration", AnalyticsConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutBucketAnalyticsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?analytics", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketAnalyticsConfiguration" }, PutBucketAnalyticsConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutBucketInventoryConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, InventoryConfiguration: Body("InventoryConfiguration", InventoryConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutBucketInventoryConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?inventory", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketInventoryConfiguration" }, PutBucketInventoryConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutBucketLifecycleConfigurationOutput = Schema.Struct({TransitionDefaultMinimumObjectSize: Schema.optional(Header("x-amz-transition-default-minimum-object-size"))})
export const PutBucketLifecycleConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?lifecycle", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketLifecycleConfiguration" }, PutBucketLifecycleConfigurationRequest, PutBucketLifecycleConfigurationOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutBucketNotificationConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), NotificationConfiguration: Body("NotificationConfiguration", NotificationConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), SkipDestinationValidation: Schema.optional(Header("x-amz-skip-destination-validation", Schema.Boolean))})
export const PutBucketNotificationConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?notification", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketNotificationConfiguration" }, PutBucketNotificationConfigurationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutBucketReplicationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ReplicationConfiguration: Body("ReplicationConfiguration", ReplicationConfiguration), Token: Schema.optional(Header("x-amz-bucket-object-lock-token")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))})
export const PutBucketReplication = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}?replication", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "PutBucketReplication" }, PutBucketReplicationRequest, Schema.Struct({}), Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const RestoreObjectOutput = Schema.Struct({RequestCharged: Schema.optional(Header("x-amz-request-charged")), RestoreOutputPath: Schema.optional(Header("x-amz-restore-output-path"))})
const ObjectAlreadyInActiveTierError = Schema.Struct({})
export const RestoreObject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?restore", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "RestoreObject" }, RestoreObjectRequest, RestoreObjectOutput, ErrorAnnotation("ObjectAlreadyInActiveTierError", ObjectAlreadyInActiveTierError)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const StatsEvent = Schema.Struct({Details: Schema.optional(Stats)})
const ProgressEvent = Schema.Struct({Details: Schema.optional(Progress)})
const SelectObjectContentEventStream = Schema.Union(RecordsEvent, StatsEvent, ProgressEvent, ContinuationEvent, EndEvent)
const SelectObjectContentOutput = Schema.Struct({Payload: Schema.optional(Body("undefined", SelectObjectContentEventStream))})
export const SelectObjectContent = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/{Bucket}/{Key+}?select&select-type=2", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "SelectObjectContent" }, SelectObjectContentRequest, SelectObjectContentOutput, Schema.Void), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
