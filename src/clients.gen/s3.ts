import { Schema} from "effect"
import { FormatXMLRequest,FormatXMLResponse,FormatAwsXMLError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const ObjectAttributesList = Schema.Array(Schema.String);
export const OptionalObjectAttributesList = Schema.Array(Schema.String);
export const AbortMultipartUploadRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Path("Key", Schema.String), UploadId: Schema.String, RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), IfMatchInitiatedTime: Schema.optional(Header("x-amz-if-match-initiated-time", Schema.Date))});
export const Metadata = Schema.Record({key: Schema.String, value: Schema.String});
export const CreateMultipartUploadRequest = Schema.Struct({ACL: Schema.optional(Header("x-amz-acl")), Bucket: Path("Bucket", Schema.String), CacheControl: Schema.optional(Header("Cache-Control")), ContentDisposition: Schema.optional(Header("Content-Disposition")), ContentEncoding: Schema.optional(Header("Content-Encoding")), ContentLanguage: Schema.optional(Header("Content-Language")), ContentType: Schema.optional(Header("Content-Type")), Expires: Schema.optional(Header("Expires")), GrantFullControl: Schema.optional(Header("x-amz-grant-full-control")), GrantRead: Schema.optional(Header("x-amz-grant-read")), GrantReadACP: Schema.optional(Header("x-amz-grant-read-acp")), GrantWriteACP: Schema.optional(Header("x-amz-grant-write-acp")), Key: Path("Key", Schema.String), Metadata: Schema.optional(Metadata), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), StorageClass: Schema.optional(Header("x-amz-storage-class")), WebsiteRedirectLocation: Schema.optional(Header("x-amz-website-redirect-location")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), Tagging: Schema.optional(Header("x-amz-tagging")), ObjectLockMode: Schema.optional(Header("x-amz-object-lock-mode")), ObjectLockRetainUntilDate: Schema.optional(Header("x-amz-object-lock-retain-until-date", Schema.Date)), ObjectLockLegalHoldStatus: Schema.optional(Header("x-amz-object-lock-legal-hold")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ChecksumAlgorithm: Schema.optional(Header("x-amz-checksum-algorithm")), ChecksumType: Schema.optional(Header("x-amz-checksum-type"))});
export const CreateSessionRequest = Schema.Struct({SessionMode: Schema.optional(Header("x-amz-create-session-mode")), Bucket: Path("Bucket", Schema.String), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean))});
export const DeleteBucketRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketAnalyticsConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketCorsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketEncryptionRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketIntelligentTieringConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketInventoryConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketLifecycleRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketMetadataConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketMetadataTableConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketMetricsConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketOwnershipControlsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketPolicyRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketReplicationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketTaggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteBucketWebsiteRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeleteObjectRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Path("Key", Schema.String), MFA: Schema.optional(Header("x-amz-mfa")), VersionId: Schema.optional(Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), BypassGovernanceRetention: Schema.optional(Header("x-amz-bypass-governance-retention", Schema.Boolean)), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), IfMatch: Schema.optional(Header("If-Match")), IfMatchLastModifiedTime: Schema.optional(Header("x-amz-if-match-last-modified-time", Schema.Date)), IfMatchSize: Schema.optional(Header("x-amz-if-match-size", Schema.Number))});
export const DeleteObjectTaggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const DeletePublicAccessBlockRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketAccelerateConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), RequestPayer: Schema.optional(Header("x-amz-request-payer"))});
export const GetBucketAclRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketAnalyticsConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketCorsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketEncryptionRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketIntelligentTieringConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketInventoryConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketLifecycleConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketLocationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketLoggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketMetadataConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketMetadataTableConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketMetricsConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketNotificationConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketOwnershipControlsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketPolicyRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketPolicyStatusRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketReplicationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketRequestPaymentRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketTaggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketVersioningRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetBucketWebsiteRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetObjectRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), IfMatch: Schema.optional(Header("If-Match")), IfModifiedSince: Schema.optional(Header("If-Modified-Since", Schema.Date)), IfNoneMatch: Schema.optional(Header("If-None-Match")), IfUnmodifiedSince: Schema.optional(Header("If-Unmodified-Since", Schema.Date)), Key: Path("Key", Schema.String), Range: Schema.optional(Header("Range")), ResponseCacheControl: Schema.optional(Schema.String), ResponseContentDisposition: Schema.optional(Schema.String), ResponseContentEncoding: Schema.optional(Schema.String), ResponseContentLanguage: Schema.optional(Schema.String), ResponseContentType: Schema.optional(Schema.String), ResponseExpires: Schema.optional(Schema.Date), VersionId: Schema.optional(Schema.String), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), PartNumber: Schema.optional(Schema.Number), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ChecksumMode: Schema.optional(Header("x-amz-checksum-mode"))});
export const GetObjectAclRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Path("Key", Schema.String), VersionId: Schema.optional(Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetObjectAttributesRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), MaxParts: Schema.optional(Header("x-amz-max-parts", Schema.Number)), PartNumberMarker: Schema.optional(Header("x-amz-part-number-marker")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ObjectAttributes: Header("x-amz-object-attributes", ObjectAttributesList)});
export const GetObjectLegalHoldRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetObjectLockConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetObjectRetentionRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetObjectTaggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), RequestPayer: Schema.optional(Header("x-amz-request-payer"))});
export const GetObjectTorrentRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const GetPublicAccessBlockRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const HeadBucketRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const HeadObjectRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), IfMatch: Schema.optional(Header("If-Match")), IfModifiedSince: Schema.optional(Header("If-Modified-Since", Schema.Date)), IfNoneMatch: Schema.optional(Header("If-None-Match")), IfUnmodifiedSince: Schema.optional(Header("If-Unmodified-Since", Schema.Date)), Key: Path("Key", Schema.String), Range: Schema.optional(Header("Range")), ResponseCacheControl: Schema.optional(Schema.String), ResponseContentDisposition: Schema.optional(Schema.String), ResponseContentEncoding: Schema.optional(Schema.String), ResponseContentLanguage: Schema.optional(Schema.String), ResponseContentType: Schema.optional(Schema.String), ResponseExpires: Schema.optional(Schema.Date), VersionId: Schema.optional(Schema.String), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), PartNumber: Schema.optional(Schema.Number), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ChecksumMode: Schema.optional(Header("x-amz-checksum-mode"))});
export const ListBucketAnalyticsConfigurationsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContinuationToken: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const ListBucketIntelligentTieringConfigurationsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContinuationToken: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const ListBucketInventoryConfigurationsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContinuationToken: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const ListBucketMetricsConfigurationsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContinuationToken: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const ListBucketsRequest = Schema.Struct({MaxBuckets: Schema.optional(Schema.Number), ContinuationToken: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), BucketRegion: Schema.optional(Schema.String)});
export const ListDirectoryBucketsRequest = Schema.Struct({ContinuationToken: Schema.optional(Schema.String), MaxDirectoryBuckets: Schema.optional(Schema.Number)});
export const ListMultipartUploadsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Delimiter: Schema.optional(Schema.String), EncodingType: Schema.optional(Schema.String), KeyMarker: Schema.optional(Schema.String), MaxUploads: Schema.optional(Schema.Number), Prefix: Schema.optional(Schema.String), UploadIdMarker: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), RequestPayer: Schema.optional(Header("x-amz-request-payer"))});
export const ListObjectsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Delimiter: Schema.optional(Schema.String), EncodingType: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxKeys: Schema.optional(Schema.Number), Prefix: Schema.optional(Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), OptionalObjectAttributes: Schema.optional(Header("x-amz-optional-object-attributes", OptionalObjectAttributesList))});
export const ListObjectsV2Request = Schema.Struct({Bucket: Path("Bucket", Schema.String), Delimiter: Schema.optional(Schema.String), EncodingType: Schema.optional(Schema.String), MaxKeys: Schema.optional(Schema.Number), Prefix: Schema.optional(Schema.String), ContinuationToken: Schema.optional(Schema.String), FetchOwner: Schema.optional(Schema.Boolean), StartAfter: Schema.optional(Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), OptionalObjectAttributes: Schema.optional(Header("x-amz-optional-object-attributes", OptionalObjectAttributesList))});
export const ListObjectVersionsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Delimiter: Schema.optional(Schema.String), EncodingType: Schema.optional(Schema.String), KeyMarker: Schema.optional(Schema.String), MaxKeys: Schema.optional(Schema.Number), Prefix: Schema.optional(Schema.String), VersionIdMarker: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), OptionalObjectAttributes: Schema.optional(Header("x-amz-optional-object-attributes", OptionalObjectAttributesList))});
export const ListPartsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Path("Key", Schema.String), MaxParts: Schema.optional(Schema.Number), PartNumberMarker: Schema.optional(Schema.String), UploadId: Schema.String, RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5"))});
export const PutBucketPolicyRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ConfirmRemoveSelfBucketAccess: Schema.optional(Header("x-amz-confirm-remove-self-bucket-access", Schema.Boolean)), Policy: Body("undefined", Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutObjectRequest = Schema.Struct({ACL: Schema.optional(Header("x-amz-acl")), Body: Schema.optional(Body("undefined", StreamBody())), Bucket: Path("Bucket", Schema.String), CacheControl: Schema.optional(Header("Cache-Control")), ContentDisposition: Schema.optional(Header("Content-Disposition")), ContentEncoding: Schema.optional(Header("Content-Encoding")), ContentLanguage: Schema.optional(Header("Content-Language")), ContentLength: Schema.optional(Header("Content-Length", Schema.Number)), ContentMD5: Schema.optional(Header("Content-MD5")), ContentType: Schema.optional(Header("Content-Type")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), Expires: Schema.optional(Header("Expires")), IfMatch: Schema.optional(Header("If-Match")), IfNoneMatch: Schema.optional(Header("If-None-Match")), GrantFullControl: Schema.optional(Header("x-amz-grant-full-control")), GrantRead: Schema.optional(Header("x-amz-grant-read")), GrantReadACP: Schema.optional(Header("x-amz-grant-read-acp")), GrantWriteACP: Schema.optional(Header("x-amz-grant-write-acp")), Key: Path("Key", Schema.String), WriteOffsetBytes: Schema.optional(Header("x-amz-write-offset-bytes", Schema.Number)), Metadata: Schema.optional(Metadata), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), StorageClass: Schema.optional(Header("x-amz-storage-class")), WebsiteRedirectLocation: Schema.optional(Header("x-amz-website-redirect-location")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), Tagging: Schema.optional(Header("x-amz-tagging")), ObjectLockMode: Schema.optional(Header("x-amz-object-lock-mode")), ObjectLockRetainUntilDate: Schema.optional(Header("x-amz-object-lock-retain-until-date", Schema.Date)), ObjectLockLegalHoldStatus: Schema.optional(Header("x-amz-object-lock-legal-hold")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const Grantee = Schema.Struct({DisplayName: Schema.optional(Schema.String), EmailAddress: Schema.optional(Schema.String), ID: Schema.optional(Schema.String), URI: Schema.optional(Schema.String), Type: Schema.String});
export const Grant = Schema.Struct({Grantee: Schema.optional(Grantee), Permission: Schema.optional(Schema.String)});
export const Grants = Schema.Array(Grant);
export const Owner = Schema.Struct({DisplayName: Schema.optional(Schema.String), ID: Schema.optional(Schema.String)});
export const AccessControlPolicy = Schema.Struct({Grants: Schema.optional(Grants), Owner: Schema.optional(Owner)});
export const PutObjectAclRequest = Schema.Struct({ACL: Schema.optional(Header("x-amz-acl")), AccessControlPolicy: Schema.optional(Body("AccessControlPolicy", AccessControlPolicy)), Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), GrantFullControl: Schema.optional(Header("x-amz-grant-full-control")), GrantRead: Schema.optional(Header("x-amz-grant-read")), GrantReadACP: Schema.optional(Header("x-amz-grant-read-acp")), GrantWrite: Schema.optional(Header("x-amz-grant-write")), GrantWriteACP: Schema.optional(Header("x-amz-grant-write-acp")), Key: Path("Key", Schema.String), RequestPayer: Schema.optional(Header("x-amz-request-payer")), VersionId: Schema.optional(Schema.String), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const Tag = Schema.Struct({Key: Schema.String, Value: Schema.String});
export const TagSet = Schema.Array(Tag);
export const Tagging = Schema.Struct({TagSet: TagSet});
export const PutObjectTaggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), Tagging: Body("Tagging", Tagging), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), RequestPayer: Schema.optional(Header("x-amz-request-payer"))});
export const RenameObjectRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Path("Key", Schema.String), RenameSource: Header("x-amz-rename-source"), DestinationIfMatch: Schema.optional(Header("If-Match")), DestinationIfNoneMatch: Schema.optional(Header("If-None-Match")), DestinationIfModifiedSince: Schema.optional(Header("If-Modified-Since", Schema.Date)), DestinationIfUnmodifiedSince: Schema.optional(Header("If-Unmodified-Since", Schema.Date)), SourceIfMatch: Schema.optional(Header("x-amz-rename-source-if-match")), SourceIfNoneMatch: Schema.optional(Header("x-amz-rename-source-if-none-match")), SourceIfModifiedSince: Schema.optional(Header("x-amz-rename-source-if-modified-since", Schema.Date)), SourceIfUnmodifiedSince: Schema.optional(Header("x-amz-rename-source-if-unmodified-since", Schema.Date)), ClientToken: Schema.optional(Header("x-amz-client-token"))});
export const RenameObjectOutput = Schema.Struct({});
export const IdempotencyParameterMismatch = Schema.Struct({});
export const UploadPartRequest = Schema.Struct({Body: Schema.optional(Body("undefined", StreamBody())), Bucket: Path("Bucket", Schema.String), ContentLength: Schema.optional(Header("Content-Length", Schema.Number)), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), Key: Path("Key", Schema.String), PartNumber: Schema.Number, UploadId: Schema.String, SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const UploadPartCopyRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), CopySource: Header("x-amz-copy-source"), CopySourceIfMatch: Schema.optional(Header("x-amz-copy-source-if-match")), CopySourceIfModifiedSince: Schema.optional(Header("x-amz-copy-source-if-modified-since", Schema.Date)), CopySourceIfNoneMatch: Schema.optional(Header("x-amz-copy-source-if-none-match")), CopySourceIfUnmodifiedSince: Schema.optional(Header("x-amz-copy-source-if-unmodified-since", Schema.Date)), CopySourceRange: Schema.optional(Header("x-amz-copy-source-range")), Key: Schema.String, PartNumber: Schema.Number, UploadId: Schema.String, SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), CopySourceSSECustomerAlgorithm: Schema.optional(Header("x-amz-copy-source-server-side-encryption-customer-algorithm")), CopySourceSSECustomerKey: Schema.optional(Header("x-amz-copy-source-server-side-encryption-customer-key")), CopySourceSSECustomerKeyMD5: Schema.optional(Header("x-amz-copy-source-server-side-encryption-customer-key-MD5")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ExpectedSourceBucketOwner: Schema.optional(Header("x-amz-source-expected-bucket-owner"))});
export const WriteGetObjectResponseRequest = Schema.Struct({RequestRoute: Header("x-amz-request-route"), RequestToken: Header("x-amz-request-token"), Body: Schema.optional(Body("undefined", StreamBody())), StatusCode: Schema.optional(Header("x-amz-fwd-status", Schema.Number)), ErrorCode: Schema.optional(Header("x-amz-fwd-error-code")), ErrorMessage: Schema.optional(Header("x-amz-fwd-error-message")), AcceptRanges: Schema.optional(Header("x-amz-fwd-header-accept-ranges")), CacheControl: Schema.optional(Header("x-amz-fwd-header-Cache-Control")), ContentDisposition: Schema.optional(Header("x-amz-fwd-header-Content-Disposition")), ContentEncoding: Schema.optional(Header("x-amz-fwd-header-Content-Encoding")), ContentLanguage: Schema.optional(Header("x-amz-fwd-header-Content-Language")), ContentLength: Schema.optional(Header("Content-Length", Schema.Number)), ContentRange: Schema.optional(Header("x-amz-fwd-header-Content-Range")), ContentType: Schema.optional(Header("x-amz-fwd-header-Content-Type")), ChecksumCRC32: Schema.optional(Header("x-amz-fwd-header-x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-fwd-header-x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-fwd-header-x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-fwd-header-x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-fwd-header-x-amz-checksum-sha256")), DeleteMarker: Schema.optional(Header("x-amz-fwd-header-x-amz-delete-marker", Schema.Boolean)), ETag: Schema.optional(Header("x-amz-fwd-header-ETag")), Expires: Schema.optional(Header("x-amz-fwd-header-Expires")), Expiration: Schema.optional(Header("x-amz-fwd-header-x-amz-expiration")), LastModified: Schema.optional(Header("x-amz-fwd-header-Last-Modified", Schema.Date)), MissingMeta: Schema.optional(Header("x-amz-fwd-header-x-amz-missing-meta", Schema.Number)), Metadata: Schema.optional(Metadata), ObjectLockMode: Schema.optional(Header("x-amz-fwd-header-x-amz-object-lock-mode")), ObjectLockLegalHoldStatus: Schema.optional(Header("x-amz-fwd-header-x-amz-object-lock-legal-hold")), ObjectLockRetainUntilDate: Schema.optional(Header("x-amz-fwd-header-x-amz-object-lock-retain-until-date", Schema.Date)), PartsCount: Schema.optional(Header("x-amz-fwd-header-x-amz-mp-parts-count", Schema.Number)), ReplicationStatus: Schema.optional(Header("x-amz-fwd-header-x-amz-replication-status")), RequestCharged: Schema.optional(Header("x-amz-fwd-header-x-amz-request-charged")), Restore: Schema.optional(Header("x-amz-fwd-header-x-amz-restore")), ServerSideEncryption: Schema.optional(Header("x-amz-fwd-header-x-amz-server-side-encryption")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm")), SSEKMSKeyId: Schema.optional(Header("x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-fwd-header-x-amz-server-side-encryption-customer-key-MD5")), StorageClass: Schema.optional(Header("x-amz-fwd-header-x-amz-storage-class")), TagCount: Schema.optional(Header("x-amz-fwd-header-x-amz-tagging-count", Schema.Number)), VersionId: Schema.optional(Header("x-amz-fwd-header-x-amz-version-id")), BucketKeyEnabled: Schema.optional(Header("x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean))});
export const InventoryOptionalFields = Schema.Array(Schema.String);
export const EventBridgeConfiguration = Schema.Struct({});
export const ParquetInput = Schema.Struct({});
export const AnalyticsAndOperator = Schema.Struct({Prefix: Schema.optional(Schema.String), Tags: Schema.optional(TagSet)});
export const AnalyticsFilter = Schema.Union(Schema.String, Tag, AnalyticsAndOperator);
export const AnalyticsS3BucketDestination = Schema.Struct({Format: Schema.String, BucketAccountId: Schema.optional(Schema.String), Bucket: Schema.String, Prefix: Schema.optional(Schema.String)});
export const AnalyticsExportDestination = Schema.Struct({S3BucketDestination: AnalyticsS3BucketDestination});
export const StorageClassAnalysisDataExport = Schema.Struct({OutputSchemaVersion: Schema.String, Destination: AnalyticsExportDestination});
export const StorageClassAnalysis = Schema.Struct({DataExport: Schema.optional(StorageClassAnalysisDataExport)});
export const AnalyticsConfiguration = Schema.Struct({Id: Schema.String, Filter: Schema.optional(AnalyticsFilter), StorageClassAnalysis: StorageClassAnalysis});
export const AnalyticsConfigurationList = Schema.Array(AnalyticsConfiguration);
export const IntelligentTieringAndOperator = Schema.Struct({Prefix: Schema.optional(Schema.String), Tags: Schema.optional(TagSet)});
export const IntelligentTieringFilter = Schema.Struct({Prefix: Schema.optional(Schema.String), Tag: Schema.optional(Tag), And: Schema.optional(IntelligentTieringAndOperator)});
export const Tiering = Schema.Struct({Days: Schema.Number, AccessTier: Schema.String});
export const TieringList = Schema.Array(Tiering);
export const IntelligentTieringConfiguration = Schema.Struct({Id: Schema.String, Filter: Schema.optional(IntelligentTieringFilter), Status: Schema.String, Tierings: TieringList});
export const IntelligentTieringConfigurationList = Schema.Array(IntelligentTieringConfiguration);
export const SSES3 = Schema.Struct({});
export const SSEKMS = Schema.Struct({KeyId: Schema.String});
export const InventoryEncryption = Schema.Struct({SSES3: Schema.optional(SSES3), SSEKMS: Schema.optional(SSEKMS)});
export const InventoryS3BucketDestination = Schema.Struct({AccountId: Schema.optional(Schema.String), Bucket: Schema.String, Format: Schema.String, Prefix: Schema.optional(Schema.String), Encryption: Schema.optional(InventoryEncryption)});
export const InventoryDestination = Schema.Struct({S3BucketDestination: InventoryS3BucketDestination});
export const InventoryFilter = Schema.Struct({Prefix: Schema.String});
export const InventorySchedule = Schema.Struct({Frequency: Schema.String});
export const InventoryConfiguration = Schema.Struct({Destination: InventoryDestination, IsEnabled: Schema.Boolean, Filter: Schema.optional(InventoryFilter), Id: Schema.String, IncludedObjectVersions: Schema.String, OptionalFields: Schema.optional(InventoryOptionalFields), Schedule: InventorySchedule});
export const InventoryConfigurationList = Schema.Array(InventoryConfiguration);
export const MetricsAndOperator = Schema.Struct({Prefix: Schema.optional(Schema.String), Tags: Schema.optional(TagSet), AccessPointArn: Schema.optional(Schema.String)});
export const MetricsFilter = Schema.Union(Schema.String, Tag, Schema.String, MetricsAndOperator);
export const MetricsConfiguration = Schema.Struct({Id: Schema.String, Filter: Schema.optional(MetricsFilter)});
export const MetricsConfigurationList = Schema.Array(MetricsConfiguration);
export const AccelerateConfiguration = Schema.Struct({Status: Schema.optional(Schema.String)});
export const RequestPaymentConfiguration = Schema.Struct({Payer: Schema.String});
export const VersioningConfiguration = Schema.Struct({MFADelete: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)});
export const ObjectLockLegalHold = Schema.Struct({Status: Schema.optional(Schema.String)});
export const ObjectLockRetention = Schema.Struct({Mode: Schema.optional(Schema.String), RetainUntilDate: Schema.optional(Schema.Date)});
export const PublicAccessBlockConfiguration = Schema.Struct({BlockPublicAcls: Schema.optional(Schema.Boolean), IgnorePublicAcls: Schema.optional(Schema.Boolean), BlockPublicPolicy: Schema.optional(Schema.Boolean), RestrictPublicBuckets: Schema.optional(Schema.Boolean)});
export const RequestProgress = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)});
export const ScanRange = Schema.Struct({Start: Schema.optional(Schema.Number), End: Schema.optional(Schema.Number)});
export const AllowedHeaders = Schema.Array(Schema.String);
export const AllowedMethods = Schema.Array(Schema.String);
export const AllowedOrigins = Schema.Array(Schema.String);
export const ExposeHeaders = Schema.Array(Schema.String);
export const EventList = Schema.Array(Schema.String);
export const AbortMultipartUploadOutput = Schema.Struct({RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const NoSuchUpload = Schema.Struct({});
export const CopyObjectRequest = Schema.Struct({ACL: Schema.optional(Header("x-amz-acl")), Bucket: Path("Bucket", Schema.String), CacheControl: Schema.optional(Header("Cache-Control")), ChecksumAlgorithm: Schema.optional(Header("x-amz-checksum-algorithm")), ContentDisposition: Schema.optional(Header("Content-Disposition")), ContentEncoding: Schema.optional(Header("Content-Encoding")), ContentLanguage: Schema.optional(Header("Content-Language")), ContentType: Schema.optional(Header("Content-Type")), CopySource: Header("x-amz-copy-source"), CopySourceIfMatch: Schema.optional(Header("x-amz-copy-source-if-match")), CopySourceIfModifiedSince: Schema.optional(Header("x-amz-copy-source-if-modified-since", Schema.Date)), CopySourceIfNoneMatch: Schema.optional(Header("x-amz-copy-source-if-none-match")), CopySourceIfUnmodifiedSince: Schema.optional(Header("x-amz-copy-source-if-unmodified-since", Schema.Date)), Expires: Schema.optional(Header("Expires")), GrantFullControl: Schema.optional(Header("x-amz-grant-full-control")), GrantRead: Schema.optional(Header("x-amz-grant-read")), GrantReadACP: Schema.optional(Header("x-amz-grant-read-acp")), GrantWriteACP: Schema.optional(Header("x-amz-grant-write-acp")), IfMatch: Schema.optional(Header("If-Match")), IfNoneMatch: Schema.optional(Header("If-None-Match")), Key: Path("Key", Schema.String), Metadata: Schema.optional(Metadata), MetadataDirective: Schema.optional(Header("x-amz-metadata-directive")), TaggingDirective: Schema.optional(Header("x-amz-tagging-directive")), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), StorageClass: Schema.optional(Header("x-amz-storage-class")), WebsiteRedirectLocation: Schema.optional(Header("x-amz-website-redirect-location")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), CopySourceSSECustomerAlgorithm: Schema.optional(Header("x-amz-copy-source-server-side-encryption-customer-algorithm")), CopySourceSSECustomerKey: Schema.optional(Header("x-amz-copy-source-server-side-encryption-customer-key")), CopySourceSSECustomerKeyMD5: Schema.optional(Header("x-amz-copy-source-server-side-encryption-customer-key-MD5")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), Tagging: Schema.optional(Header("x-amz-tagging")), ObjectLockMode: Schema.optional(Header("x-amz-object-lock-mode")), ObjectLockRetainUntilDate: Schema.optional(Header("x-amz-object-lock-retain-until-date", Schema.Date)), ObjectLockLegalHoldStatus: Schema.optional(Header("x-amz-object-lock-legal-hold")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ExpectedSourceBucketOwner: Schema.optional(Header("x-amz-source-expected-bucket-owner"))});
export const CreateMultipartUploadOutput = Schema.Struct({AbortDate: Schema.optional(Header("x-amz-abort-date", Schema.Date)), AbortRuleId: Schema.optional(Header("x-amz-abort-rule-id")), Bucket: Schema.optional(Schema.String), Key: Schema.optional(Schema.String), UploadId: Schema.optional(Schema.String), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestCharged: Schema.optional(Header("x-amz-request-charged")), ChecksumAlgorithm: Schema.optional(Header("x-amz-checksum-algorithm")), ChecksumType: Schema.optional(Header("x-amz-checksum-type"))});
export const DeleteObjectOutput = Schema.Struct({DeleteMarker: Schema.optional(Header("x-amz-delete-marker", Schema.Boolean)), VersionId: Schema.optional(Header("x-amz-version-id")), RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const DeleteObjectTaggingOutput = Schema.Struct({VersionId: Schema.optional(Header("x-amz-version-id"))});
export const GetBucketAccelerateConfigurationOutput = Schema.Struct({Status: Schema.optional(Schema.String), RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const GetBucketAclOutput = Schema.Struct({Owner: Schema.optional(Owner), Grants: Schema.optional(Grants)});
export const GetBucketAnalyticsConfigurationOutput = Schema.Struct({AnalyticsConfiguration: Schema.optional(Body("undefined", AnalyticsConfiguration))});
export const CORSRule = Schema.Struct({ID: Schema.optional(Schema.String), AllowedHeaders: Schema.optional(AllowedHeaders), AllowedMethods: AllowedMethods, AllowedOrigins: AllowedOrigins, ExposeHeaders: Schema.optional(ExposeHeaders), MaxAgeSeconds: Schema.optional(Schema.Number)});
export const CORSRules = Schema.Array(CORSRule);
export const GetBucketCorsOutput = Schema.Struct({CORSRules: Schema.optional(CORSRules)});
export const ServerSideEncryptionByDefault = Schema.Struct({SSEAlgorithm: Schema.String, KMSMasterKeyID: Schema.optional(Schema.String)});
export const ServerSideEncryptionRule = Schema.Struct({ApplyServerSideEncryptionByDefault: Schema.optional(ServerSideEncryptionByDefault), BucketKeyEnabled: Schema.optional(Schema.Boolean)});
export const ServerSideEncryptionRules = Schema.Array(ServerSideEncryptionRule);
export const ServerSideEncryptionConfiguration = Schema.Struct({Rules: ServerSideEncryptionRules});
export const GetBucketEncryptionOutput = Schema.Struct({ServerSideEncryptionConfiguration: Schema.optional(Body("undefined", ServerSideEncryptionConfiguration))});
export const GetBucketIntelligentTieringConfigurationOutput = Schema.Struct({IntelligentTieringConfiguration: Schema.optional(Body("undefined", IntelligentTieringConfiguration))});
export const GetBucketInventoryConfigurationOutput = Schema.Struct({InventoryConfiguration: Schema.optional(Body("undefined", InventoryConfiguration))});
export const LifecycleExpiration = Schema.Struct({Date: Schema.optional(Schema.Date), Days: Schema.optional(Schema.Number), ExpiredObjectDeleteMarker: Schema.optional(Schema.Boolean)});
export const LifecycleRuleAndOperator = Schema.Struct({Prefix: Schema.optional(Schema.String), Tags: Schema.optional(TagSet), ObjectSizeGreaterThan: Schema.optional(Schema.Number), ObjectSizeLessThan: Schema.optional(Schema.Number)});
export const LifecycleRuleFilter = Schema.Struct({Prefix: Schema.optional(Schema.String), Tag: Schema.optional(Tag), ObjectSizeGreaterThan: Schema.optional(Schema.Number), ObjectSizeLessThan: Schema.optional(Schema.Number), And: Schema.optional(LifecycleRuleAndOperator)});
export const Transition = Schema.Struct({Date: Schema.optional(Schema.Date), Days: Schema.optional(Schema.Number), StorageClass: Schema.optional(Schema.String)});
export const TransitionList = Schema.Array(Transition);
export const NoncurrentVersionTransition = Schema.Struct({NoncurrentDays: Schema.optional(Schema.Number), StorageClass: Schema.optional(Schema.String), NewerNoncurrentVersions: Schema.optional(Schema.Number)});
export const NoncurrentVersionTransitionList = Schema.Array(NoncurrentVersionTransition);
export const NoncurrentVersionExpiration = Schema.Struct({NoncurrentDays: Schema.optional(Schema.Number), NewerNoncurrentVersions: Schema.optional(Schema.Number)});
export const AbortIncompleteMultipartUpload = Schema.Struct({DaysAfterInitiation: Schema.optional(Schema.Number)});
export const LifecycleRule = Schema.Struct({Expiration: Schema.optional(LifecycleExpiration), ID: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), Filter: Schema.optional(LifecycleRuleFilter), Status: Schema.String, Transitions: Schema.optional(TransitionList), NoncurrentVersionTransitions: Schema.optional(NoncurrentVersionTransitionList), NoncurrentVersionExpiration: Schema.optional(NoncurrentVersionExpiration), AbortIncompleteMultipartUpload: Schema.optional(AbortIncompleteMultipartUpload)});
export const LifecycleRules = Schema.Array(LifecycleRule);
export const GetBucketLifecycleConfigurationOutput = Schema.Struct({Rules: Schema.optional(LifecycleRules), TransitionDefaultMinimumObjectSize: Schema.optional(Header("x-amz-transition-default-minimum-object-size"))});
export const GetBucketLocationOutput = Schema.Struct({LocationConstraint: Schema.optional(Schema.String)});
export const TargetGrant = Schema.Struct({Grantee: Schema.optional(Grantee), Permission: Schema.optional(Schema.String)});
export const TargetGrants = Schema.Array(TargetGrant);
export const SimplePrefix = Schema.Struct({});
export const PartitionedPrefix = Schema.Struct({PartitionDateSource: Schema.optional(Schema.String)});
export const TargetObjectKeyFormat = Schema.Struct({SimplePrefix: Schema.optional(SimplePrefix), PartitionedPrefix: Schema.optional(PartitionedPrefix)});
export const LoggingEnabled = Schema.Struct({TargetBucket: Schema.String, TargetGrants: Schema.optional(TargetGrants), TargetPrefix: Schema.String, TargetObjectKeyFormat: Schema.optional(TargetObjectKeyFormat)});
export const GetBucketLoggingOutput = Schema.Struct({LoggingEnabled: Schema.optional(LoggingEnabled)});
export const GetBucketMetricsConfigurationOutput = Schema.Struct({MetricsConfiguration: Schema.optional(Body("undefined", MetricsConfiguration))});
export const OwnershipControlsRule = Schema.Struct({ObjectOwnership: Schema.String});
export const OwnershipControlsRules = Schema.Array(OwnershipControlsRule);
export const OwnershipControls = Schema.Struct({Rules: OwnershipControlsRules});
export const GetBucketOwnershipControlsOutput = Schema.Struct({OwnershipControls: Schema.optional(Body("undefined", OwnershipControls))});
export const GetBucketPolicyOutput = Schema.Struct({Policy: Schema.optional(Body("undefined", Schema.String))});
export const ReplicationRuleAndOperator = Schema.Struct({Prefix: Schema.optional(Schema.String), Tags: Schema.optional(TagSet)});
export const ReplicationRuleFilter = Schema.Struct({Prefix: Schema.optional(Schema.String), Tag: Schema.optional(Tag), And: Schema.optional(ReplicationRuleAndOperator)});
export const SseKmsEncryptedObjects = Schema.Struct({Status: Schema.String});
export const ReplicaModifications = Schema.Struct({Status: Schema.String});
export const SourceSelectionCriteria = Schema.Struct({SseKmsEncryptedObjects: Schema.optional(SseKmsEncryptedObjects), ReplicaModifications: Schema.optional(ReplicaModifications)});
export const ExistingObjectReplication = Schema.Struct({Status: Schema.String});
export const AccessControlTranslation = Schema.Struct({Owner: Schema.String});
export const EncryptionConfiguration = Schema.Struct({ReplicaKmsKeyID: Schema.optional(Schema.String)});
export const ReplicationTimeValue = Schema.Struct({Minutes: Schema.optional(Schema.Number)});
export const ReplicationTime = Schema.Struct({Status: Schema.String, Time: ReplicationTimeValue});
export const Metrics = Schema.Struct({Status: Schema.String, EventThreshold: Schema.optional(ReplicationTimeValue)});
export const Destination = Schema.Struct({Bucket: Schema.String, Account: Schema.optional(Schema.String), StorageClass: Schema.optional(Schema.String), AccessControlTranslation: Schema.optional(AccessControlTranslation), EncryptionConfiguration: Schema.optional(EncryptionConfiguration), ReplicationTime: Schema.optional(ReplicationTime), Metrics: Schema.optional(Metrics)});
export const DeleteMarkerReplication = Schema.Struct({Status: Schema.optional(Schema.String)});
export const ReplicationRule = Schema.Struct({ID: Schema.optional(Schema.String), Priority: Schema.optional(Schema.Number), Prefix: Schema.optional(Schema.String), Filter: Schema.optional(ReplicationRuleFilter), Status: Schema.String, SourceSelectionCriteria: Schema.optional(SourceSelectionCriteria), ExistingObjectReplication: Schema.optional(ExistingObjectReplication), Destination: Destination, DeleteMarkerReplication: Schema.optional(DeleteMarkerReplication)});
export const ReplicationRules = Schema.Array(ReplicationRule);
export const ReplicationConfiguration = Schema.Struct({Role: Schema.String, Rules: ReplicationRules});
export const GetBucketReplicationOutput = Schema.Struct({ReplicationConfiguration: Schema.optional(Body("undefined", ReplicationConfiguration))});
export const GetBucketRequestPaymentOutput = Schema.Struct({Payer: Schema.optional(Schema.String)});
export const GetBucketTaggingOutput = Schema.Struct({TagSet: TagSet});
export const GetBucketVersioningOutput = Schema.Struct({Status: Schema.optional(Schema.String), MFADelete: Schema.optional(Schema.String)});
export const RedirectAllRequestsTo = Schema.Struct({HostName: Schema.String, Protocol: Schema.optional(Schema.String)});
export const IndexDocument = Schema.Struct({Suffix: Schema.String});
export const ErrorDocument = Schema.Struct({Key: Schema.String});
export const Condition = Schema.Struct({HttpErrorCodeReturnedEquals: Schema.optional(Schema.String), KeyPrefixEquals: Schema.optional(Schema.String)});
export const Redirect = Schema.Struct({HostName: Schema.optional(Schema.String), HttpRedirectCode: Schema.optional(Schema.String), Protocol: Schema.optional(Schema.String), ReplaceKeyPrefixWith: Schema.optional(Schema.String), ReplaceKeyWith: Schema.optional(Schema.String)});
export const RoutingRule = Schema.Struct({Condition: Schema.optional(Condition), Redirect: Redirect});
export const RoutingRules = Schema.Array(RoutingRule);
export const GetBucketWebsiteOutput = Schema.Struct({RedirectAllRequestsTo: Schema.optional(RedirectAllRequestsTo), IndexDocument: Schema.optional(IndexDocument), ErrorDocument: Schema.optional(ErrorDocument), RoutingRules: Schema.optional(RoutingRules)});
export const GetObjectOutput = Schema.Struct({Body: Schema.optional(Body("undefined", StreamBody())), DeleteMarker: Schema.optional(Header("x-amz-delete-marker", Schema.Boolean)), AcceptRanges: Schema.optional(Header("accept-ranges")), Expiration: Schema.optional(Header("x-amz-expiration")), Restore: Schema.optional(Header("x-amz-restore")), LastModified: Schema.optional(Header("Last-Modified", Schema.Date)), ContentLength: Schema.optional(Header("Content-Length", Schema.Number)), ETag: Schema.optional(Header("ETag")), ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), ChecksumType: Schema.optional(Header("x-amz-checksum-type")), MissingMeta: Schema.optional(Header("x-amz-missing-meta", Schema.Number)), VersionId: Schema.optional(Header("x-amz-version-id")), CacheControl: Schema.optional(Header("Cache-Control")), ContentDisposition: Schema.optional(Header("Content-Disposition")), ContentEncoding: Schema.optional(Header("Content-Encoding")), ContentLanguage: Schema.optional(Header("Content-Language")), ContentRange: Schema.optional(Header("Content-Range")), ContentType: Schema.optional(Header("Content-Type")), Expires: Schema.optional(Header("Expires")), WebsiteRedirectLocation: Schema.optional(Header("x-amz-website-redirect-location")), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), Metadata: Schema.optional(Metadata), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), StorageClass: Schema.optional(Header("x-amz-storage-class")), RequestCharged: Schema.optional(Header("x-amz-request-charged")), ReplicationStatus: Schema.optional(Header("x-amz-replication-status")), PartsCount: Schema.optional(Header("x-amz-mp-parts-count", Schema.Number)), TagCount: Schema.optional(Header("x-amz-tagging-count", Schema.Number)), ObjectLockMode: Schema.optional(Header("x-amz-object-lock-mode")), ObjectLockRetainUntilDate: Schema.optional(Header("x-amz-object-lock-retain-until-date", Schema.Date)), ObjectLockLegalHoldStatus: Schema.optional(Header("x-amz-object-lock-legal-hold"))});
export const GetObjectAclOutput = Schema.Struct({Owner: Schema.optional(Owner), Grants: Schema.optional(Grants), RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const NoSuchKey = Schema.Struct({});
export const GetObjectLegalHoldOutput = Schema.Struct({LegalHold: Schema.optional(Body("LegalHold", ObjectLockLegalHold))});
export const DefaultRetention = Schema.Struct({Mode: Schema.optional(Schema.String), Days: Schema.optional(Schema.Number), Years: Schema.optional(Schema.Number)});
export const ObjectLockRule = Schema.Struct({DefaultRetention: Schema.optional(DefaultRetention)});
export const ObjectLockConfiguration = Schema.Struct({ObjectLockEnabled: Schema.optional(Schema.String), Rule: Schema.optional(ObjectLockRule)});
export const GetObjectLockConfigurationOutput = Schema.Struct({ObjectLockConfiguration: Schema.optional(Body("undefined", ObjectLockConfiguration))});
export const GetObjectRetentionOutput = Schema.Struct({Retention: Schema.optional(Body("Retention", ObjectLockRetention))});
export const GetObjectTaggingOutput = Schema.Struct({VersionId: Schema.optional(Header("x-amz-version-id")), TagSet: TagSet});
export const GetObjectTorrentOutput = Schema.Struct({Body: Schema.optional(Body("undefined", StreamBody())), RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const GetPublicAccessBlockOutput = Schema.Struct({PublicAccessBlockConfiguration: Schema.optional(Body("undefined", PublicAccessBlockConfiguration))});
export const HeadBucketOutput = Schema.Struct({BucketArn: Schema.optional(Header("x-amz-bucket-arn")), BucketLocationType: Schema.optional(Header("x-amz-bucket-location-type")), BucketLocationName: Schema.optional(Header("x-amz-bucket-location-name")), BucketRegion: Schema.optional(Header("x-amz-bucket-region")), AccessPointAlias: Schema.optional(Header("x-amz-access-point-alias", Schema.Boolean))});
export const NotFound = Schema.Struct({});
export const HeadObjectOutput = Schema.Struct({DeleteMarker: Schema.optional(Header("x-amz-delete-marker", Schema.Boolean)), AcceptRanges: Schema.optional(Header("accept-ranges")), Expiration: Schema.optional(Header("x-amz-expiration")), Restore: Schema.optional(Header("x-amz-restore")), ArchiveStatus: Schema.optional(Header("x-amz-archive-status")), LastModified: Schema.optional(Header("Last-Modified", Schema.Date)), ContentLength: Schema.optional(Header("Content-Length", Schema.Number)), ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), ChecksumType: Schema.optional(Header("x-amz-checksum-type")), ETag: Schema.optional(Header("ETag")), MissingMeta: Schema.optional(Header("x-amz-missing-meta", Schema.Number)), VersionId: Schema.optional(Header("x-amz-version-id")), CacheControl: Schema.optional(Header("Cache-Control")), ContentDisposition: Schema.optional(Header("Content-Disposition")), ContentEncoding: Schema.optional(Header("Content-Encoding")), ContentLanguage: Schema.optional(Header("Content-Language")), ContentType: Schema.optional(Header("Content-Type")), ContentRange: Schema.optional(Header("Content-Range")), Expires: Schema.optional(Header("Expires")), WebsiteRedirectLocation: Schema.optional(Header("x-amz-website-redirect-location")), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), Metadata: Schema.optional(Metadata), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), StorageClass: Schema.optional(Header("x-amz-storage-class")), RequestCharged: Schema.optional(Header("x-amz-request-charged")), ReplicationStatus: Schema.optional(Header("x-amz-replication-status")), PartsCount: Schema.optional(Header("x-amz-mp-parts-count", Schema.Number)), TagCount: Schema.optional(Header("x-amz-tagging-count", Schema.Number)), ObjectLockMode: Schema.optional(Header("x-amz-object-lock-mode")), ObjectLockRetainUntilDate: Schema.optional(Header("x-amz-object-lock-retain-until-date", Schema.Date)), ObjectLockLegalHoldStatus: Schema.optional(Header("x-amz-object-lock-legal-hold"))});
export const ListBucketAnalyticsConfigurationsOutput = Schema.Struct({IsTruncated: Schema.optional(Schema.Boolean), ContinuationToken: Schema.optional(Schema.String), NextContinuationToken: Schema.optional(Schema.String), AnalyticsConfigurationList: Schema.optional(AnalyticsConfigurationList)});
export const ListBucketIntelligentTieringConfigurationsOutput = Schema.Struct({IsTruncated: Schema.optional(Schema.Boolean), ContinuationToken: Schema.optional(Schema.String), NextContinuationToken: Schema.optional(Schema.String), IntelligentTieringConfigurationList: Schema.optional(IntelligentTieringConfigurationList)});
export const ListBucketInventoryConfigurationsOutput = Schema.Struct({ContinuationToken: Schema.optional(Schema.String), InventoryConfigurationList: Schema.optional(InventoryConfigurationList), IsTruncated: Schema.optional(Schema.Boolean), NextContinuationToken: Schema.optional(Schema.String)});
export const ListBucketMetricsConfigurationsOutput = Schema.Struct({IsTruncated: Schema.optional(Schema.Boolean), ContinuationToken: Schema.optional(Schema.String), NextContinuationToken: Schema.optional(Schema.String), MetricsConfigurationList: Schema.optional(MetricsConfigurationList)});
export const Bucket = Schema.Struct({Name: Schema.optional(Schema.String), CreationDate: Schema.optional(Schema.Date), BucketRegion: Schema.optional(Schema.String), BucketArn: Schema.optional(Schema.String)});
export const Buckets = Schema.Array(Bucket);
export const ListDirectoryBucketsOutput = Schema.Struct({Buckets: Schema.optional(Buckets), ContinuationToken: Schema.optional(Schema.String)});
export const ChecksumAlgorithmList = Schema.Array(Schema.String);
export const RestoreStatus = Schema.Struct({IsRestoreInProgress: Schema.optional(Schema.Boolean), RestoreExpiryDate: Schema.optional(Schema.Date)});
export const Object = Schema.Struct({Key: Schema.optional(Schema.String), LastModified: Schema.optional(Schema.Date), ETag: Schema.optional(Schema.String), ChecksumAlgorithm: Schema.optional(ChecksumAlgorithmList), ChecksumType: Schema.optional(Schema.String), Size: Schema.optional(Schema.Number), StorageClass: Schema.optional(Schema.String), Owner: Schema.optional(Owner), RestoreStatus: Schema.optional(RestoreStatus)});
export const ObjectList = Schema.Array(Object);
export const CommonPrefix = Schema.Struct({Prefix: Schema.optional(Schema.String)});
export const CommonPrefixList = Schema.Array(CommonPrefix);
export const ListObjectsV2Output = Schema.Struct({IsTruncated: Schema.optional(Schema.Boolean), Contents: Schema.optional(ObjectList), Name: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), Delimiter: Schema.optional(Schema.String), MaxKeys: Schema.optional(Schema.Number), CommonPrefixes: Schema.optional(CommonPrefixList), EncodingType: Schema.optional(Schema.String), KeyCount: Schema.optional(Schema.Number), ContinuationToken: Schema.optional(Schema.String), NextContinuationToken: Schema.optional(Schema.String), StartAfter: Schema.optional(Schema.String), RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const NoSuchBucket = Schema.Struct({});
export const PutBucketAccelerateConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), AccelerateConfiguration: Body("AccelerateConfiguration", AccelerateConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm"))});
export const PutBucketRequestPaymentRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), RequestPaymentConfiguration: Body("RequestPaymentConfiguration", RequestPaymentConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutBucketTaggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), Tagging: Body("Tagging", Tagging), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutBucketVersioningRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), MFA: Schema.optional(Header("x-amz-mfa")), VersioningConfiguration: Body("VersioningConfiguration", VersioningConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutObjectOutput = Schema.Struct({Expiration: Schema.optional(Header("x-amz-expiration")), ETag: Schema.optional(Header("ETag")), ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), ChecksumType: Schema.optional(Header("x-amz-checksum-type")), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), VersionId: Schema.optional(Header("x-amz-version-id")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), Size: Schema.optional(Header("x-amz-object-size", Schema.Number)), RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const EncryptionTypeMismatch = Schema.Struct({});
export const InvalidRequest = Schema.Struct({});
export const InvalidWriteOffset = Schema.Struct({});
export const TooManyParts = Schema.Struct({});
export const PutObjectAclOutput = Schema.Struct({RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const PutObjectLegalHoldRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, LegalHold: Schema.optional(Body("LegalHold", ObjectLockLegalHold)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), VersionId: Schema.optional(Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutObjectRetentionRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, Retention: Schema.optional(Body("Retention", ObjectLockRetention)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), VersionId: Schema.optional(Schema.String), BypassGovernanceRetention: Schema.optional(Header("x-amz-bypass-governance-retention", Schema.Boolean)), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutObjectTaggingOutput = Schema.Struct({VersionId: Schema.optional(Header("x-amz-version-id"))});
export const PutPublicAccessBlockRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), PublicAccessBlockConfiguration: Body("PublicAccessBlockConfiguration", PublicAccessBlockConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const UploadPartOutput = Schema.Struct({ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), ETag: Schema.optional(Header("ETag")), ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const CompletedPart = Schema.Struct({ETag: Schema.optional(Schema.String), ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String), PartNumber: Schema.optional(Schema.Number)});
export const CompletedPartList = Schema.Array(CompletedPart);
export const LocationInfo = Schema.Struct({Type: Schema.optional(Schema.String), Name: Schema.optional(Schema.String)});
export const BucketInfo = Schema.Struct({DataRedundancy: Schema.optional(Schema.String), Type: Schema.optional(Schema.String)});
export const RecordExpiration = Schema.Struct({Expiration: Schema.String, Days: Schema.optional(Schema.Number)});
export const MetadataTableEncryptionConfiguration = Schema.Struct({SseAlgorithm: Schema.String, KmsKeyArn: Schema.optional(Schema.String)});
export const JournalTableConfiguration = Schema.Struct({RecordExpiration: RecordExpiration, EncryptionConfiguration: Schema.optional(MetadataTableEncryptionConfiguration)});
export const InventoryTableConfiguration = Schema.Struct({ConfigurationState: Schema.String, EncryptionConfiguration: Schema.optional(MetadataTableEncryptionConfiguration)});
export const S3TablesDestination = Schema.Struct({TableBucketArn: Schema.String, TableName: Schema.String});
export const ObjectIdentifier = Schema.Struct({Key: Schema.String, VersionId: Schema.optional(Schema.String), ETag: Schema.optional(Schema.String), LastModifiedTime: Schema.optional(Schema.Date), Size: Schema.optional(Schema.Number)});
export const ObjectIdentifierList = Schema.Array(ObjectIdentifier);
export const FilterRule = Schema.Struct({Name: Schema.optional(Schema.String), Value: Schema.optional(Schema.String)});
export const FilterRuleList = Schema.Array(FilterRule);
export const S3KeyFilter = Schema.Struct({FilterRules: Schema.optional(FilterRuleList)});
export const NotificationConfigurationFilter = Schema.Struct({Key: Schema.optional(S3KeyFilter)});
export const QueueConfiguration = Schema.Struct({Id: Schema.optional(Schema.String), QueueArn: Schema.String, Events: EventList, Filter: Schema.optional(NotificationConfigurationFilter)});
export const QueueConfigurationList = Schema.Array(QueueConfiguration);
export const LambdaFunctionConfiguration = Schema.Struct({Id: Schema.optional(Schema.String), LambdaFunctionArn: Schema.String, Events: EventList, Filter: Schema.optional(NotificationConfigurationFilter)});
export const LambdaFunctionConfigurationList = Schema.Array(LambdaFunctionConfiguration);
export const GlacierJobParameters = Schema.Struct({Tier: Schema.String});
export const CSVInput = Schema.Struct({FileHeaderInfo: Schema.optional(Schema.String), Comments: Schema.optional(Schema.String), QuoteEscapeCharacter: Schema.optional(Schema.String), RecordDelimiter: Schema.optional(Schema.String), FieldDelimiter: Schema.optional(Schema.String), QuoteCharacter: Schema.optional(Schema.String), AllowQuotedRecordDelimiter: Schema.optional(Schema.Boolean)});
export const JSONInput = Schema.Struct({Type: Schema.optional(Schema.String)});
export const InputSerialization = Schema.Struct({CSV: Schema.optional(CSVInput), CompressionType: Schema.optional(Schema.String), JSON: Schema.optional(JSONInput), Parquet: Schema.optional(ParquetInput)});
export const CSVOutput = Schema.Struct({QuoteFields: Schema.optional(Schema.String), QuoteEscapeCharacter: Schema.optional(Schema.String), RecordDelimiter: Schema.optional(Schema.String), FieldDelimiter: Schema.optional(Schema.String), QuoteCharacter: Schema.optional(Schema.String)});
export const JSONOutput = Schema.Struct({RecordDelimiter: Schema.optional(Schema.String)});
export const OutputSerialization = Schema.Struct({CSV: Schema.optional(CSVOutput), JSON: Schema.optional(JSONOutput)});
export const SelectParameters = Schema.Struct({InputSerialization: InputSerialization, ExpressionType: Schema.String, Expression: Schema.String, OutputSerialization: OutputSerialization});
export const CompletedMultipartUpload = Schema.Struct({Parts: Schema.optional(CompletedPartList)});
export const CreateBucketConfiguration = Schema.Struct({LocationConstraint: Schema.optional(Schema.String), Location: Schema.optional(LocationInfo), Bucket: Schema.optional(BucketInfo), Tags: Schema.optional(TagSet)});
export const MetadataConfiguration = Schema.Struct({JournalTableConfiguration: JournalTableConfiguration, InventoryTableConfiguration: Schema.optional(InventoryTableConfiguration)});
export const MetadataTableConfiguration = Schema.Struct({S3TablesDestination: S3TablesDestination});
export const SessionCredentials = Schema.Struct({AccessKeyId: Schema.String, SecretAccessKey: Schema.String, SessionToken: Schema.String, Expiration: Schema.Date});
export const Delete = Schema.Struct({Objects: ObjectIdentifierList, Quiet: Schema.optional(Schema.Boolean)});
export const PolicyStatus = Schema.Struct({IsPublic: Schema.optional(Schema.Boolean)});
export const Checksum = Schema.Struct({ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String), ChecksumType: Schema.optional(Schema.String)});
export const Initiator = Schema.Struct({ID: Schema.optional(Schema.String), DisplayName: Schema.optional(Schema.String)});
export const MultipartUpload = Schema.Struct({UploadId: Schema.optional(Schema.String), Key: Schema.optional(Schema.String), Initiated: Schema.optional(Schema.Date), StorageClass: Schema.optional(Schema.String), Owner: Schema.optional(Owner), Initiator: Schema.optional(Initiator), ChecksumAlgorithm: Schema.optional(Schema.String), ChecksumType: Schema.optional(Schema.String)});
export const MultipartUploadList = Schema.Array(MultipartUpload);
export const ObjectVersion = Schema.Struct({ETag: Schema.optional(Schema.String), ChecksumAlgorithm: Schema.optional(ChecksumAlgorithmList), ChecksumType: Schema.optional(Schema.String), Size: Schema.optional(Schema.Number), StorageClass: Schema.optional(Schema.String), Key: Schema.optional(Schema.String), VersionId: Schema.optional(Schema.String), IsLatest: Schema.optional(Schema.Boolean), LastModified: Schema.optional(Schema.Date), Owner: Schema.optional(Owner), RestoreStatus: Schema.optional(RestoreStatus)});
export const ObjectVersionList = Schema.Array(ObjectVersion);
export const DeleteMarkerEntry = Schema.Struct({Owner: Schema.optional(Owner), Key: Schema.optional(Schema.String), VersionId: Schema.optional(Schema.String), IsLatest: Schema.optional(Schema.Boolean), LastModified: Schema.optional(Schema.Date)});
export const DeleteMarkers = Schema.Array(DeleteMarkerEntry);
export const Part = Schema.Struct({PartNumber: Schema.optional(Schema.Number), LastModified: Schema.optional(Schema.Date), ETag: Schema.optional(Schema.String), Size: Schema.optional(Schema.Number), ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String)});
export const Parts = Schema.Array(Part);
export const CORSConfiguration = Schema.Struct({CORSRules: CORSRules});
export const InventoryTableConfigurationUpdates = Schema.Struct({ConfigurationState: Schema.String, EncryptionConfiguration: Schema.optional(MetadataTableEncryptionConfiguration)});
export const JournalTableConfigurationUpdates = Schema.Struct({RecordExpiration: RecordExpiration});
export const CopyPartResult = Schema.Struct({ETag: Schema.optional(Schema.String), LastModified: Schema.optional(Schema.Date), ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String)});
export const CompleteMultipartUploadRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Path("Key", Schema.String), MultipartUpload: Schema.optional(Body("CompleteMultipartUpload", CompletedMultipartUpload)), UploadId: Schema.String, ChecksumCRC32: Schema.optional(Header("x-amz-checksum-crc32")), ChecksumCRC32C: Schema.optional(Header("x-amz-checksum-crc32c")), ChecksumCRC64NVME: Schema.optional(Header("x-amz-checksum-crc64nvme")), ChecksumSHA1: Schema.optional(Header("x-amz-checksum-sha1")), ChecksumSHA256: Schema.optional(Header("x-amz-checksum-sha256")), ChecksumType: Schema.optional(Header("x-amz-checksum-type")), MpuObjectSize: Schema.optional(Header("x-amz-mp-object-size", Schema.Number)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), IfMatch: Schema.optional(Header("If-Match")), IfNoneMatch: Schema.optional(Header("If-None-Match")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5"))});
export const CreateBucketRequest = Schema.Struct({ACL: Schema.optional(Header("x-amz-acl")), Bucket: Path("Bucket", Schema.String), CreateBucketConfiguration: Schema.optional(Body("CreateBucketConfiguration", CreateBucketConfiguration)), GrantFullControl: Schema.optional(Header("x-amz-grant-full-control")), GrantRead: Schema.optional(Header("x-amz-grant-read")), GrantReadACP: Schema.optional(Header("x-amz-grant-read-acp")), GrantWrite: Schema.optional(Header("x-amz-grant-write")), GrantWriteACP: Schema.optional(Header("x-amz-grant-write-acp")), ObjectLockEnabledForBucket: Schema.optional(Header("x-amz-bucket-object-lock-enabled", Schema.Boolean)), ObjectOwnership: Schema.optional(Header("x-amz-object-ownership"))});
export const CreateBucketMetadataConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), MetadataConfiguration: Body("MetadataConfiguration", MetadataConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const CreateBucketMetadataTableConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), MetadataTableConfiguration: Body("MetadataTableConfiguration", MetadataTableConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const CreateSessionOutput = Schema.Struct({ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), Credentials: SessionCredentials});
export const DeleteObjectsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Delete: Body("Delete", Delete), MFA: Schema.optional(Header("x-amz-mfa")), RequestPayer: Schema.optional(Header("x-amz-request-payer")), BypassGovernanceRetention: Schema.optional(Header("x-amz-bypass-governance-retention", Schema.Boolean)), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm"))});
export const GetBucketPolicyStatusOutput = Schema.Struct({PolicyStatus: Schema.optional(Body("undefined", PolicyStatus))});
export const InvalidObjectState = Schema.Struct({StorageClass: Schema.optional(Schema.String), AccessTier: Schema.optional(Schema.String)});
export const ListBucketsOutput = Schema.Struct({Buckets: Schema.optional(Buckets), Owner: Schema.optional(Owner), ContinuationToken: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String)});
export const ListMultipartUploadsOutput = Schema.Struct({Bucket: Schema.optional(Schema.String), KeyMarker: Schema.optional(Schema.String), UploadIdMarker: Schema.optional(Schema.String), NextKeyMarker: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), Delimiter: Schema.optional(Schema.String), NextUploadIdMarker: Schema.optional(Schema.String), MaxUploads: Schema.optional(Schema.Number), IsTruncated: Schema.optional(Schema.Boolean), Uploads: Schema.optional(MultipartUploadList), CommonPrefixes: Schema.optional(CommonPrefixList), EncodingType: Schema.optional(Schema.String), RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const ListObjectVersionsOutput = Schema.Struct({IsTruncated: Schema.optional(Schema.Boolean), KeyMarker: Schema.optional(Schema.String), VersionIdMarker: Schema.optional(Schema.String), NextKeyMarker: Schema.optional(Schema.String), NextVersionIdMarker: Schema.optional(Schema.String), Versions: Schema.optional(ObjectVersionList), DeleteMarkers: Schema.optional(DeleteMarkers), Name: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), Delimiter: Schema.optional(Schema.String), MaxKeys: Schema.optional(Schema.Number), CommonPrefixes: Schema.optional(CommonPrefixList), EncodingType: Schema.optional(Schema.String), RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const ListPartsOutput = Schema.Struct({AbortDate: Schema.optional(Header("x-amz-abort-date", Schema.Date)), AbortRuleId: Schema.optional(Header("x-amz-abort-rule-id")), Bucket: Schema.optional(Schema.String), Key: Schema.optional(Schema.String), UploadId: Schema.optional(Schema.String), PartNumberMarker: Schema.optional(Schema.String), NextPartNumberMarker: Schema.optional(Schema.String), MaxParts: Schema.optional(Schema.Number), IsTruncated: Schema.optional(Schema.Boolean), Parts: Schema.optional(Parts), Initiator: Schema.optional(Initiator), Owner: Schema.optional(Owner), StorageClass: Schema.optional(Schema.String), RequestCharged: Schema.optional(Header("x-amz-request-charged")), ChecksumAlgorithm: Schema.optional(Schema.String), ChecksumType: Schema.optional(Schema.String)});
export const PutBucketCorsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), CORSConfiguration: Body("CORSConfiguration", CORSConfiguration), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutBucketOwnershipControlsRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), OwnershipControls: Body("OwnershipControls", OwnershipControls), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm"))});
export const PutObjectLegalHoldOutput = Schema.Struct({RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const PutObjectRetentionOutput = Schema.Struct({RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const SelectObjectContentRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKey: Schema.optional(Header("x-amz-server-side-encryption-customer-key")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), Expression: Schema.String, ExpressionType: Schema.String, RequestProgress: Schema.optional(RequestProgress), InputSerialization: InputSerialization, OutputSerialization: OutputSerialization, ScanRange: Schema.optional(ScanRange), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const UpdateBucketMetadataInventoryTableConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), InventoryTableConfiguration: Body("InventoryTableConfiguration", InventoryTableConfigurationUpdates), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const UpdateBucketMetadataJournalTableConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), JournalTableConfiguration: Body("JournalTableConfiguration", JournalTableConfigurationUpdates), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const UploadPartCopyOutput = Schema.Struct({CopySourceVersionId: Schema.optional(Header("x-amz-copy-source-version-id")), CopyPartResult: Schema.optional(Body("undefined", CopyPartResult)), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const ErrorDetails = Schema.Struct({ErrorCode: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String)});
export const ObjectPart = Schema.Struct({PartNumber: Schema.optional(Schema.Number), Size: Schema.optional(Schema.Number), ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String)});
export const PartsList = Schema.Array(ObjectPart);
export const Encryption = Schema.Struct({EncryptionType: Schema.String, KMSKeyId: Schema.optional(Schema.String), KMSContext: Schema.optional(Schema.String)});
export const MetadataEntry = Schema.Struct({Name: Schema.optional(Schema.String), Value: Schema.optional(Schema.String)});
export const UserMetadata = Schema.Array(MetadataEntry);
export const CopyObjectResult = Schema.Struct({ETag: Schema.optional(Schema.String), LastModified: Schema.optional(Schema.Date), ChecksumType: Schema.optional(Schema.String), ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String)});
export const GetObjectAttributesParts = Schema.Struct({TotalPartsCount: Schema.optional(Schema.Number), PartNumberMarker: Schema.optional(Schema.String), NextPartNumberMarker: Schema.optional(Schema.String), MaxParts: Schema.optional(Schema.Number), IsTruncated: Schema.optional(Schema.Boolean), Parts: Schema.optional(PartsList)});
export const WebsiteConfiguration = Schema.Struct({ErrorDocument: Schema.optional(ErrorDocument), IndexDocument: Schema.optional(IndexDocument), RedirectAllRequestsTo: Schema.optional(RedirectAllRequestsTo), RoutingRules: Schema.optional(RoutingRules)});
export const DestinationResult = Schema.Struct({TableBucketType: Schema.optional(Schema.String), TableBucketArn: Schema.optional(Schema.String), TableNamespace: Schema.optional(Schema.String)});
export const JournalTableConfigurationResult = Schema.Struct({TableStatus: Schema.String, Error: Schema.optional(ErrorDetails), TableName: Schema.String, TableArn: Schema.optional(Schema.String), RecordExpiration: RecordExpiration});
export const InventoryTableConfigurationResult = Schema.Struct({ConfigurationState: Schema.String, TableStatus: Schema.optional(Schema.String), Error: Schema.optional(ErrorDetails), TableName: Schema.optional(Schema.String), TableArn: Schema.optional(Schema.String)});
export const S3TablesDestinationResult = Schema.Struct({TableBucketArn: Schema.String, TableName: Schema.String, TableArn: Schema.String, TableNamespace: Schema.String});
export const S3Location = Schema.Struct({BucketName: Schema.String, Prefix: Schema.String, Encryption: Schema.optional(Encryption), CannedACL: Schema.optional(Schema.String), AccessControlList: Schema.optional(Grants), Tagging: Schema.optional(Tagging), UserMetadata: Schema.optional(UserMetadata), StorageClass: Schema.optional(Schema.String)});
export const CompleteMultipartUploadOutput = Schema.Struct({Location: Schema.optional(Schema.String), Bucket: Schema.optional(Schema.String), Key: Schema.optional(Schema.String), Expiration: Schema.optional(Header("x-amz-expiration")), ETag: Schema.optional(Schema.String), ChecksumCRC32: Schema.optional(Schema.String), ChecksumCRC32C: Schema.optional(Schema.String), ChecksumCRC64NVME: Schema.optional(Schema.String), ChecksumSHA1: Schema.optional(Schema.String), ChecksumSHA256: Schema.optional(Schema.String), ChecksumType: Schema.optional(Schema.String), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), VersionId: Schema.optional(Header("x-amz-version-id")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const CopyObjectOutput = Schema.Struct({CopyObjectResult: Schema.optional(Body("undefined", CopyObjectResult)), Expiration: Schema.optional(Header("x-amz-expiration")), CopySourceVersionId: Schema.optional(Header("x-amz-copy-source-version-id")), VersionId: Schema.optional(Header("x-amz-version-id")), ServerSideEncryption: Schema.optional(Header("x-amz-server-side-encryption")), SSECustomerAlgorithm: Schema.optional(Header("x-amz-server-side-encryption-customer-algorithm")), SSECustomerKeyMD5: Schema.optional(Header("x-amz-server-side-encryption-customer-key-MD5")), SSEKMSKeyId: Schema.optional(Header("x-amz-server-side-encryption-aws-kms-key-id")), SSEKMSEncryptionContext: Schema.optional(Header("x-amz-server-side-encryption-context")), BucketKeyEnabled: Schema.optional(Header("x-amz-server-side-encryption-bucket-key-enabled", Schema.Boolean)), RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const ObjectNotInActiveTierError = Schema.Struct({});
export const CreateBucketOutput = Schema.Struct({Location: Schema.optional(Header("Location")), BucketArn: Schema.optional(Header("x-amz-bucket-arn"))});
export const BucketAlreadyExists = Schema.Struct({});
export const BucketAlreadyOwnedByYou = Schema.Struct({});
export const GetObjectAttributesOutput = Schema.Struct({DeleteMarker: Schema.optional(Header("x-amz-delete-marker", Schema.Boolean)), LastModified: Schema.optional(Header("Last-Modified", Schema.Date)), VersionId: Schema.optional(Header("x-amz-version-id")), RequestCharged: Schema.optional(Header("x-amz-request-charged")), ETag: Schema.optional(Schema.String), Checksum: Schema.optional(Checksum), ObjectParts: Schema.optional(GetObjectAttributesParts), StorageClass: Schema.optional(Schema.String), ObjectSize: Schema.optional(Schema.Number)});
export const ListObjectsOutput = Schema.Struct({IsTruncated: Schema.optional(Schema.Boolean), Marker: Schema.optional(Schema.String), NextMarker: Schema.optional(Schema.String), Contents: Schema.optional(ObjectList), Name: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), Delimiter: Schema.optional(Schema.String), MaxKeys: Schema.optional(Schema.Number), CommonPrefixes: Schema.optional(CommonPrefixList), EncodingType: Schema.optional(Schema.String), RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const PutBucketAclRequest = Schema.Struct({ACL: Schema.optional(Header("x-amz-acl")), AccessControlPolicy: Schema.optional(Body("AccessControlPolicy", AccessControlPolicy)), Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), GrantFullControl: Schema.optional(Header("x-amz-grant-full-control")), GrantRead: Schema.optional(Header("x-amz-grant-read")), GrantReadACP: Schema.optional(Header("x-amz-grant-read-acp")), GrantWrite: Schema.optional(Header("x-amz-grant-write")), GrantWriteACP: Schema.optional(Header("x-amz-grant-write-acp")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutBucketEncryptionRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ServerSideEncryptionConfiguration: Body("ServerSideEncryptionConfiguration", ServerSideEncryptionConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutBucketIntelligentTieringConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), IntelligentTieringConfiguration: Body("IntelligentTieringConfiguration", IntelligentTieringConfiguration)});
export const PutBucketMetricsConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, MetricsConfiguration: Body("MetricsConfiguration", MetricsConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutBucketWebsiteRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), WebsiteConfiguration: Body("WebsiteConfiguration", WebsiteConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutObjectLockConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ObjectLockConfiguration: Schema.optional(Body("ObjectLockConfiguration", ObjectLockConfiguration)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), Token: Schema.optional(Header("x-amz-bucket-object-lock-token")), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const MetadataConfigurationResult = Schema.Struct({DestinationResult: DestinationResult, JournalTableConfigurationResult: Schema.optional(JournalTableConfigurationResult), InventoryTableConfigurationResult: Schema.optional(InventoryTableConfigurationResult)});
export const MetadataTableConfigurationResult = Schema.Struct({S3TablesDestinationResult: S3TablesDestinationResult});
export const OutputLocation = Schema.Struct({S3: Schema.optional(S3Location)});
export const ContinuationEvent = Schema.Struct({});
export const EndEvent = Schema.Struct({});
export const DeletedObject = Schema.Struct({Key: Schema.optional(Schema.String), VersionId: Schema.optional(Schema.String), DeleteMarker: Schema.optional(Schema.Boolean), DeleteMarkerVersionId: Schema.optional(Schema.String)});
export const DeletedObjects = Schema.Array(DeletedObject);
export const Error = Schema.Struct({Key: Schema.optional(Schema.String), VersionId: Schema.optional(Schema.String), Code: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const Errors = Schema.Array(Error);
export const GetBucketMetadataConfigurationResult = Schema.Struct({MetadataConfigurationResult: MetadataConfigurationResult});
export const GetBucketMetadataTableConfigurationResult = Schema.Struct({MetadataTableConfigurationResult: MetadataTableConfigurationResult, Status: Schema.String, Error: Schema.optional(ErrorDetails)});
export const BucketLifecycleConfiguration = Schema.Struct({Rules: LifecycleRules});
export const BucketLoggingStatus = Schema.Struct({LoggingEnabled: Schema.optional(LoggingEnabled)});
export const RestoreRequest = Schema.Struct({Days: Schema.optional(Schema.Number), GlacierJobParameters: Schema.optional(GlacierJobParameters), Type: Schema.optional(Schema.String), Tier: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), SelectParameters: Schema.optional(SelectParameters), OutputLocation: Schema.optional(OutputLocation)});
export const DeleteObjectsOutput = Schema.Struct({Deleted: Schema.optional(DeletedObjects), RequestCharged: Schema.optional(Header("x-amz-request-charged")), Errors: Schema.optional(Errors)});
export const GetBucketMetadataConfigurationOutput = Schema.Struct({GetBucketMetadataConfigurationResult: Schema.optional(Body("undefined", GetBucketMetadataConfigurationResult))});
export const GetBucketMetadataTableConfigurationOutput = Schema.Struct({GetBucketMetadataTableConfigurationResult: Schema.optional(Body("undefined", GetBucketMetadataTableConfigurationResult))});
export const PutBucketLifecycleConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), LifecycleConfiguration: Schema.optional(Body("LifecycleConfiguration", BucketLifecycleConfiguration)), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), TransitionDefaultMinimumObjectSize: Schema.optional(Header("x-amz-transition-default-minimum-object-size"))});
export const PutBucketLoggingRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), BucketLoggingStatus: Body("BucketLoggingStatus", BucketLoggingStatus), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutObjectLockConfigurationOutput = Schema.Struct({RequestCharged: Schema.optional(Header("x-amz-request-charged"))});
export const RestoreObjectRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Key: Schema.String, VersionId: Schema.optional(Schema.String), RestoreRequest: Schema.optional(Body("RestoreRequest", RestoreRequest)), RequestPayer: Schema.optional(Header("x-amz-request-payer")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const TopicConfiguration = Schema.Struct({Id: Schema.optional(Schema.String), TopicArn: Schema.String, Events: EventList, Filter: Schema.optional(NotificationConfigurationFilter)});
export const TopicConfigurationList = Schema.Array(TopicConfiguration);
export const RecordsEvent = Schema.Struct({Payload: Schema.optional(StreamBody())});
export const NotificationConfiguration = Schema.Struct({TopicConfigurations: Schema.optional(TopicConfigurationList), QueueConfigurations: Schema.optional(QueueConfigurationList), LambdaFunctionConfigurations: Schema.optional(LambdaFunctionConfigurationList), EventBridgeConfiguration: Schema.optional(EventBridgeConfiguration)});
export const Stats = Schema.Struct({BytesScanned: Schema.optional(Schema.Number), BytesProcessed: Schema.optional(Schema.Number), BytesReturned: Schema.optional(Schema.Number)});
export const Progress = Schema.Struct({BytesScanned: Schema.optional(Schema.Number), BytesProcessed: Schema.optional(Schema.Number), BytesReturned: Schema.optional(Schema.Number)});
export const PutBucketAnalyticsConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, AnalyticsConfiguration: Body("AnalyticsConfiguration", AnalyticsConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutBucketInventoryConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), Id: Schema.String, InventoryConfiguration: Body("InventoryConfiguration", InventoryConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const PutBucketLifecycleConfigurationOutput = Schema.Struct({TransitionDefaultMinimumObjectSize: Schema.optional(Header("x-amz-transition-default-minimum-object-size"))});
export const PutBucketNotificationConfigurationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), NotificationConfiguration: Body("NotificationConfiguration", NotificationConfiguration), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner")), SkipDestinationValidation: Schema.optional(Header("x-amz-skip-destination-validation", Schema.Boolean))});
export const PutBucketReplicationRequest = Schema.Struct({Bucket: Path("Bucket", Schema.String), ContentMD5: Schema.optional(Header("Content-MD5")), ChecksumAlgorithm: Schema.optional(Header("x-amz-sdk-checksum-algorithm")), ReplicationConfiguration: Body("ReplicationConfiguration", ReplicationConfiguration), Token: Schema.optional(Header("x-amz-bucket-object-lock-token")), ExpectedBucketOwner: Schema.optional(Header("x-amz-expected-bucket-owner"))});
export const RestoreObjectOutput = Schema.Struct({RequestCharged: Schema.optional(Header("x-amz-request-charged")), RestoreOutputPath: Schema.optional(Header("x-amz-restore-output-path"))});
export const ObjectAlreadyInActiveTierError = Schema.Struct({});
export const StatsEvent = Schema.Struct({Details: Schema.optional(Stats)});
export const ProgressEvent = Schema.Struct({Details: Schema.optional(Progress)});
export const SelectObjectContentEventStream = Schema.Union(RecordsEvent, StatsEvent, ProgressEvent, ContinuationEvent, EndEvent);
export const SelectObjectContentOutput = Schema.Struct({Payload: Schema.optional(Body("undefined", SelectObjectContentEventStream))});

//# Errors
export class IdempotencyParameterMismatchError extends Schema.TaggedError<IdempotencyParameterMismatchError>()("IdempotencyParameterMismatch", IdempotencyParameterMismatch) {};
export class NoSuchUploadError extends Schema.TaggedError<NoSuchUploadError>()("NoSuchUpload", NoSuchUpload) {};
export class NoSuchKeyError extends Schema.TaggedError<NoSuchKeyError>()("NoSuchKey", NoSuchKey) {};
export class NotFoundError extends Schema.TaggedError<NotFoundError>()("NotFound", NotFound) {};
export class NoSuchBucketError extends Schema.TaggedError<NoSuchBucketError>()("NoSuchBucket", NoSuchBucket) {};
export class EncryptionTypeMismatchError extends Schema.TaggedError<EncryptionTypeMismatchError>()("EncryptionTypeMismatch", EncryptionTypeMismatch) {};
export class InvalidRequestError extends Schema.TaggedError<InvalidRequestError>()("InvalidRequest", InvalidRequest) {};
export class InvalidWriteOffsetError extends Schema.TaggedError<InvalidWriteOffsetError>()("InvalidWriteOffset", InvalidWriteOffset) {};
export class TooManyPartsError extends Schema.TaggedError<TooManyPartsError>()("TooManyParts", TooManyParts) {};
export class InvalidObjectStateError extends Schema.TaggedError<InvalidObjectStateError>()("InvalidObjectState", InvalidObjectState) {};
export class ObjectNotInActiveTierErrorError extends Schema.TaggedError<ObjectNotInActiveTierErrorError>()("ObjectNotInActiveTierError", ObjectNotInActiveTierError) {};
export class BucketAlreadyExistsError extends Schema.TaggedError<BucketAlreadyExistsError>()("BucketAlreadyExists", BucketAlreadyExists) {};
export class BucketAlreadyOwnedByYouError extends Schema.TaggedError<BucketAlreadyOwnedByYouError>()("BucketAlreadyOwnedByYou", BucketAlreadyOwnedByYou) {};
export class ObjectAlreadyInActiveTierErrorError extends Schema.TaggedError<ObjectAlreadyInActiveTierErrorError>()("ObjectAlreadyInActiveTierError", ObjectAlreadyInActiveTierError) {};

//# Operations
export const deleteBucket = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucket" }, DeleteBucketRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketAnalyticsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?analytics", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketAnalyticsConfiguration" }, DeleteBucketAnalyticsConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketCors = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?cors", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketCors" }, DeleteBucketCorsRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketEncryption = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?encryption", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketEncryption" }, DeleteBucketEncryptionRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketIntelligentTieringConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?intelligent-tiering", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketIntelligentTieringConfiguration" }, DeleteBucketIntelligentTieringConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketInventoryConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?inventory", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketInventoryConfiguration" }, DeleteBucketInventoryConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketLifecycle = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?lifecycle", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketLifecycle" }, DeleteBucketLifecycleRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketMetadataConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?metadataConfiguration", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketMetadataConfiguration" }, DeleteBucketMetadataConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketMetadataTableConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?metadataTable", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketMetadataTableConfiguration" }, DeleteBucketMetadataTableConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketMetricsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?metrics", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketMetricsConfiguration" }, DeleteBucketMetricsConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketOwnershipControls = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?ownershipControls", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketOwnershipControls" }, DeleteBucketOwnershipControlsRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?policy", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketPolicy" }, DeleteBucketPolicyRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketReplication = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?replication", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketReplication" }, DeleteBucketReplicationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketTagging = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?tagging", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketTagging" }, DeleteBucketTaggingRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteBucketWebsite = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?website", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteBucketWebsite" }, DeleteBucketWebsiteRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deletePublicAccessBlock = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?publicAccessBlock", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeletePublicAccessBlock" }, DeletePublicAccessBlockRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketNotificationConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?notification", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketNotificationConfiguration" }, GetBucketNotificationConfigurationRequest, NotificationConfiguration, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?policy", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketPolicy" }, PutBucketPolicyRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const renameObject = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?renameObject", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.RenameObject" }, RenameObjectRequest, RenameObjectOutput, [IdempotencyParameterMismatchError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const writeGetObjectResponse = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/WriteGetObjectResponse", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.WriteGetObjectResponse" }, WriteGetObjectResponseRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const abortMultipartUpload = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?x-id=AbortMultipartUpload", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.AbortMultipartUpload" }, AbortMultipartUploadRequest, AbortMultipartUploadOutput, [NoSuchUploadError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createMultipartUpload = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?uploads", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.CreateMultipartUpload" }, CreateMultipartUploadRequest, CreateMultipartUploadOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteObject = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?x-id=DeleteObject", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteObject" }, DeleteObjectRequest, DeleteObjectOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteObjectTagging = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?tagging", method: "DELETE", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteObjectTagging" }, DeleteObjectTaggingRequest, DeleteObjectTaggingOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketAccelerateConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?accelerate", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketAccelerateConfiguration" }, GetBucketAccelerateConfigurationRequest, GetBucketAccelerateConfigurationOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketAcl = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?acl", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketAcl" }, GetBucketAclRequest, GetBucketAclOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketAnalyticsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?analytics&x-id=GetBucketAnalyticsConfiguration", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketAnalyticsConfiguration" }, GetBucketAnalyticsConfigurationRequest, GetBucketAnalyticsConfigurationOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketCors = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?cors", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketCors" }, GetBucketCorsRequest, GetBucketCorsOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketEncryption = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?encryption", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketEncryption" }, GetBucketEncryptionRequest, GetBucketEncryptionOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketIntelligentTieringConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?intelligent-tiering&x-id=GetBucketIntelligentTieringConfiguration", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketIntelligentTieringConfiguration" }, GetBucketIntelligentTieringConfigurationRequest, GetBucketIntelligentTieringConfigurationOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketInventoryConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?inventory&x-id=GetBucketInventoryConfiguration", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketInventoryConfiguration" }, GetBucketInventoryConfigurationRequest, GetBucketInventoryConfigurationOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketLifecycleConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?lifecycle", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketLifecycleConfiguration" }, GetBucketLifecycleConfigurationRequest, GetBucketLifecycleConfigurationOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketLocation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?location", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketLocation" }, GetBucketLocationRequest, GetBucketLocationOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketLogging = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?logging", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketLogging" }, GetBucketLoggingRequest, GetBucketLoggingOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketMetricsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?metrics&x-id=GetBucketMetricsConfiguration", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketMetricsConfiguration" }, GetBucketMetricsConfigurationRequest, GetBucketMetricsConfigurationOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketOwnershipControls = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?ownershipControls", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketOwnershipControls" }, GetBucketOwnershipControlsRequest, GetBucketOwnershipControlsOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?policy", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketPolicy" }, GetBucketPolicyRequest, GetBucketPolicyOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketReplication = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?replication", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketReplication" }, GetBucketReplicationRequest, GetBucketReplicationOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketRequestPayment = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?requestPayment", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketRequestPayment" }, GetBucketRequestPaymentRequest, GetBucketRequestPaymentOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketTagging = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?tagging", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketTagging" }, GetBucketTaggingRequest, GetBucketTaggingOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketVersioning = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?versioning", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketVersioning" }, GetBucketVersioningRequest, GetBucketVersioningOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketWebsite = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?website", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketWebsite" }, GetBucketWebsiteRequest, GetBucketWebsiteOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getObjectAcl = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?acl", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetObjectAcl" }, GetObjectAclRequest, GetObjectAclOutput, [NoSuchKeyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getObjectLegalHold = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?legal-hold", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetObjectLegalHold" }, GetObjectLegalHoldRequest, GetObjectLegalHoldOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getObjectLockConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?object-lock", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetObjectLockConfiguration" }, GetObjectLockConfigurationRequest, GetObjectLockConfigurationOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getObjectRetention = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?retention", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetObjectRetention" }, GetObjectRetentionRequest, GetObjectRetentionOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getObjectTagging = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?tagging", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetObjectTagging" }, GetObjectTaggingRequest, GetObjectTaggingOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getObjectTorrent = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?torrent", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetObjectTorrent" }, GetObjectTorrentRequest, GetObjectTorrentOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getPublicAccessBlock = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?publicAccessBlock", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetPublicAccessBlock" }, GetPublicAccessBlockRequest, GetPublicAccessBlockOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const headBucket = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}", method: "HEAD", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.HeadBucket" }, HeadBucketRequest, HeadBucketOutput, [NotFoundError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const headObject = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}", method: "HEAD", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.HeadObject" }, HeadObjectRequest, HeadObjectOutput, [NotFoundError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listBucketAnalyticsConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?analytics&x-id=ListBucketAnalyticsConfigurations", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.ListBucketAnalyticsConfigurations" }, ListBucketAnalyticsConfigurationsRequest, ListBucketAnalyticsConfigurationsOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listBucketIntelligentTieringConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?intelligent-tiering&x-id=ListBucketIntelligentTieringConfigurations", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.ListBucketIntelligentTieringConfigurations" }, ListBucketIntelligentTieringConfigurationsRequest, ListBucketIntelligentTieringConfigurationsOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listBucketInventoryConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?inventory&x-id=ListBucketInventoryConfigurations", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.ListBucketInventoryConfigurations" }, ListBucketInventoryConfigurationsRequest, ListBucketInventoryConfigurationsOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listBucketMetricsConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?metrics&x-id=ListBucketMetricsConfigurations", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.ListBucketMetricsConfigurations" }, ListBucketMetricsConfigurationsRequest, ListBucketMetricsConfigurationsOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDirectoryBuckets = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/?x-id=ListDirectoryBuckets", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.ListDirectoryBuckets" }, ListDirectoryBucketsRequest, ListDirectoryBucketsOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listObjectsV2 = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?list-type=2", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.ListObjectsV2" }, ListObjectsV2Request, ListObjectsV2Output, [NoSuchBucketError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketAccelerateConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?accelerate", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketAccelerateConfiguration" }, PutBucketAccelerateConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketRequestPayment = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?requestPayment", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketRequestPayment" }, PutBucketRequestPaymentRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketTagging = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?tagging", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketTagging" }, PutBucketTaggingRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketVersioning = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?versioning", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketVersioning" }, PutBucketVersioningRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putObject = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?x-id=PutObject", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutObject" }, PutObjectRequest, PutObjectOutput, [EncryptionTypeMismatchError, InvalidRequestError, InvalidWriteOffsetError, TooManyPartsError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putObjectAcl = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?acl", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutObjectAcl" }, PutObjectAclRequest, PutObjectAclOutput, [NoSuchKeyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putObjectTagging = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?tagging", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutObjectTagging" }, PutObjectTaggingRequest, PutObjectTaggingOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putPublicAccessBlock = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?publicAccessBlock", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutPublicAccessBlock" }, PutPublicAccessBlockRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const uploadPart = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?x-id=UploadPart", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.UploadPart" }, UploadPartRequest, UploadPartOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createBucketMetadataConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?metadataConfiguration", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.CreateBucketMetadataConfiguration" }, CreateBucketMetadataConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createBucketMetadataTableConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?metadataTable", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.CreateBucketMetadataTableConfiguration" }, CreateBucketMetadataTableConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createSession = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?session", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.CreateSession" }, CreateSessionRequest, CreateSessionOutput, [NoSuchBucketError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketPolicyStatus = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?policyStatus", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketPolicyStatus" }, GetBucketPolicyStatusRequest, GetBucketPolicyStatusOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getObject = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?x-id=GetObject", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetObject" }, GetObjectRequest, GetObjectOutput, [InvalidObjectStateError, NoSuchKeyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listBuckets = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/?x-id=ListBuckets", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.ListBuckets" }, ListBucketsRequest, ListBucketsOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listMultipartUploads = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?uploads", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.ListMultipartUploads" }, ListMultipartUploadsRequest, ListMultipartUploadsOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listObjectVersions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?versions", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.ListObjectVersions" }, ListObjectVersionsRequest, ListObjectVersionsOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listParts = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?x-id=ListParts", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.ListParts" }, ListPartsRequest, ListPartsOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketCors = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?cors", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketCors" }, PutBucketCorsRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketOwnershipControls = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?ownershipControls", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketOwnershipControls" }, PutBucketOwnershipControlsRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putObjectLegalHold = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?legal-hold", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutObjectLegalHold" }, PutObjectLegalHoldRequest, PutObjectLegalHoldOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putObjectRetention = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?retention", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutObjectRetention" }, PutObjectRetentionRequest, PutObjectRetentionOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateBucketMetadataInventoryTableConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?metadataInventoryTable", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.UpdateBucketMetadataInventoryTableConfiguration" }, UpdateBucketMetadataInventoryTableConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateBucketMetadataJournalTableConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?metadataJournalTable", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.UpdateBucketMetadataJournalTableConfiguration" }, UpdateBucketMetadataJournalTableConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const uploadPartCopy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?x-id=UploadPartCopy", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.UploadPartCopy" }, UploadPartCopyRequest, UploadPartCopyOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const completeMultipartUpload = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.CompleteMultipartUpload" }, CompleteMultipartUploadRequest, CompleteMultipartUploadOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const copyObject = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?x-id=CopyObject", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.CopyObject" }, CopyObjectRequest, CopyObjectOutput, [ObjectNotInActiveTierErrorError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createBucket = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.CreateBucket" }, CreateBucketRequest, CreateBucketOutput, [BucketAlreadyExistsError, BucketAlreadyOwnedByYouError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getObjectAttributes = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?attributes", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetObjectAttributes" }, GetObjectAttributesRequest, GetObjectAttributesOutput, [NoSuchKeyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listObjects = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.ListObjects" }, ListObjectsRequest, ListObjectsOutput, [NoSuchBucketError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketAcl = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?acl", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketAcl" }, PutBucketAclRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketEncryption = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?encryption", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketEncryption" }, PutBucketEncryptionRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketIntelligentTieringConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?intelligent-tiering", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketIntelligentTieringConfiguration" }, PutBucketIntelligentTieringConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketMetricsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?metrics", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketMetricsConfiguration" }, PutBucketMetricsConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketWebsite = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?website", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketWebsite" }, PutBucketWebsiteRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteObjects = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?delete", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.DeleteObjects" }, DeleteObjectsRequest, DeleteObjectsOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketMetadataConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?metadataConfiguration", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketMetadataConfiguration" }, GetBucketMetadataConfigurationRequest, GetBucketMetadataConfigurationOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getBucketMetadataTableConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?metadataTable", method: "GET", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.GetBucketMetadataTableConfiguration" }, GetBucketMetadataTableConfigurationRequest, GetBucketMetadataTableConfigurationOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketLogging = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?logging", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketLogging" }, PutBucketLoggingRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putObjectLockConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?object-lock", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutObjectLockConfiguration" }, PutObjectLockConfigurationRequest, PutObjectLockConfigurationOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketAnalyticsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?analytics", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketAnalyticsConfiguration" }, PutBucketAnalyticsConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketInventoryConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?inventory", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketInventoryConfiguration" }, PutBucketInventoryConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketLifecycleConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?lifecycle", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketLifecycleConfiguration" }, PutBucketLifecycleConfigurationRequest, PutBucketLifecycleConfigurationOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketNotificationConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?notification", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketNotificationConfiguration" }, PutBucketNotificationConfigurationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putBucketReplication = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}?replication", method: "PUT", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.PutBucketReplication" }, PutBucketReplicationRequest, Schema.Struct({}), []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const restoreObject = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?restore", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.RestoreObject" }, RestoreObjectRequest, RestoreObjectOutput, [ObjectAlreadyInActiveTierErrorError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const selectObjectContent = /*#__PURE__*/ makeOperation(() => Operation({ version: "2006-03-01", uri: "/{Bucket}/{Key+}?select&select-type=2", method: "POST", sdkId: "S3", sigV4ServiceName: "s3", name: "AmazonS3.SelectObjectContent" }, SelectObjectContentRequest, SelectObjectContentOutput, []), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
