import { Schema} from "effect"
import { FormatXMLRequest, FormatXMLResponse, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
const SchemaFacetList = Schema.Array(SchemaFacet)
const AttributeNameList = Schema.Array(Schema.String)
const TagKeyList = Schema.Array(Schema.String)
const ApplySchemaRequest = Schema.Struct({PublishedSchemaArn: Schema.String, DirectoryArn: Header("x-amz-data-partition")})
const AttachObjectRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ParentReference: ObjectReference, ChildReference: ObjectReference, LinkName: Schema.String})
const AttachPolicyRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), PolicyReference: ObjectReference, ObjectReference: ObjectReference})
const AttachPolicyResponse = Schema.Struct({})
const AttachToIndexRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), IndexReference: ObjectReference, TargetReference: ObjectReference})
const CreateDirectoryRequest = Schema.Struct({Name: Schema.String, SchemaArn: Header("x-amz-data-partition")})
const CreateObjectRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), SchemaFacets: SchemaFacetList, ObjectAttributeList: Schema.optional(AttributeKeyAndValueList), ParentReference: Schema.optional(ObjectReference), LinkName: Schema.optional(Schema.String)})
const CreateSchemaRequest = Schema.Struct({Name: Schema.String})
const DeleteDirectoryRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition")})
const DeleteFacetRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), Name: Schema.String})
const DeleteFacetResponse = Schema.Struct({})
const DeleteObjectRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ObjectReference: ObjectReference})
const DeleteObjectResponse = Schema.Struct({})
const DeleteSchemaRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition")})
const DeleteTypedLinkFacetRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), Name: Schema.String})
const DeleteTypedLinkFacetResponse = Schema.Struct({})
const DetachFromIndexRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), IndexReference: ObjectReference, TargetReference: ObjectReference})
const DetachObjectRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ParentReference: ObjectReference, LinkName: Schema.String})
const DetachPolicyRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), PolicyReference: ObjectReference, ObjectReference: ObjectReference})
const DetachPolicyResponse = Schema.Struct({})
const DisableDirectoryRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition")})
const EnableDirectoryRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition")})
const GetAppliedSchemaVersionRequest = Schema.Struct({SchemaArn: Schema.String})
const GetDirectoryRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition")})
const GetFacetRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), Name: Schema.String})
const GetLinkAttributesRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), TypedLinkSpecifier: TypedLinkSpecifier, AttributeNames: AttributeNameList, ConsistencyLevel: Schema.optional(Schema.String)})
const GetObjectAttributesRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ObjectReference: ObjectReference, ConsistencyLevel: Schema.optional(Header("x-amz-consistency-level")), SchemaFacet: SchemaFacet, AttributeNames: AttributeNameList})
const GetObjectInformationRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ObjectReference: ObjectReference, ConsistencyLevel: Schema.optional(Header("x-amz-consistency-level"))})
const GetSchemaAsJsonRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition")})
const GetTypedLinkFacetInformationRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), Name: Schema.String})
const ListAppliedSchemaArnsRequest = Schema.Struct({DirectoryArn: Schema.String, SchemaArn: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const ListAttachedIndicesRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), TargetReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), ConsistencyLevel: Schema.optional(Header("x-amz-consistency-level"))})
const ListDevelopmentSchemaArnsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const ListDirectoriesRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), state: Schema.optional(Schema.String)})
const ListFacetAttributesRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), Name: Schema.String, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const ListFacetNamesRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const ListManagedSchemaArnsRequest = Schema.Struct({SchemaArn: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const ListObjectAttributesRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ObjectReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), ConsistencyLevel: Schema.optional(Header("x-amz-consistency-level")), FacetFilter: Schema.optional(SchemaFacet)})
const ListObjectChildrenRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ObjectReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), ConsistencyLevel: Schema.optional(Header("x-amz-consistency-level"))})
const ListObjectParentPathsRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ObjectReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const ListObjectParentsRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ObjectReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), ConsistencyLevel: Schema.optional(Header("x-amz-consistency-level")), IncludeAllLinksToEachParent: Schema.optional(Schema.Boolean)})
const ListObjectPoliciesRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ObjectReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), ConsistencyLevel: Schema.optional(Header("x-amz-consistency-level"))})
const ListOutgoingTypedLinksRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ObjectReference: ObjectReference, FilterAttributeRanges: Schema.optional(TypedLinkAttributeRangeList), FilterTypedLink: Schema.optional(TypedLinkSchemaAndFacetName), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), ConsistencyLevel: Schema.optional(Schema.String)})
const ListPolicyAttachmentsRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), PolicyReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), ConsistencyLevel: Schema.optional(Header("x-amz-consistency-level"))})
const ListPublishedSchemaArnsRequest = Schema.Struct({SchemaArn: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const ListTagsForResourceRequest = Schema.Struct({ResourceArn: Schema.String, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const ListTypedLinkFacetAttributesRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), Name: Schema.String, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const ListTypedLinkFacetNamesRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const LookupPolicyRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ObjectReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const PublishSchemaRequest = Schema.Struct({DevelopmentSchemaArn: Header("x-amz-data-partition"), Version: Schema.String, MinorVersion: Schema.optional(Schema.String), Name: Schema.optional(Schema.String)})
const PutSchemaFromJsonRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), Document: Schema.String})
const RemoveFacetFromObjectRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), SchemaFacet: SchemaFacet, ObjectReference: ObjectReference})
const RemoveFacetFromObjectResponse = Schema.Struct({})
const UntagResourceRequest = Schema.Struct({ResourceArn: Schema.String, TagKeys: TagKeyList})
const UntagResourceResponse = Schema.Struct({})
const UpdateSchemaRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), Name: Schema.String})
const UpgradeAppliedSchemaRequest = Schema.Struct({PublishedSchemaArn: Schema.String, DirectoryArn: Schema.String, DryRun: Schema.optional(Schema.Boolean)})
const UpgradePublishedSchemaRequest = Schema.Struct({DevelopmentSchemaArn: Schema.String, PublishedSchemaArn: Schema.String, MinorVersion: Schema.String, DryRun: Schema.optional(Schema.Boolean)})
const SchemaFacet = Schema.Struct({SchemaArn: Schema.optional(Schema.String), FacetName: Schema.optional(Schema.String)})
const ObjectReference = Schema.Struct({Selector: Schema.optional(Schema.String)})
const TypedLinkSchemaAndFacetName = Schema.Struct({SchemaArn: Schema.String, TypedLinkName: Schema.String})
const AttributeNameAndValue = Schema.Struct({AttributeName: Schema.String, Value: TypedAttributeValue})
const AttributeNameAndValueList = Schema.Array(AttributeNameAndValue)
const AttributeKey = Schema.Struct({SchemaArn: Schema.String, FacetName: Schema.String, Name: Schema.String})
const AttributeKeyList = Schema.Array(AttributeKey)
const TypedLinkSpecifier = Schema.Struct({TypedLinkFacet: TypedLinkSchemaAndFacetName, SourceObjectReference: ObjectReference, TargetObjectReference: ObjectReference, IdentityAttributeValues: AttributeNameAndValueList})
const Arns = Schema.Array(Schema.String)
const DirectoryList = Schema.Array(Directory)
const FacetNameList = Schema.Array(Schema.String)
const ObjectAttributeRange = Schema.Struct({AttributeKey: Schema.optional(AttributeKey), Range: Schema.optional(TypedAttributeValueRange)})
const ObjectAttributeRangeList = Schema.Array(ObjectAttributeRange)
const ObjectIdentifierList = Schema.Array(Schema.String)
const TypedLinkSpecifierList = Schema.Array(TypedLinkSpecifier)
const TypedLinkNameList = Schema.Array(Schema.String)
const Tag = Schema.Struct({Key: Schema.optional(Schema.String), Value: Schema.optional(Schema.String)})
const TagList = Schema.Array(Tag)
const FacetAttributeUpdate = Schema.Struct({Attribute: Schema.optional(FacetAttribute), Action: Schema.optional(Schema.String)})
const FacetAttributeUpdateList = Schema.Array(FacetAttributeUpdate)
const TypedLinkFacetAttributeUpdate = Schema.Struct({Attribute: TypedLinkAttributeDefinition, Action: Schema.String})
const TypedLinkFacetAttributeUpdateList = Schema.Array(TypedLinkFacetAttributeUpdate)
const ApplySchemaResponse = Schema.Struct({AppliedSchemaArn: Schema.optional(Schema.String), DirectoryArn: Schema.optional(Schema.String)})
const AttachObjectResponse = Schema.Struct({AttachedObjectIdentifier: Schema.optional(Schema.String)})
const AccessDeniedException = Schema.Struct({Message: Schema.optional(Schema.String)})
const AttachToIndexResponse = Schema.Struct({AttachedObjectIdentifier: Schema.optional(Schema.String)})
const AttachTypedLinkRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), SourceObjectReference: ObjectReference, TargetObjectReference: ObjectReference, TypedLinkFacet: TypedLinkSchemaAndFacetName, Attributes: AttributeNameAndValueList})
const CreateDirectoryResponse = Schema.Struct({DirectoryArn: Schema.String, Name: Schema.String, ObjectIdentifier: Schema.String, AppliedSchemaArn: Schema.String})
const CreateIndexRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), OrderedIndexedAttributeList: AttributeKeyList, IsUnique: Schema.Boolean, ParentReference: Schema.optional(ObjectReference), LinkName: Schema.optional(Schema.String)})
const CreateObjectResponse = Schema.Struct({ObjectIdentifier: Schema.optional(Schema.String)})
const CreateSchemaResponse = Schema.Struct({SchemaArn: Schema.optional(Schema.String)})
const DeleteDirectoryResponse = Schema.Struct({DirectoryArn: Schema.String})
const FacetInUseException = Schema.Struct({Message: Schema.optional(Schema.String)})
const DirectoryNotEnabledException = Schema.Struct({Message: Schema.optional(Schema.String)})
const DeleteSchemaResponse = Schema.Struct({SchemaArn: Schema.optional(Schema.String)})
const FacetNotFoundException = Schema.Struct({Message: Schema.optional(Schema.String)})
const DetachFromIndexResponse = Schema.Struct({DetachedObjectIdentifier: Schema.optional(Schema.String)})
const DetachObjectResponse = Schema.Struct({DetachedObjectIdentifier: Schema.optional(Schema.String)})
const InternalServiceException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DetachPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/policy/detach", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "DetachPolicy" }, DetachPolicyRequest, DetachPolicyResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("NotPolicyException", NotPolicyException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DetachTypedLinkRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), TypedLinkSpecifier: TypedLinkSpecifier})
export const DetachTypedLink = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/typedlink/detach", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "DetachTypedLink" }, DetachTypedLinkRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DisableDirectoryResponse = Schema.Struct({DirectoryArn: Schema.String})
export const DisableDirectory = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/directory/disable", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "DisableDirectory" }, DisableDirectoryRequest, DisableDirectoryResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryDeletedException", DirectoryDeletedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const EnableDirectoryResponse = Schema.Struct({DirectoryArn: Schema.String})
export const EnableDirectory = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/directory/enable", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "EnableDirectory" }, EnableDirectoryRequest, EnableDirectoryResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryDeletedException", DirectoryDeletedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetAppliedSchemaVersionResponse = Schema.Struct({AppliedSchemaArn: Schema.optional(Schema.String)})
export const GetAppliedSchemaVersion = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema/getappliedschema", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "GetAppliedSchemaVersion" }, GetAppliedSchemaVersionRequest, GetAppliedSchemaVersionResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetLinkAttributesResponse = Schema.Struct({Attributes: Schema.optional(AttributeKeyAndValueList)})
export const GetLinkAttributes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/typedlink/attributes/get", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "GetLinkAttributes" }, GetLinkAttributesRequest, GetLinkAttributesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetObjectAttributesResponse = Schema.Struct({Attributes: Schema.optional(AttributeKeyAndValueList)})
export const GetObjectAttributes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/attributes/get", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "GetObjectAttributes" }, GetObjectAttributesRequest, GetObjectAttributesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetObjectInformationResponse = Schema.Struct({SchemaFacets: Schema.optional(SchemaFacetList), ObjectIdentifier: Schema.optional(Schema.String)})
export const GetObjectInformation = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/information", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "GetObjectInformation" }, GetObjectInformationRequest, GetObjectInformationResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetSchemaAsJsonResponse = Schema.Struct({Name: Schema.optional(Schema.String), Document: Schema.optional(Schema.String)})
export const GetSchemaAsJson = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema/json", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "GetSchemaAsJson" }, GetSchemaAsJsonRequest, GetSchemaAsJsonResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetTypedLinkFacetInformationResponse = Schema.Struct({IdentityAttributeOrder: Schema.optional(AttributeNameList)})
const ListAppliedSchemaArnsResponse = Schema.Struct({SchemaArns: Schema.optional(Arns), NextToken: Schema.optional(Schema.String)})
export const ListAppliedSchemaArns = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema/applied", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListAppliedSchemaArns" }, ListAppliedSchemaArnsRequest, ListAppliedSchemaArnsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDevelopmentSchemaArnsResponse = Schema.Struct({SchemaArns: Schema.optional(Arns), NextToken: Schema.optional(Schema.String)})
export const ListDevelopmentSchemaArns = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema/development", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListDevelopmentSchemaArns" }, ListDevelopmentSchemaArnsRequest, ListDevelopmentSchemaArnsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDirectoriesResponse = Schema.Struct({Directories: DirectoryList, NextToken: Schema.optional(Schema.String)})
export const ListDirectories = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/directory/list", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListDirectories" }, ListDirectoriesRequest, ListDirectoriesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListFacetAttributesResponse = Schema.Struct({Attributes: Schema.optional(FacetAttributeList), NextToken: Schema.optional(Schema.String)})
export const ListFacetAttributes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/facet/attributes", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListFacetAttributes" }, ListFacetAttributesRequest, ListFacetAttributesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("FacetNotFoundException", FacetNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListFacetNamesResponse = Schema.Struct({FacetNames: Schema.optional(FacetNameList), NextToken: Schema.optional(Schema.String)})
export const ListFacetNames = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/facet/list", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListFacetNames" }, ListFacetNamesRequest, ListFacetNamesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListIndexRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), RangesOnIndexedValues: Schema.optional(ObjectAttributeRangeList), IndexReference: ObjectReference, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String), ConsistencyLevel: Schema.optional(Header("x-amz-consistency-level"))})
const ListManagedSchemaArnsResponse = Schema.Struct({SchemaArns: Schema.optional(Arns), NextToken: Schema.optional(Schema.String)})
export const ListManagedSchemaArns = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema/managed", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListManagedSchemaArns" }, ListManagedSchemaArnsRequest, ListManagedSchemaArnsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListObjectAttributesResponse = Schema.Struct({Attributes: Schema.optional(AttributeKeyAndValueList), NextToken: Schema.optional(Schema.String)})
export const ListObjectAttributes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/attributes", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListObjectAttributes" }, ListObjectAttributesRequest, ListObjectAttributesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListObjectPoliciesResponse = Schema.Struct({AttachedPolicyIds: Schema.optional(ObjectIdentifierList), NextToken: Schema.optional(Schema.String)})
export const ListObjectPolicies = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/policy", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListObjectPolicies" }, ListObjectPoliciesRequest, ListObjectPoliciesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListOutgoingTypedLinksResponse = Schema.Struct({TypedLinkSpecifiers: Schema.optional(TypedLinkSpecifierList), NextToken: Schema.optional(Schema.String)})
export const ListOutgoingTypedLinks = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/typedlink/outgoing", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListOutgoingTypedLinks" }, ListOutgoingTypedLinksRequest, ListOutgoingTypedLinksResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListPolicyAttachmentsResponse = Schema.Struct({ObjectIdentifiers: Schema.optional(ObjectIdentifierList), NextToken: Schema.optional(Schema.String)})
export const ListPolicyAttachments = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/policy/attachment", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListPolicyAttachments" }, ListPolicyAttachmentsRequest, ListPolicyAttachmentsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("NotPolicyException", NotPolicyException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListPublishedSchemaArnsResponse = Schema.Struct({SchemaArns: Schema.optional(Arns), NextToken: Schema.optional(Schema.String)})
export const ListPublishedSchemaArns = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema/published", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListPublishedSchemaArns" }, ListPublishedSchemaArnsRequest, ListPublishedSchemaArnsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListTagsForResourceResponse = Schema.Struct({Tags: Schema.optional(TagList), NextToken: Schema.optional(Schema.String)})
const ListTypedLinkFacetAttributesResponse = Schema.Struct({Attributes: Schema.optional(TypedLinkAttributeDefinitionList), NextToken: Schema.optional(Schema.String)})
export const ListTypedLinkFacetAttributes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/typedlink/facet/attributes", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListTypedLinkFacetAttributes" }, ListTypedLinkFacetAttributesRequest, ListTypedLinkFacetAttributesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("FacetNotFoundException", FacetNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListTypedLinkFacetNamesResponse = Schema.Struct({FacetNames: Schema.optional(TypedLinkNameList), NextToken: Schema.optional(Schema.String)})
export const ListTypedLinkFacetNames = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/typedlink/facet/list", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListTypedLinkFacetNames" }, ListTypedLinkFacetNamesRequest, ListTypedLinkFacetNamesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PublishSchemaResponse = Schema.Struct({PublishedSchemaArn: Schema.optional(Schema.String)})
const PutSchemaFromJsonResponse = Schema.Struct({Arn: Schema.optional(Schema.String)})
const FacetValidationException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const RemoveFacetFromObject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/facets/delete", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "RemoveFacetFromObject" }, RemoveFacetFromObjectRequest, RemoveFacetFromObjectResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TagResourceRequest = Schema.Struct({ResourceArn: Schema.String, Tags: TagList})
const TagResourceResponse = Schema.Struct({})
export const TagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/tags/add", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "TagResource" }, TagResourceRequest, TagResourceResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidTaggingRequestException", InvalidTaggingRequestException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidArnException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UntagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/tags/remove", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "UntagResource" }, UntagResourceRequest, UntagResourceResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidTaggingRequestException", InvalidTaggingRequestException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateFacetRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), Name: Schema.String, AttributeUpdates: Schema.optional(FacetAttributeUpdateList), ObjectType: Schema.optional(Schema.String)})
const UpdateFacetResponse = Schema.Struct({})
const UpdateSchemaResponse = Schema.Struct({SchemaArn: Schema.optional(Schema.String)})
export const UpdateSchema = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema/update", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "UpdateSchema" }, UpdateSchemaRequest, UpdateSchemaResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateTypedLinkFacetRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), Name: Schema.String, AttributeUpdates: TypedLinkFacetAttributeUpdateList, IdentityAttributeOrder: AttributeNameList})
const UpdateTypedLinkFacetResponse = Schema.Struct({})
export const UpdateTypedLinkFacet = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/typedlink/facet", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "UpdateTypedLinkFacet" }, UpdateTypedLinkFacetRequest, UpdateTypedLinkFacetResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("FacetNotFoundException", FacetNotFoundException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidFacetUpdateException", InvalidFacetUpdateException), ErrorAnnotation("InvalidRuleException", InvalidRuleException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpgradeAppliedSchemaResponse = Schema.Struct({UpgradedSchemaArn: Schema.optional(Schema.String), DirectoryArn: Schema.optional(Schema.String)})
const UpgradePublishedSchemaResponse = Schema.Struct({UpgradedSchemaArn: Schema.optional(Schema.String)})
export const UpgradePublishedSchema = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema/upgradepublished", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "UpgradePublishedSchema" }, UpgradePublishedSchemaRequest, UpgradePublishedSchemaResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("IncompatibleSchemaException", IncompatibleSchemaException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidAttachmentException", InvalidAttachmentException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TypedAttributeValue = Schema.Union(Schema.String, StreamBody(), Schema.Boolean, Schema.String, Schema.Date)
const BatchListObjectAttributes = Schema.Struct({ObjectReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), FacetFilter: Schema.optional(SchemaFacet)})
const BatchListObjectChildren = Schema.Struct({ObjectReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const BatchListAttachedIndices = Schema.Struct({TargetReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const BatchListObjectParentPaths = Schema.Struct({ObjectReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const BatchGetObjectInformation = Schema.Struct({ObjectReference: ObjectReference})
const BatchGetObjectAttributes = Schema.Struct({ObjectReference: ObjectReference, SchemaFacet: SchemaFacet, AttributeNames: AttributeNameList})
const BatchListObjectParents = Schema.Struct({ObjectReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const BatchListObjectPolicies = Schema.Struct({ObjectReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const BatchListPolicyAttachments = Schema.Struct({PolicyReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const BatchLookupPolicy = Schema.Struct({ObjectReference: ObjectReference, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const BatchListIndex = Schema.Struct({RangesOnIndexedValues: Schema.optional(ObjectAttributeRangeList), IndexReference: ObjectReference, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const BatchListOutgoingTypedLinks = Schema.Struct({ObjectReference: ObjectReference, FilterAttributeRanges: Schema.optional(TypedLinkAttributeRangeList), FilterTypedLink: Schema.optional(TypedLinkSchemaAndFacetName), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const BatchListIncomingTypedLinks = Schema.Struct({ObjectReference: ObjectReference, FilterAttributeRanges: Schema.optional(TypedLinkAttributeRangeList), FilterTypedLink: Schema.optional(TypedLinkSchemaAndFacetName), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const BatchGetLinkAttributes = Schema.Struct({TypedLinkSpecifier: TypedLinkSpecifier, AttributeNames: AttributeNameList})
const BatchCreateObject = Schema.Struct({SchemaFacet: SchemaFacetList, ObjectAttributeList: AttributeKeyAndValueList, ParentReference: Schema.optional(ObjectReference), LinkName: Schema.optional(Schema.String), BatchReferenceName: Schema.optional(Schema.String)})
const BatchAttachObject = Schema.Struct({ParentReference: ObjectReference, ChildReference: ObjectReference, LinkName: Schema.String})
const BatchDetachObject = Schema.Struct({ParentReference: ObjectReference, LinkName: Schema.String, BatchReferenceName: Schema.optional(Schema.String)})
const BatchUpdateObjectAttributes = Schema.Struct({ObjectReference: ObjectReference, AttributeUpdates: ObjectAttributeUpdateList})
const BatchDeleteObject = Schema.Struct({ObjectReference: ObjectReference})
const BatchAddFacetToObject = Schema.Struct({SchemaFacet: SchemaFacet, ObjectAttributeList: AttributeKeyAndValueList, ObjectReference: ObjectReference})
const BatchRemoveFacetFromObject = Schema.Struct({SchemaFacet: SchemaFacet, ObjectReference: ObjectReference})
const BatchAttachPolicy = Schema.Struct({PolicyReference: ObjectReference, ObjectReference: ObjectReference})
const BatchDetachPolicy = Schema.Struct({PolicyReference: ObjectReference, ObjectReference: ObjectReference})
const BatchCreateIndex = Schema.Struct({OrderedIndexedAttributeList: AttributeKeyList, IsUnique: Schema.Boolean, ParentReference: Schema.optional(ObjectReference), LinkName: Schema.optional(Schema.String), BatchReferenceName: Schema.optional(Schema.String)})
const BatchAttachToIndex = Schema.Struct({IndexReference: ObjectReference, TargetReference: ObjectReference})
const BatchDetachFromIndex = Schema.Struct({IndexReference: ObjectReference, TargetReference: ObjectReference})
const BatchAttachTypedLink = Schema.Struct({SourceObjectReference: ObjectReference, TargetObjectReference: ObjectReference, TypedLinkFacet: TypedLinkSchemaAndFacetName, Attributes: AttributeNameAndValueList})
const BatchDetachTypedLink = Schema.Struct({TypedLinkSpecifier: TypedLinkSpecifier})
const BatchUpdateLinkAttributes = Schema.Struct({TypedLinkSpecifier: TypedLinkSpecifier, AttributeUpdates: LinkAttributeUpdateList})
const FacetAttributeReference = Schema.Struct({TargetFacetName: Schema.String, TargetAttributeName: Schema.String})
const TypedLinkAttributeDefinition = Schema.Struct({Name: Schema.String, Type: Schema.String, DefaultValue: Schema.optional(TypedAttributeValue), IsImmutable: Schema.optional(Schema.Boolean), Rules: Schema.optional(RuleMap), RequiredBehavior: Schema.String})
const TypedLinkAttributeDefinitionList = Schema.Array(TypedLinkAttributeDefinition)
const TypedAttributeValueRange = Schema.Struct({StartMode: Schema.String, StartValue: Schema.optional(TypedAttributeValue), EndMode: Schema.String, EndValue: Schema.optional(TypedAttributeValue)})
const LinkAttributeAction = Schema.Struct({AttributeActionType: Schema.optional(Schema.String), AttributeUpdateValue: Schema.optional(TypedAttributeValue)})
const ObjectAttributeAction = Schema.Struct({ObjectAttributeActionType: Schema.optional(Schema.String), ObjectAttributeUpdateValue: Schema.optional(TypedAttributeValue)})
const AttributeKeyAndValue = Schema.Struct({Key: AttributeKey, Value: TypedAttributeValue})
const AttributeKeyAndValueList = Schema.Array(AttributeKeyAndValue)
const BatchReadOperation = Schema.Struct({ListObjectAttributes: Schema.optional(BatchListObjectAttributes), ListObjectChildren: Schema.optional(BatchListObjectChildren), ListAttachedIndices: Schema.optional(BatchListAttachedIndices), ListObjectParentPaths: Schema.optional(BatchListObjectParentPaths), GetObjectInformation: Schema.optional(BatchGetObjectInformation), GetObjectAttributes: Schema.optional(BatchGetObjectAttributes), ListObjectParents: Schema.optional(BatchListObjectParents), ListObjectPolicies: Schema.optional(BatchListObjectPolicies), ListPolicyAttachments: Schema.optional(BatchListPolicyAttachments), LookupPolicy: Schema.optional(BatchLookupPolicy), ListIndex: Schema.optional(BatchListIndex), ListOutgoingTypedLinks: Schema.optional(BatchListOutgoingTypedLinks), ListIncomingTypedLinks: Schema.optional(BatchListIncomingTypedLinks), GetLinkAttributes: Schema.optional(BatchGetLinkAttributes)})
const BatchReadOperationList = Schema.Array(BatchReadOperation)
const BatchWriteOperation = Schema.Struct({CreateObject: Schema.optional(BatchCreateObject), AttachObject: Schema.optional(BatchAttachObject), DetachObject: Schema.optional(BatchDetachObject), UpdateObjectAttributes: Schema.optional(BatchUpdateObjectAttributes), DeleteObject: Schema.optional(BatchDeleteObject), AddFacetToObject: Schema.optional(BatchAddFacetToObject), RemoveFacetFromObject: Schema.optional(BatchRemoveFacetFromObject), AttachPolicy: Schema.optional(BatchAttachPolicy), DetachPolicy: Schema.optional(BatchDetachPolicy), CreateIndex: Schema.optional(BatchCreateIndex), AttachToIndex: Schema.optional(BatchAttachToIndex), DetachFromIndex: Schema.optional(BatchDetachFromIndex), AttachTypedLink: Schema.optional(BatchAttachTypedLink), DetachTypedLink: Schema.optional(BatchDetachTypedLink), UpdateLinkAttributes: Schema.optional(BatchUpdateLinkAttributes)})
const BatchWriteOperationList = Schema.Array(BatchWriteOperation)
const TypedLinkFacet = Schema.Struct({Name: Schema.String, Attributes: TypedLinkAttributeDefinitionList, IdentityAttributeOrder: AttributeNameList})
const Directory = Schema.Struct({Name: Schema.optional(Schema.String), DirectoryArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String), CreationDateTime: Schema.optional(Schema.Date)})
const Facet = Schema.Struct({Name: Schema.optional(Schema.String), ObjectType: Schema.optional(Schema.String), FacetStyle: Schema.optional(Schema.String)})
const IndexAttachment = Schema.Struct({IndexedAttributes: Schema.optional(AttributeKeyAndValueList), ObjectIdentifier: Schema.optional(Schema.String)})
const IndexAttachmentList = Schema.Array(IndexAttachment)
const TypedLinkAttributeRange = Schema.Struct({AttributeName: Schema.optional(Schema.String), Range: TypedAttributeValueRange})
const TypedLinkAttributeRangeList = Schema.Array(TypedLinkAttributeRange)
const LinkNameToObjectIdentifierMap = Schema.Record({key: Schema.String, value: Schema.String})
const PathToObjectIdentifiers = Schema.Struct({Path: Schema.optional(Schema.String), ObjectIdentifiers: Schema.optional(ObjectIdentifierList)})
const PathToObjectIdentifiersList = Schema.Array(PathToObjectIdentifiers)
const ObjectIdentifierToLinkNameMap = Schema.Record({key: Schema.String, value: Schema.String})
const ObjectIdentifierAndLinkNameTuple = Schema.Struct({ObjectIdentifier: Schema.optional(Schema.String), LinkName: Schema.optional(Schema.String)})
const ObjectIdentifierAndLinkNameList = Schema.Array(ObjectIdentifierAndLinkNameTuple)
const LinkAttributeUpdate = Schema.Struct({AttributeKey: Schema.optional(AttributeKey), AttributeAction: Schema.optional(LinkAttributeAction)})
const LinkAttributeUpdateList = Schema.Array(LinkAttributeUpdate)
const ObjectAttributeUpdate = Schema.Struct({ObjectAttributeKey: Schema.optional(AttributeKey), ObjectAttributeAction: Schema.optional(ObjectAttributeAction)})
const ObjectAttributeUpdateList = Schema.Array(ObjectAttributeUpdate)
const AddFacetToObjectRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), SchemaFacet: SchemaFacet, ObjectAttributeList: Schema.optional(AttributeKeyAndValueList), ObjectReference: ObjectReference})
const AddFacetToObjectResponse = Schema.Struct({})
export const AddFacetToObject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/facets", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "AddFacetToObject" }, AddFacetToObjectRequest, AddFacetToObjectResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidAttachmentException = Schema.Struct({Message: Schema.optional(Schema.String)})
const LimitExceededException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const AttachObject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/attach", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "AttachObject" }, AttachObjectRequest, AttachObjectResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidAttachmentException", InvalidAttachmentException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("LinkNameAlreadyInUseException", LinkNameAlreadyInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NotPolicyException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const AttachPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/policy/attach", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "AttachPolicy" }, AttachPolicyRequest, AttachPolicyResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("NotPolicyException", NotPolicyException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const IndexedAttributeMissingException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const AttachToIndex = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/index/attach", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "AttachToIndex" }, AttachToIndexRequest, AttachToIndexResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("IndexedAttributeMissingException", IndexedAttributeMissingException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidAttachmentException", InvalidAttachmentException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("LinkNameAlreadyInUseException", LinkNameAlreadyInUseException), ErrorAnnotation("NotIndexException", NotIndexException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const AttachTypedLinkResponse = Schema.Struct({TypedLinkSpecifier: Schema.optional(TypedLinkSpecifier)})
export const AttachTypedLink = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/typedlink/attach", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "AttachTypedLink" }, AttachTypedLinkRequest, AttachTypedLinkResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidAttachmentException", InvalidAttachmentException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const BatchReadRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), Operations: BatchReadOperationList, ConsistencyLevel: Schema.optional(Header("x-amz-consistency-level"))})
const BatchWriteRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), Operations: BatchWriteOperationList})
const DirectoryAlreadyExistsException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateDirectory = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/directory/create", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "CreateDirectory" }, CreateDirectoryRequest, CreateDirectoryResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryAlreadyExistsException", DirectoryAlreadyExistsException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateIndexResponse = Schema.Struct({ObjectIdentifier: Schema.optional(Schema.String)})
const LinkNameAlreadyInUseException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateObject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "CreateObject" }, CreateObjectRequest, CreateObjectResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("LinkNameAlreadyInUseException", LinkNameAlreadyInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("UnsupportedIndexTypeException", UnsupportedIndexTypeException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const RetryableConflictException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateSchema = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema/create", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "CreateSchema" }, CreateSchemaRequest, CreateSchemaResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("SchemaAlreadyExistsException", SchemaAlreadyExistsException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateTypedLinkFacetRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), Facet: TypedLinkFacet})
const CreateTypedLinkFacetResponse = Schema.Struct({})
const DirectoryDeletedException = Schema.Struct({Message: Schema.optional(Schema.String)})
const ResourceNotFoundException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteFacet = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/facet/delete", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "DeleteFacet" }, DeleteFacetRequest, DeleteFacetResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("FacetInUseException", FacetInUseException), ErrorAnnotation("FacetNotFoundException", FacetNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ObjectNotDetachedException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteObject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/delete", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "DeleteObject" }, DeleteObjectRequest, DeleteObjectResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ObjectNotDetachedException", ObjectNotDetachedException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const StillContainsLinksException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteSchema = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "DeleteSchema" }, DeleteSchemaRequest, DeleteSchemaResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("StillContainsLinksException", StillContainsLinksException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ValidationException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteTypedLinkFacet = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/typedlink/facet/delete", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "DeleteTypedLinkFacet" }, DeleteTypedLinkFacetRequest, DeleteTypedLinkFacetResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("FacetNotFoundException", FacetNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NotIndexException = Schema.Struct({Message: Schema.optional(Schema.String)})
const NotNodeException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DetachObject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/detach", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "DetachObject" }, DetachObjectRequest, DetachObjectResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("NotNodeException", NotNodeException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetDirectoryResponse = Schema.Struct({Directory: Directory})
export const GetDirectory = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/directory/get", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "GetDirectory" }, GetDirectoryRequest, GetDirectoryResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetFacetResponse = Schema.Struct({Facet: Schema.optional(Facet)})
export const GetFacet = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/facet", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "GetFacet" }, GetFacetRequest, GetFacetResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("FacetNotFoundException", FacetNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidNextTokenException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const GetTypedLinkFacetInformation = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/typedlink/facet/get", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "GetTypedLinkFacetInformation" }, GetTypedLinkFacetInformationRequest, GetTypedLinkFacetInformationResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("FacetNotFoundException", FacetNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListAttachedIndicesResponse = Schema.Struct({IndexAttachments: Schema.optional(IndexAttachmentList), NextToken: Schema.optional(Schema.String)})
export const ListAttachedIndices = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/indices", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListAttachedIndices" }, ListAttachedIndicesRequest, ListAttachedIndicesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListIncomingTypedLinksRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ObjectReference: ObjectReference, FilterAttributeRanges: Schema.optional(TypedLinkAttributeRangeList), FilterTypedLink: Schema.optional(TypedLinkSchemaAndFacetName), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), ConsistencyLevel: Schema.optional(Schema.String)})
const ListIndexResponse = Schema.Struct({IndexAttachments: Schema.optional(IndexAttachmentList), NextToken: Schema.optional(Schema.String)})
export const ListIndex = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/index/targets", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListIndex" }, ListIndexRequest, ListIndexResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("NotIndexException", NotIndexException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListObjectChildrenResponse = Schema.Struct({Children: Schema.optional(LinkNameToObjectIdentifierMap), NextToken: Schema.optional(Schema.String)})
export const ListObjectChildren = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/children", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListObjectChildren" }, ListObjectChildrenRequest, ListObjectChildrenResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("NotNodeException", NotNodeException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListObjectParentPathsResponse = Schema.Struct({PathToObjectIdentifiersList: Schema.optional(PathToObjectIdentifiersList), NextToken: Schema.optional(Schema.String)})
export const ListObjectParentPaths = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/parentpaths", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListObjectParentPaths" }, ListObjectParentPathsRequest, ListObjectParentPathsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListObjectParentsResponse = Schema.Struct({Parents: Schema.optional(ObjectIdentifierToLinkNameMap), NextToken: Schema.optional(Schema.String), ParentLinks: Schema.optional(ObjectIdentifierAndLinkNameList)})
const InvalidTaggingRequestException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const ListTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/tags", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidTaggingRequestException", InvalidTaggingRequestException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const SchemaAlreadyPublishedException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const PublishSchema = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema/publish", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "PublishSchema" }, PublishSchemaRequest, PublishSchemaResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("SchemaAlreadyPublishedException", SchemaAlreadyPublishedException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidRuleException = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidFacetUpdateException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateFacet = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/facet", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "UpdateFacet" }, UpdateFacetRequest, UpdateFacetResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("FacetNotFoundException", FacetNotFoundException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidFacetUpdateException", InvalidFacetUpdateException), ErrorAnnotation("InvalidRuleException", InvalidRuleException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateLinkAttributesRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), TypedLinkSpecifier: TypedLinkSpecifier, AttributeUpdates: LinkAttributeUpdateList})
const UpdateLinkAttributesResponse = Schema.Struct({})
export const UpdateLinkAttributes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/typedlink/attributes/update", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "UpdateLinkAttributes" }, UpdateLinkAttributesRequest, UpdateLinkAttributesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateObjectAttributesRequest = Schema.Struct({DirectoryArn: Header("x-amz-data-partition"), ObjectReference: ObjectReference, AttributeUpdates: ObjectAttributeUpdateList})
const IncompatibleSchemaException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpgradeAppliedSchema = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema/upgradeapplied", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "UpgradeAppliedSchema" }, UpgradeAppliedSchemaRequest, UpgradeAppliedSchemaResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("IncompatibleSchemaException", IncompatibleSchemaException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidAttachmentException", InvalidAttachmentException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("SchemaAlreadyExistsException", SchemaAlreadyExistsException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PolicyAttachment = Schema.Struct({PolicyId: Schema.optional(Schema.String), ObjectIdentifier: Schema.optional(Schema.String), PolicyType: Schema.optional(Schema.String)})
const PolicyAttachmentList = Schema.Array(PolicyAttachment)
const PolicyToPath = Schema.Struct({Path: Schema.optional(Schema.String), Policies: Schema.optional(PolicyAttachmentList)})
const PolicyToPathList = Schema.Array(PolicyToPath)
const SchemaAlreadyExistsException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const ApplySchema = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema/apply", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ApplySchema" }, ApplySchemaRequest, ApplySchemaResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidAttachmentException", InvalidAttachmentException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("SchemaAlreadyExistsException", SchemaAlreadyExistsException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const RuleParameterMap = Schema.Record({key: Schema.String, value: Schema.String})
const UnsupportedIndexTypeException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateIndex = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/index", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "CreateIndex" }, CreateIndexRequest, CreateIndexResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("LinkNameAlreadyInUseException", LinkNameAlreadyInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("UnsupportedIndexTypeException", UnsupportedIndexTypeException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const FacetAlreadyExistsException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateTypedLinkFacet = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/typedlink/facet/create", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "CreateTypedLinkFacet" }, CreateTypedLinkFacetRequest, CreateTypedLinkFacetResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("FacetAlreadyExistsException", FacetAlreadyExistsException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidRuleException", InvalidRuleException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DirectoryNotDisabledException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteDirectory = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/directory", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "DeleteDirectory" }, DeleteDirectoryRequest, DeleteDirectoryResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryDeletedException", DirectoryDeletedException), ErrorAnnotation("DirectoryNotDisabledException", DirectoryNotDisabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ObjectAlreadyDetachedException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DetachFromIndex = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/index/detach", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "DetachFromIndex" }, DetachFromIndexRequest, DetachFromIndexResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("NotIndexException", NotIndexException), ErrorAnnotation("ObjectAlreadyDetachedException", ObjectAlreadyDetachedException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListIncomingTypedLinksResponse = Schema.Struct({LinkSpecifiers: Schema.optional(TypedLinkSpecifierList), NextToken: Schema.optional(Schema.String)})
export const ListIncomingTypedLinks = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/typedlink/incoming", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListIncomingTypedLinks" }, ListIncomingTypedLinksRequest, ListIncomingTypedLinksResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CannotListParentOfRootException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const ListObjectParents = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/parent", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "ListObjectParents" }, ListObjectParentsRequest, ListObjectParentsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("CannotListParentOfRootException", CannotListParentOfRootException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const LookupPolicyResponse = Schema.Struct({PolicyToPathList: Schema.optional(PolicyToPathList), NextToken: Schema.optional(Schema.String)})
export const LookupPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/policy/lookup", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "LookupPolicy" }, LookupPolicyRequest, LookupPolicyResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidNextTokenException", InvalidNextTokenException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidSchemaDocException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const PutSchemaFromJson = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/schema/json", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "PutSchemaFromJson" }, PutSchemaFromJsonRequest, PutSchemaFromJsonResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidRuleException", InvalidRuleException), ErrorAnnotation("InvalidSchemaDocException", InvalidSchemaDocException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateObjectAttributesResponse = Schema.Struct({ObjectIdentifier: Schema.optional(Schema.String)})
export const UpdateObjectAttributes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/object/update", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "UpdateObjectAttributes" }, UpdateObjectAttributesRequest, UpdateObjectAttributesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("LinkNameAlreadyInUseException", LinkNameAlreadyInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const BatchDeleteObjectResponse = Schema.Struct({})
const BatchAddFacetToObjectResponse = Schema.Struct({})
const BatchRemoveFacetFromObjectResponse = Schema.Struct({})
const BatchAttachPolicyResponse = Schema.Struct({})
const BatchDetachPolicyResponse = Schema.Struct({})
const BatchDetachTypedLinkResponse = Schema.Struct({})
const BatchUpdateLinkAttributesResponse = Schema.Struct({})
const Rule = Schema.Struct({Type: Schema.optional(Schema.String), Parameters: Schema.optional(RuleParameterMap)})
const RuleMap = Schema.Record({key: Schema.String, value: Rule})
const BatchReadException = Schema.Struct({Type: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
const BatchCreateObjectResponse = Schema.Struct({ObjectIdentifier: Schema.optional(Schema.String)})
const BatchAttachObjectResponse = Schema.Struct({attachedObjectIdentifier: Schema.optional(Schema.String)})
const BatchDetachObjectResponse = Schema.Struct({detachedObjectIdentifier: Schema.optional(Schema.String)})
const BatchUpdateObjectAttributesResponse = Schema.Struct({ObjectIdentifier: Schema.optional(Schema.String)})
const BatchCreateIndexResponse = Schema.Struct({ObjectIdentifier: Schema.optional(Schema.String)})
const BatchAttachToIndexResponse = Schema.Struct({AttachedObjectIdentifier: Schema.optional(Schema.String)})
const BatchDetachFromIndexResponse = Schema.Struct({DetachedObjectIdentifier: Schema.optional(Schema.String)})
const BatchAttachTypedLinkResponse = Schema.Struct({TypedLinkSpecifier: Schema.optional(TypedLinkSpecifier)})
const FacetAttributeDefinition = Schema.Struct({Type: Schema.String, DefaultValue: Schema.optional(TypedAttributeValue), IsImmutable: Schema.optional(Schema.Boolean), Rules: Schema.optional(RuleMap)})
const BatchWriteOperationResponse = Schema.Struct({CreateObject: Schema.optional(BatchCreateObjectResponse), AttachObject: Schema.optional(BatchAttachObjectResponse), DetachObject: Schema.optional(BatchDetachObjectResponse), UpdateObjectAttributes: Schema.optional(BatchUpdateObjectAttributesResponse), DeleteObject: Schema.optional(BatchDeleteObjectResponse), AddFacetToObject: Schema.optional(BatchAddFacetToObjectResponse), RemoveFacetFromObject: Schema.optional(BatchRemoveFacetFromObjectResponse), AttachPolicy: Schema.optional(BatchAttachPolicyResponse), DetachPolicy: Schema.optional(BatchDetachPolicyResponse), CreateIndex: Schema.optional(BatchCreateIndexResponse), AttachToIndex: Schema.optional(BatchAttachToIndexResponse), DetachFromIndex: Schema.optional(BatchDetachFromIndexResponse), AttachTypedLink: Schema.optional(BatchAttachTypedLinkResponse), DetachTypedLink: Schema.optional(BatchDetachTypedLinkResponse), UpdateLinkAttributes: Schema.optional(BatchUpdateLinkAttributesResponse)})
const BatchWriteOperationResponseList = Schema.Array(BatchWriteOperationResponse)
const FacetAttribute = Schema.Struct({Name: Schema.String, AttributeDefinition: Schema.optional(FacetAttributeDefinition), AttributeReference: Schema.optional(FacetAttributeReference), RequiredBehavior: Schema.optional(Schema.String)})
const FacetAttributeList = Schema.Array(FacetAttribute)
const BatchListObjectAttributesResponse = Schema.Struct({Attributes: Schema.optional(AttributeKeyAndValueList), NextToken: Schema.optional(Schema.String)})
const BatchListObjectChildrenResponse = Schema.Struct({Children: Schema.optional(LinkNameToObjectIdentifierMap), NextToken: Schema.optional(Schema.String)})
const BatchGetObjectInformationResponse = Schema.Struct({SchemaFacets: Schema.optional(SchemaFacetList), ObjectIdentifier: Schema.optional(Schema.String)})
const BatchGetObjectAttributesResponse = Schema.Struct({Attributes: Schema.optional(AttributeKeyAndValueList)})
const BatchListAttachedIndicesResponse = Schema.Struct({IndexAttachments: Schema.optional(IndexAttachmentList), NextToken: Schema.optional(Schema.String)})
const BatchListObjectParentPathsResponse = Schema.Struct({PathToObjectIdentifiersList: Schema.optional(PathToObjectIdentifiersList), NextToken: Schema.optional(Schema.String)})
const BatchListObjectPoliciesResponse = Schema.Struct({AttachedPolicyIds: Schema.optional(ObjectIdentifierList), NextToken: Schema.optional(Schema.String)})
const BatchListPolicyAttachmentsResponse = Schema.Struct({ObjectIdentifiers: Schema.optional(ObjectIdentifierList), NextToken: Schema.optional(Schema.String)})
const BatchLookupPolicyResponse = Schema.Struct({PolicyToPathList: Schema.optional(PolicyToPathList), NextToken: Schema.optional(Schema.String)})
const BatchListIndexResponse = Schema.Struct({IndexAttachments: Schema.optional(IndexAttachmentList), NextToken: Schema.optional(Schema.String)})
const BatchListOutgoingTypedLinksResponse = Schema.Struct({TypedLinkSpecifiers: Schema.optional(TypedLinkSpecifierList), NextToken: Schema.optional(Schema.String)})
const BatchListIncomingTypedLinksResponse = Schema.Struct({LinkSpecifiers: Schema.optional(TypedLinkSpecifierList), NextToken: Schema.optional(Schema.String)})
const BatchGetLinkAttributesResponse = Schema.Struct({Attributes: Schema.optional(AttributeKeyAndValueList)})
const BatchListObjectParentsResponse = Schema.Struct({ParentLinks: Schema.optional(ObjectIdentifierAndLinkNameList), NextToken: Schema.optional(Schema.String)})
const BatchWriteResponse = Schema.Struct({Responses: Schema.optional(BatchWriteOperationResponseList)})
const CreateFacetRequest = Schema.Struct({SchemaArn: Header("x-amz-data-partition"), Name: Schema.String, Attributes: Schema.optional(FacetAttributeList), ObjectType: Schema.optional(Schema.String), FacetStyle: Schema.optional(Schema.String)})
const CreateFacetResponse = Schema.Struct({})
export const CreateFacet = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/facet/create", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "CreateFacet" }, CreateFacetRequest, CreateFacetResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("FacetAlreadyExistsException", FacetAlreadyExistsException), ErrorAnnotation("FacetValidationException", FacetValidationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("InvalidRuleException", InvalidRuleException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const BatchReadSuccessfulResponse = Schema.Struct({ListObjectAttributes: Schema.optional(BatchListObjectAttributesResponse), ListObjectChildren: Schema.optional(BatchListObjectChildrenResponse), GetObjectInformation: Schema.optional(BatchGetObjectInformationResponse), GetObjectAttributes: Schema.optional(BatchGetObjectAttributesResponse), ListAttachedIndices: Schema.optional(BatchListAttachedIndicesResponse), ListObjectParentPaths: Schema.optional(BatchListObjectParentPathsResponse), ListObjectPolicies: Schema.optional(BatchListObjectPoliciesResponse), ListPolicyAttachments: Schema.optional(BatchListPolicyAttachmentsResponse), LookupPolicy: Schema.optional(BatchLookupPolicyResponse), ListIndex: Schema.optional(BatchListIndexResponse), ListOutgoingTypedLinks: Schema.optional(BatchListOutgoingTypedLinksResponse), ListIncomingTypedLinks: Schema.optional(BatchListIncomingTypedLinksResponse), GetLinkAttributes: Schema.optional(BatchGetLinkAttributesResponse), ListObjectParents: Schema.optional(BatchListObjectParentsResponse)})
const BatchReadOperationResponse = Schema.Struct({SuccessfulResponse: Schema.optional(BatchReadSuccessfulResponse), ExceptionResponse: Schema.optional(BatchReadException)})
const BatchReadOperationResponseList = Schema.Array(BatchReadOperationResponse)
const BatchReadResponse = Schema.Struct({Responses: Schema.optional(BatchReadOperationResponseList)})
export const BatchRead = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/batchread", method: "POST", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "BatchRead" }, BatchReadRequest, BatchReadResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const BatchWriteException = Schema.Struct({Index: Schema.optional(Schema.Number), Type: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
export const BatchWrite = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/amazonclouddirectory/2017-01-11/batchwrite", method: "PUT", sdkId: "CloudDirectory", sigV4ServiceName: "clouddirectory", name: "BatchWrite" }, BatchWriteRequest, BatchWriteResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("BatchWriteException", BatchWriteException), ErrorAnnotation("DirectoryNotEnabledException", DirectoryNotEnabledException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidArnException", InvalidArnException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("RetryableConflictException", RetryableConflictException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
