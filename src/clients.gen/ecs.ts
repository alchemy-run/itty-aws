import { Schema} from "effect"
import { FormatAwsJSON11Request,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
export const ServiceDeploymentBrief = Schema.Struct({serviceDeploymentArn: Schema.optional(Schema.String), serviceArn: Schema.optional(Schema.String), clusterArn: Schema.optional(Schema.String), startedAt: Schema.optional(Schema.Date), createdAt: Schema.optional(Schema.Date), finishedAt: Schema.optional(Schema.Date), targetServiceRevisionArn: Schema.optional(Schema.String), status: Schema.optional(Schema.String), statusReason: Schema.optional(Schema.String)});
export const ServiceDeploymentsBrief = Schema.Array(ServiceDeploymentBrief);
export const ServiceConnectTlsCertificateAuthority = Schema.Struct({awsPcaAuthorityArn: Schema.optional(Schema.String)});
export const NetworkBandwidthGbpsRequest = Schema.Struct({min: Schema.optional(Schema.Number), max: Schema.optional(Schema.Number)});
export const AcceleratorTotalMemoryMiBRequest = Schema.Struct({min: Schema.optional(Schema.Number), max: Schema.optional(Schema.Number)});
export const PlatformUnknownException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TargetNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ManagedAgent = Schema.Struct({lastStartedAt: Schema.optional(Schema.Date), name: Schema.optional(Schema.String), reason: Schema.optional(Schema.String), lastStatus: Schema.optional(Schema.String)});
export const NetworkInterface = Schema.Struct({attachmentId: Schema.optional(Schema.String), privateIpv4Address: Schema.optional(Schema.String), ipv6Address: Schema.optional(Schema.String)});
export const ManagedAgents = Schema.Array(ManagedAgent);
export const ServiceRevisionLoadBalancer = Schema.Struct({targetGroupArn: Schema.optional(Schema.String), productionListenerRule: Schema.optional(Schema.String)});
export const NetworkInterfaces = Schema.Array(NetworkInterface);
export const InstanceHealthCheckResult = Schema.Struct({type: Schema.optional(Schema.String), status: Schema.optional(Schema.String), lastUpdated: Schema.optional(Schema.Date), lastStatusChange: Schema.optional(Schema.Date)});
export const ServiceRevisionLoadBalancers = Schema.Array(ServiceRevisionLoadBalancer);
export const TargetNotConnectedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ServiceConnectServiceResource = Schema.Struct({discoveryName: Schema.optional(Schema.String), discoveryArn: Schema.optional(Schema.String)});
export const InstanceHealthCheckResultList = Schema.Array(InstanceHealthCheckResult);
export const UpdateInProgressException = Schema.Struct({message: Schema.optional(Schema.String)});
export const AcceleratorCountRequest = Schema.Struct({min: Schema.optional(Schema.Number), max: Schema.optional(Schema.Number)});
export const ServiceConnectServiceResourceList = Schema.Array(ServiceConnectServiceResource);
export const ServiceDeploymentNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdateCapacityProviderResponse = Schema.Struct({capacityProvider: Schema.optional(CapacityProvider)});
export const NoUpdateAvailableException = Schema.Struct({message: Schema.optional(Schema.String)});
export const BaselineEbsBandwidthMbpsRequest = Schema.Struct({min: Schema.optional(Schema.Number), max: Schema.optional(Schema.Number)});
export const TotalLocalStorageGBRequest = Schema.Struct({min: Schema.optional(Schema.Number), max: Schema.optional(Schema.Number)});
export const NetworkInterfaceCountRequest = Schema.Struct({min: Schema.optional(Schema.Number), max: Schema.optional(Schema.Number)});
export const TaskEphemeralStorage = Schema.Struct({sizeInGiB: Schema.optional(Schema.Number), kmsKeyId: Schema.optional(Schema.String)});
export const MemoryGiBPerVCpuRequest = Schema.Struct({min: Schema.optional(Schema.Number), max: Schema.optional(Schema.Number)});
export const ContainerImages = Schema.Array(ContainerImage);
export const MemoryMiBRequest = Schema.Struct({min: Schema.Number, max: Schema.optional(Schema.Number)});
export const VCpuCountRangeRequest = Schema.Struct({min: Schema.Number, max: Schema.optional(Schema.Number)});
export const ServiceConnectTestTrafficHeaderMatchRules = Schema.Struct({exact: Schema.String});
export const ContainerImage = Schema.Struct({containerName: Schema.optional(Schema.String), imageDigest: Schema.optional(Schema.String), image: Schema.optional(Schema.String)});
export const ServiceDeploymentAlarms = Schema.Struct({status: Schema.optional(Schema.String), alarmNames: Schema.optional(StringList), triggeredAlarmNames: Schema.optional(StringList)});
export const ServiceDeploymentCircuitBreaker = Schema.Struct({status: Schema.optional(Schema.String), failureCount: Schema.optional(Schema.Number), threshold: Schema.optional(Schema.Number)});
export const Rollback = Schema.Struct({reason: Schema.optional(Schema.String), startedAt: Schema.optional(Schema.Date), serviceRevisionArn: Schema.optional(Schema.String)});
export const ServiceRevisionsSummaryList = Schema.Array(ServiceRevisionSummary);
export const ServiceRevisionSummary = Schema.Struct({arn: Schema.optional(Schema.String), requestedTaskCount: Schema.optional(Schema.Number), runningTaskCount: Schema.optional(Schema.Number), pendingTaskCount: Schema.optional(Schema.Number), requestedTestTrafficWeight: Schema.optional(Schema.Number), requestedProductionTrafficWeight: Schema.optional(Schema.Number)});
export const CreateClusterResponse = Schema.Struct({cluster: Schema.optional(Cluster)});
export const DeploymentEphemeralStorage = Schema.Struct({kmsKeyId: Schema.optional(Schema.String)});
export const ClusterContainsCapacityProviderException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ServiceEvent = Schema.Struct({id: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), message: Schema.optional(Schema.String)});
export const TaskSetNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ServiceEvents = Schema.Array(ServiceEvent);
export const ServiceNotActiveException = Schema.Struct({message: Schema.optional(Schema.String)});
export const Attachment = Schema.Struct({id: Schema.optional(Schema.String), type: Schema.optional(Schema.String), status: Schema.optional(Schema.String), details: Schema.optional(AttachmentDetails)});
export const ClusterServiceConnectDefaults = Schema.Struct({namespace: Schema.optional(Schema.String)});
export const PlatformTaskDefinitionIncompatibilityException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RegisterTaskDefinitionResponse = Schema.Struct({taskDefinition: Schema.optional(TaskDefinition), tags: Schema.optional(Tags)});
export const RunTaskResponse = Schema.Struct({tasks: Schema.optional(Tasks), failures: Schema.optional(Failures)});
export const Attachments = Schema.Array(Attachment);
export const MissingVersionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const BlockedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ClusterContainsContainerInstancesException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreateCapacityProviderResponse = Schema.Struct({capacityProvider: Schema.optional(CapacityProvider)});
export const ServiceConnectTestTrafficHeaderRules = Schema.Struct({name: Schema.String, value: Schema.optional(ServiceConnectTestTrafficHeaderMatchRules)});
export const LimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ManagedInstancesProvider = Schema.Struct({infrastructureRoleArn: Schema.optional(Schema.String), instanceLaunchTemplate: Schema.optional(InstanceLaunchTemplate), propagateTags: Schema.optional(Schema.String)});
export const CreateServiceResponse = Schema.Struct({service: Schema.optional(Service)});
export const ClusterContainsTasksException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ClusterContainsServicesException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ResourceNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SubmitTaskStateChangeResponse = Schema.Struct({acknowledgment: Schema.optional(Schema.String)});
export const SubmitContainerStateChangeResponse = Schema.Struct({acknowledgment: Schema.optional(Schema.String)});
export const SubmitAttachmentStateChangesResponse = Schema.Struct({acknowledgment: Schema.optional(Schema.String)});
export const ConflictException = Schema.Struct({resourceIds: Schema.optional(ResourceIds), message: Schema.optional(Schema.String)});
export const UnsupportedFeatureException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RegisterContainerInstanceResponse = Schema.Struct({containerInstance: Schema.optional(ContainerInstance)});
export const ResourceInUseException = Schema.Struct({message: Schema.optional(Schema.String)});
export const AttributeLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ServiceNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const NamespaceNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const AccessDeniedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ServerException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidParameterException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DeleteAttributesResponse = Schema.Struct({attributes: Schema.optional(Attributes)});
export const CreateTaskSetResponse = Schema.Struct({taskSet: Schema.optional(TaskSet)});
export const TaskManagedEBSVolumeTerminationPolicy = Schema.Struct({deleteOnTermination: Schema.Boolean});
export const FSxWindowsFileServerAuthorizationConfig = Schema.Struct({credentialsParameter: Schema.String, domain: Schema.String});
export const EFSAuthorizationConfig = Schema.Struct({accessPointId: Schema.optional(Schema.String), iam: Schema.optional(Schema.String)});
export const StringMap = Schema.Record({key: Schema.String, value: Schema.String});
export const FirelensConfigurationOptionsMap = Schema.Record({key: Schema.String, value: Schema.String});
export const TmpfsList = Schema.Array(Tmpfs);
export const Tmpfs = Schema.Struct({containerPath: Schema.String, size: Schema.Number, mountOptions: Schema.optional(StringList)});
export const DevicesList = Schema.Array(Device);
export const Device = Schema.Struct({hostPath: Schema.String, containerPath: Schema.optional(Schema.String), permissions: Schema.optional(DeviceCgroupPermissions)});
export const Container = Schema.Struct({containerArn: Schema.optional(Schema.String), taskArn: Schema.optional(Schema.String), name: Schema.optional(Schema.String), image: Schema.optional(Schema.String), imageDigest: Schema.optional(Schema.String), runtimeId: Schema.optional(Schema.String), lastStatus: Schema.optional(Schema.String), exitCode: Schema.optional(Schema.Number), reason: Schema.optional(Schema.String), networkBindings: Schema.optional(NetworkBindings), networkInterfaces: Schema.optional(NetworkInterfaces), healthStatus: Schema.optional(Schema.String), managedAgents: Schema.optional(ManagedAgents), cpu: Schema.optional(Schema.String), memory: Schema.optional(Schema.String), memoryReservation: Schema.optional(Schema.String), gpuIds: Schema.optional(GpuIds)});
export const ServiceConnectTestTrafficRules = Schema.Struct({header: ServiceConnectTestTrafficHeaderRules});
export const KernelCapabilities = Schema.Struct({add: Schema.optional(StringList), drop: Schema.optional(StringList)});
export const Containers = Schema.Array(Container);
export const ResolvedConfiguration = Schema.Struct({loadBalancers: Schema.optional(ServiceRevisionLoadBalancers)});
export const GpuIds = Schema.Array(Schema.String);
export const AttachmentDetails = Schema.Array(KeyValuePair);
export const EBSTagSpecifications = Schema.Array(EBSTagSpecification);
export const EBSTagSpecification = Schema.Struct({resourceType: Schema.String, tags: Schema.optional(Tags), propagateTags: Schema.optional(Schema.String)});
export const LogConfigurationOptionsMap = Schema.Record({key: Schema.String, value: Schema.String});
export const TimeoutConfiguration = Schema.Struct({idleTimeoutSeconds: Schema.optional(Schema.Number), perRequestTimeoutSeconds: Schema.optional(Schema.Number)});
export const ExecuteCommandLogConfiguration = Schema.Struct({cloudWatchLogGroupName: Schema.optional(Schema.String), cloudWatchEncryptionEnabled: Schema.optional(Schema.Boolean), s3BucketName: Schema.optional(Schema.String), s3EncryptionEnabled: Schema.optional(Schema.Boolean), s3KeyPrefix: Schema.optional(Schema.String)});
export const ContainerInstanceHealthStatus = Schema.Struct({overallStatus: Schema.optional(Schema.String), details: Schema.optional(InstanceHealthCheckResultList)});
export const ManagedInstancesStorageConfiguration = Schema.Struct({storageSizeGiB: Schema.optional(Schema.Number)});
export const ManagedInstancesNetworkConfiguration = Schema.Struct({subnets: Schema.optional(StringList), securityGroups: Schema.optional(StringList)});
export const ResourceIds = Schema.Array(Schema.String);
export const Deployment = Schema.Struct({id: Schema.optional(Schema.String), status: Schema.optional(Schema.String), taskDefinition: Schema.optional(Schema.String), desiredCount: Schema.optional(Schema.Number), pendingCount: Schema.optional(Schema.Number), runningCount: Schema.optional(Schema.Number), failedTasks: Schema.optional(Schema.Number), createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date), capacityProviderStrategy: Schema.optional(CapacityProviderStrategy), launchType: Schema.optional(Schema.String), platformVersion: Schema.optional(Schema.String), platformFamily: Schema.optional(Schema.String), networkConfiguration: Schema.optional(NetworkConfiguration), rolloutState: Schema.optional(Schema.String), rolloutStateReason: Schema.optional(Schema.String), serviceConnectConfiguration: Schema.optional(ServiceConnectConfiguration), serviceConnectResources: Schema.optional(ServiceConnectServiceResourceList), volumeConfigurations: Schema.optional(ServiceVolumeConfigurations), fargateEphemeralStorage: Schema.optional(DeploymentEphemeralStorage), vpcLatticeConfigurations: Schema.optional(VpcLatticeConfigurations)});
export const ProtectedTasks = Schema.Array(ProtectedTask);
export const Deployments = Schema.Array(Deployment);
export const ProtectedTask = Schema.Struct({taskArn: Schema.optional(Schema.String), protectionEnabled: Schema.optional(Schema.Boolean), expirationDate: Schema.optional(Schema.Date)});
export const Session = Schema.Struct({sessionId: Schema.optional(Schema.String), streamUrl: Schema.optional(Schema.String), tokenValue: Schema.optional(Schema.String)});
export const Failures = Schema.Array(Failure);
export const Failure = Schema.Struct({arn: Schema.optional(Schema.String), reason: Schema.optional(Schema.String), detail: Schema.optional(Schema.String)});
export const TaskDefinitionList = Schema.Array(TaskDefinition);
export const TaskDefinition = Schema.Struct({taskDefinitionArn: Schema.optional(Schema.String), containerDefinitions: Schema.optional(ContainerDefinitions), family: Schema.optional(Schema.String), taskRoleArn: Schema.optional(Schema.String), executionRoleArn: Schema.optional(Schema.String), networkMode: Schema.optional(Schema.String), revision: Schema.optional(Schema.Number), volumes: Schema.optional(VolumeList), status: Schema.optional(Schema.String), requiresAttributes: Schema.optional(RequiresAttributes), placementConstraints: Schema.optional(TaskDefinitionPlacementConstraints), compatibilities: Schema.optional(CompatibilityList), runtimePlatform: Schema.optional(RuntimePlatform), requiresCompatibilities: Schema.optional(CompatibilityList), cpu: Schema.optional(Schema.String), memory: Schema.optional(Schema.String), inferenceAccelerators: Schema.optional(InferenceAccelerators), pidMode: Schema.optional(Schema.String), ipcMode: Schema.optional(Schema.String), proxyConfiguration: Schema.optional(ProxyConfiguration), registeredAt: Schema.optional(Schema.Date), deregisteredAt: Schema.optional(Schema.Date), registeredBy: Schema.optional(Schema.String), ephemeralStorage: Schema.optional(EphemeralStorage), enableFaultInjection: Schema.optional(Schema.Boolean)});
export const Setting = Schema.Struct({name: Schema.optional(Schema.String), value: Schema.optional(Schema.String), principalArn: Schema.optional(Schema.String), type: Schema.optional(Schema.String)});
export const DeviceCgroupPermissions = Schema.Array(Schema.String);
export const AllowedInstanceTypeSet = Schema.Array(Schema.String);
export const AcceleratorNameSet = Schema.Array(Schema.String);
export const AcceleratorManufacturerSet = Schema.Array(Schema.String);
export const AcceleratorTypeSet = Schema.Array(Schema.String);
export const ListServiceDeploymentsResponse = Schema.Struct({serviceDeployments: Schema.optional(ServiceDeploymentsBrief), nextToken: Schema.optional(Schema.String)});
export const LocalStorageTypeSet = Schema.Array(Schema.String);
export const InstanceGenerationSet = Schema.Array(Schema.String);
export const ExcludedInstanceTypeSet = Schema.Array(Schema.String);
export const CpuManufacturerSet = Schema.Array(Schema.String);
export const InstanceLaunchTemplateUpdate = Schema.Struct({ec2InstanceProfileArn: Schema.optional(Schema.String), networkConfiguration: Schema.optional(ManagedInstancesNetworkConfiguration), storageConfiguration: Schema.optional(ManagedInstancesStorageConfiguration), monitoring: Schema.optional(Schema.String), instanceRequirements: Schema.optional(InstanceRequirementsRequest)});
export const InferenceAcceleratorOverrides = Schema.Array(InferenceAcceleratorOverride);
export const InferenceAcceleratorOverride = Schema.Struct({deviceName: Schema.optional(Schema.String), deviceType: Schema.optional(Schema.String)});
export const ContainerOverrides = Schema.Array(ContainerOverride);
export const ServiceConnectTlsConfiguration = Schema.Struct({issuerCertificateAuthority: ServiceConnectTlsCertificateAuthority, kmsKey: Schema.optional(Schema.String), roleArn: Schema.optional(Schema.String)});
export const ContainerOverride = Schema.Struct({name: Schema.optional(Schema.String), command: Schema.optional(StringList), environment: Schema.optional(EnvironmentVariables), environmentFiles: Schema.optional(EnvironmentFiles), cpu: Schema.optional(Schema.Number), memory: Schema.optional(Schema.Number), memoryReservation: Schema.optional(Schema.Number), resourceRequirements: Schema.optional(ResourceRequirements)});
export const HostVolumeProperties = Schema.Struct({sourcePath: Schema.optional(Schema.String)});
export const ResourceRequirements = Schema.Array(ResourceRequirement);
export const ResourceRequirement = Schema.Struct({value: Schema.String, type: Schema.String});
export const SystemControls = Schema.Array(SystemControl);
export const InstanceRequirementsRequest = Schema.Struct({vCpuCount: VCpuCountRangeRequest, memoryMiB: MemoryMiBRequest, cpuManufacturers: Schema.optional(CpuManufacturerSet), memoryGiBPerVCpu: Schema.optional(MemoryGiBPerVCpuRequest), excludedInstanceTypes: Schema.optional(ExcludedInstanceTypeSet), instanceGenerations: Schema.optional(InstanceGenerationSet), spotMaxPricePercentageOverLowestPrice: Schema.optional(Schema.Number), onDemandMaxPricePercentageOverLowestPrice: Schema.optional(Schema.Number), bareMetal: Schema.optional(Schema.String), burstablePerformance: Schema.optional(Schema.String), requireHibernateSupport: Schema.optional(Schema.Boolean), networkInterfaceCount: Schema.optional(NetworkInterfaceCountRequest), localStorage: Schema.optional(Schema.String), localStorageTypes: Schema.optional(LocalStorageTypeSet), totalLocalStorageGB: Schema.optional(TotalLocalStorageGBRequest), baselineEbsBandwidthMbps: Schema.optional(BaselineEbsBandwidthMbpsRequest), acceleratorTypes: Schema.optional(AcceleratorTypeSet), acceleratorCount: Schema.optional(AcceleratorCountRequest), acceleratorManufacturers: Schema.optional(AcceleratorManufacturerSet), acceleratorNames: Schema.optional(AcceleratorNameSet), acceleratorTotalMemoryMiB: Schema.optional(AcceleratorTotalMemoryMiBRequest), networkBandwidthGbps: Schema.optional(NetworkBandwidthGbpsRequest), allowedInstanceTypes: Schema.optional(AllowedInstanceTypeSet), maxSpotPriceAsPercentageOfOptimalOnDemandPrice: Schema.optional(Schema.Number)});
export const SystemControl = Schema.Struct({namespace: Schema.optional(Schema.String), value: Schema.optional(Schema.String)});
export const HealthCheck = Schema.Struct({command: StringList, interval: Schema.optional(Schema.Number), timeout: Schema.optional(Schema.Number), retries: Schema.optional(Schema.Number), startPeriod: Schema.optional(Schema.Number)});
export const UlimitList = Schema.Array(Ulimit);
export const Ulimit = Schema.Struct({name: Schema.String, softLimit: Schema.Number, hardLimit: Schema.Number});
export const DockerLabelsMap = Schema.Record({key: Schema.String, value: Schema.String});
export const ServiceDeployment = Schema.Struct({serviceDeploymentArn: Schema.optional(Schema.String), serviceArn: Schema.optional(Schema.String), clusterArn: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), startedAt: Schema.optional(Schema.Date), finishedAt: Schema.optional(Schema.Date), stoppedAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date), sourceServiceRevisions: Schema.optional(ServiceRevisionsSummaryList), targetServiceRevision: Schema.optional(ServiceRevisionSummary), status: Schema.optional(Schema.String), statusReason: Schema.optional(Schema.String), lifecycleStage: Schema.optional(Schema.String), deploymentConfiguration: Schema.optional(DeploymentConfiguration), rollback: Schema.optional(Rollback), deploymentCircuitBreaker: Schema.optional(ServiceDeploymentCircuitBreaker), alarms: Schema.optional(ServiceDeploymentAlarms)});
export const HostEntryList = Schema.Array(HostEntry);
export const ServiceDeployments = Schema.Array(ServiceDeployment);
export const HostEntry = Schema.Struct({hostname: Schema.String, ipAddress: Schema.String});
export const ContainerDependencies = Schema.Array(ContainerDependency);
export const ContainerDependency = Schema.Struct({containerName: Schema.String, condition: Schema.String});
export const SecretList = Schema.Array(Secret);
export const TaskSet = Schema.Struct({id: Schema.optional(Schema.String), taskSetArn: Schema.optional(Schema.String), serviceArn: Schema.optional(Schema.String), clusterArn: Schema.optional(Schema.String), startedBy: Schema.optional(Schema.String), externalId: Schema.optional(Schema.String), status: Schema.optional(Schema.String), taskDefinition: Schema.optional(Schema.String), computedDesiredCount: Schema.optional(Schema.Number), pendingCount: Schema.optional(Schema.Number), runningCount: Schema.optional(Schema.Number), createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date), launchType: Schema.optional(Schema.String), capacityProviderStrategy: Schema.optional(CapacityProviderStrategy), platformVersion: Schema.optional(Schema.String), platformFamily: Schema.optional(Schema.String), networkConfiguration: Schema.optional(NetworkConfiguration), loadBalancers: Schema.optional(LoadBalancers), serviceRegistries: Schema.optional(ServiceRegistries), scale: Schema.optional(Scale), stabilityStatus: Schema.optional(Schema.String), stabilityStatusAt: Schema.optional(Schema.Date), tags: Schema.optional(Tags), fargateEphemeralStorage: Schema.optional(DeploymentEphemeralStorage)});
export const Secret = Schema.Struct({name: Schema.String, valueFrom: Schema.String});
export const VolumeFromList = Schema.Array(VolumeFrom);
export const VolumeFrom = Schema.Struct({sourceContainer: Schema.optional(Schema.String), readOnly: Schema.optional(Schema.Boolean)});
export const MountPointList = Schema.Array(MountPoint);
export const TaskManagedEBSVolumeConfiguration = Schema.Struct({encrypted: Schema.optional(Schema.Boolean), kmsKeyId: Schema.optional(Schema.String), volumeType: Schema.optional(Schema.String), sizeInGiB: Schema.optional(Schema.Number), snapshotId: Schema.optional(Schema.String), volumeInitializationRate: Schema.optional(Schema.Number), iops: Schema.optional(Schema.Number), throughput: Schema.optional(Schema.Number), tagSpecifications: Schema.optional(EBSTagSpecifications), roleArn: Schema.String, terminationPolicy: Schema.optional(TaskManagedEBSVolumeTerminationPolicy), filesystemType: Schema.optional(Schema.String)});
export const Cluster = Schema.Struct({clusterArn: Schema.optional(Schema.String), clusterName: Schema.optional(Schema.String), configuration: Schema.optional(ClusterConfiguration), status: Schema.optional(Schema.String), registeredContainerInstancesCount: Schema.optional(Schema.Number), runningTasksCount: Schema.optional(Schema.Number), pendingTasksCount: Schema.optional(Schema.Number), activeServicesCount: Schema.optional(Schema.Number), statistics: Schema.optional(Statistics), tags: Schema.optional(Tags), settings: Schema.optional(ClusterSettings), capacityProviders: Schema.optional(StringList), defaultCapacityProviderStrategy: Schema.optional(CapacityProviderStrategy), attachments: Schema.optional(Attachments), attachmentsStatus: Schema.optional(Schema.String), serviceConnectDefaults: Schema.optional(ClusterServiceConnectDefaults)});
export const CapacityProvider = Schema.Struct({capacityProviderArn: Schema.optional(Schema.String), name: Schema.optional(Schema.String), cluster: Schema.optional(Schema.String), status: Schema.optional(Schema.String), autoScalingGroupProvider: Schema.optional(AutoScalingGroupProvider), managedInstancesProvider: Schema.optional(ManagedInstancesProvider), updateStatus: Schema.optional(Schema.String), updateStatusReason: Schema.optional(Schema.String), tags: Schema.optional(Tags), type: Schema.optional(Schema.String)});
export const MountPoint = Schema.Struct({sourceVolume: Schema.optional(Schema.String), containerPath: Schema.optional(Schema.String), readOnly: Schema.optional(Schema.Boolean)});
export const EnvironmentFiles = Schema.Array(EnvironmentFile);
export const EnvironmentFile = Schema.Struct({value: Schema.String, type: Schema.String});
export const EnvironmentVariables = Schema.Array(KeyValuePair);
export const KeyValuePair = Schema.Struct({name: Schema.optional(Schema.String), value: Schema.optional(Schema.String)});
export const FSxWindowsFileServerVolumeConfiguration = Schema.Struct({fileSystemId: Schema.String, rootDirectory: Schema.String, authorizationConfig: FSxWindowsFileServerAuthorizationConfig});
export const EFSVolumeConfiguration = Schema.Struct({fileSystemId: Schema.String, rootDirectory: Schema.optional(Schema.String), transitEncryption: Schema.optional(Schema.String), transitEncryptionPort: Schema.optional(Schema.Number), authorizationConfig: Schema.optional(EFSAuthorizationConfig)});
export const DockerVolumeConfiguration = Schema.Struct({scope: Schema.optional(Schema.String), autoprovision: Schema.optional(Schema.Boolean), driver: Schema.optional(Schema.String), driverOpts: Schema.optional(StringMap), labels: Schema.optional(StringMap)});
export const ContainerRestartPolicy = Schema.Struct({enabled: Schema.Boolean, ignoredExitCodes: Schema.optional(IntegerList), restartAttemptPeriod: Schema.optional(Schema.Number)});
export const FirelensConfiguration = Schema.Struct({type: Schema.String, options: Schema.optional(FirelensConfigurationOptionsMap)});
export const PortMappingList = Schema.Array(PortMapping);
export const PortMapping = Schema.Struct({containerPort: Schema.optional(Schema.Number), hostPort: Schema.optional(Schema.Number), protocol: Schema.optional(Schema.String), name: Schema.optional(Schema.String), appProtocol: Schema.optional(Schema.String), containerPortRange: Schema.optional(Schema.String)});
export const Task = Schema.Struct({attachments: Schema.optional(Attachments), attributes: Schema.optional(Attributes), availabilityZone: Schema.optional(Schema.String), capacityProviderName: Schema.optional(Schema.String), clusterArn: Schema.optional(Schema.String), connectivity: Schema.optional(Schema.String), connectivityAt: Schema.optional(Schema.Date), containerInstanceArn: Schema.optional(Schema.String), containers: Schema.optional(Containers), cpu: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), desiredStatus: Schema.optional(Schema.String), enableExecuteCommand: Schema.optional(Schema.Boolean), executionStoppedAt: Schema.optional(Schema.Date), group: Schema.optional(Schema.String), healthStatus: Schema.optional(Schema.String), inferenceAccelerators: Schema.optional(InferenceAccelerators), lastStatus: Schema.optional(Schema.String), launchType: Schema.optional(Schema.String), memory: Schema.optional(Schema.String), overrides: Schema.optional(TaskOverride), platformVersion: Schema.optional(Schema.String), platformFamily: Schema.optional(Schema.String), pullStartedAt: Schema.optional(Schema.Date), pullStoppedAt: Schema.optional(Schema.Date), startedAt: Schema.optional(Schema.Date), startedBy: Schema.optional(Schema.String), stopCode: Schema.optional(Schema.String), stoppedAt: Schema.optional(Schema.Date), stoppedReason: Schema.optional(Schema.String), stoppingAt: Schema.optional(Schema.Date), tags: Schema.optional(Tags), taskArn: Schema.optional(Schema.String), taskDefinitionArn: Schema.optional(Schema.String), version: Schema.optional(Schema.Number), ephemeralStorage: Schema.optional(EphemeralStorage), fargateEphemeralStorage: Schema.optional(TaskEphemeralStorage)});
export const ServiceConnectClientAlias = Schema.Struct({port: Schema.Number, dnsName: Schema.optional(Schema.String), testTrafficRules: Schema.optional(ServiceConnectTestTrafficRules)});
export const RepositoryCredentials = Schema.Struct({credentialsParameter: Schema.String});
export const ServiceConnectClientAliasList = Schema.Array(ServiceConnectClientAlias);
export const Tasks = Schema.Array(Task);
export const ServiceRevision = Schema.Struct({serviceRevisionArn: Schema.optional(Schema.String), serviceArn: Schema.optional(Schema.String), clusterArn: Schema.optional(Schema.String), taskDefinition: Schema.optional(Schema.String), capacityProviderStrategy: Schema.optional(CapacityProviderStrategy), launchType: Schema.optional(Schema.String), platformVersion: Schema.optional(Schema.String), platformFamily: Schema.optional(Schema.String), loadBalancers: Schema.optional(LoadBalancers), serviceRegistries: Schema.optional(ServiceRegistries), networkConfiguration: Schema.optional(NetworkConfiguration), containerImages: Schema.optional(ContainerImages), guardDutyEnabled: Schema.optional(Schema.Boolean), serviceConnectConfiguration: Schema.optional(ServiceConnectConfiguration), volumeConfigurations: Schema.optional(ServiceVolumeConfigurations), fargateEphemeralStorage: Schema.optional(DeploymentEphemeralStorage), createdAt: Schema.optional(Schema.Date), vpcLatticeConfigurations: Schema.optional(VpcLatticeConfigurations), resolvedConfiguration: Schema.optional(ResolvedConfiguration)});
export const RequiresAttributes = Schema.Array(Attribute);
export const ServiceRevisions = Schema.Array(ServiceRevision);
export const Statistics = Schema.Array(KeyValuePair);
export const ServiceConnectAccessLogConfiguration = Schema.Struct({format: Schema.String, includeQueryParameters: Schema.optional(Schema.String)});
export const AwsVpcConfiguration = Schema.Struct({subnets: StringList, securityGroups: Schema.optional(StringList), assignPublicIp: Schema.optional(Schema.String)});
export const CanaryConfiguration = Schema.Struct({canaryPercent: Schema.optional(Schema.Number), canaryBakeTimeInMinutes: Schema.optional(Schema.Number)});
export const LinearConfiguration = Schema.Struct({stepPercent: Schema.optional(Schema.Number), stepBakeTimeInMinutes: Schema.optional(Schema.Number)});
export const ContainerInstance = Schema.Struct({containerInstanceArn: Schema.optional(Schema.String), ec2InstanceId: Schema.optional(Schema.String), capacityProviderName: Schema.optional(Schema.String), version: Schema.optional(Schema.Number), versionInfo: Schema.optional(VersionInfo), remainingResources: Schema.optional(Resources), registeredResources: Schema.optional(Resources), status: Schema.optional(Schema.String), statusReason: Schema.optional(Schema.String), agentConnected: Schema.optional(Schema.Boolean), runningTasksCount: Schema.optional(Schema.Number), pendingTasksCount: Schema.optional(Schema.Number), agentUpdateStatus: Schema.optional(Schema.String), attributes: Schema.optional(Attributes), registeredAt: Schema.optional(Schema.Date), attachments: Schema.optional(Attachments), tags: Schema.optional(Tags), healthStatus: Schema.optional(ContainerInstanceHealthStatus)});
export const DeploymentLifecycleHookList = Schema.Array(DeploymentLifecycleHook);
export const DeploymentLifecycleHook = Schema.Struct({hookTargetArn: Schema.optional(Schema.String), roleArn: Schema.optional(Schema.String), lifecycleStages: Schema.optional(DeploymentLifecycleHookStageList), hookDetails: Schema.optional(Schema.JsonValue)});
export const DeploymentAlarms = Schema.Struct({alarmNames: StringList, rollback: Schema.Boolean, enable: Schema.Boolean});
export const DeploymentCircuitBreaker = Schema.Struct({enable: Schema.Boolean, rollback: Schema.Boolean});
export const AdvancedConfiguration = Schema.Struct({alternateTargetGroupArn: Schema.optional(Schema.String), productionListenerRule: Schema.optional(Schema.String), testListenerRule: Schema.optional(Schema.String), roleArn: Schema.optional(Schema.String)});
export const Service = Schema.Struct({serviceArn: Schema.optional(Schema.String), serviceName: Schema.optional(Schema.String), clusterArn: Schema.optional(Schema.String), loadBalancers: Schema.optional(LoadBalancers), serviceRegistries: Schema.optional(ServiceRegistries), status: Schema.optional(Schema.String), desiredCount: Schema.optional(Schema.Number), runningCount: Schema.optional(Schema.Number), pendingCount: Schema.optional(Schema.Number), launchType: Schema.optional(Schema.String), capacityProviderStrategy: Schema.optional(CapacityProviderStrategy), platformVersion: Schema.optional(Schema.String), platformFamily: Schema.optional(Schema.String), taskDefinition: Schema.optional(Schema.String), deploymentConfiguration: Schema.optional(DeploymentConfiguration), taskSets: Schema.optional(TaskSets), deployments: Schema.optional(Deployments), roleArn: Schema.optional(Schema.String), events: Schema.optional(ServiceEvents), createdAt: Schema.optional(Schema.Date), placementConstraints: Schema.optional(PlacementConstraints), placementStrategy: Schema.optional(PlacementStrategies), networkConfiguration: Schema.optional(NetworkConfiguration), healthCheckGracePeriodSeconds: Schema.optional(Schema.Number), schedulingStrategy: Schema.optional(Schema.String), deploymentController: Schema.optional(DeploymentController), tags: Schema.optional(Tags), createdBy: Schema.optional(Schema.String), enableECSManagedTags: Schema.optional(Schema.Boolean), propagateTags: Schema.optional(Schema.String), enableExecuteCommand: Schema.optional(Schema.Boolean), availabilityZoneRebalancing: Schema.optional(Schema.String)});
export const LinuxParameters = Schema.Struct({capabilities: Schema.optional(KernelCapabilities), devices: Schema.optional(DevicesList), initProcessEnabled: Schema.optional(Schema.Boolean), sharedMemorySize: Schema.optional(Schema.Number), tmpfs: Schema.optional(TmpfsList), maxSwap: Schema.optional(Schema.Number), swappiness: Schema.optional(Schema.Number)});
export const ManagedStorageConfiguration = Schema.Struct({kmsKeyId: Schema.optional(Schema.String), fargateEphemeralStorageKmsKeyId: Schema.optional(Schema.String)});
export const ManagedScaling = Schema.Struct({status: Schema.optional(Schema.String), targetCapacity: Schema.optional(Schema.Number), minimumScalingStepSize: Schema.optional(Schema.Number), maximumScalingStepSize: Schema.optional(Schema.Number), instanceWarmupPeriod: Schema.optional(Schema.Number)});
export const UpdateTaskSetResponse = Schema.Struct({taskSet: Schema.optional(TaskSet)});
export const UpdateTaskProtectionResponse = Schema.Struct({protectedTasks: Schema.optional(ProtectedTasks), failures: Schema.optional(Failures)});
export const UpdateServicePrimaryTaskSetResponse = Schema.Struct({taskSet: Schema.optional(TaskSet)});
export const UpdateServiceResponse = Schema.Struct({service: Schema.optional(Service)});
export const UpdateContainerInstancesStateResponse = Schema.Struct({containerInstances: Schema.optional(ContainerInstances), failures: Schema.optional(Failures)});
export const UpdateContainerAgentResponse = Schema.Struct({containerInstance: Schema.optional(ContainerInstance)});
export const UpdateClusterSettingsResponse = Schema.Struct({cluster: Schema.optional(Cluster)});
export const UpdateClusterResponse = Schema.Struct({cluster: Schema.optional(Cluster)});
export const ClusterNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ClientException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ServiceManagedEBSVolumeConfiguration = Schema.Struct({encrypted: Schema.optional(Schema.Boolean), kmsKeyId: Schema.optional(Schema.String), volumeType: Schema.optional(Schema.String), sizeInGiB: Schema.optional(Schema.Number), snapshotId: Schema.optional(Schema.String), volumeInitializationRate: Schema.optional(Schema.Number), iops: Schema.optional(Schema.Number), throughput: Schema.optional(Schema.Number), tagSpecifications: Schema.optional(EBSTagSpecifications), roleArn: Schema.String, filesystemType: Schema.optional(Schema.String)});
export const StopTaskResponse = Schema.Struct({task: Schema.optional(Task)});
export const LogConfiguration = Schema.Struct({logDriver: Schema.String, options: Schema.optional(LogConfigurationOptionsMap), secretOptions: Schema.optional(SecretList)});
export const StopServiceDeploymentResponse = Schema.Struct({serviceDeploymentArn: Schema.optional(Schema.String)});
export const StartTaskResponse = Schema.Struct({tasks: Schema.optional(Tasks), failures: Schema.optional(Failures)});
export const PutClusterCapacityProvidersResponse = Schema.Struct({cluster: Schema.optional(Cluster)});
export const PutAttributesResponse = Schema.Struct({attributes: Schema.optional(Attributes)});
export const PutAccountSettingDefaultResponse = Schema.Struct({setting: Schema.optional(Setting)});
export const PutAccountSettingResponse = Schema.Struct({setting: Schema.optional(Setting)});
export const ListTasksResponse = Schema.Struct({taskArns: Schema.optional(StringList), nextToken: Schema.optional(Schema.String)});
export const ListTaskDefinitionsResponse = Schema.Struct({taskDefinitionArns: Schema.optional(StringList), nextToken: Schema.optional(Schema.String)});
export const ListTaskDefinitionFamiliesResponse = Schema.Struct({families: Schema.optional(StringList), nextToken: Schema.optional(Schema.String)});
export const ListTagsForResourceResponse = Schema.Struct({tags: Schema.optional(Tags)});
export const ListServicesByNamespaceResponse = Schema.Struct({serviceArns: Schema.optional(StringList), nextToken: Schema.optional(Schema.String)});
export const ExecuteCommandConfiguration = Schema.Struct({kmsKeyId: Schema.optional(Schema.String), logging: Schema.optional(Schema.String), logConfiguration: Schema.optional(ExecuteCommandLogConfiguration)});
export const ListServicesResponse = Schema.Struct({serviceArns: Schema.optional(StringList), nextToken: Schema.optional(Schema.String)});
export const ListContainerInstancesResponse = Schema.Struct({containerInstanceArns: Schema.optional(StringList), nextToken: Schema.optional(Schema.String)});
export const ListClustersResponse = Schema.Struct({clusterArns: Schema.optional(StringList), nextToken: Schema.optional(Schema.String)});
export const ListAttributesResponse = Schema.Struct({attributes: Schema.optional(Attributes), nextToken: Schema.optional(Schema.String)});
export const ListAccountSettingsResponse = Schema.Struct({settings: Schema.optional(Settings), nextToken: Schema.optional(Schema.String)});
export const DiscoverPollEndpointResponse = Schema.Struct({endpoint: Schema.optional(Schema.String), telemetryEndpoint: Schema.optional(Schema.String), serviceConnectEndpoint: Schema.optional(Schema.String)});
export const DescribeTaskSetsResponse = Schema.Struct({taskSets: Schema.optional(TaskSets), failures: Schema.optional(Failures)});
export const DescribeTaskDefinitionResponse = Schema.Struct({taskDefinition: Schema.optional(TaskDefinition), tags: Schema.optional(Tags)});
export const DescribeServicesResponse = Schema.Struct({services: Schema.optional(Services), failures: Schema.optional(Failures)});
export const DescribeContainerInstancesResponse = Schema.Struct({containerInstances: Schema.optional(ContainerInstances), failures: Schema.optional(Failures)});
export const DescribeClustersResponse = Schema.Struct({clusters: Schema.optional(Clusters), failures: Schema.optional(Failures)});
export const DescribeCapacityProvidersResponse = Schema.Struct({capacityProviders: Schema.optional(CapacityProviders), failures: Schema.optional(Failures), nextToken: Schema.optional(Schema.String)});
export const DeregisterTaskDefinitionResponse = Schema.Struct({taskDefinition: Schema.optional(TaskDefinition)});
export const IntegerList = Schema.Array(Schema.Number);
export const DeploymentLifecycleHookStageList = Schema.Array(Schema.String);
export const AutoScalingGroupProviderUpdate = Schema.Struct({managedScaling: Schema.optional(ManagedScaling), managedTerminationProtection: Schema.optional(Schema.String), managedDraining: Schema.optional(Schema.String)});
export const ManagedAgentStateChanges = Schema.Array(ManagedAgentStateChange);
export const GetTaskProtectionResponse = Schema.Struct({protectedTasks: Schema.optional(ProtectedTasks), failures: Schema.optional(Failures)});
export const ExecuteCommandResponse = Schema.Struct({clusterArn: Schema.optional(Schema.String), containerArn: Schema.optional(Schema.String), containerName: Schema.optional(Schema.String), interactive: Schema.optional(Schema.Boolean), session: Schema.optional(Session), taskArn: Schema.optional(Schema.String)});
export const ManagedAgentStateChange = Schema.Struct({containerName: Schema.String, managedAgentName: Schema.String, status: Schema.String, reason: Schema.optional(Schema.String)});
export const ContainerStateChanges = Schema.Array(ContainerStateChange);
export const ContainerStateChange = Schema.Struct({containerName: Schema.optional(Schema.String), imageDigest: Schema.optional(Schema.String), runtimeId: Schema.optional(Schema.String), exitCode: Schema.optional(Schema.Number), networkBindings: Schema.optional(NetworkBindings), reason: Schema.optional(Schema.String), status: Schema.optional(Schema.String)});
export const NetworkBindings = Schema.Array(NetworkBinding);
export const NetworkBinding = Schema.Struct({bindIP: Schema.optional(Schema.String), containerPort: Schema.optional(Schema.Number), hostPort: Schema.optional(Schema.Number), protocol: Schema.optional(Schema.String), containerPortRange: Schema.optional(Schema.String), hostPortRange: Schema.optional(Schema.String)});
export const AttachmentStateChanges = Schema.Array(AttachmentStateChange);
export const AttachmentStateChange = Schema.Struct({attachmentArn: Schema.String, status: Schema.String});
export const RuntimePlatform = Schema.Struct({cpuArchitecture: Schema.optional(Schema.String), operatingSystemFamily: Schema.optional(Schema.String)});
export const EphemeralStorage = Schema.Struct({sizeInGiB: Schema.Number});
export const InstanceLaunchTemplate = Schema.Struct({ec2InstanceProfileArn: Schema.String, networkConfiguration: ManagedInstancesNetworkConfiguration, storageConfiguration: Schema.optional(ManagedInstancesStorageConfiguration), monitoring: Schema.optional(Schema.String), instanceRequirements: Schema.optional(InstanceRequirementsRequest)});
export const DeleteTaskDefinitionsResponse = Schema.Struct({taskDefinitions: Schema.optional(TaskDefinitionList), failures: Schema.optional(Failures)});
export const ServiceConnectService = Schema.Struct({portName: Schema.String, discoveryName: Schema.optional(Schema.String), clientAliases: Schema.optional(ServiceConnectClientAliasList), ingressPortOverride: Schema.optional(Schema.Number), timeout: Schema.optional(TimeoutConfiguration), tls: Schema.optional(ServiceConnectTlsConfiguration)});
export const InferenceAccelerators = Schema.Array(InferenceAccelerator);
export const ServiceConnectServiceList = Schema.Array(ServiceConnectService);
export const InferenceAccelerator = Schema.Struct({deviceName: Schema.String, deviceType: Schema.String});
export const DeleteAccountSettingResponse = Schema.Struct({setting: Schema.optional(Setting)});
export const UpdateManagedInstancesProviderConfiguration = Schema.Struct({infrastructureRoleArn: Schema.String, instanceLaunchTemplate: InstanceLaunchTemplateUpdate, propagateTags: Schema.optional(Schema.String)});
export const ProxyConfiguration = Schema.Struct({type: Schema.optional(Schema.String), containerName: Schema.String, properties: Schema.optional(ProxyConfigurationProperties)});
export const TaskDefinitionPlacementConstraints = Schema.Array(TaskDefinitionPlacementConstraint);
export const TaskDefinitionPlacementConstraint = Schema.Struct({type: Schema.optional(Schema.String), expression: Schema.optional(Schema.String)});
export const PlatformDevices = Schema.Array(PlatformDevice);
export const PlatformDevice = Schema.Struct({id: Schema.String, type: Schema.String});
export const VersionInfo = Schema.Struct({agentVersion: Schema.optional(Schema.String), agentHash: Schema.optional(Schema.String), dockerVersion: Schema.optional(Schema.String)});
export const Resources = Schema.Array(Resource);
export const Resource = Schema.Struct({name: Schema.optional(Schema.String), type: Schema.optional(Schema.String), doubleValue: Schema.optional(Schema.Number), longValue: Schema.optional(Schema.Number), integerValue: Schema.optional(Schema.Number), stringSetValue: Schema.optional(StringList)});
export const CreatedAt = Schema.Struct({before: Schema.optional(Schema.Date), after: Schema.optional(Schema.Date)});
export const Settings = Schema.Array(Setting);
export const TaskSets = Schema.Array(TaskSet);
export const Services = Schema.Array(Service);
export const TaskOverride = Schema.Struct({containerOverrides: Schema.optional(ContainerOverrides), cpu: Schema.optional(Schema.String), inferenceAcceleratorOverrides: Schema.optional(InferenceAcceleratorOverrides), executionRoleArn: Schema.optional(Schema.String), memory: Schema.optional(Schema.String), taskRoleArn: Schema.optional(Schema.String), ephemeralStorage: Schema.optional(EphemeralStorage)});
export const ContainerInstances = Schema.Array(ContainerInstance);
export const Clusters = Schema.Array(Cluster);
export const CapacityProviders = Schema.Array(CapacityProvider);
export const Attributes = Schema.Array(Attribute);
export const Attribute = Schema.Struct({name: Schema.String, value: Schema.optional(Schema.String), targetType: Schema.optional(Schema.String), targetId: Schema.optional(Schema.String)});
export const Scale = Schema.Struct({value: Schema.optional(Schema.Number), unit: Schema.optional(Schema.String)});
export const VpcLatticeConfigurations = Schema.Array(VpcLatticeConfiguration);
export const VpcLatticeConfiguration = Schema.Struct({roleArn: Schema.String, targetGroupArn: Schema.String, portName: Schema.String});
export const DeploymentController = Schema.Struct({type: Schema.String});
export const PlacementStrategies = Schema.Array(PlacementStrategy);
export const PlacementStrategy = Schema.Struct({type: Schema.optional(Schema.String), field: Schema.optional(Schema.String)});
export const DescribeServiceDeploymentsResponse = Schema.Struct({serviceDeployments: Schema.optional(ServiceDeployments), failures: Schema.optional(Failures)});
export const PlacementConstraints = Schema.Array(PlacementConstraint);
export const PlacementConstraint = Schema.Struct({type: Schema.optional(Schema.String), expression: Schema.optional(Schema.String)});
export const ServiceRegistries = Schema.Array(ServiceRegistry);
export const ServiceRegistry = Schema.Struct({registryArn: Schema.optional(Schema.String), port: Schema.optional(Schema.Number), containerName: Schema.optional(Schema.String), containerPort: Schema.optional(Schema.Number)});
export const DeleteTaskSetResponse = Schema.Struct({taskSet: Schema.optional(TaskSet)});
export const ClusterServiceConnectDefaultsRequest = Schema.Struct({namespace: Schema.String});
export const DeleteCapacityProviderResponse = Schema.Struct({capacityProvider: Schema.optional(CapacityProvider)});
export const DeleteClusterResponse = Schema.Struct({cluster: Schema.optional(Cluster)});
export const CapacityProviderStrategy = Schema.Array(CapacityProviderStrategyItem);
export const CapacityProviderStrategyItem = Schema.Struct({capacityProvider: Schema.String, weight: Schema.optional(Schema.Number), base: Schema.optional(Schema.Number)});
export const ClusterSettings = Schema.Array(ClusterSetting);
export const ClusterSetting = Schema.Struct({name: Schema.optional(Schema.String), value: Schema.optional(Schema.String)});
export const Tags = Schema.Array(Tag);
export const Tag = Schema.Struct({key: Schema.optional(Schema.String), value: Schema.optional(Schema.String)});
export const DescribeTasksResponse = Schema.Struct({tasks: Schema.optional(Tasks), failures: Schema.optional(Failures)});
export const ProxyConfigurationProperties = Schema.Array(KeyValuePair);
export const DescribeServiceRevisionsResponse = Schema.Struct({serviceRevisions: Schema.optional(ServiceRevisions), failures: Schema.optional(Failures)});
export const UpdateTaskSetRequest = Schema.Struct({cluster: Schema.String, service: Schema.String, taskSet: Schema.String, scale: Scale});
export const TaskVolumeConfiguration = Schema.Struct({name: Schema.String, managedEBSVolume: Schema.optional(TaskManagedEBSVolumeConfiguration)});
export const UpdateTaskProtectionRequest = Schema.Struct({cluster: Schema.String, tasks: StringList, protectionEnabled: Schema.Boolean, expiresInMinutes: Schema.optional(Schema.Number)});
export const TaskVolumeConfigurations = Schema.Array(TaskVolumeConfiguration);
export const DeregisterContainerInstanceResponse = Schema.Struct({containerInstance: Schema.optional(ContainerInstance)});
export const UpdateServicePrimaryTaskSetRequest = Schema.Struct({cluster: Schema.String, service: Schema.String, primaryTaskSet: Schema.String});
export const DeleteServiceResponse = Schema.Struct({service: Schema.optional(Service)});
export const UpdateServiceRequest = Schema.Struct({cluster: Schema.optional(Schema.String), service: Schema.String, desiredCount: Schema.optional(Schema.Number), taskDefinition: Schema.optional(Schema.String), capacityProviderStrategy: Schema.optional(CapacityProviderStrategy), deploymentConfiguration: Schema.optional(DeploymentConfiguration), availabilityZoneRebalancing: Schema.optional(Schema.String), networkConfiguration: Schema.optional(NetworkConfiguration), placementConstraints: Schema.optional(PlacementConstraints), placementStrategy: Schema.optional(PlacementStrategies), platformVersion: Schema.optional(Schema.String), forceNewDeployment: Schema.optional(Schema.Boolean), healthCheckGracePeriodSeconds: Schema.optional(Schema.Number), deploymentController: Schema.optional(DeploymentController), enableExecuteCommand: Schema.optional(Schema.Boolean), enableECSManagedTags: Schema.optional(Schema.Boolean), loadBalancers: Schema.optional(LoadBalancers), propagateTags: Schema.optional(Schema.String), serviceRegistries: Schema.optional(ServiceRegistries), serviceConnectConfiguration: Schema.optional(ServiceConnectConfiguration), volumeConfigurations: Schema.optional(ServiceVolumeConfigurations), vpcLatticeConfigurations: Schema.optional(VpcLatticeConfigurations)});
export const UpdateContainerInstancesStateRequest = Schema.Struct({cluster: Schema.optional(Schema.String), containerInstances: StringList, status: Schema.String});
export const UpdateContainerAgentRequest = Schema.Struct({cluster: Schema.optional(Schema.String), containerInstance: Schema.String});
export const UpdateClusterSettingsRequest = Schema.Struct({cluster: Schema.String, settings: ClusterSettings});
export const UpdateClusterRequest = Schema.Struct({cluster: Schema.String, settings: Schema.optional(ClusterSettings), configuration: Schema.optional(ClusterConfiguration), serviceConnectDefaults: Schema.optional(ClusterServiceConnectDefaultsRequest)});
export const UntagResourceResponse = Schema.Struct({});
export const UntagResourceRequest = Schema.Struct({resourceArn: Schema.String, tagKeys: TagKeys});
export const Volume = Schema.Struct({name: Schema.optional(Schema.String), host: Schema.optional(HostVolumeProperties), dockerVolumeConfiguration: Schema.optional(DockerVolumeConfiguration), efsVolumeConfiguration: Schema.optional(EFSVolumeConfiguration), fsxWindowsFileServerVolumeConfiguration: Schema.optional(FSxWindowsFileServerVolumeConfiguration), configuredAtLaunch: Schema.optional(Schema.Boolean)});
export const ContainerDefinition = Schema.Struct({name: Schema.optional(Schema.String), image: Schema.optional(Schema.String), repositoryCredentials: Schema.optional(RepositoryCredentials), cpu: Schema.optional(Schema.Number), memory: Schema.optional(Schema.Number), memoryReservation: Schema.optional(Schema.Number), links: Schema.optional(StringList), portMappings: Schema.optional(PortMappingList), essential: Schema.optional(Schema.Boolean), restartPolicy: Schema.optional(ContainerRestartPolicy), entryPoint: Schema.optional(StringList), command: Schema.optional(StringList), environment: Schema.optional(EnvironmentVariables), environmentFiles: Schema.optional(EnvironmentFiles), mountPoints: Schema.optional(MountPointList), volumesFrom: Schema.optional(VolumeFromList), linuxParameters: Schema.optional(LinuxParameters), secrets: Schema.optional(SecretList), dependsOn: Schema.optional(ContainerDependencies), startTimeout: Schema.optional(Schema.Number), stopTimeout: Schema.optional(Schema.Number), versionConsistency: Schema.optional(Schema.String), hostname: Schema.optional(Schema.String), user: Schema.optional(Schema.String), workingDirectory: Schema.optional(Schema.String), disableNetworking: Schema.optional(Schema.Boolean), privileged: Schema.optional(Schema.Boolean), readonlyRootFilesystem: Schema.optional(Schema.Boolean), dnsServers: Schema.optional(StringList), dnsSearchDomains: Schema.optional(StringList), extraHosts: Schema.optional(HostEntryList), dockerSecurityOptions: Schema.optional(StringList), interactive: Schema.optional(Schema.Boolean), pseudoTerminal: Schema.optional(Schema.Boolean), dockerLabels: Schema.optional(DockerLabelsMap), ulimits: Schema.optional(UlimitList), logConfiguration: Schema.optional(LogConfiguration), healthCheck: Schema.optional(HealthCheck), systemControls: Schema.optional(SystemControls), resourceRequirements: Schema.optional(ResourceRequirements), firelensConfiguration: Schema.optional(FirelensConfiguration), credentialSpecs: Schema.optional(StringList)});
export const VolumeList = Schema.Array(Volume);
export const TagResourceResponse = Schema.Struct({});
export const ContainerDefinitions = Schema.Array(ContainerDefinition);
export const TagResourceRequest = Schema.Struct({resourceArn: Schema.String, tags: Tags});
export const NetworkConfiguration = Schema.Struct({awsvpcConfiguration: Schema.optional(AwsVpcConfiguration)});
export const TagKeys = Schema.Array(Schema.String);
export const CompatibilityList = Schema.Array(Schema.String);
export const StopTaskRequest = Schema.Struct({cluster: Schema.optional(Schema.String), task: Schema.String, reason: Schema.optional(Schema.String)});
export const StopServiceDeploymentRequest = Schema.Struct({serviceDeploymentArn: Schema.String, stopType: Schema.optional(Schema.String)});
export const DeploymentConfiguration = Schema.Struct({deploymentCircuitBreaker: Schema.optional(DeploymentCircuitBreaker), maximumPercent: Schema.optional(Schema.Number), minimumHealthyPercent: Schema.optional(Schema.Number), alarms: Schema.optional(DeploymentAlarms), strategy: Schema.optional(Schema.String), bakeTimeInMinutes: Schema.optional(Schema.Number), lifecycleHooks: Schema.optional(DeploymentLifecycleHookList), linearConfiguration: Schema.optional(LinearConfiguration), canaryConfiguration: Schema.optional(CanaryConfiguration)});
export const StartTaskRequest = Schema.Struct({cluster: Schema.optional(Schema.String), containerInstances: StringList, enableECSManagedTags: Schema.optional(Schema.Boolean), enableExecuteCommand: Schema.optional(Schema.Boolean), group: Schema.optional(Schema.String), networkConfiguration: Schema.optional(NetworkConfiguration), overrides: Schema.optional(TaskOverride), propagateTags: Schema.optional(Schema.String), referenceId: Schema.optional(Schema.String), startedBy: Schema.optional(Schema.String), tags: Schema.optional(Tags), taskDefinition: Schema.String, volumeConfigurations: Schema.optional(TaskVolumeConfigurations)});
export const LoadBalancer = Schema.Struct({targetGroupArn: Schema.optional(Schema.String), loadBalancerName: Schema.optional(Schema.String), containerName: Schema.optional(Schema.String), containerPort: Schema.optional(Schema.Number), advancedConfiguration: Schema.optional(AdvancedConfiguration)});
export const ServiceDeploymentStatusList = Schema.Array(Schema.String);
export const LoadBalancers = Schema.Array(LoadBalancer);
export const TaskSetFieldList = Schema.Array(Schema.String);
export const TaskFieldList = Schema.Array(Schema.String);
export const PutClusterCapacityProvidersRequest = Schema.Struct({cluster: Schema.String, capacityProviders: StringList, defaultCapacityProviderStrategy: CapacityProviderStrategy});
export const PutAttributesRequest = Schema.Struct({cluster: Schema.optional(Schema.String), attributes: Attributes});
export const PutAccountSettingDefaultRequest = Schema.Struct({name: Schema.String, value: Schema.String});
export const PutAccountSettingRequest = Schema.Struct({name: Schema.String, value: Schema.String, principalArn: Schema.optional(Schema.String)});
export const ListTasksRequest = Schema.Struct({cluster: Schema.optional(Schema.String), containerInstance: Schema.optional(Schema.String), family: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), startedBy: Schema.optional(Schema.String), serviceName: Schema.optional(Schema.String), desiredStatus: Schema.optional(Schema.String), launchType: Schema.optional(Schema.String)});
export const ServiceVolumeConfiguration = Schema.Struct({name: Schema.String, managedEBSVolume: Schema.optional(ServiceManagedEBSVolumeConfiguration)});
export const ListTaskDefinitionsRequest = Schema.Struct({familyPrefix: Schema.optional(Schema.String), status: Schema.optional(Schema.String), sort: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ServiceVolumeConfigurations = Schema.Array(ServiceVolumeConfiguration);
export const ListTaskDefinitionFamiliesRequest = Schema.Struct({familyPrefix: Schema.optional(Schema.String), status: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListTagsForResourceRequest = Schema.Struct({resourceArn: Schema.String});
export const AutoScalingGroupProvider = Schema.Struct({autoScalingGroupArn: Schema.String, managedScaling: Schema.optional(ManagedScaling), managedTerminationProtection: Schema.optional(Schema.String), managedDraining: Schema.optional(Schema.String)});
export const ListServicesByNamespaceRequest = Schema.Struct({namespace: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListServicesRequest = Schema.Struct({cluster: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), launchType: Schema.optional(Schema.String), schedulingStrategy: Schema.optional(Schema.String)});
export const TaskDefinitionFieldList = Schema.Array(Schema.String);
export const ListContainerInstancesRequest = Schema.Struct({cluster: Schema.optional(Schema.String), filter: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), status: Schema.optional(Schema.String)});
export const ListClustersRequest = Schema.Struct({nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListAttributesRequest = Schema.Struct({cluster: Schema.optional(Schema.String), targetType: Schema.String, attributeName: Schema.optional(Schema.String), attributeValue: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const SubmitTaskStateChangeRequest = Schema.Struct({cluster: Schema.optional(Schema.String), task: Schema.optional(Schema.String), status: Schema.optional(Schema.String), reason: Schema.optional(Schema.String), containers: Schema.optional(ContainerStateChanges), attachments: Schema.optional(AttachmentStateChanges), managedAgents: Schema.optional(ManagedAgentStateChanges), pullStartedAt: Schema.optional(Schema.Date), pullStoppedAt: Schema.optional(Schema.Date), executionStoppedAt: Schema.optional(Schema.Date)});
export const SubmitContainerStateChangeRequest = Schema.Struct({cluster: Schema.optional(Schema.String), task: Schema.optional(Schema.String), containerName: Schema.optional(Schema.String), runtimeId: Schema.optional(Schema.String), status: Schema.optional(Schema.String), exitCode: Schema.optional(Schema.Number), reason: Schema.optional(Schema.String), networkBindings: Schema.optional(NetworkBindings)});
export const SubmitAttachmentStateChangesRequest = Schema.Struct({cluster: Schema.optional(Schema.String), attachments: AttachmentStateChanges});
export const ListAccountSettingsRequest = Schema.Struct({name: Schema.optional(Schema.String), value: Schema.optional(Schema.String), principalArn: Schema.optional(Schema.String), effectiveSettings: Schema.optional(Schema.Boolean), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const GetTaskProtectionRequest = Schema.Struct({cluster: Schema.String, tasks: Schema.optional(StringList)});
export const ExecuteCommandRequest = Schema.Struct({cluster: Schema.optional(Schema.String), container: Schema.optional(Schema.String), command: Schema.String, interactive: Schema.Boolean, task: Schema.String});
export const DiscoverPollEndpointRequest = Schema.Struct({containerInstance: Schema.optional(Schema.String), cluster: Schema.optional(Schema.String)});
export const ClusterConfiguration = Schema.Struct({executeCommandConfiguration: Schema.optional(ExecuteCommandConfiguration), managedStorageConfiguration: Schema.optional(ManagedStorageConfiguration)});
export const RegisterContainerInstanceRequest = Schema.Struct({cluster: Schema.optional(Schema.String), instanceIdentityDocument: Schema.optional(Schema.String), instanceIdentityDocumentSignature: Schema.optional(Schema.String), totalResources: Schema.optional(Resources), versionInfo: Schema.optional(VersionInfo), containerInstanceArn: Schema.optional(Schema.String), attributes: Schema.optional(Attributes), platformDevices: Schema.optional(PlatformDevices), tags: Schema.optional(Tags)});
export const DescribeTaskSetsRequest = Schema.Struct({cluster: Schema.String, service: Schema.String, taskSets: Schema.optional(StringList), include: Schema.optional(TaskSetFieldList)});
export const DescribeTasksRequest = Schema.Struct({cluster: Schema.optional(Schema.String), tasks: StringList, include: Schema.optional(TaskFieldList)});
export const DescribeTaskDefinitionRequest = Schema.Struct({taskDefinition: Schema.String, include: Schema.optional(TaskDefinitionFieldList)});
export const DescribeServicesRequest = Schema.Struct({cluster: Schema.optional(Schema.String), services: StringList, include: Schema.optional(ServiceFieldList)});
export const ListServiceDeploymentsRequest = Schema.Struct({service: Schema.String, cluster: Schema.optional(Schema.String), status: Schema.optional(ServiceDeploymentStatusList), createdAt: Schema.optional(CreatedAt), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const DescribeServiceRevisionsRequest = Schema.Struct({serviceRevisionArns: StringList});
export const ServiceConnectConfiguration = Schema.Struct({enabled: Schema.Boolean, namespace: Schema.optional(Schema.String), services: Schema.optional(ServiceConnectServiceList), logConfiguration: Schema.optional(LogConfiguration), accessLogConfiguration: Schema.optional(ServiceConnectAccessLogConfiguration)});
export const DescribeServiceDeploymentsRequest = Schema.Struct({serviceDeploymentArns: StringList});
export const DescribeContainerInstancesRequest = Schema.Struct({cluster: Schema.optional(Schema.String), containerInstances: StringList, include: Schema.optional(ContainerInstanceFieldList)});
export const DescribeClustersRequest = Schema.Struct({clusters: Schema.optional(StringList), include: Schema.optional(ClusterFieldList)});
export const DescribeCapacityProvidersRequest = Schema.Struct({capacityProviders: Schema.optional(StringList), cluster: Schema.optional(Schema.String), include: Schema.optional(CapacityProviderFieldList), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const UpdateCapacityProviderRequest = Schema.Struct({name: Schema.String, cluster: Schema.optional(Schema.String), autoScalingGroupProvider: Schema.optional(AutoScalingGroupProviderUpdate), managedInstancesProvider: Schema.optional(UpdateManagedInstancesProviderConfiguration)});
export const DeregisterTaskDefinitionRequest = Schema.Struct({taskDefinition: Schema.String});
export const DeregisterContainerInstanceRequest = Schema.Struct({cluster: Schema.optional(Schema.String), containerInstance: Schema.String, force: Schema.optional(Schema.Boolean)});
export const DeleteTaskSetRequest = Schema.Struct({cluster: Schema.String, service: Schema.String, taskSet: Schema.String, force: Schema.optional(Schema.Boolean)});
export const DeleteTaskDefinitionsRequest = Schema.Struct({taskDefinitions: StringList});
export const DeleteServiceRequest = Schema.Struct({cluster: Schema.optional(Schema.String), service: Schema.String, force: Schema.optional(Schema.Boolean)});
export const DeleteClusterRequest = Schema.Struct({cluster: Schema.String});
export const DeleteCapacityProviderRequest = Schema.Struct({capacityProvider: Schema.String, cluster: Schema.optional(Schema.String)});
export const CreateManagedInstancesProviderConfiguration = Schema.Struct({infrastructureRoleArn: Schema.String, instanceLaunchTemplate: InstanceLaunchTemplate, propagateTags: Schema.optional(Schema.String)});
export const ServiceFieldList = Schema.Array(Schema.String);
export const DeleteAccountSettingRequest = Schema.Struct({name: Schema.String, principalArn: Schema.optional(Schema.String)});
export const DeleteAttributesRequest = Schema.Struct({cluster: Schema.optional(Schema.String), attributes: Attributes});
export const ContainerInstanceFieldList = Schema.Array(Schema.String);
export const CreateTaskSetRequest = Schema.Struct({service: Schema.String, cluster: Schema.String, externalId: Schema.optional(Schema.String), taskDefinition: Schema.String, networkConfiguration: Schema.optional(NetworkConfiguration), loadBalancers: Schema.optional(LoadBalancers), serviceRegistries: Schema.optional(ServiceRegistries), launchType: Schema.optional(Schema.String), capacityProviderStrategy: Schema.optional(CapacityProviderStrategy), platformVersion: Schema.optional(Schema.String), scale: Schema.optional(Scale), clientToken: Schema.optional(Schema.String), tags: Schema.optional(Tags)});
export const ClusterFieldList = Schema.Array(Schema.String);
export const CapacityProviderFieldList = Schema.Array(Schema.String);
export const StringList = Schema.Array(Schema.String);
export const DescribeClusters = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DescribeClusters" }, DescribeClustersRequest, DescribeClustersResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeContainerInstances = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DescribeContainerInstances" }, DescribeContainerInstancesRequest, DescribeContainerInstancesResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeServices = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DescribeServices" }, DescribeServicesRequest, DescribeServicesResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeTaskDefinition = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DescribeTaskDefinition" }, DescribeTaskDefinitionRequest, DescribeTaskDefinitionResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DiscoverPollEndpoint = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DiscoverPollEndpoint" }, DiscoverPollEndpointRequest, DiscoverPollEndpointResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListAccountSettings = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.ListAccountSettings" }, ListAccountSettingsRequest, ListAccountSettingsResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListAttributes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.ListAttributes" }, ListAttributesRequest, ListAttributesResponse, Schema.Union(ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const RunTaskRequest = Schema.Struct({capacityProviderStrategy: Schema.optional(CapacityProviderStrategy), cluster: Schema.optional(Schema.String), count: Schema.optional(Schema.Number), enableECSManagedTags: Schema.optional(Schema.Boolean), enableExecuteCommand: Schema.optional(Schema.Boolean), group: Schema.optional(Schema.String), launchType: Schema.optional(Schema.String), networkConfiguration: Schema.optional(NetworkConfiguration), overrides: Schema.optional(TaskOverride), placementConstraints: Schema.optional(PlacementConstraints), placementStrategy: Schema.optional(PlacementStrategies), platformVersion: Schema.optional(Schema.String), propagateTags: Schema.optional(Schema.String), referenceId: Schema.optional(Schema.String), startedBy: Schema.optional(Schema.String), tags: Schema.optional(Tags), taskDefinition: Schema.String, clientToken: Schema.optional(Schema.String), volumeConfigurations: Schema.optional(TaskVolumeConfigurations)});
export const RegisterTaskDefinitionRequest = Schema.Struct({family: Schema.String, taskRoleArn: Schema.optional(Schema.String), executionRoleArn: Schema.optional(Schema.String), networkMode: Schema.optional(Schema.String), containerDefinitions: ContainerDefinitions, volumes: Schema.optional(VolumeList), placementConstraints: Schema.optional(TaskDefinitionPlacementConstraints), requiresCompatibilities: Schema.optional(CompatibilityList), cpu: Schema.optional(Schema.String), memory: Schema.optional(Schema.String), tags: Schema.optional(Tags), pidMode: Schema.optional(Schema.String), ipcMode: Schema.optional(Schema.String), proxyConfiguration: Schema.optional(ProxyConfiguration), inferenceAccelerators: Schema.optional(InferenceAccelerators), ephemeralStorage: Schema.optional(EphemeralStorage), runtimePlatform: Schema.optional(RuntimePlatform), enableFaultInjection: Schema.optional(Schema.Boolean)});
export const ListClusters = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.ListClusters" }, ListClustersRequest, ListClustersResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListContainerInstances = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.ListContainerInstances" }, ListContainerInstancesRequest, ListContainerInstancesResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListServices = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.ListServices" }, ListServicesRequest, ListServicesResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTaskDefinitionFamilies = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.ListTaskDefinitionFamilies" }, ListTaskDefinitionFamiliesRequest, ListTaskDefinitionFamiliesResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTaskDefinitions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.ListTaskDefinitions" }, ListTaskDefinitionsRequest, ListTaskDefinitionsResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PutAccountSetting = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.PutAccountSetting" }, PutAccountSettingRequest, PutAccountSettingResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PutAccountSettingDefault = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.PutAccountSettingDefault" }, PutAccountSettingDefaultRequest, PutAccountSettingDefaultResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const StopTask = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.StopTask" }, StopTaskRequest, StopTaskResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UntagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.UntagResource" }, UntagResourceRequest, UntagResourceResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateCluster = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.UpdateCluster" }, UpdateClusterRequest, UpdateClusterResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("NamespaceNotFoundException", NamespaceNotFoundException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateClusterSettings = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.UpdateClusterSettings" }, UpdateClusterSettingsRequest, UpdateClusterSettingsResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateContainerInstancesState = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.UpdateContainerInstancesState" }, UpdateContainerInstancesStateRequest, UpdateContainerInstancesStateResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateTaskProtection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.UpdateTaskProtection" }, UpdateTaskProtectionRequest, UpdateTaskProtectionResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteAccountSetting = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DeleteAccountSetting" }, DeleteAccountSettingRequest, DeleteAccountSettingResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteTaskDefinitions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DeleteTaskDefinitions" }, DeleteTaskDefinitionsRequest, DeleteTaskDefinitionsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeregisterTaskDefinition = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DeregisterTaskDefinition" }, DeregisterTaskDefinitionRequest, DeregisterTaskDefinitionResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeCapacityProviders = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DescribeCapacityProviders" }, DescribeCapacityProvidersRequest, DescribeCapacityProvidersResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeTaskSets = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DescribeTaskSets" }, DescribeTaskSetsRequest, DescribeTaskSetsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("ServiceNotActiveException", ServiceNotActiveException), ErrorAnnotation("ServiceNotFoundException", ServiceNotFoundException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetTaskProtection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.GetTaskProtection" }, GetTaskProtectionRequest, GetTaskProtectionResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListServicesByNamespace = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.ListServicesByNamespace" }, ListServicesByNamespaceRequest, ListServicesByNamespaceResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("NamespaceNotFoundException", NamespaceNotFoundException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTasks = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.ListTasks" }, ListTasksRequest, ListTasksResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("ServiceNotFoundException", ServiceNotFoundException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PutAttributes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.PutAttributes" }, PutAttributesRequest, PutAttributesResponse, Schema.Union(ErrorAnnotation("AttributeLimitExceededException", AttributeLimitExceededException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("TargetNotFoundException", TargetNotFoundException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const RegisterContainerInstance = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.RegisterContainerInstance" }, RegisterContainerInstanceRequest, RegisterContainerInstanceResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const StartTask = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.StartTask" }, StartTaskRequest, StartTaskResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const SubmitAttachmentStateChanges = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.SubmitAttachmentStateChanges" }, SubmitAttachmentStateChangesRequest, SubmitAttachmentStateChangesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const SubmitContainerStateChange = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.SubmitContainerStateChange" }, SubmitContainerStateChangeRequest, SubmitContainerStateChangeResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const SubmitTaskStateChange = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.SubmitTaskStateChange" }, SubmitTaskStateChangeRequest, SubmitTaskStateChangeResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const TagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.TagResource" }, TagResourceRequest, TagResourceResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateService = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.UpdateService" }, UpdateServiceRequest, UpdateServiceResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("NamespaceNotFoundException", NamespaceNotFoundException), ErrorAnnotation("PlatformTaskDefinitionIncompatibilityException", PlatformTaskDefinitionIncompatibilityException), ErrorAnnotation("PlatformUnknownException", PlatformUnknownException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("ServiceNotActiveException", ServiceNotActiveException), ErrorAnnotation("ServiceNotFoundException", ServiceNotFoundException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateServicePrimaryTaskSet = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.UpdateServicePrimaryTaskSet" }, UpdateServicePrimaryTaskSetRequest, UpdateServicePrimaryTaskSetResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("ServiceNotActiveException", ServiceNotActiveException), ErrorAnnotation("ServiceNotFoundException", ServiceNotFoundException), ErrorAnnotation("TaskSetNotFoundException", TaskSetNotFoundException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateClusterRequest = Schema.Struct({clusterName: Schema.optional(Schema.String), tags: Schema.optional(Tags), settings: Schema.optional(ClusterSettings), configuration: Schema.optional(ClusterConfiguration), capacityProviders: Schema.optional(StringList), defaultCapacityProviderStrategy: Schema.optional(CapacityProviderStrategy), serviceConnectDefaults: Schema.optional(ClusterServiceConnectDefaultsRequest)});
export const UpdateTaskSet = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.UpdateTaskSet" }, UpdateTaskSetRequest, UpdateTaskSetResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("ServiceNotActiveException", ServiceNotActiveException), ErrorAnnotation("ServiceNotFoundException", ServiceNotFoundException), ErrorAnnotation("TaskSetNotFoundException", TaskSetNotFoundException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateTaskSet = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.CreateTaskSet" }, CreateTaskSetRequest, CreateTaskSetResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("NamespaceNotFoundException", NamespaceNotFoundException), ErrorAnnotation("PlatformTaskDefinitionIncompatibilityException", PlatformTaskDefinitionIncompatibilityException), ErrorAnnotation("PlatformUnknownException", PlatformUnknownException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("ServiceNotActiveException", ServiceNotActiveException), ErrorAnnotation("ServiceNotFoundException", ServiceNotFoundException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteAttributes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DeleteAttributes" }, DeleteAttributesRequest, DeleteAttributesResponse, Schema.Union(ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("TargetNotFoundException", TargetNotFoundException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteCapacityProvider = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DeleteCapacityProvider" }, DeleteCapacityProviderRequest, DeleteCapacityProviderResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteTaskSet = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DeleteTaskSet" }, DeleteTaskSetRequest, DeleteTaskSetResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("ServiceNotActiveException", ServiceNotActiveException), ErrorAnnotation("ServiceNotFoundException", ServiceNotFoundException), ErrorAnnotation("TaskSetNotFoundException", TaskSetNotFoundException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeServiceDeployments = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DescribeServiceDeployments" }, DescribeServiceDeploymentsRequest, DescribeServiceDeploymentsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("ServiceNotFoundException", ServiceNotFoundException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ExecuteCommand = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.ExecuteCommand" }, ExecuteCommandRequest, ExecuteCommandResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("TargetNotConnectedException", TargetNotConnectedException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListServiceDeployments = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.ListServiceDeployments" }, ListServiceDeploymentsRequest, ListServiceDeploymentsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("ServiceNotFoundException", ServiceNotFoundException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PutClusterCapacityProviders = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.PutClusterCapacityProviders" }, PutClusterCapacityProvidersRequest, PutClusterCapacityProvidersResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("UpdateInProgressException", UpdateInProgressException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const StopServiceDeployment = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.StopServiceDeployment" }, StopServiceDeploymentRequest, StopServiceDeploymentResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("ServiceDeploymentNotFoundException", ServiceDeploymentNotFoundException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateCapacityProvider = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.UpdateCapacityProvider" }, UpdateCapacityProviderRequest, UpdateCapacityProviderResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateContainerAgent = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.UpdateContainerAgent" }, UpdateContainerAgentRequest, UpdateContainerAgentResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("MissingVersionException", MissingVersionException), ErrorAnnotation("NoUpdateAvailableException", NoUpdateAvailableException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("UpdateInProgressException", UpdateInProgressException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateCapacityProviderRequest = Schema.Struct({name: Schema.String, cluster: Schema.optional(Schema.String), autoScalingGroupProvider: Schema.optional(AutoScalingGroupProvider), managedInstancesProvider: Schema.optional(CreateManagedInstancesProviderConfiguration), tags: Schema.optional(Tags)});
export const CreateCluster = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.CreateCluster" }, CreateClusterRequest, CreateClusterResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("NamespaceNotFoundException", NamespaceNotFoundException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteService = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DeleteService" }, DeleteServiceRequest, DeleteServiceResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("ServiceNotFoundException", ServiceNotFoundException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeregisterContainerInstance = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DeregisterContainerInstance" }, DeregisterContainerInstanceRequest, DeregisterContainerInstanceResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeServiceRevisions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DescribeServiceRevisions" }, DescribeServiceRevisionsRequest, DescribeServiceRevisionsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("ServiceNotFoundException", ServiceNotFoundException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeTasks = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DescribeTasks" }, DescribeTasksRequest, DescribeTasksResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const RegisterTaskDefinition = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.RegisterTaskDefinition" }, RegisterTaskDefinitionRequest, RegisterTaskDefinitionResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateServiceRequest = Schema.Struct({cluster: Schema.optional(Schema.String), serviceName: Schema.String, taskDefinition: Schema.optional(Schema.String), availabilityZoneRebalancing: Schema.optional(Schema.String), loadBalancers: Schema.optional(LoadBalancers), serviceRegistries: Schema.optional(ServiceRegistries), desiredCount: Schema.optional(Schema.Number), clientToken: Schema.optional(Schema.String), launchType: Schema.optional(Schema.String), capacityProviderStrategy: Schema.optional(CapacityProviderStrategy), platformVersion: Schema.optional(Schema.String), role: Schema.optional(Schema.String), deploymentConfiguration: Schema.optional(DeploymentConfiguration), placementConstraints: Schema.optional(PlacementConstraints), placementStrategy: Schema.optional(PlacementStrategies), networkConfiguration: Schema.optional(NetworkConfiguration), healthCheckGracePeriodSeconds: Schema.optional(Schema.Number), schedulingStrategy: Schema.optional(Schema.String), deploymentController: Schema.optional(DeploymentController), tags: Schema.optional(Tags), enableECSManagedTags: Schema.optional(Schema.Boolean), propagateTags: Schema.optional(Schema.String), enableExecuteCommand: Schema.optional(Schema.Boolean), serviceConnectConfiguration: Schema.optional(ServiceConnectConfiguration), volumeConfigurations: Schema.optional(ServiceVolumeConfigurations), vpcLatticeConfigurations: Schema.optional(VpcLatticeConfigurations)});
export const RunTask = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.RunTask" }, RunTaskRequest, RunTaskResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("BlockedException", BlockedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("PlatformTaskDefinitionIncompatibilityException", PlatformTaskDefinitionIncompatibilityException), ErrorAnnotation("PlatformUnknownException", PlatformUnknownException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateCapacityProvider = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.CreateCapacityProvider" }, CreateCapacityProviderRequest, CreateCapacityProviderResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException), ErrorAnnotation("UpdateInProgressException", UpdateInProgressException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateService = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.CreateService" }, CreateServiceRequest, CreateServiceResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("NamespaceNotFoundException", NamespaceNotFoundException), ErrorAnnotation("PlatformTaskDefinitionIncompatibilityException", PlatformTaskDefinitionIncompatibilityException), ErrorAnnotation("PlatformUnknownException", PlatformUnknownException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("UnsupportedFeatureException", UnsupportedFeatureException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteCluster = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "ECS", sigV4ServiceName: "ecs", name: "AmazonEC2ContainerServiceV20141113.DeleteCluster" }, DeleteClusterRequest, DeleteClusterResponse, Schema.Union(ErrorAnnotation("ClientException", ClientException), ErrorAnnotation("ClusterContainsCapacityProviderException", ClusterContainsCapacityProviderException), ErrorAnnotation("ClusterContainsContainerInstancesException", ClusterContainsContainerInstancesException), ErrorAnnotation("ClusterContainsServicesException", ClusterContainsServicesException), ErrorAnnotation("ClusterContainsTasksException", ClusterContainsTasksException), ErrorAnnotation("ClusterNotFoundException", ClusterNotFoundException), ErrorAnnotation("InvalidParameterException", InvalidParameterException), ErrorAnnotation("ServerException", ServerException), ErrorAnnotation("UpdateInProgressException", UpdateInProgressException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
