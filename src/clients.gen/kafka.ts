import { Schema} from "effect"
import { FormatXMLRequest, FormatXMLResponse, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
const __listOf__string = Schema.Array(Schema.String)
const BatchAssociateScramSecretRequest = Schema.Struct({ClusterArn: Schema.String, SecretArnList: __listOf__string})
const BatchDisassociateScramSecretRequest = Schema.Struct({ClusterArn: Schema.String, SecretArnList: __listOf__string})
const CreateConfigurationRequest = Schema.Struct({Description: Schema.optional(Schema.String), KafkaVersions: Schema.optional(__listOf__string), Name: Schema.String, ServerProperties: StreamBody()})
const CreateVpcConnectionRequest = Schema.Struct({TargetClusterArn: Schema.String, Authentication: Schema.String, VpcId: Schema.String, ClientSubnets: __listOf__string, SecurityGroups: __listOf__string, Tags: Schema.optional(__mapOf__string)})
const DeleteClusterRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.optional(Schema.String)})
const DeleteClusterPolicyRequest = Schema.Struct({ClusterArn: Schema.String})
const DeleteClusterPolicyResponse = Schema.Struct({})
const DeleteConfigurationRequest = Schema.Struct({Arn: Schema.String})
const DeleteReplicatorRequest = Schema.Struct({CurrentVersion: Schema.optional(Schema.String), ReplicatorArn: Schema.String})
const DeleteVpcConnectionRequest = Schema.Struct({Arn: Schema.String})
const DescribeClusterRequest = Schema.Struct({ClusterArn: Schema.String})
const DescribeClusterOperationRequest = Schema.Struct({ClusterOperationArn: Schema.String})
const DescribeClusterOperationV2Request = Schema.Struct({ClusterOperationArn: Schema.String})
const DescribeClusterV2Request = Schema.Struct({ClusterArn: Schema.String})
const DescribeConfigurationRequest = Schema.Struct({Arn: Schema.String})
const DescribeConfigurationRevisionRequest = Schema.Struct({Arn: Schema.String, Revision: Schema.Number})
const DescribeReplicatorRequest = Schema.Struct({ReplicatorArn: Schema.String})
const DescribeVpcConnectionRequest = Schema.Struct({Arn: Schema.String})
const GetBootstrapBrokersRequest = Schema.Struct({ClusterArn: Schema.String})
const GetClusterPolicyRequest = Schema.Struct({ClusterArn: Schema.String})
const GetCompatibleKafkaVersionsRequest = Schema.Struct({ClusterArn: Schema.optional(Schema.String)})
const ListClientVpcConnectionsRequest = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListClusterOperationsRequest = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListClusterOperationsV2Request = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListClustersRequest = Schema.Struct({ClusterNameFilter: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListClustersV2Request = Schema.Struct({ClusterNameFilter: Schema.optional(Schema.String), ClusterTypeFilter: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListConfigurationRevisionsRequest = Schema.Struct({Arn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListConfigurationsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListKafkaVersionsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListNodesRequest = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListReplicatorsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String), ReplicatorNameFilter: Schema.optional(Schema.String)})
const ListScramSecretsRequest = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListTagsForResourceRequest = Schema.Struct({ResourceArn: Schema.String})
const ListVpcConnectionsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const PutClusterPolicyRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.optional(Schema.String), Policy: Schema.String})
const RebootBrokerRequest = Schema.Struct({BrokerIds: __listOf__string, ClusterArn: Schema.String})
const RejectClientVpcConnectionRequest = Schema.Struct({ClusterArn: Schema.String, VpcConnectionArn: Schema.String})
const RejectClientVpcConnectionResponse = Schema.Struct({})
const TagResourceRequest = Schema.Struct({ResourceArn: Schema.String, Tags: __mapOf__string})
const UntagResourceRequest = Schema.Struct({ResourceArn: Schema.String, TagKeys: __listOf__string})
const UpdateBrokerCountRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, TargetNumberOfBrokerNodes: Schema.Number})
const UpdateBrokerTypeRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, TargetInstanceType: Schema.String})
const UpdateClusterConfigurationRequest = Schema.Struct({ClusterArn: Schema.String, ConfigurationInfo: ConfigurationInfo, CurrentVersion: Schema.String})
const UpdateClusterKafkaVersionRequest = Schema.Struct({ClusterArn: Schema.String, ConfigurationInfo: Schema.optional(ConfigurationInfo), CurrentVersion: Schema.String, TargetKafkaVersion: Schema.String})
const UpdateConfigurationRequest = Schema.Struct({Arn: Schema.String, Description: Schema.optional(Schema.String), ServerProperties: StreamBody()})
const UpdateMonitoringRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), LoggingInfo: Schema.optional(LoggingInfo)})
const UpdateRebalancingRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, Rebalancing: Rebalancing})
const UpdateSecurityRequest = Schema.Struct({ClientAuthentication: Schema.optional(ClientAuthentication), ClusterArn: Schema.String, CurrentVersion: Schema.String, EncryptionInfo: Schema.optional(EncryptionInfo)})
const __listOf__stringMax256 = Schema.Array(Schema.String)
const __listOf__stringMax249 = Schema.Array(Schema.String)
const Rebalancing = Schema.Struct({Status: Schema.optional(Schema.String)})
const ConfigurationInfo = Schema.Struct({Arn: Schema.String, Revision: Schema.Number})
const __mapOf__string = Schema.Record({key: Schema.String, value: Schema.String})
const ProvisionedRequest = Schema.Struct({BrokerNodeGroupInfo: BrokerNodeGroupInfo, Rebalancing: Schema.optional(Rebalancing), ClientAuthentication: Schema.optional(ClientAuthentication), ConfigurationInfo: Schema.optional(ConfigurationInfo), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), KafkaVersion: Schema.String, LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.Number, StorageMode: Schema.optional(Schema.String)})
const __listOfClusterOperationInfo = Schema.Array(ClusterOperationInfo)
const __listOfClusterInfo = Schema.Array(ClusterInfo)
const __listOfCluster = Schema.Array(Cluster)
const __listOfConfigurationRevision = Schema.Array(ConfigurationRevision)
const BrokerEBSVolumeInfo = Schema.Struct({KafkaBrokerNodeId: Schema.String, ProvisionedThroughput: Schema.optional(ProvisionedThroughput), VolumeSizeGB: Schema.optional(Schema.Number)})
const __listOfBrokerEBSVolumeInfo = Schema.Array(BrokerEBSVolumeInfo)
const ConsumerGroupReplicationUpdate = Schema.Struct({ConsumerGroupsToExclude: __listOf__stringMax256, ConsumerGroupsToReplicate: __listOf__stringMax256, DetectAndCopyNewConsumerGroups: Schema.Boolean, SynchroniseConsumerGroupOffsets: Schema.Boolean})
const TopicReplicationUpdate = Schema.Struct({CopyAccessControlListsForTopics: Schema.Boolean, CopyTopicConfigurations: Schema.Boolean, DetectAndCopyNewTopics: Schema.Boolean, TopicsToExclude: __listOf__stringMax249, TopicsToReplicate: __listOf__stringMax249})
const ProvisionedThroughput = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), VolumeThroughput: Schema.optional(Schema.Number)})
const BatchDisassociateScramSecretResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), UnprocessedScramSecrets: Schema.optional(__listOfUnprocessedScramSecret)})
const CreateVpcConnectionResponse = Schema.Struct({VpcConnectionArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String), Authentication: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), ClientSubnets: Schema.optional(__listOf__string), SecurityGroups: Schema.optional(__listOf__string), CreationTime: Schema.optional(Schema.Date), Tags: Schema.optional(__mapOf__string)})
const DeleteClusterResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String)})
export const DeleteCluster = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "DeleteCluster" }, DeleteClusterRequest, DeleteClusterResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const BadRequestException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
export const DeleteClusterPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/policy", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "DeleteClusterPolicy" }, DeleteClusterPolicyRequest, DeleteClusterPolicyResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteConfigurationResponse = Schema.Struct({Arn: Schema.optional(Schema.String), State: Schema.optional(Schema.String)})
export const DeleteConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations/{Arn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "DeleteConfiguration" }, DeleteConfigurationRequest, DeleteConfigurationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteReplicatorResponse = Schema.Struct({ReplicatorArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)})
const DeleteVpcConnectionResponse = Schema.Struct({VpcConnectionArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String)})
export const DeleteVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/vpc-connection/{Arn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "DeleteVpcConnection" }, DeleteVpcConnectionRequest, DeleteVpcConnectionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeConfigurationResponse = Schema.Struct({Arn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), Description: Schema.optional(Schema.String), KafkaVersions: Schema.optional(__listOf__string), LatestRevision: Schema.optional(ConfigurationRevision), Name: Schema.optional(Schema.String), State: Schema.optional(Schema.String)})
export const DescribeConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations/{Arn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "DescribeConfiguration" }, DescribeConfigurationRequest, DescribeConfigurationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeConfigurationRevisionResponse = Schema.Struct({Arn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), Description: Schema.optional(Schema.String), Revision: Schema.optional(Schema.Number), ServerProperties: Schema.optional(StreamBody())})
export const DescribeConfigurationRevision = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations/{Arn}/revisions/{Revision}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "DescribeConfigurationRevision" }, DescribeConfigurationRevisionRequest, DescribeConfigurationRevisionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeVpcConnectionResponse = Schema.Struct({VpcConnectionArn: Schema.optional(Schema.String), TargetClusterArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String), Authentication: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), Subnets: Schema.optional(__listOf__string), SecurityGroups: Schema.optional(__listOf__string), CreationTime: Schema.optional(Schema.Date), Tags: Schema.optional(__mapOf__string)})
export const DescribeVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/vpc-connection/{Arn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "DescribeVpcConnection" }, DescribeVpcConnectionRequest, DescribeVpcConnectionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetBootstrapBrokersResponse = Schema.Struct({BootstrapBrokerString: Schema.optional(Schema.String), BootstrapBrokerStringTls: Schema.optional(Schema.String), BootstrapBrokerStringSaslScram: Schema.optional(Schema.String), BootstrapBrokerStringSaslIam: Schema.optional(Schema.String), BootstrapBrokerStringPublicTls: Schema.optional(Schema.String), BootstrapBrokerStringPublicSaslScram: Schema.optional(Schema.String), BootstrapBrokerStringPublicSaslIam: Schema.optional(Schema.String), BootstrapBrokerStringVpcConnectivityTls: Schema.optional(Schema.String), BootstrapBrokerStringVpcConnectivitySaslScram: Schema.optional(Schema.String), BootstrapBrokerStringVpcConnectivitySaslIam: Schema.optional(Schema.String)})
const GetClusterPolicyResponse = Schema.Struct({CurrentVersion: Schema.optional(Schema.String), Policy: Schema.optional(Schema.String)})
export const GetClusterPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/policy", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "GetClusterPolicy" }, GetClusterPolicyRequest, GetClusterPolicyResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListClusterOperationsResponse = Schema.Struct({ClusterOperationInfoList: Schema.optional(__listOfClusterOperationInfo), NextToken: Schema.optional(Schema.String)})
export const ListClusterOperations = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/operations", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "ListClusterOperations" }, ListClusterOperationsRequest, ListClusterOperationsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListClustersResponse = Schema.Struct({ClusterInfoList: Schema.optional(__listOfClusterInfo), NextToken: Schema.optional(Schema.String)})
export const ListClusters = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "ListClusters" }, ListClustersRequest, ListClustersResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListClustersV2Response = Schema.Struct({ClusterInfoList: Schema.optional(__listOfCluster), NextToken: Schema.optional(Schema.String)})
export const ListClustersV2 = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/api/v2/clusters", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "ListClustersV2" }, ListClustersV2Request, ListClustersV2Response, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListConfigurationRevisionsResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), Revisions: Schema.optional(__listOfConfigurationRevision)})
export const ListConfigurationRevisions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations/{Arn}/revisions", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "ListConfigurationRevisions" }, ListConfigurationRevisionsRequest, ListConfigurationRevisionsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListScramSecretsResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), SecretArnList: Schema.optional(__listOf__string)})
export const ListScramSecrets = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/scram-secrets", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "ListScramSecrets" }, ListScramSecretsRequest, ListScramSecretsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListTagsForResourceResponse = Schema.Struct({Tags: Schema.optional(__mapOf__string)})
export const ListTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/tags/{ResourceArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutClusterPolicyResponse = Schema.Struct({CurrentVersion: Schema.optional(Schema.String)})
export const PutClusterPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/policy", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "PutClusterPolicy" }, PutClusterPolicyRequest, PutClusterPolicyResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const RebootBrokerResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)})
export const RebootBroker = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/reboot-broker", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "RebootBroker" }, RebootBrokerRequest, RebootBrokerResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ForbiddenException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
export const RejectClientVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/client-vpc-connection", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "RejectClientVpcConnection" }, RejectClientVpcConnectionRequest, RejectClientVpcConnectionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InternalServerErrorException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
export const TagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/tags/{ResourceArn}", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "TagResource" }, TagResourceRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NotFoundException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
export const UntagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/tags/{ResourceArn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "UntagResource" }, UntagResourceRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateBrokerCountResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)})
export const UpdateBrokerCount = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/nodes/count", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "UpdateBrokerCount" }, UpdateBrokerCountRequest, UpdateBrokerCountResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateBrokerStorageRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, TargetBrokerEBSVolumeInfo: __listOfBrokerEBSVolumeInfo})
const UpdateBrokerTypeResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)})
export const UpdateBrokerType = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/nodes/type", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "UpdateBrokerType" }, UpdateBrokerTypeRequest, UpdateBrokerTypeResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateClusterConfigurationResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)})
export const UpdateClusterConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/configuration", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "UpdateClusterConfiguration" }, UpdateClusterConfigurationRequest, UpdateClusterConfigurationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateClusterKafkaVersionResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)})
export const UpdateClusterKafkaVersion = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/version", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "UpdateClusterKafkaVersion" }, UpdateClusterKafkaVersionRequest, UpdateClusterKafkaVersionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateConfigurationResponse = Schema.Struct({Arn: Schema.optional(Schema.String), LatestRevision: Schema.optional(ConfigurationRevision)})
export const UpdateConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations/{Arn}", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "UpdateConfiguration" }, UpdateConfigurationRequest, UpdateConfigurationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateMonitoringResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)})
export const UpdateMonitoring = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/monitoring", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "UpdateMonitoring" }, UpdateMonitoringRequest, UpdateMonitoringResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateRebalancingResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)})
export const UpdateRebalancing = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/rebalancing", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "UpdateRebalancing" }, UpdateRebalancingRequest, UpdateRebalancingResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateReplicationInfoRequest = Schema.Struct({ConsumerGroupReplication: Schema.optional(ConsumerGroupReplicationUpdate), CurrentVersion: Schema.String, ReplicatorArn: Schema.String, SourceKafkaClusterArn: Schema.String, TargetKafkaClusterArn: Schema.String, TopicReplication: Schema.optional(TopicReplicationUpdate)})
const UpdateSecurityResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)})
export const UpdateSecurity = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/security", method: "PATCH", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "UpdateSecurity" }, UpdateSecurityRequest, UpdateSecurityResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateStorageRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, ProvisionedThroughput: Schema.optional(ProvisionedThroughput), StorageMode: Schema.optional(Schema.String), VolumeSizeGB: Schema.optional(Schema.Number)})
const Tls = Schema.Struct({CertificateAuthorityArnList: Schema.optional(__listOf__string), Enabled: Schema.optional(Schema.Boolean)})
const Unauthenticated = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)})
const EncryptionAtRest = Schema.Struct({DataVolumeKMSKeyId: Schema.String})
const EncryptionInTransit = Schema.Struct({ClientBroker: Schema.optional(Schema.String), InCluster: Schema.optional(Schema.Boolean)})
const VpcConfig = Schema.Struct({SubnetIds: __listOf__string, SecurityGroupIds: Schema.optional(__listOf__string)})
const __listOfVpcConfig = Schema.Array(VpcConfig)
const AmazonMskCluster = Schema.Struct({MskClusterArn: Schema.String})
const KafkaClusterClientVpcConfig = Schema.Struct({SecurityGroupIds: Schema.optional(__listOf__string), SubnetIds: __listOf__string})
const ConsumerGroupReplication = Schema.Struct({ConsumerGroupsToExclude: Schema.optional(__listOf__stringMax256), ConsumerGroupsToReplicate: __listOf__stringMax256, DetectAndCopyNewConsumerGroups: Schema.optional(Schema.Boolean), SynchroniseConsumerGroupOffsets: Schema.optional(Schema.Boolean)})
const PublicAccess = Schema.Struct({Type: Schema.optional(Schema.String)})
const UnprocessedScramSecret = Schema.Struct({ErrorCode: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String), SecretArn: Schema.optional(Schema.String)})
const __listOfUnprocessedScramSecret = Schema.Array(UnprocessedScramSecret)
const EncryptionInfo = Schema.Struct({EncryptionAtRest: Schema.optional(EncryptionAtRest), EncryptionInTransit: Schema.optional(EncryptionInTransit)})
const ConfigurationRevision = Schema.Struct({CreationTime: Schema.Date, Description: Schema.optional(Schema.String), Revision: Schema.Number})
const KafkaCluster = Schema.Struct({AmazonMskCluster: AmazonMskCluster, VpcConfig: KafkaClusterClientVpcConfig})
const __listOfKafkaCluster = Schema.Array(KafkaCluster)
const KafkaClusterDescription = Schema.Struct({AmazonMskCluster: Schema.optional(AmazonMskCluster), KafkaClusterAlias: Schema.optional(Schema.String), VpcConfig: Schema.optional(KafkaClusterClientVpcConfig)})
const __listOfKafkaClusterDescription = Schema.Array(KafkaClusterDescription)
const ReplicationInfoDescription = Schema.Struct({ConsumerGroupReplication: Schema.optional(ConsumerGroupReplication), SourceKafkaClusterAlias: Schema.optional(Schema.String), TargetCompressionType: Schema.optional(Schema.String), TargetKafkaClusterAlias: Schema.optional(Schema.String), TopicReplication: Schema.optional(TopicReplication)})
const __listOfReplicationInfoDescription = Schema.Array(ReplicationInfoDescription)
const ReplicationStateInfo = Schema.Struct({Code: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
const CompatibleKafkaVersion = Schema.Struct({SourceVersion: Schema.optional(Schema.String), TargetVersions: Schema.optional(__listOf__string)})
const __listOfCompatibleKafkaVersion = Schema.Array(CompatibleKafkaVersion)
const ClientVpcConnection = Schema.Struct({Authentication: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), State: Schema.optional(Schema.String), VpcConnectionArn: Schema.String, Owner: Schema.optional(Schema.String)})
const __listOfClientVpcConnection = Schema.Array(ClientVpcConnection)
const ClusterOperationV2Summary = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), OperationArn: Schema.optional(Schema.String), OperationState: Schema.optional(Schema.String), OperationType: Schema.optional(Schema.String)})
const __listOfClusterOperationV2Summary = Schema.Array(ClusterOperationV2Summary)
const Configuration = Schema.Struct({Arn: Schema.String, CreationTime: Schema.Date, Description: Schema.String, KafkaVersions: __listOf__string, LatestRevision: ConfigurationRevision, Name: Schema.String, State: Schema.String})
const __listOfConfiguration = Schema.Array(Configuration)
const KafkaVersion = Schema.Struct({Version: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)})
const __listOfKafkaVersion = Schema.Array(KafkaVersion)
const VpcConnection = Schema.Struct({VpcConnectionArn: Schema.String, TargetClusterArn: Schema.String, CreationTime: Schema.optional(Schema.Date), Authentication: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), State: Schema.optional(Schema.String)})
const __listOfVpcConnection = Schema.Array(VpcConnection)
const EBSStorageInfo = Schema.Struct({ProvisionedThroughput: Schema.optional(ProvisionedThroughput), VolumeSize: Schema.optional(Schema.Number)})
const Scram = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)})
const Iam = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)})
const JmxExporterInfo = Schema.Struct({EnabledInBroker: Schema.Boolean})
const NodeExporterInfo = Schema.Struct({EnabledInBroker: Schema.Boolean})
const CloudWatchLogs = Schema.Struct({Enabled: Schema.Boolean, LogGroup: Schema.optional(Schema.String)})
const Firehose = Schema.Struct({DeliveryStream: Schema.optional(Schema.String), Enabled: Schema.Boolean})
const S3 = Schema.Struct({Bucket: Schema.optional(Schema.String), Enabled: Schema.Boolean, Prefix: Schema.optional(Schema.String)})
const ServerlessSasl = Schema.Struct({Iam: Schema.optional(Iam)})
const ReplicationStartingPosition = Schema.Struct({Type: Schema.optional(Schema.String)})
const ReplicationTopicNameConfiguration = Schema.Struct({Type: Schema.optional(Schema.String)})
const BatchAssociateScramSecretResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), UnprocessedScramSecrets: Schema.optional(__listOfUnprocessedScramSecret)})
export const BatchAssociateScramSecret = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/scram-secrets", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "BatchAssociateScramSecret" }, BatchAssociateScramSecretRequest, BatchAssociateScramSecretResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ServiceUnavailableException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
export const BatchDisassociateScramSecret = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/scram-secrets", method: "PATCH", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "BatchDisassociateScramSecret" }, BatchDisassociateScramSecretRequest, BatchDisassociateScramSecretResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateConfigurationResponse = Schema.Struct({Arn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), LatestRevision: Schema.optional(ConfigurationRevision), Name: Schema.optional(Schema.String), State: Schema.optional(Schema.String)})
export const CreateConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "CreateConfiguration" }, CreateConfigurationRequest, CreateConfigurationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyRequestsException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
export const CreateVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/vpc-connection", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "CreateVpcConnection" }, CreateVpcConnectionRequest, CreateVpcConnectionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UnauthorizedException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
export const DeleteReplicator = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/replication/v1/replicators/{ReplicatorArn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "DeleteReplicator" }, DeleteReplicatorRequest, DeleteReplicatorResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeReplicatorResponse = Schema.Struct({CreationTime: Schema.optional(Schema.Date), CurrentVersion: Schema.optional(Schema.String), IsReplicatorReference: Schema.optional(Schema.Boolean), KafkaClusters: Schema.optional(__listOfKafkaClusterDescription), ReplicationInfoList: Schema.optional(__listOfReplicationInfoDescription), ReplicatorArn: Schema.optional(Schema.String), ReplicatorDescription: Schema.optional(Schema.String), ReplicatorName: Schema.optional(Schema.String), ReplicatorResourceArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String), ServiceExecutionRoleArn: Schema.optional(Schema.String), StateInfo: Schema.optional(ReplicationStateInfo), Tags: Schema.optional(__mapOf__string)})
export const DescribeReplicator = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/replication/v1/replicators/{ReplicatorArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "DescribeReplicator" }, DescribeReplicatorRequest, DescribeReplicatorResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ConflictException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
export const GetBootstrapBrokers = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/bootstrap-brokers", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "GetBootstrapBrokers" }, GetBootstrapBrokersRequest, GetBootstrapBrokersResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetCompatibleKafkaVersionsResponse = Schema.Struct({CompatibleKafkaVersions: Schema.optional(__listOfCompatibleKafkaVersion)})
export const GetCompatibleKafkaVersions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/compatible-kafka-versions", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "GetCompatibleKafkaVersions" }, GetCompatibleKafkaVersionsRequest, GetCompatibleKafkaVersionsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListClientVpcConnectionsResponse = Schema.Struct({ClientVpcConnections: Schema.optional(__listOfClientVpcConnection), NextToken: Schema.optional(Schema.String)})
export const ListClientVpcConnections = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/client-vpc-connections", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "ListClientVpcConnections" }, ListClientVpcConnectionsRequest, ListClientVpcConnectionsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListClusterOperationsV2Response = Schema.Struct({ClusterOperationInfoList: Schema.optional(__listOfClusterOperationV2Summary), NextToken: Schema.optional(Schema.String)})
export const ListClusterOperationsV2 = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/api/v2/clusters/{ClusterArn}/operations", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "ListClusterOperationsV2" }, ListClusterOperationsV2Request, ListClusterOperationsV2Response, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListConfigurationsResponse = Schema.Struct({Configurations: Schema.optional(__listOfConfiguration), NextToken: Schema.optional(Schema.String)})
export const ListConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "ListConfigurations" }, ListConfigurationsRequest, ListConfigurationsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListKafkaVersionsResponse = Schema.Struct({KafkaVersions: Schema.optional(__listOfKafkaVersion), NextToken: Schema.optional(Schema.String)})
export const ListKafkaVersions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/kafka-versions", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "ListKafkaVersions" }, ListKafkaVersionsRequest, ListKafkaVersionsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListVpcConnectionsResponse = Schema.Struct({VpcConnections: Schema.optional(__listOfVpcConnection), NextToken: Schema.optional(Schema.String)})
export const ListVpcConnections = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/vpc-connections", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "ListVpcConnections" }, ListVpcConnectionsRequest, ListVpcConnectionsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateBrokerStorageResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)})
export const UpdateBrokerStorage = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/nodes/storage", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "UpdateBrokerStorage" }, UpdateBrokerStorageRequest, UpdateBrokerStorageResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateReplicationInfoResponse = Schema.Struct({ReplicatorArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)})
export const UpdateReplicationInfo = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/replication/v1/replicators/{ReplicatorArn}/replication-info", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "UpdateReplicationInfo" }, UpdateReplicationInfoRequest, UpdateReplicationInfoResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateStorageResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)})
export const UpdateStorage = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/storage", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "UpdateStorage" }, UpdateStorageRequest, UpdateStorageResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const StorageInfo = Schema.Struct({EbsStorageInfo: Schema.optional(EBSStorageInfo)})
const Sasl = Schema.Struct({Scram: Schema.optional(Scram), Iam: Schema.optional(Iam)})
const PrometheusInfo = Schema.Struct({JmxExporter: Schema.optional(JmxExporterInfo), NodeExporter: Schema.optional(NodeExporterInfo)})
const BrokerLogs = Schema.Struct({CloudWatchLogs: Schema.optional(CloudWatchLogs), Firehose: Schema.optional(Firehose), S3: Schema.optional(S3)})
const ServerlessClientAuthentication = Schema.Struct({Sasl: Schema.optional(ServerlessSasl)})
const TopicReplication = Schema.Struct({CopyAccessControlListsForTopics: Schema.optional(Schema.Boolean), CopyTopicConfigurations: Schema.optional(Schema.Boolean), DetectAndCopyNewTopics: Schema.optional(Schema.Boolean), StartingPosition: Schema.optional(ReplicationStartingPosition), TopicNameConfiguration: Schema.optional(ReplicationTopicNameConfiguration), TopicsToExclude: Schema.optional(__listOf__stringMax249), TopicsToReplicate: __listOf__stringMax249})
const BrokerSoftwareInfo = Schema.Struct({ConfigurationArn: Schema.optional(Schema.String), ConfigurationRevision: Schema.optional(Schema.Number), KafkaVersion: Schema.optional(Schema.String)})
const StateInfo = Schema.Struct({Code: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
const ErrorInfo = Schema.Struct({ErrorCode: Schema.optional(Schema.String), ErrorString: Schema.optional(Schema.String)})
const ClusterOperationV2Provisioned = Schema.Struct({OperationSteps: Schema.optional(__listOfClusterOperationStep), SourceClusterInfo: Schema.optional(MutableClusterInfo), TargetClusterInfo: Schema.optional(MutableClusterInfo), VpcConnectionInfo: Schema.optional(VpcConnectionInfo)})
const Provisioned = Schema.Struct({BrokerNodeGroupInfo: BrokerNodeGroupInfo, Rebalancing: Schema.optional(Rebalancing), CurrentBrokerSoftwareInfo: Schema.optional(BrokerSoftwareInfo), ClientAuthentication: Schema.optional(ClientAuthentication), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.Number, ZookeeperConnectString: Schema.optional(Schema.String), ZookeeperConnectStringTls: Schema.optional(Schema.String), StorageMode: Schema.optional(Schema.String), CustomerActionStatus: Schema.optional(Schema.String)})
const Serverless = Schema.Struct({VpcConfigs: __listOfVpcConfig, ClientAuthentication: Schema.optional(ServerlessClientAuthentication)})
const BrokerNodeInfo = Schema.Struct({AttachedENIId: Schema.optional(Schema.String), BrokerId: Schema.optional(Schema.Number), ClientSubnet: Schema.optional(Schema.String), ClientVpcIpAddress: Schema.optional(Schema.String), CurrentBrokerSoftwareInfo: Schema.optional(BrokerSoftwareInfo), Endpoints: Schema.optional(__listOf__string)})
const ControllerNodeInfo = Schema.Struct({Endpoints: Schema.optional(__listOf__string)})
const ZookeeperNodeInfo = Schema.Struct({AttachedENIId: Schema.optional(Schema.String), ClientVpcIpAddress: Schema.optional(Schema.String), Endpoints: Schema.optional(__listOf__string), ZookeeperId: Schema.optional(Schema.Number), ZookeeperVersion: Schema.optional(Schema.String)})
const KafkaClusterSummary = Schema.Struct({AmazonMskCluster: Schema.optional(AmazonMskCluster), KafkaClusterAlias: Schema.optional(Schema.String)})
const __listOfKafkaClusterSummary = Schema.Array(KafkaClusterSummary)
const ReplicationInfoSummary = Schema.Struct({SourceKafkaClusterAlias: Schema.optional(Schema.String), TargetKafkaClusterAlias: Schema.optional(Schema.String)})
const __listOfReplicationInfoSummary = Schema.Array(ReplicationInfoSummary)
const __listOf__double = Schema.Array(Schema.Number)
const VpcConnectivityTls = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)})
const BrokerNodeGroupInfo = Schema.Struct({BrokerAZDistribution: Schema.optional(Schema.String), ClientSubnets: __listOf__string, InstanceType: Schema.String, SecurityGroups: Schema.optional(__listOf__string), StorageInfo: Schema.optional(StorageInfo), ConnectivityInfo: Schema.optional(ConnectivityInfo), ZoneIds: Schema.optional(__listOf__string)})
const ClientAuthentication = Schema.Struct({Sasl: Schema.optional(Sasl), Tls: Schema.optional(Tls), Unauthenticated: Schema.optional(Unauthenticated)})
const OpenMonitoringInfo = Schema.Struct({Prometheus: PrometheusInfo})
const LoggingInfo = Schema.Struct({BrokerLogs: BrokerLogs})
const ServerlessRequest = Schema.Struct({VpcConfigs: __listOfVpcConfig, ClientAuthentication: Schema.optional(ServerlessClientAuthentication)})
const ReplicationInfo = Schema.Struct({ConsumerGroupReplication: ConsumerGroupReplication, SourceKafkaClusterArn: Schema.String, TargetCompressionType: Schema.String, TargetKafkaClusterArn: Schema.String, TopicReplication: TopicReplication})
const __listOfReplicationInfo = Schema.Array(ReplicationInfo)
const Cluster = Schema.Struct({ActiveOperationArn: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String), ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), CurrentVersion: Schema.optional(Schema.String), State: Schema.optional(Schema.String), StateInfo: Schema.optional(StateInfo), Tags: Schema.optional(__mapOf__string), Provisioned: Schema.optional(Provisioned), Serverless: Schema.optional(Serverless)})
const NodeInfo = Schema.Struct({AddedToClusterTime: Schema.optional(Schema.String), BrokerNodeInfo: Schema.optional(BrokerNodeInfo), ControllerNodeInfo: Schema.optional(ControllerNodeInfo), InstanceType: Schema.optional(Schema.String), NodeARN: Schema.optional(Schema.String), NodeType: Schema.optional(Schema.String), ZookeeperNodeInfo: Schema.optional(ZookeeperNodeInfo)})
const __listOfNodeInfo = Schema.Array(NodeInfo)
const ReplicatorSummary = Schema.Struct({CreationTime: Schema.optional(Schema.Date), CurrentVersion: Schema.optional(Schema.String), IsReplicatorReference: Schema.optional(Schema.Boolean), KafkaClustersSummary: Schema.optional(__listOfKafkaClusterSummary), ReplicationInfoSummaryList: Schema.optional(__listOfReplicationInfoSummary), ReplicatorArn: Schema.optional(Schema.String), ReplicatorName: Schema.optional(Schema.String), ReplicatorResourceArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)})
const __listOfReplicatorSummary = Schema.Array(ReplicatorSummary)
const ClusterOperationStepInfo = Schema.Struct({StepStatus: Schema.optional(Schema.String)})
const BrokerCountUpdateInfo = Schema.Struct({CreatedBrokerIds: Schema.optional(__listOf__double), DeletedBrokerIds: Schema.optional(__listOf__double)})
const UserIdentity = Schema.Struct({Type: Schema.optional(Schema.String), PrincipalId: Schema.optional(Schema.String)})
const VpcConnectionInfoServerless = Schema.Struct({CreationTime: Schema.optional(Schema.Date), Owner: Schema.optional(Schema.String), UserIdentity: Schema.optional(UserIdentity), VpcConnectionArn: Schema.optional(Schema.String)})
const CreateClusterRequest = Schema.Struct({BrokerNodeGroupInfo: BrokerNodeGroupInfo, Rebalancing: Schema.optional(Rebalancing), ClientAuthentication: Schema.optional(ClientAuthentication), ClusterName: Schema.String, ConfigurationInfo: Schema.optional(ConfigurationInfo), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), KafkaVersion: Schema.String, LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.Number, Tags: Schema.optional(__mapOf__string), StorageMode: Schema.optional(Schema.String)})
const CreateClusterV2Request = Schema.Struct({ClusterName: Schema.String, Tags: Schema.optional(__mapOf__string), Provisioned: Schema.optional(ProvisionedRequest), Serverless: Schema.optional(ServerlessRequest)})
const CreateReplicatorRequest = Schema.Struct({Description: Schema.optional(Schema.String), KafkaClusters: __listOfKafkaCluster, ReplicationInfoList: __listOfReplicationInfo, ReplicatorName: Schema.String, ServiceExecutionRoleArn: Schema.String, Tags: Schema.optional(__mapOf__string)})
const DescribeClusterV2Response = Schema.Struct({ClusterInfo: Schema.optional(Cluster)})
export const DescribeClusterV2 = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/api/v2/clusters/{ClusterArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "DescribeClusterV2" }, DescribeClusterV2Request, DescribeClusterV2Response, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListNodesResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), NodeInfoList: Schema.optional(__listOfNodeInfo)})
export const ListNodes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/nodes", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "ListNodes" }, ListNodesRequest, ListNodesResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListReplicatorsResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), Replicators: Schema.optional(__listOfReplicatorSummary)})
export const ListReplicators = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/replication/v1/replicators", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "ListReplicators" }, ListReplicatorsRequest, ListReplicatorsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const VpcConnectivityScram = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)})
const VpcConnectivityIam = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)})
const ClusterOperationStep = Schema.Struct({StepInfo: Schema.optional(ClusterOperationStepInfo), StepName: Schema.optional(Schema.String)})
const __listOfClusterOperationStep = Schema.Array(ClusterOperationStep)
const MutableClusterInfo = Schema.Struct({BrokerEBSVolumeInfo: Schema.optional(__listOfBrokerEBSVolumeInfo), ConfigurationInfo: Schema.optional(ConfigurationInfo), NumberOfBrokerNodes: Schema.optional(Schema.Number), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoring), KafkaVersion: Schema.optional(Schema.String), LoggingInfo: Schema.optional(LoggingInfo), InstanceType: Schema.optional(Schema.String), ClientAuthentication: Schema.optional(ClientAuthentication), EncryptionInfo: Schema.optional(EncryptionInfo), ConnectivityInfo: Schema.optional(ConnectivityInfo), StorageMode: Schema.optional(Schema.String), BrokerCountUpdateInfo: Schema.optional(BrokerCountUpdateInfo), Rebalancing: Schema.optional(Rebalancing)})
const VpcConnectionInfo = Schema.Struct({VpcConnectionArn: Schema.optional(Schema.String), Owner: Schema.optional(Schema.String), UserIdentity: Schema.optional(UserIdentity), CreationTime: Schema.optional(Schema.Date)})
const ClusterOperationV2Serverless = Schema.Struct({VpcConnectionInfo: Schema.optional(VpcConnectionInfoServerless)})
const JmxExporter = Schema.Struct({EnabledInBroker: Schema.Boolean})
const NodeExporter = Schema.Struct({EnabledInBroker: Schema.Boolean})
const VpcConnectivitySasl = Schema.Struct({Scram: Schema.optional(VpcConnectivityScram), Iam: Schema.optional(VpcConnectivityIam)})
const ClusterOperationInfo = Schema.Struct({ClientRequestId: Schema.optional(Schema.String), ClusterArn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), ErrorInfo: Schema.optional(ErrorInfo), OperationArn: Schema.optional(Schema.String), OperationState: Schema.optional(Schema.String), OperationSteps: Schema.optional(__listOfClusterOperationStep), OperationType: Schema.optional(Schema.String), SourceClusterInfo: Schema.optional(MutableClusterInfo), TargetClusterInfo: Schema.optional(MutableClusterInfo), VpcConnectionInfo: Schema.optional(VpcConnectionInfo)})
const ClusterOperationV2 = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), ErrorInfo: Schema.optional(ErrorInfo), OperationArn: Schema.optional(Schema.String), OperationState: Schema.optional(Schema.String), OperationType: Schema.optional(Schema.String), Provisioned: Schema.optional(ClusterOperationV2Provisioned), Serverless: Schema.optional(ClusterOperationV2Serverless)})
const Prometheus = Schema.Struct({JmxExporter: Schema.optional(JmxExporter), NodeExporter: Schema.optional(NodeExporter)})
const VpcConnectivityClientAuthentication = Schema.Struct({Sasl: Schema.optional(VpcConnectivitySasl), Tls: Schema.optional(VpcConnectivityTls)})
const CreateClusterResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), State: Schema.optional(Schema.String)})
export const CreateCluster = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "CreateCluster" }, CreateClusterRequest, CreateClusterResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateClusterV2Response = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), State: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String)})
export const CreateClusterV2 = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/api/v2/clusters", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "CreateClusterV2" }, CreateClusterV2Request, CreateClusterV2Response, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateReplicatorResponse = Schema.Struct({ReplicatorArn: Schema.optional(Schema.String), ReplicatorName: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)})
export const CreateReplicator = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/replication/v1/replicators", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "CreateReplicator" }, CreateReplicatorRequest, CreateReplicatorResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeClusterOperationResponse = Schema.Struct({ClusterOperationInfo: Schema.optional(ClusterOperationInfo)})
export const DescribeClusterOperation = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/operations/{ClusterOperationArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "DescribeClusterOperation" }, DescribeClusterOperationRequest, DescribeClusterOperationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeClusterOperationV2Response = Schema.Struct({ClusterOperationInfo: Schema.optional(ClusterOperationV2)})
export const DescribeClusterOperationV2 = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/api/v2/operations/{ClusterOperationArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "DescribeClusterOperationV2" }, DescribeClusterOperationV2Request, DescribeClusterOperationV2Response, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const OpenMonitoring = Schema.Struct({Prometheus: Prometheus})
const VpcConnectivity = Schema.Struct({ClientAuthentication: Schema.optional(VpcConnectivityClientAuthentication)})
const ClusterInfo = Schema.Struct({ActiveOperationArn: Schema.optional(Schema.String), BrokerNodeGroupInfo: Schema.optional(BrokerNodeGroupInfo), Rebalancing: Schema.optional(Rebalancing), ClientAuthentication: Schema.optional(ClientAuthentication), ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), CurrentBrokerSoftwareInfo: Schema.optional(BrokerSoftwareInfo), CurrentVersion: Schema.optional(Schema.String), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoring), LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.optional(Schema.Number), State: Schema.optional(Schema.String), StateInfo: Schema.optional(StateInfo), Tags: Schema.optional(__mapOf__string), ZookeeperConnectString: Schema.optional(Schema.String), ZookeeperConnectStringTls: Schema.optional(Schema.String), StorageMode: Schema.optional(Schema.String), CustomerActionStatus: Schema.optional(Schema.String)})
const ConnectivityInfo = Schema.Struct({PublicAccess: Schema.optional(PublicAccess), VpcConnectivity: Schema.optional(VpcConnectivity)})
const DescribeClusterResponse = Schema.Struct({ClusterInfo: Schema.optional(ClusterInfo)})
export const DescribeCluster = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "DescribeCluster" }, DescribeClusterRequest, DescribeClusterResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateConnectivityRequest = Schema.Struct({ClusterArn: Schema.String, ConnectivityInfo: ConnectivityInfo, CurrentVersion: Schema.String})
const UpdateConnectivityResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)})
export const UpdateConnectivity = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/connectivity", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "UpdateConnectivity" }, UpdateConnectivityRequest, UpdateConnectivityResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
