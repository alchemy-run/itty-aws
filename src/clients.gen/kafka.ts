import { Schema} from "effect"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const __listOf__string = Schema.Array(Schema.String);
export const BatchAssociateScramSecretRequest = Schema.Struct({ClusterArn: Schema.String, SecretArnList: __listOf__string});
export const BatchDisassociateScramSecretRequest = Schema.Struct({ClusterArn: Schema.String, SecretArnList: __listOf__string});
export const CreateConfigurationRequest = Schema.Struct({Description: Schema.optional(Schema.String), KafkaVersions: Schema.optional(__listOf__string), Name: Schema.String, ServerProperties: StreamBody()});
export const __mapOf__string = Schema.Record({key: Schema.String, value: Schema.String});
export const CreateVpcConnectionRequest = Schema.Struct({TargetClusterArn: Schema.String, Authentication: Schema.String, VpcId: Schema.String, ClientSubnets: __listOf__string, SecurityGroups: __listOf__string, Tags: Schema.optional(__mapOf__string)});
export const DeleteClusterRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.optional(Schema.String)});
export const DeleteClusterPolicyRequest = Schema.Struct({ClusterArn: Schema.String});
export const DeleteClusterPolicyResponse = Schema.Struct({});
export const DeleteConfigurationRequest = Schema.Struct({Arn: Schema.String});
export const DeleteReplicatorRequest = Schema.Struct({CurrentVersion: Schema.optional(Schema.String), ReplicatorArn: Schema.String});
export const DeleteVpcConnectionRequest = Schema.Struct({Arn: Schema.String});
export const DescribeClusterRequest = Schema.Struct({ClusterArn: Schema.String});
export const DescribeClusterOperationRequest = Schema.Struct({ClusterOperationArn: Schema.String});
export const DescribeClusterOperationV2Request = Schema.Struct({ClusterOperationArn: Schema.String});
export const DescribeClusterV2Request = Schema.Struct({ClusterArn: Schema.String});
export const DescribeConfigurationRequest = Schema.Struct({Arn: Schema.String});
export const DescribeConfigurationRevisionRequest = Schema.Struct({Arn: Schema.String, Revision: Schema.Number});
export const DescribeReplicatorRequest = Schema.Struct({ReplicatorArn: Schema.String});
export const DescribeVpcConnectionRequest = Schema.Struct({Arn: Schema.String});
export const GetBootstrapBrokersRequest = Schema.Struct({ClusterArn: Schema.String});
export const GetClusterPolicyRequest = Schema.Struct({ClusterArn: Schema.String});
export const GetCompatibleKafkaVersionsRequest = Schema.Struct({ClusterArn: Schema.optional(Schema.String)});
export const ListClientVpcConnectionsRequest = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListClusterOperationsRequest = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListClusterOperationsV2Request = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListClustersRequest = Schema.Struct({ClusterNameFilter: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListClustersV2Request = Schema.Struct({ClusterNameFilter: Schema.optional(Schema.String), ClusterTypeFilter: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListConfigurationRevisionsRequest = Schema.Struct({Arn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListConfigurationsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListKafkaVersionsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListNodesRequest = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListReplicatorsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String), ReplicatorNameFilter: Schema.optional(Schema.String)});
export const ListScramSecretsRequest = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListTagsForResourceRequest = Schema.Struct({ResourceArn: Schema.String});
export const ListVpcConnectionsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const PutClusterPolicyRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.optional(Schema.String), Policy: Schema.String});
export const RebootBrokerRequest = Schema.Struct({BrokerIds: __listOf__string, ClusterArn: Schema.String});
export const RejectClientVpcConnectionRequest = Schema.Struct({ClusterArn: Schema.String, VpcConnectionArn: Schema.String});
export const RejectClientVpcConnectionResponse = Schema.Struct({});
export const TagResourceRequest = Schema.Struct({ResourceArn: Schema.String, Tags: __mapOf__string});
export const UntagResourceRequest = Schema.Struct({ResourceArn: Schema.String, TagKeys: __listOf__string});
export const UpdateBrokerCountRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, TargetNumberOfBrokerNodes: Schema.Number});
export const UpdateBrokerTypeRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, TargetInstanceType: Schema.String});
export const ConfigurationInfo = Schema.Struct({Arn: Schema.String, Revision: Schema.Number});
export const UpdateClusterConfigurationRequest = Schema.Struct({ClusterArn: Schema.String, ConfigurationInfo: ConfigurationInfo, CurrentVersion: Schema.String});
export const UpdateClusterKafkaVersionRequest = Schema.Struct({ClusterArn: Schema.String, ConfigurationInfo: Schema.optional(ConfigurationInfo), CurrentVersion: Schema.String, TargetKafkaVersion: Schema.String});
export const UpdateConfigurationRequest = Schema.Struct({Arn: Schema.String, Description: Schema.optional(Schema.String), ServerProperties: StreamBody()});
export const JmxExporterInfo = Schema.Struct({EnabledInBroker: Schema.Boolean});
export const NodeExporterInfo = Schema.Struct({EnabledInBroker: Schema.Boolean});
export const PrometheusInfo = Schema.Struct({JmxExporter: Schema.optional(JmxExporterInfo), NodeExporter: Schema.optional(NodeExporterInfo)});
export const OpenMonitoringInfo = Schema.Struct({Prometheus: PrometheusInfo});
export const CloudWatchLogs = Schema.Struct({Enabled: Schema.Boolean, LogGroup: Schema.optional(Schema.String)});
export const Firehose = Schema.Struct({DeliveryStream: Schema.optional(Schema.String), Enabled: Schema.Boolean});
export const S3 = Schema.Struct({Bucket: Schema.optional(Schema.String), Enabled: Schema.Boolean, Prefix: Schema.optional(Schema.String)});
export const BrokerLogs = Schema.Struct({CloudWatchLogs: Schema.optional(CloudWatchLogs), Firehose: Schema.optional(Firehose), S3: Schema.optional(S3)});
export const LoggingInfo = Schema.Struct({BrokerLogs: BrokerLogs});
export const UpdateMonitoringRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), LoggingInfo: Schema.optional(LoggingInfo)});
export const Scram = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)});
export const Iam = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)});
export const Sasl = Schema.Struct({Scram: Schema.optional(Scram), Iam: Schema.optional(Iam)});
export const Tls = Schema.Struct({CertificateAuthorityArnList: Schema.optional(__listOf__string), Enabled: Schema.optional(Schema.Boolean)});
export const Unauthenticated = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)});
export const ClientAuthentication = Schema.Struct({Sasl: Schema.optional(Sasl), Tls: Schema.optional(Tls), Unauthenticated: Schema.optional(Unauthenticated)});
export const EncryptionAtRest = Schema.Struct({DataVolumeKMSKeyId: Schema.String});
export const EncryptionInTransit = Schema.Struct({ClientBroker: Schema.optional(Schema.String), InCluster: Schema.optional(Schema.Boolean)});
export const EncryptionInfo = Schema.Struct({EncryptionAtRest: Schema.optional(EncryptionAtRest), EncryptionInTransit: Schema.optional(EncryptionInTransit)});
export const UpdateSecurityRequest = Schema.Struct({ClientAuthentication: Schema.optional(ClientAuthentication), ClusterArn: Schema.String, CurrentVersion: Schema.String, EncryptionInfo: Schema.optional(EncryptionInfo)});
export const __listOf__stringMax256 = Schema.Array(Schema.String);
export const __listOf__stringMax249 = Schema.Array(Schema.String);
export const ProvisionedThroughput = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), VolumeThroughput: Schema.optional(Schema.Number)});
export const EBSStorageInfo = Schema.Struct({ProvisionedThroughput: Schema.optional(ProvisionedThroughput), VolumeSize: Schema.optional(Schema.Number)});
export const StorageInfo = Schema.Struct({EbsStorageInfo: Schema.optional(EBSStorageInfo)});
export const PublicAccess = Schema.Struct({Type: Schema.optional(Schema.String)});
export const VpcConnectivityScram = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)});
export const VpcConnectivityIam = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)});
export const VpcConnectivitySasl = Schema.Struct({Scram: Schema.optional(VpcConnectivityScram), Iam: Schema.optional(VpcConnectivityIam)});
export const VpcConnectivityTls = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)});
export const VpcConnectivityClientAuthentication = Schema.Struct({Sasl: Schema.optional(VpcConnectivitySasl), Tls: Schema.optional(VpcConnectivityTls)});
export const VpcConnectivity = Schema.Struct({ClientAuthentication: Schema.optional(VpcConnectivityClientAuthentication)});
export const ConnectivityInfo = Schema.Struct({PublicAccess: Schema.optional(PublicAccess), VpcConnectivity: Schema.optional(VpcConnectivity)});
export const BrokerNodeGroupInfo = Schema.Struct({BrokerAZDistribution: Schema.optional(Schema.String), ClientSubnets: __listOf__string, InstanceType: Schema.String, SecurityGroups: Schema.optional(__listOf__string), StorageInfo: Schema.optional(StorageInfo), ConnectivityInfo: Schema.optional(ConnectivityInfo), ZoneIds: Schema.optional(__listOf__string)});
export const ProvisionedRequest = Schema.Struct({BrokerNodeGroupInfo: BrokerNodeGroupInfo, ClientAuthentication: Schema.optional(ClientAuthentication), ConfigurationInfo: Schema.optional(ConfigurationInfo), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), KafkaVersion: Schema.String, LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.Number, StorageMode: Schema.optional(Schema.String)});
export const ErrorInfo = Schema.Struct({ErrorCode: Schema.optional(Schema.String), ErrorString: Schema.optional(Schema.String)});
export const ClusterOperationStepInfo = Schema.Struct({StepStatus: Schema.optional(Schema.String)});
export const ClusterOperationStep = Schema.Struct({StepInfo: Schema.optional(ClusterOperationStepInfo), StepName: Schema.optional(Schema.String)});
export const __listOfClusterOperationStep = Schema.Array(ClusterOperationStep);
export const BrokerEBSVolumeInfo = Schema.Struct({KafkaBrokerNodeId: Schema.String, ProvisionedThroughput: Schema.optional(ProvisionedThroughput), VolumeSizeGB: Schema.optional(Schema.Number)});
export const __listOfBrokerEBSVolumeInfo = Schema.Array(BrokerEBSVolumeInfo);
export const JmxExporter = Schema.Struct({EnabledInBroker: Schema.Boolean});
export const NodeExporter = Schema.Struct({EnabledInBroker: Schema.Boolean});
export const Prometheus = Schema.Struct({JmxExporter: Schema.optional(JmxExporter), NodeExporter: Schema.optional(NodeExporter)});
export const OpenMonitoring = Schema.Struct({Prometheus: Prometheus});
export const __listOf__double = Schema.Array(Schema.Number);
export const BrokerCountUpdateInfo = Schema.Struct({CreatedBrokerIds: Schema.optional(__listOf__double), DeletedBrokerIds: Schema.optional(__listOf__double)});
export const MutableClusterInfo = Schema.Struct({BrokerEBSVolumeInfo: Schema.optional(__listOfBrokerEBSVolumeInfo), ConfigurationInfo: Schema.optional(ConfigurationInfo), NumberOfBrokerNodes: Schema.optional(Schema.Number), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoring), KafkaVersion: Schema.optional(Schema.String), LoggingInfo: Schema.optional(LoggingInfo), InstanceType: Schema.optional(Schema.String), ClientAuthentication: Schema.optional(ClientAuthentication), EncryptionInfo: Schema.optional(EncryptionInfo), ConnectivityInfo: Schema.optional(ConnectivityInfo), StorageMode: Schema.optional(Schema.String), BrokerCountUpdateInfo: Schema.optional(BrokerCountUpdateInfo)});
export const UserIdentity = Schema.Struct({Type: Schema.optional(Schema.String), PrincipalId: Schema.optional(Schema.String)});
export const VpcConnectionInfo = Schema.Struct({VpcConnectionArn: Schema.optional(Schema.String), Owner: Schema.optional(Schema.String), UserIdentity: Schema.optional(UserIdentity), CreationTime: Schema.optional(Schema.Date)});
export const ClusterOperationInfo = Schema.Struct({ClientRequestId: Schema.optional(Schema.String), ClusterArn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), ErrorInfo: Schema.optional(ErrorInfo), OperationArn: Schema.optional(Schema.String), OperationState: Schema.optional(Schema.String), OperationSteps: Schema.optional(__listOfClusterOperationStep), OperationType: Schema.optional(Schema.String), SourceClusterInfo: Schema.optional(MutableClusterInfo), TargetClusterInfo: Schema.optional(MutableClusterInfo), VpcConnectionInfo: Schema.optional(VpcConnectionInfo)});
export const __listOfClusterOperationInfo = Schema.Array(ClusterOperationInfo);
export const BrokerSoftwareInfo = Schema.Struct({ConfigurationArn: Schema.optional(Schema.String), ConfigurationRevision: Schema.optional(Schema.Number), KafkaVersion: Schema.optional(Schema.String)});
export const StateInfo = Schema.Struct({Code: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const ClusterInfo = Schema.Struct({ActiveOperationArn: Schema.optional(Schema.String), BrokerNodeGroupInfo: Schema.optional(BrokerNodeGroupInfo), ClientAuthentication: Schema.optional(ClientAuthentication), ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), CurrentBrokerSoftwareInfo: Schema.optional(BrokerSoftwareInfo), CurrentVersion: Schema.optional(Schema.String), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoring), LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.optional(Schema.Number), State: Schema.optional(Schema.String), StateInfo: Schema.optional(StateInfo), Tags: Schema.optional(__mapOf__string), ZookeeperConnectString: Schema.optional(Schema.String), ZookeeperConnectStringTls: Schema.optional(Schema.String), StorageMode: Schema.optional(Schema.String), CustomerActionStatus: Schema.optional(Schema.String)});
export const __listOfClusterInfo = Schema.Array(ClusterInfo);
export const Provisioned = Schema.Struct({BrokerNodeGroupInfo: BrokerNodeGroupInfo, CurrentBrokerSoftwareInfo: Schema.optional(BrokerSoftwareInfo), ClientAuthentication: Schema.optional(ClientAuthentication), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.Number, ZookeeperConnectString: Schema.optional(Schema.String), ZookeeperConnectStringTls: Schema.optional(Schema.String), StorageMode: Schema.optional(Schema.String), CustomerActionStatus: Schema.optional(Schema.String)});
export const VpcConfig = Schema.Struct({SubnetIds: __listOf__string, SecurityGroupIds: Schema.optional(__listOf__string)});
export const __listOfVpcConfig = Schema.Array(VpcConfig);
export const ServerlessSasl = Schema.Struct({Iam: Schema.optional(Iam)});
export const ServerlessClientAuthentication = Schema.Struct({Sasl: Schema.optional(ServerlessSasl)});
export const Serverless = Schema.Struct({VpcConfigs: __listOfVpcConfig, ClientAuthentication: Schema.optional(ServerlessClientAuthentication)});
export const Cluster = Schema.Struct({ActiveOperationArn: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String), ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), CurrentVersion: Schema.optional(Schema.String), State: Schema.optional(Schema.String), StateInfo: Schema.optional(StateInfo), Tags: Schema.optional(__mapOf__string), Provisioned: Schema.optional(Provisioned), Serverless: Schema.optional(Serverless)});
export const __listOfCluster = Schema.Array(Cluster);
export const ConfigurationRevision = Schema.Struct({CreationTime: Schema.Date, Description: Schema.optional(Schema.String), Revision: Schema.Number});
export const __listOfConfigurationRevision = Schema.Array(ConfigurationRevision);
export const ConsumerGroupReplicationUpdate = Schema.Struct({ConsumerGroupsToExclude: __listOf__stringMax256, ConsumerGroupsToReplicate: __listOf__stringMax256, DetectAndCopyNewConsumerGroups: Schema.Boolean, SynchroniseConsumerGroupOffsets: Schema.Boolean});
export const TopicReplicationUpdate = Schema.Struct({CopyAccessControlListsForTopics: Schema.Boolean, CopyTopicConfigurations: Schema.Boolean, DetectAndCopyNewTopics: Schema.Boolean, TopicsToExclude: __listOf__stringMax249, TopicsToReplicate: __listOf__stringMax249});
export const UnprocessedScramSecret = Schema.Struct({ErrorCode: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String), SecretArn: Schema.optional(Schema.String)});
export const __listOfUnprocessedScramSecret = Schema.Array(UnprocessedScramSecret);
export const BatchDisassociateScramSecretResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), UnprocessedScramSecrets: Schema.optional(__listOfUnprocessedScramSecret)});
export const CreateVpcConnectionResponse = Schema.Struct({VpcConnectionArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String), Authentication: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), ClientSubnets: Schema.optional(__listOf__string), SecurityGroups: Schema.optional(__listOf__string), CreationTime: Schema.optional(Schema.Date), Tags: Schema.optional(__mapOf__string)});
export const DeleteClusterResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const BadRequestException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const DeleteConfigurationResponse = Schema.Struct({Arn: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const DeleteReplicatorResponse = Schema.Struct({ReplicatorArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)});
export const DeleteVpcConnectionResponse = Schema.Struct({VpcConnectionArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const DescribeConfigurationResponse = Schema.Struct({Arn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), Description: Schema.optional(Schema.String), KafkaVersions: Schema.optional(__listOf__string), LatestRevision: Schema.optional(ConfigurationRevision), Name: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const DescribeConfigurationRevisionResponse = Schema.Struct({Arn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), Description: Schema.optional(Schema.String), Revision: Schema.optional(Schema.Number), ServerProperties: Schema.optional(StreamBody())});
export const DescribeVpcConnectionResponse = Schema.Struct({VpcConnectionArn: Schema.optional(Schema.String), TargetClusterArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String), Authentication: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), Subnets: Schema.optional(__listOf__string), SecurityGroups: Schema.optional(__listOf__string), CreationTime: Schema.optional(Schema.Date), Tags: Schema.optional(__mapOf__string)});
export const GetBootstrapBrokersResponse = Schema.Struct({BootstrapBrokerString: Schema.optional(Schema.String), BootstrapBrokerStringTls: Schema.optional(Schema.String), BootstrapBrokerStringSaslScram: Schema.optional(Schema.String), BootstrapBrokerStringSaslIam: Schema.optional(Schema.String), BootstrapBrokerStringPublicTls: Schema.optional(Schema.String), BootstrapBrokerStringPublicSaslScram: Schema.optional(Schema.String), BootstrapBrokerStringPublicSaslIam: Schema.optional(Schema.String), BootstrapBrokerStringVpcConnectivityTls: Schema.optional(Schema.String), BootstrapBrokerStringVpcConnectivitySaslScram: Schema.optional(Schema.String), BootstrapBrokerStringVpcConnectivitySaslIam: Schema.optional(Schema.String)});
export const GetClusterPolicyResponse = Schema.Struct({CurrentVersion: Schema.optional(Schema.String), Policy: Schema.optional(Schema.String)});
export const ListClusterOperationsResponse = Schema.Struct({ClusterOperationInfoList: Schema.optional(__listOfClusterOperationInfo), NextToken: Schema.optional(Schema.String)});
export const ListClustersResponse = Schema.Struct({ClusterInfoList: Schema.optional(__listOfClusterInfo), NextToken: Schema.optional(Schema.String)});
export const ListClustersV2Response = Schema.Struct({ClusterInfoList: Schema.optional(__listOfCluster), NextToken: Schema.optional(Schema.String)});
export const ListConfigurationRevisionsResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), Revisions: Schema.optional(__listOfConfigurationRevision)});
export const ListScramSecretsResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), SecretArnList: Schema.optional(__listOf__string)});
export const ListTagsForResourceResponse = Schema.Struct({Tags: Schema.optional(__mapOf__string)});
export const PutClusterPolicyResponse = Schema.Struct({CurrentVersion: Schema.optional(Schema.String)});
export const RebootBrokerResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const ForbiddenException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const InternalServerErrorException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const NotFoundException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const UpdateBrokerCountResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const UpdateBrokerStorageRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, TargetBrokerEBSVolumeInfo: __listOfBrokerEBSVolumeInfo});
export const UpdateBrokerTypeResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const UpdateClusterConfigurationResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const UpdateClusterKafkaVersionResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const UpdateConfigurationResponse = Schema.Struct({Arn: Schema.optional(Schema.String), LatestRevision: Schema.optional(ConfigurationRevision)});
export const UpdateMonitoringResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const UpdateReplicationInfoRequest = Schema.Struct({ConsumerGroupReplication: Schema.optional(ConsumerGroupReplicationUpdate), CurrentVersion: Schema.String, ReplicatorArn: Schema.String, SourceKafkaClusterArn: Schema.String, TargetKafkaClusterArn: Schema.String, TopicReplication: Schema.optional(TopicReplicationUpdate)});
export const UpdateSecurityResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const UpdateStorageRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, ProvisionedThroughput: Schema.optional(ProvisionedThroughput), StorageMode: Schema.optional(Schema.String), VolumeSizeGB: Schema.optional(Schema.Number)});
export const AmazonMskCluster = Schema.Struct({MskClusterArn: Schema.String});
export const KafkaClusterClientVpcConfig = Schema.Struct({SecurityGroupIds: Schema.optional(__listOf__string), SubnetIds: __listOf__string});
export const ConsumerGroupReplication = Schema.Struct({ConsumerGroupsToExclude: Schema.optional(__listOf__stringMax256), ConsumerGroupsToReplicate: __listOf__stringMax256, DetectAndCopyNewConsumerGroups: Schema.optional(Schema.Boolean), SynchroniseConsumerGroupOffsets: Schema.optional(Schema.Boolean)});
export const KafkaCluster = Schema.Struct({AmazonMskCluster: AmazonMskCluster, VpcConfig: KafkaClusterClientVpcConfig});
export const __listOfKafkaCluster = Schema.Array(KafkaCluster);
export const KafkaClusterDescription = Schema.Struct({AmazonMskCluster: Schema.optional(AmazonMskCluster), KafkaClusterAlias: Schema.optional(Schema.String), VpcConfig: Schema.optional(KafkaClusterClientVpcConfig)});
export const __listOfKafkaClusterDescription = Schema.Array(KafkaClusterDescription);
export const ReplicationStartingPosition = Schema.Struct({Type: Schema.optional(Schema.String)});
export const ReplicationTopicNameConfiguration = Schema.Struct({Type: Schema.optional(Schema.String)});
export const TopicReplication = Schema.Struct({CopyAccessControlListsForTopics: Schema.optional(Schema.Boolean), CopyTopicConfigurations: Schema.optional(Schema.Boolean), DetectAndCopyNewTopics: Schema.optional(Schema.Boolean), StartingPosition: Schema.optional(ReplicationStartingPosition), TopicNameConfiguration: Schema.optional(ReplicationTopicNameConfiguration), TopicsToExclude: Schema.optional(__listOf__stringMax249), TopicsToReplicate: __listOf__stringMax249});
export const ReplicationInfoDescription = Schema.Struct({ConsumerGroupReplication: Schema.optional(ConsumerGroupReplication), SourceKafkaClusterAlias: Schema.optional(Schema.String), TargetCompressionType: Schema.optional(Schema.String), TargetKafkaClusterAlias: Schema.optional(Schema.String), TopicReplication: Schema.optional(TopicReplication)});
export const __listOfReplicationInfoDescription = Schema.Array(ReplicationInfoDescription);
export const ReplicationStateInfo = Schema.Struct({Code: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const CompatibleKafkaVersion = Schema.Struct({SourceVersion: Schema.optional(Schema.String), TargetVersions: Schema.optional(__listOf__string)});
export const __listOfCompatibleKafkaVersion = Schema.Array(CompatibleKafkaVersion);
export const ClientVpcConnection = Schema.Struct({Authentication: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), State: Schema.optional(Schema.String), VpcConnectionArn: Schema.String, Owner: Schema.optional(Schema.String)});
export const __listOfClientVpcConnection = Schema.Array(ClientVpcConnection);
export const ClusterOperationV2Summary = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), OperationArn: Schema.optional(Schema.String), OperationState: Schema.optional(Schema.String), OperationType: Schema.optional(Schema.String)});
export const __listOfClusterOperationV2Summary = Schema.Array(ClusterOperationV2Summary);
export const Configuration = Schema.Struct({Arn: Schema.String, CreationTime: Schema.Date, Description: Schema.String, KafkaVersions: __listOf__string, LatestRevision: ConfigurationRevision, Name: Schema.String, State: Schema.String});
export const __listOfConfiguration = Schema.Array(Configuration);
export const KafkaVersion = Schema.Struct({Version: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)});
export const __listOfKafkaVersion = Schema.Array(KafkaVersion);
export const VpcConnection = Schema.Struct({VpcConnectionArn: Schema.String, TargetClusterArn: Schema.String, CreationTime: Schema.optional(Schema.Date), Authentication: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const __listOfVpcConnection = Schema.Array(VpcConnection);
export const BatchAssociateScramSecretResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), UnprocessedScramSecrets: Schema.optional(__listOfUnprocessedScramSecret)});
export const ServiceUnavailableException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const CreateConfigurationResponse = Schema.Struct({Arn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), LatestRevision: Schema.optional(ConfigurationRevision), Name: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const TooManyRequestsException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const UnauthorizedException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const DescribeReplicatorResponse = Schema.Struct({CreationTime: Schema.optional(Schema.Date), CurrentVersion: Schema.optional(Schema.String), IsReplicatorReference: Schema.optional(Schema.Boolean), KafkaClusters: Schema.optional(__listOfKafkaClusterDescription), ReplicationInfoList: Schema.optional(__listOfReplicationInfoDescription), ReplicatorArn: Schema.optional(Schema.String), ReplicatorDescription: Schema.optional(Schema.String), ReplicatorName: Schema.optional(Schema.String), ReplicatorResourceArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String), ServiceExecutionRoleArn: Schema.optional(Schema.String), StateInfo: Schema.optional(ReplicationStateInfo), Tags: Schema.optional(__mapOf__string)});
export const ConflictException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const GetCompatibleKafkaVersionsResponse = Schema.Struct({CompatibleKafkaVersions: Schema.optional(__listOfCompatibleKafkaVersion)});
export const ListClientVpcConnectionsResponse = Schema.Struct({ClientVpcConnections: Schema.optional(__listOfClientVpcConnection), NextToken: Schema.optional(Schema.String)});
export const ListClusterOperationsV2Response = Schema.Struct({ClusterOperationInfoList: Schema.optional(__listOfClusterOperationV2Summary), NextToken: Schema.optional(Schema.String)});
export const ListConfigurationsResponse = Schema.Struct({Configurations: Schema.optional(__listOfConfiguration), NextToken: Schema.optional(Schema.String)});
export const ListKafkaVersionsResponse = Schema.Struct({KafkaVersions: Schema.optional(__listOfKafkaVersion), NextToken: Schema.optional(Schema.String)});
export const ListVpcConnectionsResponse = Schema.Struct({VpcConnections: Schema.optional(__listOfVpcConnection), NextToken: Schema.optional(Schema.String)});
export const UpdateBrokerStorageResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const UpdateReplicationInfoResponse = Schema.Struct({ReplicatorArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)});
export const UpdateStorageResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const ClusterOperationV2Provisioned = Schema.Struct({OperationSteps: Schema.optional(__listOfClusterOperationStep), SourceClusterInfo: Schema.optional(MutableClusterInfo), TargetClusterInfo: Schema.optional(MutableClusterInfo), VpcConnectionInfo: Schema.optional(VpcConnectionInfo)});
export const BrokerNodeInfo = Schema.Struct({AttachedENIId: Schema.optional(Schema.String), BrokerId: Schema.optional(Schema.Number), ClientSubnet: Schema.optional(Schema.String), ClientVpcIpAddress: Schema.optional(Schema.String), CurrentBrokerSoftwareInfo: Schema.optional(BrokerSoftwareInfo), Endpoints: Schema.optional(__listOf__string)});
export const ControllerNodeInfo = Schema.Struct({Endpoints: Schema.optional(__listOf__string)});
export const ZookeeperNodeInfo = Schema.Struct({AttachedENIId: Schema.optional(Schema.String), ClientVpcIpAddress: Schema.optional(Schema.String), Endpoints: Schema.optional(__listOf__string), ZookeeperId: Schema.optional(Schema.Number), ZookeeperVersion: Schema.optional(Schema.String)});
export const KafkaClusterSummary = Schema.Struct({AmazonMskCluster: Schema.optional(AmazonMskCluster), KafkaClusterAlias: Schema.optional(Schema.String)});
export const __listOfKafkaClusterSummary = Schema.Array(KafkaClusterSummary);
export const ReplicationInfoSummary = Schema.Struct({SourceKafkaClusterAlias: Schema.optional(Schema.String), TargetKafkaClusterAlias: Schema.optional(Schema.String)});
export const __listOfReplicationInfoSummary = Schema.Array(ReplicationInfoSummary);
export const ServerlessRequest = Schema.Struct({VpcConfigs: __listOfVpcConfig, ClientAuthentication: Schema.optional(ServerlessClientAuthentication)});
export const ReplicationInfo = Schema.Struct({ConsumerGroupReplication: ConsumerGroupReplication, SourceKafkaClusterArn: Schema.String, TargetCompressionType: Schema.String, TargetKafkaClusterArn: Schema.String, TopicReplication: TopicReplication});
export const __listOfReplicationInfo = Schema.Array(ReplicationInfo);
export const NodeInfo = Schema.Struct({AddedToClusterTime: Schema.optional(Schema.String), BrokerNodeInfo: Schema.optional(BrokerNodeInfo), ControllerNodeInfo: Schema.optional(ControllerNodeInfo), InstanceType: Schema.optional(Schema.String), NodeARN: Schema.optional(Schema.String), NodeType: Schema.optional(Schema.String), ZookeeperNodeInfo: Schema.optional(ZookeeperNodeInfo)});
export const __listOfNodeInfo = Schema.Array(NodeInfo);
export const ReplicatorSummary = Schema.Struct({CreationTime: Schema.optional(Schema.Date), CurrentVersion: Schema.optional(Schema.String), IsReplicatorReference: Schema.optional(Schema.Boolean), KafkaClustersSummary: Schema.optional(__listOfKafkaClusterSummary), ReplicationInfoSummaryList: Schema.optional(__listOfReplicationInfoSummary), ReplicatorArn: Schema.optional(Schema.String), ReplicatorName: Schema.optional(Schema.String), ReplicatorResourceArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)});
export const __listOfReplicatorSummary = Schema.Array(ReplicatorSummary);
export const VpcConnectionInfoServerless = Schema.Struct({CreationTime: Schema.optional(Schema.Date), Owner: Schema.optional(Schema.String), UserIdentity: Schema.optional(UserIdentity), VpcConnectionArn: Schema.optional(Schema.String)});
export const CreateClusterRequest = Schema.Struct({BrokerNodeGroupInfo: BrokerNodeGroupInfo, ClientAuthentication: Schema.optional(ClientAuthentication), ClusterName: Schema.String, ConfigurationInfo: Schema.optional(ConfigurationInfo), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), KafkaVersion: Schema.String, LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.Number, Tags: Schema.optional(__mapOf__string), StorageMode: Schema.optional(Schema.String)});
export const CreateClusterV2Request = Schema.Struct({ClusterName: Schema.String, Tags: Schema.optional(__mapOf__string), Provisioned: Schema.optional(ProvisionedRequest), Serverless: Schema.optional(ServerlessRequest)});
export const CreateReplicatorRequest = Schema.Struct({Description: Schema.optional(Schema.String), KafkaClusters: __listOfKafkaCluster, ReplicationInfoList: __listOfReplicationInfo, ReplicatorName: Schema.String, ServiceExecutionRoleArn: Schema.String, Tags: Schema.optional(__mapOf__string)});
export const DescribeClusterV2Response = Schema.Struct({ClusterInfo: Schema.optional(Cluster)});
export const ListNodesResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), NodeInfoList: Schema.optional(__listOfNodeInfo)});
export const ListReplicatorsResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), Replicators: Schema.optional(__listOfReplicatorSummary)});
export const ClusterOperationV2Serverless = Schema.Struct({VpcConnectionInfo: Schema.optional(VpcConnectionInfoServerless)});
export const ClusterOperationV2 = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), ErrorInfo: Schema.optional(ErrorInfo), OperationArn: Schema.optional(Schema.String), OperationState: Schema.optional(Schema.String), OperationType: Schema.optional(Schema.String), Provisioned: Schema.optional(ClusterOperationV2Provisioned), Serverless: Schema.optional(ClusterOperationV2Serverless)});
export const CreateClusterResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const CreateClusterV2Response = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), State: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String)});
export const CreateReplicatorResponse = Schema.Struct({ReplicatorArn: Schema.optional(Schema.String), ReplicatorName: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)});
export const DescribeClusterOperationResponse = Schema.Struct({ClusterOperationInfo: Schema.optional(ClusterOperationInfo)});
export const DescribeClusterOperationV2Response = Schema.Struct({ClusterOperationInfo: Schema.optional(ClusterOperationV2)});
export const DescribeClusterResponse = Schema.Struct({ClusterInfo: Schema.optional(ClusterInfo)});
export const UpdateConnectivityRequest = Schema.Struct({ClusterArn: Schema.String, ConnectivityInfo: ConnectivityInfo, CurrentVersion: Schema.String});
export const UpdateConnectivityResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});

//# Errors
export class BadRequestExceptionError extends Schema.TaggedError<BadRequestExceptionError>()("BadRequestException", BadRequestException) {};
export class InternalServerErrorExceptionError extends Schema.TaggedError<InternalServerErrorExceptionError>()("InternalServerErrorException", InternalServerErrorException) {};
export class ForbiddenExceptionError extends Schema.TaggedError<ForbiddenExceptionError>()("ForbiddenException", ForbiddenException) {};
export class NotFoundExceptionError extends Schema.TaggedError<NotFoundExceptionError>()("NotFoundException", NotFoundException) {};
export class ServiceUnavailableExceptionError extends Schema.TaggedError<ServiceUnavailableExceptionError>()("ServiceUnavailableException", ServiceUnavailableException) {};
export class TooManyRequestsExceptionError extends Schema.TaggedError<TooManyRequestsExceptionError>()("TooManyRequestsException", TooManyRequestsException) {};
export class UnauthorizedExceptionError extends Schema.TaggedError<UnauthorizedExceptionError>()("UnauthorizedException", UnauthorizedException) {};
export class ConflictExceptionError extends Schema.TaggedError<ConflictExceptionError>()("ConflictException", ConflictException) {};

//# Operations
export const deleteCluster = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteCluster" }, DeleteClusterRequest, DeleteClusterResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteClusterPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/policy", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteClusterPolicy" }, DeleteClusterPolicyRequest, DeleteClusterPolicyResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations/{Arn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteConfiguration" }, DeleteConfigurationRequest, DeleteConfigurationResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/vpc-connection/{Arn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteVpcConnection" }, DeleteVpcConnectionRequest, DeleteVpcConnectionResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations/{Arn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeConfiguration" }, DescribeConfigurationRequest, DescribeConfigurationResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeConfigurationRevision = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations/{Arn}/revisions/{Revision}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeConfigurationRevision" }, DescribeConfigurationRevisionRequest, DescribeConfigurationRevisionResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/vpc-connection/{Arn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeVpcConnection" }, DescribeVpcConnectionRequest, DescribeVpcConnectionResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getClusterPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/policy", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.GetClusterPolicy" }, GetClusterPolicyRequest, GetClusterPolicyResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listClusterOperations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/operations", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClusterOperations" }, ListClusterOperationsRequest, ListClusterOperationsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listClusters = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClusters" }, ListClustersRequest, ListClustersResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listClustersV2 = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/api/v2/clusters", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClustersV2" }, ListClustersV2Request, ListClustersV2Response, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listConfigurationRevisions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations/{Arn}/revisions", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListConfigurationRevisions" }, ListConfigurationRevisionsRequest, ListConfigurationRevisionsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listScramSecrets = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/scram-secrets", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListScramSecrets" }, ListScramSecretsRequest, ListScramSecretsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/tags/{ResourceArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, [BadRequestExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const putClusterPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/policy", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.PutClusterPolicy" }, PutClusterPolicyRequest, PutClusterPolicyResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const rebootBroker = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/reboot-broker", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.RebootBroker" }, RebootBrokerRequest, RebootBrokerResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const rejectClientVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/client-vpc-connection", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.RejectClientVpcConnection" }, RejectClientVpcConnectionRequest, RejectClientVpcConnectionResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const tagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/tags/{ResourceArn}", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.TagResource" }, TagResourceRequest, Schema.Struct({}), [BadRequestExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const untagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/tags/{ResourceArn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UntagResource" }, UntagResourceRequest, Schema.Struct({}), [BadRequestExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateBrokerCount = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/nodes/count", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateBrokerCount" }, UpdateBrokerCountRequest, UpdateBrokerCountResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateBrokerType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/nodes/type", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateBrokerType" }, UpdateBrokerTypeRequest, UpdateBrokerTypeResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateClusterConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/configuration", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateClusterConfiguration" }, UpdateClusterConfigurationRequest, UpdateClusterConfigurationResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateClusterKafkaVersion = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/version", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateClusterKafkaVersion" }, UpdateClusterKafkaVersionRequest, UpdateClusterKafkaVersionResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations/{Arn}", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateConfiguration" }, UpdateConfigurationRequest, UpdateConfigurationResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateMonitoring = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/monitoring", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateMonitoring" }, UpdateMonitoringRequest, UpdateMonitoringResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateSecurity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/security", method: "PATCH", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateSecurity" }, UpdateSecurityRequest, UpdateSecurityResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const batchAssociateScramSecret = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/scram-secrets", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.BatchAssociateScramSecret" }, BatchAssociateScramSecretRequest, BatchAssociateScramSecretResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const batchDisassociateScramSecret = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/scram-secrets", method: "PATCH", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.BatchDisassociateScramSecret" }, BatchDisassociateScramSecretRequest, BatchDisassociateScramSecretResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateConfiguration" }, CreateConfigurationRequest, CreateConfigurationResponse, [BadRequestExceptionError, ConflictExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/vpc-connection", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateVpcConnection" }, CreateVpcConnectionRequest, CreateVpcConnectionResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteReplicator = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/replication/v1/replicators/{ReplicatorArn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteReplicator" }, DeleteReplicatorRequest, DeleteReplicatorResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeReplicator = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/replication/v1/replicators/{ReplicatorArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeReplicator" }, DescribeReplicatorRequest, DescribeReplicatorResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getBootstrapBrokers = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/bootstrap-brokers", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.GetBootstrapBrokers" }, GetBootstrapBrokersRequest, GetBootstrapBrokersResponse, [BadRequestExceptionError, ConflictExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getCompatibleKafkaVersions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/compatible-kafka-versions", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.GetCompatibleKafkaVersions" }, GetCompatibleKafkaVersionsRequest, GetCompatibleKafkaVersionsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listClientVpcConnections = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/client-vpc-connections", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClientVpcConnections" }, ListClientVpcConnectionsRequest, ListClientVpcConnectionsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listClusterOperationsV2 = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/api/v2/clusters/{ClusterArn}/operations", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClusterOperationsV2" }, ListClusterOperationsV2Request, ListClusterOperationsV2Response, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListConfigurations" }, ListConfigurationsRequest, ListConfigurationsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listKafkaVersions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/kafka-versions", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListKafkaVersions" }, ListKafkaVersionsRequest, ListKafkaVersionsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listVpcConnections = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/vpc-connections", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListVpcConnections" }, ListVpcConnectionsRequest, ListVpcConnectionsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateBrokerStorage = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/nodes/storage", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateBrokerStorage" }, UpdateBrokerStorageRequest, UpdateBrokerStorageResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateReplicationInfo = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/replication/v1/replicators/{ReplicatorArn}/replication-info", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateReplicationInfo" }, UpdateReplicationInfoRequest, UpdateReplicationInfoResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateStorage = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/storage", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateStorage" }, UpdateStorageRequest, UpdateStorageResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeClusterV2 = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/api/v2/clusters/{ClusterArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeClusterV2" }, DescribeClusterV2Request, DescribeClusterV2Response, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listNodes = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/nodes", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListNodes" }, ListNodesRequest, ListNodesResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listReplicators = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/replication/v1/replicators", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListReplicators" }, ListReplicatorsRequest, ListReplicatorsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createCluster = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateCluster" }, CreateClusterRequest, CreateClusterResponse, [BadRequestExceptionError, ConflictExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createClusterV2 = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/api/v2/clusters", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateClusterV2" }, CreateClusterV2Request, CreateClusterV2Response, [BadRequestExceptionError, ConflictExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createReplicator = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/replication/v1/replicators", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateReplicator" }, CreateReplicatorRequest, CreateReplicatorResponse, [BadRequestExceptionError, ConflictExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeClusterOperation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/operations/{ClusterOperationArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeClusterOperation" }, DescribeClusterOperationRequest, DescribeClusterOperationResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeClusterOperationV2 = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/api/v2/operations/{ClusterOperationArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeClusterOperationV2" }, DescribeClusterOperationV2Request, DescribeClusterOperationV2Response, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeCluster = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeCluster" }, DescribeClusterRequest, DescribeClusterResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateConnectivity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/connectivity", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateConnectivity" }, UpdateConnectivityRequest, UpdateConnectivityResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
