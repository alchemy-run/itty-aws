import * as Schema from "effect/Schema"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const __listOf__string = Schema.Array(Schema.String);
export class BatchAssociateScramSecretRequest extends Schema.Class<BatchAssociateScramSecretRequest>("BatchAssociateScramSecretRequest")({ClusterArn: Schema.String, SecretArnList: __listOf__string}) {}
export class BatchDisassociateScramSecretRequest extends Schema.Class<BatchDisassociateScramSecretRequest>("BatchDisassociateScramSecretRequest")({ClusterArn: Schema.String, SecretArnList: __listOf__string}) {}
export class CreateConfigurationRequest extends Schema.Class<CreateConfigurationRequest>("CreateConfigurationRequest")({Description: Schema.optional(Schema.String), KafkaVersions: Schema.optional(__listOf__string), Name: Schema.String, ServerProperties: StreamBody()}) {}
export const __mapOf__string = Schema.Record({key: Schema.String, value: Schema.String});
export class CreateVpcConnectionRequest extends Schema.Class<CreateVpcConnectionRequest>("CreateVpcConnectionRequest")({TargetClusterArn: Schema.String, Authentication: Schema.String, VpcId: Schema.String, ClientSubnets: __listOf__string, SecurityGroups: __listOf__string, Tags: Schema.optional(__mapOf__string)}) {}
export class DeleteClusterRequest extends Schema.Class<DeleteClusterRequest>("DeleteClusterRequest")({ClusterArn: Schema.String, CurrentVersion: Schema.optional(Schema.String)}) {}
export class DeleteClusterPolicyRequest extends Schema.Class<DeleteClusterPolicyRequest>("DeleteClusterPolicyRequest")({ClusterArn: Schema.String}) {}
export class DeleteClusterPolicyResponse extends Schema.Class<DeleteClusterPolicyResponse>("DeleteClusterPolicyResponse")({}) {}
export class DeleteConfigurationRequest extends Schema.Class<DeleteConfigurationRequest>("DeleteConfigurationRequest")({Arn: Schema.String}) {}
export class DeleteReplicatorRequest extends Schema.Class<DeleteReplicatorRequest>("DeleteReplicatorRequest")({CurrentVersion: Schema.optional(Schema.String), ReplicatorArn: Schema.String}) {}
export class DeleteVpcConnectionRequest extends Schema.Class<DeleteVpcConnectionRequest>("DeleteVpcConnectionRequest")({Arn: Schema.String}) {}
export class DescribeClusterRequest extends Schema.Class<DescribeClusterRequest>("DescribeClusterRequest")({ClusterArn: Schema.String}) {}
export class DescribeClusterOperationRequest extends Schema.Class<DescribeClusterOperationRequest>("DescribeClusterOperationRequest")({ClusterOperationArn: Schema.String}) {}
export class DescribeClusterOperationV2Request extends Schema.Class<DescribeClusterOperationV2Request>("DescribeClusterOperationV2Request")({ClusterOperationArn: Schema.String}) {}
export class DescribeClusterV2Request extends Schema.Class<DescribeClusterV2Request>("DescribeClusterV2Request")({ClusterArn: Schema.String}) {}
export class DescribeConfigurationRequest extends Schema.Class<DescribeConfigurationRequest>("DescribeConfigurationRequest")({Arn: Schema.String}) {}
export class DescribeConfigurationRevisionRequest extends Schema.Class<DescribeConfigurationRevisionRequest>("DescribeConfigurationRevisionRequest")({Arn: Schema.String, Revision: Schema.Number}) {}
export class DescribeReplicatorRequest extends Schema.Class<DescribeReplicatorRequest>("DescribeReplicatorRequest")({ReplicatorArn: Schema.String}) {}
export class DescribeTopicRequest extends Schema.Class<DescribeTopicRequest>("DescribeTopicRequest")({ClusterArn: Schema.String, TopicName: Schema.String}) {}
export class DescribeTopicPartitionsRequest extends Schema.Class<DescribeTopicPartitionsRequest>("DescribeTopicPartitionsRequest")({ClusterArn: Schema.String, TopicName: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)}) {}
export class DescribeVpcConnectionRequest extends Schema.Class<DescribeVpcConnectionRequest>("DescribeVpcConnectionRequest")({Arn: Schema.String}) {}
export class GetBootstrapBrokersRequest extends Schema.Class<GetBootstrapBrokersRequest>("GetBootstrapBrokersRequest")({ClusterArn: Schema.String}) {}
export class GetClusterPolicyRequest extends Schema.Class<GetClusterPolicyRequest>("GetClusterPolicyRequest")({ClusterArn: Schema.String}) {}
export class GetCompatibleKafkaVersionsRequest extends Schema.Class<GetCompatibleKafkaVersionsRequest>("GetCompatibleKafkaVersionsRequest")({ClusterArn: Schema.optional(Schema.String)}) {}
export class ListClientVpcConnectionsRequest extends Schema.Class<ListClientVpcConnectionsRequest>("ListClientVpcConnectionsRequest")({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)}) {}
export class ListClusterOperationsRequest extends Schema.Class<ListClusterOperationsRequest>("ListClusterOperationsRequest")({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)}) {}
export class ListClusterOperationsV2Request extends Schema.Class<ListClusterOperationsV2Request>("ListClusterOperationsV2Request")({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)}) {}
export class ListClustersRequest extends Schema.Class<ListClustersRequest>("ListClustersRequest")({ClusterNameFilter: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)}) {}
export class ListClustersV2Request extends Schema.Class<ListClustersV2Request>("ListClustersV2Request")({ClusterNameFilter: Schema.optional(Schema.String), ClusterTypeFilter: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)}) {}
export class ListConfigurationRevisionsRequest extends Schema.Class<ListConfigurationRevisionsRequest>("ListConfigurationRevisionsRequest")({Arn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)}) {}
export class ListConfigurationsRequest extends Schema.Class<ListConfigurationsRequest>("ListConfigurationsRequest")({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)}) {}
export class ListKafkaVersionsRequest extends Schema.Class<ListKafkaVersionsRequest>("ListKafkaVersionsRequest")({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)}) {}
export class ListNodesRequest extends Schema.Class<ListNodesRequest>("ListNodesRequest")({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)}) {}
export class ListReplicatorsRequest extends Schema.Class<ListReplicatorsRequest>("ListReplicatorsRequest")({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String), ReplicatorNameFilter: Schema.optional(Schema.String)}) {}
export class ListScramSecretsRequest extends Schema.Class<ListScramSecretsRequest>("ListScramSecretsRequest")({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)}) {}
export class ListTagsForResourceRequest extends Schema.Class<ListTagsForResourceRequest>("ListTagsForResourceRequest")({ResourceArn: Schema.String}) {}
export class ListTopicsRequest extends Schema.Class<ListTopicsRequest>("ListTopicsRequest")({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String), TopicNameFilter: Schema.optional(Schema.String)}) {}
export class ListVpcConnectionsRequest extends Schema.Class<ListVpcConnectionsRequest>("ListVpcConnectionsRequest")({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)}) {}
export class PutClusterPolicyRequest extends Schema.Class<PutClusterPolicyRequest>("PutClusterPolicyRequest")({ClusterArn: Schema.String, CurrentVersion: Schema.optional(Schema.String), Policy: Schema.String}) {}
export class RebootBrokerRequest extends Schema.Class<RebootBrokerRequest>("RebootBrokerRequest")({BrokerIds: __listOf__string, ClusterArn: Schema.String}) {}
export class RejectClientVpcConnectionRequest extends Schema.Class<RejectClientVpcConnectionRequest>("RejectClientVpcConnectionRequest")({ClusterArn: Schema.String, VpcConnectionArn: Schema.String}) {}
export class RejectClientVpcConnectionResponse extends Schema.Class<RejectClientVpcConnectionResponse>("RejectClientVpcConnectionResponse")({}) {}
export class TagResourceRequest extends Schema.Class<TagResourceRequest>("TagResourceRequest")({ResourceArn: Schema.String, Tags: __mapOf__string}) {}
export class UntagResourceRequest extends Schema.Class<UntagResourceRequest>("UntagResourceRequest")({ResourceArn: Schema.String, TagKeys: __listOf__string}) {}
export class UpdateBrokerCountRequest extends Schema.Class<UpdateBrokerCountRequest>("UpdateBrokerCountRequest")({ClusterArn: Schema.String, CurrentVersion: Schema.String, TargetNumberOfBrokerNodes: Schema.Number}) {}
export class UpdateBrokerTypeRequest extends Schema.Class<UpdateBrokerTypeRequest>("UpdateBrokerTypeRequest")({ClusterArn: Schema.String, CurrentVersion: Schema.String, TargetInstanceType: Schema.String}) {}
export class ConfigurationInfo extends Schema.Class<ConfigurationInfo>("ConfigurationInfo")({Arn: Schema.String, Revision: Schema.Number}) {}
export class UpdateClusterConfigurationRequest extends Schema.Class<UpdateClusterConfigurationRequest>("UpdateClusterConfigurationRequest")({ClusterArn: Schema.String, ConfigurationInfo: ConfigurationInfo, CurrentVersion: Schema.String}) {}
export class UpdateClusterKafkaVersionRequest extends Schema.Class<UpdateClusterKafkaVersionRequest>("UpdateClusterKafkaVersionRequest")({ClusterArn: Schema.String, ConfigurationInfo: Schema.optional(ConfigurationInfo), CurrentVersion: Schema.String, TargetKafkaVersion: Schema.String}) {}
export class UpdateConfigurationRequest extends Schema.Class<UpdateConfigurationRequest>("UpdateConfigurationRequest")({Arn: Schema.String, Description: Schema.optional(Schema.String), ServerProperties: StreamBody()}) {}
export class JmxExporterInfo extends Schema.Class<JmxExporterInfo>("JmxExporterInfo")({EnabledInBroker: Schema.Boolean}) {}
export class NodeExporterInfo extends Schema.Class<NodeExporterInfo>("NodeExporterInfo")({EnabledInBroker: Schema.Boolean}) {}
export class PrometheusInfo extends Schema.Class<PrometheusInfo>("PrometheusInfo")({JmxExporter: Schema.optional(JmxExporterInfo), NodeExporter: Schema.optional(NodeExporterInfo)}) {}
export class OpenMonitoringInfo extends Schema.Class<OpenMonitoringInfo>("OpenMonitoringInfo")({Prometheus: PrometheusInfo}) {}
export class CloudWatchLogs extends Schema.Class<CloudWatchLogs>("CloudWatchLogs")({Enabled: Schema.Boolean, LogGroup: Schema.optional(Schema.String)}) {}
export class Firehose extends Schema.Class<Firehose>("Firehose")({DeliveryStream: Schema.optional(Schema.String), Enabled: Schema.Boolean}) {}
export class S3 extends Schema.Class<S3>("S3")({Bucket: Schema.optional(Schema.String), Enabled: Schema.Boolean, Prefix: Schema.optional(Schema.String)}) {}
export class BrokerLogs extends Schema.Class<BrokerLogs>("BrokerLogs")({CloudWatchLogs: Schema.optional(CloudWatchLogs), Firehose: Schema.optional(Firehose), S3: Schema.optional(S3)}) {}
export class LoggingInfo extends Schema.Class<LoggingInfo>("LoggingInfo")({BrokerLogs: BrokerLogs}) {}
export class UpdateMonitoringRequest extends Schema.Class<UpdateMonitoringRequest>("UpdateMonitoringRequest")({ClusterArn: Schema.String, CurrentVersion: Schema.String, EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), LoggingInfo: Schema.optional(LoggingInfo)}) {}
export class Rebalancing extends Schema.Class<Rebalancing>("Rebalancing")({Status: Schema.optional(Schema.String)}) {}
export class UpdateRebalancingRequest extends Schema.Class<UpdateRebalancingRequest>("UpdateRebalancingRequest")({ClusterArn: Schema.String, CurrentVersion: Schema.String, Rebalancing: Rebalancing}) {}
export class Scram extends Schema.Class<Scram>("Scram")({Enabled: Schema.optional(Schema.Boolean)}) {}
export class Iam extends Schema.Class<Iam>("Iam")({Enabled: Schema.optional(Schema.Boolean)}) {}
export class Sasl extends Schema.Class<Sasl>("Sasl")({Scram: Schema.optional(Scram), Iam: Schema.optional(Iam)}) {}
export class Tls extends Schema.Class<Tls>("Tls")({CertificateAuthorityArnList: Schema.optional(__listOf__string), Enabled: Schema.optional(Schema.Boolean)}) {}
export class Unauthenticated extends Schema.Class<Unauthenticated>("Unauthenticated")({Enabled: Schema.optional(Schema.Boolean)}) {}
export class ClientAuthentication extends Schema.Class<ClientAuthentication>("ClientAuthentication")({Sasl: Schema.optional(Sasl), Tls: Schema.optional(Tls), Unauthenticated: Schema.optional(Unauthenticated)}) {}
export class EncryptionAtRest extends Schema.Class<EncryptionAtRest>("EncryptionAtRest")({DataVolumeKMSKeyId: Schema.String}) {}
export class EncryptionInTransit extends Schema.Class<EncryptionInTransit>("EncryptionInTransit")({ClientBroker: Schema.optional(Schema.String), InCluster: Schema.optional(Schema.Boolean)}) {}
export class EncryptionInfo extends Schema.Class<EncryptionInfo>("EncryptionInfo")({EncryptionAtRest: Schema.optional(EncryptionAtRest), EncryptionInTransit: Schema.optional(EncryptionInTransit)}) {}
export class UpdateSecurityRequest extends Schema.Class<UpdateSecurityRequest>("UpdateSecurityRequest")({ClientAuthentication: Schema.optional(ClientAuthentication), ClusterArn: Schema.String, CurrentVersion: Schema.String, EncryptionInfo: Schema.optional(EncryptionInfo)}) {}
export const __listOf__stringMax256 = Schema.Array(Schema.String);
export const __listOf__stringMax249 = Schema.Array(Schema.String);
export class ProvisionedThroughput extends Schema.Class<ProvisionedThroughput>("ProvisionedThroughput")({Enabled: Schema.optional(Schema.Boolean), VolumeThroughput: Schema.optional(Schema.Number)}) {}
export class EBSStorageInfo extends Schema.Class<EBSStorageInfo>("EBSStorageInfo")({ProvisionedThroughput: Schema.optional(ProvisionedThroughput), VolumeSize: Schema.optional(Schema.Number)}) {}
export class StorageInfo extends Schema.Class<StorageInfo>("StorageInfo")({EbsStorageInfo: Schema.optional(EBSStorageInfo)}) {}
export class PublicAccess extends Schema.Class<PublicAccess>("PublicAccess")({Type: Schema.optional(Schema.String)}) {}
export class VpcConnectivityScram extends Schema.Class<VpcConnectivityScram>("VpcConnectivityScram")({Enabled: Schema.optional(Schema.Boolean)}) {}
export class VpcConnectivityIam extends Schema.Class<VpcConnectivityIam>("VpcConnectivityIam")({Enabled: Schema.optional(Schema.Boolean)}) {}
export class VpcConnectivitySasl extends Schema.Class<VpcConnectivitySasl>("VpcConnectivitySasl")({Scram: Schema.optional(VpcConnectivityScram), Iam: Schema.optional(VpcConnectivityIam)}) {}
export class VpcConnectivityTls extends Schema.Class<VpcConnectivityTls>("VpcConnectivityTls")({Enabled: Schema.optional(Schema.Boolean)}) {}
export class VpcConnectivityClientAuthentication extends Schema.Class<VpcConnectivityClientAuthentication>("VpcConnectivityClientAuthentication")({Sasl: Schema.optional(VpcConnectivitySasl), Tls: Schema.optional(VpcConnectivityTls)}) {}
export class VpcConnectivity extends Schema.Class<VpcConnectivity>("VpcConnectivity")({ClientAuthentication: Schema.optional(VpcConnectivityClientAuthentication)}) {}
export class ConnectivityInfo extends Schema.Class<ConnectivityInfo>("ConnectivityInfo")({PublicAccess: Schema.optional(PublicAccess), VpcConnectivity: Schema.optional(VpcConnectivity)}) {}
export class BrokerNodeGroupInfo extends Schema.Class<BrokerNodeGroupInfo>("BrokerNodeGroupInfo")({BrokerAZDistribution: Schema.optional(Schema.String), ClientSubnets: __listOf__string, InstanceType: Schema.String, SecurityGroups: Schema.optional(__listOf__string), StorageInfo: Schema.optional(StorageInfo), ConnectivityInfo: Schema.optional(ConnectivityInfo), ZoneIds: Schema.optional(__listOf__string)}) {}
export class ProvisionedRequest extends Schema.Class<ProvisionedRequest>("ProvisionedRequest")({BrokerNodeGroupInfo: BrokerNodeGroupInfo, Rebalancing: Schema.optional(Rebalancing), ClientAuthentication: Schema.optional(ClientAuthentication), ConfigurationInfo: Schema.optional(ConfigurationInfo), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), KafkaVersion: Schema.String, LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.Number, StorageMode: Schema.optional(Schema.String)}) {}
export class ErrorInfo extends Schema.Class<ErrorInfo>("ErrorInfo")({ErrorCode: Schema.optional(Schema.String), ErrorString: Schema.optional(Schema.String)}) {}
export class ClusterOperationStepInfo extends Schema.Class<ClusterOperationStepInfo>("ClusterOperationStepInfo")({StepStatus: Schema.optional(Schema.String)}) {}
export class ClusterOperationStep extends Schema.Class<ClusterOperationStep>("ClusterOperationStep")({StepInfo: Schema.optional(ClusterOperationStepInfo), StepName: Schema.optional(Schema.String)}) {}
export const __listOfClusterOperationStep = Schema.Array(ClusterOperationStep);
export class BrokerEBSVolumeInfo extends Schema.Class<BrokerEBSVolumeInfo>("BrokerEBSVolumeInfo")({KafkaBrokerNodeId: Schema.String, ProvisionedThroughput: Schema.optional(ProvisionedThroughput), VolumeSizeGB: Schema.optional(Schema.Number)}) {}
export const __listOfBrokerEBSVolumeInfo = Schema.Array(BrokerEBSVolumeInfo);
export class JmxExporter extends Schema.Class<JmxExporter>("JmxExporter")({EnabledInBroker: Schema.Boolean}) {}
export class NodeExporter extends Schema.Class<NodeExporter>("NodeExporter")({EnabledInBroker: Schema.Boolean}) {}
export class Prometheus extends Schema.Class<Prometheus>("Prometheus")({JmxExporter: Schema.optional(JmxExporter), NodeExporter: Schema.optional(NodeExporter)}) {}
export class OpenMonitoring extends Schema.Class<OpenMonitoring>("OpenMonitoring")({Prometheus: Prometheus}) {}
export const __listOf__double = Schema.Array(Schema.Number);
export class BrokerCountUpdateInfo extends Schema.Class<BrokerCountUpdateInfo>("BrokerCountUpdateInfo")({CreatedBrokerIds: Schema.optional(__listOf__double), DeletedBrokerIds: Schema.optional(__listOf__double)}) {}
export class MutableClusterInfo extends Schema.Class<MutableClusterInfo>("MutableClusterInfo")({BrokerEBSVolumeInfo: Schema.optional(__listOfBrokerEBSVolumeInfo), ConfigurationInfo: Schema.optional(ConfigurationInfo), NumberOfBrokerNodes: Schema.optional(Schema.Number), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoring), KafkaVersion: Schema.optional(Schema.String), LoggingInfo: Schema.optional(LoggingInfo), InstanceType: Schema.optional(Schema.String), ClientAuthentication: Schema.optional(ClientAuthentication), EncryptionInfo: Schema.optional(EncryptionInfo), ConnectivityInfo: Schema.optional(ConnectivityInfo), StorageMode: Schema.optional(Schema.String), BrokerCountUpdateInfo: Schema.optional(BrokerCountUpdateInfo), Rebalancing: Schema.optional(Rebalancing)}) {}
export class UserIdentity extends Schema.Class<UserIdentity>("UserIdentity")({Type: Schema.optional(Schema.String), PrincipalId: Schema.optional(Schema.String)}) {}
export class VpcConnectionInfo extends Schema.Class<VpcConnectionInfo>("VpcConnectionInfo")({VpcConnectionArn: Schema.optional(Schema.String), Owner: Schema.optional(Schema.String), UserIdentity: Schema.optional(UserIdentity), CreationTime: Schema.optional(Schema.Date)}) {}
export class ClusterOperationInfo extends Schema.Class<ClusterOperationInfo>("ClusterOperationInfo")({ClientRequestId: Schema.optional(Schema.String), ClusterArn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), ErrorInfo: Schema.optional(ErrorInfo), OperationArn: Schema.optional(Schema.String), OperationState: Schema.optional(Schema.String), OperationSteps: Schema.optional(__listOfClusterOperationStep), OperationType: Schema.optional(Schema.String), SourceClusterInfo: Schema.optional(MutableClusterInfo), TargetClusterInfo: Schema.optional(MutableClusterInfo), VpcConnectionInfo: Schema.optional(VpcConnectionInfo)}) {}
export const __listOfClusterOperationInfo = Schema.Array(ClusterOperationInfo);
export class BrokerSoftwareInfo extends Schema.Class<BrokerSoftwareInfo>("BrokerSoftwareInfo")({ConfigurationArn: Schema.optional(Schema.String), ConfigurationRevision: Schema.optional(Schema.Number), KafkaVersion: Schema.optional(Schema.String)}) {}
export class StateInfo extends Schema.Class<StateInfo>("StateInfo")({Code: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)}) {}
export class ClusterInfo extends Schema.Class<ClusterInfo>("ClusterInfo")({ActiveOperationArn: Schema.optional(Schema.String), BrokerNodeGroupInfo: Schema.optional(BrokerNodeGroupInfo), Rebalancing: Schema.optional(Rebalancing), ClientAuthentication: Schema.optional(ClientAuthentication), ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), CurrentBrokerSoftwareInfo: Schema.optional(BrokerSoftwareInfo), CurrentVersion: Schema.optional(Schema.String), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoring), LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.optional(Schema.Number), State: Schema.optional(Schema.String), StateInfo: Schema.optional(StateInfo), Tags: Schema.optional(__mapOf__string), ZookeeperConnectString: Schema.optional(Schema.String), ZookeeperConnectStringTls: Schema.optional(Schema.String), StorageMode: Schema.optional(Schema.String), CustomerActionStatus: Schema.optional(Schema.String)}) {}
export const __listOfClusterInfo = Schema.Array(ClusterInfo);
export class Provisioned extends Schema.Class<Provisioned>("Provisioned")({BrokerNodeGroupInfo: BrokerNodeGroupInfo, Rebalancing: Schema.optional(Rebalancing), CurrentBrokerSoftwareInfo: Schema.optional(BrokerSoftwareInfo), ClientAuthentication: Schema.optional(ClientAuthentication), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.Number, ZookeeperConnectString: Schema.optional(Schema.String), ZookeeperConnectStringTls: Schema.optional(Schema.String), StorageMode: Schema.optional(Schema.String), CustomerActionStatus: Schema.optional(Schema.String)}) {}
export class VpcConfig extends Schema.Class<VpcConfig>("VpcConfig")({SubnetIds: __listOf__string, SecurityGroupIds: Schema.optional(__listOf__string)}) {}
export const __listOfVpcConfig = Schema.Array(VpcConfig);
export class ServerlessSasl extends Schema.Class<ServerlessSasl>("ServerlessSasl")({Iam: Schema.optional(Iam)}) {}
export class ServerlessClientAuthentication extends Schema.Class<ServerlessClientAuthentication>("ServerlessClientAuthentication")({Sasl: Schema.optional(ServerlessSasl)}) {}
export class Serverless extends Schema.Class<Serverless>("Serverless")({VpcConfigs: __listOfVpcConfig, ClientAuthentication: Schema.optional(ServerlessClientAuthentication)}) {}
export class Cluster extends Schema.Class<Cluster>("Cluster")({ActiveOperationArn: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String), ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), CurrentVersion: Schema.optional(Schema.String), State: Schema.optional(Schema.String), StateInfo: Schema.optional(StateInfo), Tags: Schema.optional(__mapOf__string), Provisioned: Schema.optional(Provisioned), Serverless: Schema.optional(Serverless)}) {}
export const __listOfCluster = Schema.Array(Cluster);
export class ConfigurationRevision extends Schema.Class<ConfigurationRevision>("ConfigurationRevision")({CreationTime: Schema.Date, Description: Schema.optional(Schema.String), Revision: Schema.Number}) {}
export const __listOfConfigurationRevision = Schema.Array(ConfigurationRevision);
export class ConsumerGroupReplicationUpdate extends Schema.Class<ConsumerGroupReplicationUpdate>("ConsumerGroupReplicationUpdate")({ConsumerGroupsToExclude: __listOf__stringMax256, ConsumerGroupsToReplicate: __listOf__stringMax256, DetectAndCopyNewConsumerGroups: Schema.Boolean, SynchroniseConsumerGroupOffsets: Schema.Boolean}) {}
export class TopicReplicationUpdate extends Schema.Class<TopicReplicationUpdate>("TopicReplicationUpdate")({CopyAccessControlListsForTopics: Schema.Boolean, CopyTopicConfigurations: Schema.Boolean, DetectAndCopyNewTopics: Schema.Boolean, TopicsToExclude: __listOf__stringMax249, TopicsToReplicate: __listOf__stringMax249}) {}
export class UnprocessedScramSecret extends Schema.Class<UnprocessedScramSecret>("UnprocessedScramSecret")({ErrorCode: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String), SecretArn: Schema.optional(Schema.String)}) {}
export const __listOfUnprocessedScramSecret = Schema.Array(UnprocessedScramSecret);
export class BatchDisassociateScramSecretResponse extends Schema.Class<BatchDisassociateScramSecretResponse>("BatchDisassociateScramSecretResponse")({ClusterArn: Schema.optional(Schema.String), UnprocessedScramSecrets: Schema.optional(__listOfUnprocessedScramSecret)}) {}
export class CreateVpcConnectionResponse extends Schema.Class<CreateVpcConnectionResponse>("CreateVpcConnectionResponse")({VpcConnectionArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String), Authentication: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), ClientSubnets: Schema.optional(__listOf__string), SecurityGroups: Schema.optional(__listOf__string), CreationTime: Schema.optional(Schema.Date), Tags: Schema.optional(__mapOf__string)}) {}
export class DeleteClusterResponse extends Schema.Class<DeleteClusterResponse>("DeleteClusterResponse")({ClusterArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String)}) {}
export class BadRequestException extends Schema.Class<BadRequestException>("BadRequestException")({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)}) {}
export class DeleteConfigurationResponse extends Schema.Class<DeleteConfigurationResponse>("DeleteConfigurationResponse")({Arn: Schema.optional(Schema.String), State: Schema.optional(Schema.String)}) {}
export class DeleteReplicatorResponse extends Schema.Class<DeleteReplicatorResponse>("DeleteReplicatorResponse")({ReplicatorArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)}) {}
export class DeleteVpcConnectionResponse extends Schema.Class<DeleteVpcConnectionResponse>("DeleteVpcConnectionResponse")({VpcConnectionArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String)}) {}
export class DescribeConfigurationResponse extends Schema.Class<DescribeConfigurationResponse>("DescribeConfigurationResponse")({Arn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), Description: Schema.optional(Schema.String), KafkaVersions: Schema.optional(__listOf__string), LatestRevision: Schema.optional(ConfigurationRevision), Name: Schema.optional(Schema.String), State: Schema.optional(Schema.String)}) {}
export class DescribeConfigurationRevisionResponse extends Schema.Class<DescribeConfigurationRevisionResponse>("DescribeConfigurationRevisionResponse")({Arn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), Description: Schema.optional(Schema.String), Revision: Schema.optional(Schema.Number), ServerProperties: Schema.optional(StreamBody())}) {}
export class DescribeTopicResponse extends Schema.Class<DescribeTopicResponse>("DescribeTopicResponse")({TopicArn: Schema.optional(Schema.String), TopicName: Schema.optional(Schema.String), ReplicationFactor: Schema.optional(Schema.Number), PartitionCount: Schema.optional(Schema.Number), Configs: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)}) {}
export class DescribeVpcConnectionResponse extends Schema.Class<DescribeVpcConnectionResponse>("DescribeVpcConnectionResponse")({VpcConnectionArn: Schema.optional(Schema.String), TargetClusterArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String), Authentication: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), Subnets: Schema.optional(__listOf__string), SecurityGroups: Schema.optional(__listOf__string), CreationTime: Schema.optional(Schema.Date), Tags: Schema.optional(__mapOf__string)}) {}
export class GetBootstrapBrokersResponse extends Schema.Class<GetBootstrapBrokersResponse>("GetBootstrapBrokersResponse")({BootstrapBrokerString: Schema.optional(Schema.String), BootstrapBrokerStringTls: Schema.optional(Schema.String), BootstrapBrokerStringSaslScram: Schema.optional(Schema.String), BootstrapBrokerStringSaslIam: Schema.optional(Schema.String), BootstrapBrokerStringPublicTls: Schema.optional(Schema.String), BootstrapBrokerStringPublicSaslScram: Schema.optional(Schema.String), BootstrapBrokerStringPublicSaslIam: Schema.optional(Schema.String), BootstrapBrokerStringVpcConnectivityTls: Schema.optional(Schema.String), BootstrapBrokerStringVpcConnectivitySaslScram: Schema.optional(Schema.String), BootstrapBrokerStringVpcConnectivitySaslIam: Schema.optional(Schema.String)}) {}
export class GetClusterPolicyResponse extends Schema.Class<GetClusterPolicyResponse>("GetClusterPolicyResponse")({CurrentVersion: Schema.optional(Schema.String), Policy: Schema.optional(Schema.String)}) {}
export class ListClusterOperationsResponse extends Schema.Class<ListClusterOperationsResponse>("ListClusterOperationsResponse")({ClusterOperationInfoList: Schema.optional(__listOfClusterOperationInfo), NextToken: Schema.optional(Schema.String)}) {}
export class ListClustersResponse extends Schema.Class<ListClustersResponse>("ListClustersResponse")({ClusterInfoList: Schema.optional(__listOfClusterInfo), NextToken: Schema.optional(Schema.String)}) {}
export class ListClustersV2Response extends Schema.Class<ListClustersV2Response>("ListClustersV2Response")({ClusterInfoList: Schema.optional(__listOfCluster), NextToken: Schema.optional(Schema.String)}) {}
export class ListConfigurationRevisionsResponse extends Schema.Class<ListConfigurationRevisionsResponse>("ListConfigurationRevisionsResponse")({NextToken: Schema.optional(Schema.String), Revisions: Schema.optional(__listOfConfigurationRevision)}) {}
export class ListScramSecretsResponse extends Schema.Class<ListScramSecretsResponse>("ListScramSecretsResponse")({NextToken: Schema.optional(Schema.String), SecretArnList: Schema.optional(__listOf__string)}) {}
export class ListTagsForResourceResponse extends Schema.Class<ListTagsForResourceResponse>("ListTagsForResourceResponse")({Tags: Schema.optional(__mapOf__string)}) {}
export class PutClusterPolicyResponse extends Schema.Class<PutClusterPolicyResponse>("PutClusterPolicyResponse")({CurrentVersion: Schema.optional(Schema.String)}) {}
export class RebootBrokerResponse extends Schema.Class<RebootBrokerResponse>("RebootBrokerResponse")({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)}) {}
export class ForbiddenException extends Schema.Class<ForbiddenException>("ForbiddenException")({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)}) {}
export class InternalServerErrorException extends Schema.Class<InternalServerErrorException>("InternalServerErrorException")({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)}) {}
export class NotFoundException extends Schema.Class<NotFoundException>("NotFoundException")({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)}) {}
export class UpdateBrokerCountResponse extends Schema.Class<UpdateBrokerCountResponse>("UpdateBrokerCountResponse")({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)}) {}
export class UpdateBrokerStorageRequest extends Schema.Class<UpdateBrokerStorageRequest>("UpdateBrokerStorageRequest")({ClusterArn: Schema.String, CurrentVersion: Schema.String, TargetBrokerEBSVolumeInfo: __listOfBrokerEBSVolumeInfo}) {}
export class UpdateBrokerTypeResponse extends Schema.Class<UpdateBrokerTypeResponse>("UpdateBrokerTypeResponse")({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)}) {}
export class UpdateClusterConfigurationResponse extends Schema.Class<UpdateClusterConfigurationResponse>("UpdateClusterConfigurationResponse")({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)}) {}
export class UpdateClusterKafkaVersionResponse extends Schema.Class<UpdateClusterKafkaVersionResponse>("UpdateClusterKafkaVersionResponse")({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)}) {}
export class UpdateConfigurationResponse extends Schema.Class<UpdateConfigurationResponse>("UpdateConfigurationResponse")({Arn: Schema.optional(Schema.String), LatestRevision: Schema.optional(ConfigurationRevision)}) {}
export class UpdateMonitoringResponse extends Schema.Class<UpdateMonitoringResponse>("UpdateMonitoringResponse")({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)}) {}
export class UpdateRebalancingResponse extends Schema.Class<UpdateRebalancingResponse>("UpdateRebalancingResponse")({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)}) {}
export class UpdateReplicationInfoRequest extends Schema.Class<UpdateReplicationInfoRequest>("UpdateReplicationInfoRequest")({ConsumerGroupReplication: Schema.optional(ConsumerGroupReplicationUpdate), CurrentVersion: Schema.String, ReplicatorArn: Schema.String, SourceKafkaClusterArn: Schema.String, TargetKafkaClusterArn: Schema.String, TopicReplication: Schema.optional(TopicReplicationUpdate)}) {}
export class UpdateSecurityResponse extends Schema.Class<UpdateSecurityResponse>("UpdateSecurityResponse")({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)}) {}
export class UpdateStorageRequest extends Schema.Class<UpdateStorageRequest>("UpdateStorageRequest")({ClusterArn: Schema.String, CurrentVersion: Schema.String, ProvisionedThroughput: Schema.optional(ProvisionedThroughput), StorageMode: Schema.optional(Schema.String), VolumeSizeGB: Schema.optional(Schema.Number)}) {}
export class AmazonMskCluster extends Schema.Class<AmazonMskCluster>("AmazonMskCluster")({MskClusterArn: Schema.String}) {}
export class KafkaClusterClientVpcConfig extends Schema.Class<KafkaClusterClientVpcConfig>("KafkaClusterClientVpcConfig")({SecurityGroupIds: Schema.optional(__listOf__string), SubnetIds: __listOf__string}) {}
export class ConsumerGroupReplication extends Schema.Class<ConsumerGroupReplication>("ConsumerGroupReplication")({ConsumerGroupsToExclude: Schema.optional(__listOf__stringMax256), ConsumerGroupsToReplicate: __listOf__stringMax256, DetectAndCopyNewConsumerGroups: Schema.optional(Schema.Boolean), SynchroniseConsumerGroupOffsets: Schema.optional(Schema.Boolean)}) {}
export const __listOf__integer = Schema.Array(Schema.Number);
export class KafkaCluster extends Schema.Class<KafkaCluster>("KafkaCluster")({AmazonMskCluster: AmazonMskCluster, VpcConfig: KafkaClusterClientVpcConfig}) {}
export const __listOfKafkaCluster = Schema.Array(KafkaCluster);
export class KafkaClusterDescription extends Schema.Class<KafkaClusterDescription>("KafkaClusterDescription")({AmazonMskCluster: Schema.optional(AmazonMskCluster), KafkaClusterAlias: Schema.optional(Schema.String), VpcConfig: Schema.optional(KafkaClusterClientVpcConfig)}) {}
export const __listOfKafkaClusterDescription = Schema.Array(KafkaClusterDescription);
export class ReplicationStartingPosition extends Schema.Class<ReplicationStartingPosition>("ReplicationStartingPosition")({Type: Schema.optional(Schema.String)}) {}
export class ReplicationTopicNameConfiguration extends Schema.Class<ReplicationTopicNameConfiguration>("ReplicationTopicNameConfiguration")({Type: Schema.optional(Schema.String)}) {}
export class TopicReplication extends Schema.Class<TopicReplication>("TopicReplication")({CopyAccessControlListsForTopics: Schema.optional(Schema.Boolean), CopyTopicConfigurations: Schema.optional(Schema.Boolean), DetectAndCopyNewTopics: Schema.optional(Schema.Boolean), StartingPosition: Schema.optional(ReplicationStartingPosition), TopicNameConfiguration: Schema.optional(ReplicationTopicNameConfiguration), TopicsToExclude: Schema.optional(__listOf__stringMax249), TopicsToReplicate: __listOf__stringMax249}) {}
export class ReplicationInfoDescription extends Schema.Class<ReplicationInfoDescription>("ReplicationInfoDescription")({ConsumerGroupReplication: Schema.optional(ConsumerGroupReplication), SourceKafkaClusterAlias: Schema.optional(Schema.String), TargetCompressionType: Schema.optional(Schema.String), TargetKafkaClusterAlias: Schema.optional(Schema.String), TopicReplication: Schema.optional(TopicReplication)}) {}
export const __listOfReplicationInfoDescription = Schema.Array(ReplicationInfoDescription);
export class ReplicationStateInfo extends Schema.Class<ReplicationStateInfo>("ReplicationStateInfo")({Code: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)}) {}
export class TopicPartitionInfo extends Schema.Class<TopicPartitionInfo>("TopicPartitionInfo")({Partition: Schema.optional(Schema.Number), Leader: Schema.optional(Schema.Number), Replicas: Schema.optional(__listOf__integer), Isr: Schema.optional(__listOf__integer)}) {}
export const __listOfTopicPartitionInfo = Schema.Array(TopicPartitionInfo);
export class CompatibleKafkaVersion extends Schema.Class<CompatibleKafkaVersion>("CompatibleKafkaVersion")({SourceVersion: Schema.optional(Schema.String), TargetVersions: Schema.optional(__listOf__string)}) {}
export const __listOfCompatibleKafkaVersion = Schema.Array(CompatibleKafkaVersion);
export class ClientVpcConnection extends Schema.Class<ClientVpcConnection>("ClientVpcConnection")({Authentication: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), State: Schema.optional(Schema.String), VpcConnectionArn: Schema.String, Owner: Schema.optional(Schema.String)}) {}
export const __listOfClientVpcConnection = Schema.Array(ClientVpcConnection);
export class ClusterOperationV2Summary extends Schema.Class<ClusterOperationV2Summary>("ClusterOperationV2Summary")({ClusterArn: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), OperationArn: Schema.optional(Schema.String), OperationState: Schema.optional(Schema.String), OperationType: Schema.optional(Schema.String)}) {}
export const __listOfClusterOperationV2Summary = Schema.Array(ClusterOperationV2Summary);
export class Configuration extends Schema.Class<Configuration>("Configuration")({Arn: Schema.String, CreationTime: Schema.Date, Description: Schema.String, KafkaVersions: __listOf__string, LatestRevision: ConfigurationRevision, Name: Schema.String, State: Schema.String}) {}
export const __listOfConfiguration = Schema.Array(Configuration);
export class KafkaVersion extends Schema.Class<KafkaVersion>("KafkaVersion")({Version: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)}) {}
export const __listOfKafkaVersion = Schema.Array(KafkaVersion);
export class TopicInfo extends Schema.Class<TopicInfo>("TopicInfo")({TopicArn: Schema.optional(Schema.String), TopicName: Schema.optional(Schema.String), ReplicationFactor: Schema.optional(Schema.Number), PartitionCount: Schema.optional(Schema.Number), OutOfSyncReplicaCount: Schema.optional(Schema.Number)}) {}
export const __listOfTopicInfo = Schema.Array(TopicInfo);
export class VpcConnection extends Schema.Class<VpcConnection>("VpcConnection")({VpcConnectionArn: Schema.String, TargetClusterArn: Schema.String, CreationTime: Schema.optional(Schema.Date), Authentication: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), State: Schema.optional(Schema.String)}) {}
export const __listOfVpcConnection = Schema.Array(VpcConnection);
export class BatchAssociateScramSecretResponse extends Schema.Class<BatchAssociateScramSecretResponse>("BatchAssociateScramSecretResponse")({ClusterArn: Schema.optional(Schema.String), UnprocessedScramSecrets: Schema.optional(__listOfUnprocessedScramSecret)}) {}
export class ServiceUnavailableException extends Schema.Class<ServiceUnavailableException>("ServiceUnavailableException")({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)}) {}
export class CreateConfigurationResponse extends Schema.Class<CreateConfigurationResponse>("CreateConfigurationResponse")({Arn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), LatestRevision: Schema.optional(ConfigurationRevision), Name: Schema.optional(Schema.String), State: Schema.optional(Schema.String)}) {}
export class TooManyRequestsException extends Schema.Class<TooManyRequestsException>("TooManyRequestsException")({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)}) {}
export class UnauthorizedException extends Schema.Class<UnauthorizedException>("UnauthorizedException")({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)}) {}
export class DescribeReplicatorResponse extends Schema.Class<DescribeReplicatorResponse>("DescribeReplicatorResponse")({CreationTime: Schema.optional(Schema.Date), CurrentVersion: Schema.optional(Schema.String), IsReplicatorReference: Schema.optional(Schema.Boolean), KafkaClusters: Schema.optional(__listOfKafkaClusterDescription), ReplicationInfoList: Schema.optional(__listOfReplicationInfoDescription), ReplicatorArn: Schema.optional(Schema.String), ReplicatorDescription: Schema.optional(Schema.String), ReplicatorName: Schema.optional(Schema.String), ReplicatorResourceArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String), ServiceExecutionRoleArn: Schema.optional(Schema.String), StateInfo: Schema.optional(ReplicationStateInfo), Tags: Schema.optional(__mapOf__string)}) {}
export class DescribeTopicPartitionsResponse extends Schema.Class<DescribeTopicPartitionsResponse>("DescribeTopicPartitionsResponse")({Partitions: Schema.optional(__listOfTopicPartitionInfo), NextToken: Schema.optional(Schema.String)}) {}
export class ConflictException extends Schema.Class<ConflictException>("ConflictException")({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)}) {}
export class GetCompatibleKafkaVersionsResponse extends Schema.Class<GetCompatibleKafkaVersionsResponse>("GetCompatibleKafkaVersionsResponse")({CompatibleKafkaVersions: Schema.optional(__listOfCompatibleKafkaVersion)}) {}
export class ListClientVpcConnectionsResponse extends Schema.Class<ListClientVpcConnectionsResponse>("ListClientVpcConnectionsResponse")({ClientVpcConnections: Schema.optional(__listOfClientVpcConnection), NextToken: Schema.optional(Schema.String)}) {}
export class ListClusterOperationsV2Response extends Schema.Class<ListClusterOperationsV2Response>("ListClusterOperationsV2Response")({ClusterOperationInfoList: Schema.optional(__listOfClusterOperationV2Summary), NextToken: Schema.optional(Schema.String)}) {}
export class ListConfigurationsResponse extends Schema.Class<ListConfigurationsResponse>("ListConfigurationsResponse")({Configurations: Schema.optional(__listOfConfiguration), NextToken: Schema.optional(Schema.String)}) {}
export class ListKafkaVersionsResponse extends Schema.Class<ListKafkaVersionsResponse>("ListKafkaVersionsResponse")({KafkaVersions: Schema.optional(__listOfKafkaVersion), NextToken: Schema.optional(Schema.String)}) {}
export class ListTopicsResponse extends Schema.Class<ListTopicsResponse>("ListTopicsResponse")({Topics: Schema.optional(__listOfTopicInfo), NextToken: Schema.optional(Schema.String)}) {}
export class ListVpcConnectionsResponse extends Schema.Class<ListVpcConnectionsResponse>("ListVpcConnectionsResponse")({VpcConnections: Schema.optional(__listOfVpcConnection), NextToken: Schema.optional(Schema.String)}) {}
export class UpdateBrokerStorageResponse extends Schema.Class<UpdateBrokerStorageResponse>("UpdateBrokerStorageResponse")({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)}) {}
export class UpdateReplicationInfoResponse extends Schema.Class<UpdateReplicationInfoResponse>("UpdateReplicationInfoResponse")({ReplicatorArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)}) {}
export class UpdateStorageResponse extends Schema.Class<UpdateStorageResponse>("UpdateStorageResponse")({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)}) {}
export class ClusterOperationV2Provisioned extends Schema.Class<ClusterOperationV2Provisioned>("ClusterOperationV2Provisioned")({OperationSteps: Schema.optional(__listOfClusterOperationStep), SourceClusterInfo: Schema.optional(MutableClusterInfo), TargetClusterInfo: Schema.optional(MutableClusterInfo), VpcConnectionInfo: Schema.optional(VpcConnectionInfo)}) {}
export class BrokerNodeInfo extends Schema.Class<BrokerNodeInfo>("BrokerNodeInfo")({AttachedENIId: Schema.optional(Schema.String), BrokerId: Schema.optional(Schema.Number), ClientSubnet: Schema.optional(Schema.String), ClientVpcIpAddress: Schema.optional(Schema.String), CurrentBrokerSoftwareInfo: Schema.optional(BrokerSoftwareInfo), Endpoints: Schema.optional(__listOf__string)}) {}
export class ControllerNodeInfo extends Schema.Class<ControllerNodeInfo>("ControllerNodeInfo")({Endpoints: Schema.optional(__listOf__string)}) {}
export class ZookeeperNodeInfo extends Schema.Class<ZookeeperNodeInfo>("ZookeeperNodeInfo")({AttachedENIId: Schema.optional(Schema.String), ClientVpcIpAddress: Schema.optional(Schema.String), Endpoints: Schema.optional(__listOf__string), ZookeeperId: Schema.optional(Schema.Number), ZookeeperVersion: Schema.optional(Schema.String)}) {}
export class KafkaClusterSummary extends Schema.Class<KafkaClusterSummary>("KafkaClusterSummary")({AmazonMskCluster: Schema.optional(AmazonMskCluster), KafkaClusterAlias: Schema.optional(Schema.String)}) {}
export const __listOfKafkaClusterSummary = Schema.Array(KafkaClusterSummary);
export class ReplicationInfoSummary extends Schema.Class<ReplicationInfoSummary>("ReplicationInfoSummary")({SourceKafkaClusterAlias: Schema.optional(Schema.String), TargetKafkaClusterAlias: Schema.optional(Schema.String)}) {}
export const __listOfReplicationInfoSummary = Schema.Array(ReplicationInfoSummary);
export class ServerlessRequest extends Schema.Class<ServerlessRequest>("ServerlessRequest")({VpcConfigs: __listOfVpcConfig, ClientAuthentication: Schema.optional(ServerlessClientAuthentication)}) {}
export class ReplicationInfo extends Schema.Class<ReplicationInfo>("ReplicationInfo")({ConsumerGroupReplication: ConsumerGroupReplication, SourceKafkaClusterArn: Schema.String, TargetCompressionType: Schema.String, TargetKafkaClusterArn: Schema.String, TopicReplication: TopicReplication}) {}
export const __listOfReplicationInfo = Schema.Array(ReplicationInfo);
export class NodeInfo extends Schema.Class<NodeInfo>("NodeInfo")({AddedToClusterTime: Schema.optional(Schema.String), BrokerNodeInfo: Schema.optional(BrokerNodeInfo), ControllerNodeInfo: Schema.optional(ControllerNodeInfo), InstanceType: Schema.optional(Schema.String), NodeARN: Schema.optional(Schema.String), NodeType: Schema.optional(Schema.String), ZookeeperNodeInfo: Schema.optional(ZookeeperNodeInfo)}) {}
export const __listOfNodeInfo = Schema.Array(NodeInfo);
export class ReplicatorSummary extends Schema.Class<ReplicatorSummary>("ReplicatorSummary")({CreationTime: Schema.optional(Schema.Date), CurrentVersion: Schema.optional(Schema.String), IsReplicatorReference: Schema.optional(Schema.Boolean), KafkaClustersSummary: Schema.optional(__listOfKafkaClusterSummary), ReplicationInfoSummaryList: Schema.optional(__listOfReplicationInfoSummary), ReplicatorArn: Schema.optional(Schema.String), ReplicatorName: Schema.optional(Schema.String), ReplicatorResourceArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)}) {}
export const __listOfReplicatorSummary = Schema.Array(ReplicatorSummary);
export class VpcConnectionInfoServerless extends Schema.Class<VpcConnectionInfoServerless>("VpcConnectionInfoServerless")({CreationTime: Schema.optional(Schema.Date), Owner: Schema.optional(Schema.String), UserIdentity: Schema.optional(UserIdentity), VpcConnectionArn: Schema.optional(Schema.String)}) {}
export class CreateClusterRequest extends Schema.Class<CreateClusterRequest>("CreateClusterRequest")({BrokerNodeGroupInfo: BrokerNodeGroupInfo, Rebalancing: Schema.optional(Rebalancing), ClientAuthentication: Schema.optional(ClientAuthentication), ClusterName: Schema.String, ConfigurationInfo: Schema.optional(ConfigurationInfo), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), KafkaVersion: Schema.String, LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.Number, Tags: Schema.optional(__mapOf__string), StorageMode: Schema.optional(Schema.String)}) {}
export class CreateClusterV2Request extends Schema.Class<CreateClusterV2Request>("CreateClusterV2Request")({ClusterName: Schema.String, Tags: Schema.optional(__mapOf__string), Provisioned: Schema.optional(ProvisionedRequest), Serverless: Schema.optional(ServerlessRequest)}) {}
export class CreateReplicatorRequest extends Schema.Class<CreateReplicatorRequest>("CreateReplicatorRequest")({Description: Schema.optional(Schema.String), KafkaClusters: __listOfKafkaCluster, ReplicationInfoList: __listOfReplicationInfo, ReplicatorName: Schema.String, ServiceExecutionRoleArn: Schema.String, Tags: Schema.optional(__mapOf__string)}) {}
export class DescribeClusterV2Response extends Schema.Class<DescribeClusterV2Response>("DescribeClusterV2Response")({ClusterInfo: Schema.optional(Cluster)}) {}
export class ListNodesResponse extends Schema.Class<ListNodesResponse>("ListNodesResponse")({NextToken: Schema.optional(Schema.String), NodeInfoList: Schema.optional(__listOfNodeInfo)}) {}
export class ListReplicatorsResponse extends Schema.Class<ListReplicatorsResponse>("ListReplicatorsResponse")({NextToken: Schema.optional(Schema.String), Replicators: Schema.optional(__listOfReplicatorSummary)}) {}
export class ClusterOperationV2Serverless extends Schema.Class<ClusterOperationV2Serverless>("ClusterOperationV2Serverless")({VpcConnectionInfo: Schema.optional(VpcConnectionInfoServerless)}) {}
export class ClusterOperationV2 extends Schema.Class<ClusterOperationV2>("ClusterOperationV2")({ClusterArn: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), ErrorInfo: Schema.optional(ErrorInfo), OperationArn: Schema.optional(Schema.String), OperationState: Schema.optional(Schema.String), OperationType: Schema.optional(Schema.String), Provisioned: Schema.optional(ClusterOperationV2Provisioned), Serverless: Schema.optional(ClusterOperationV2Serverless)}) {}
export class CreateClusterResponse extends Schema.Class<CreateClusterResponse>("CreateClusterResponse")({ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), State: Schema.optional(Schema.String)}) {}
export class CreateClusterV2Response extends Schema.Class<CreateClusterV2Response>("CreateClusterV2Response")({ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), State: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String)}) {}
export class CreateReplicatorResponse extends Schema.Class<CreateReplicatorResponse>("CreateReplicatorResponse")({ReplicatorArn: Schema.optional(Schema.String), ReplicatorName: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)}) {}
export class DescribeClusterOperationResponse extends Schema.Class<DescribeClusterOperationResponse>("DescribeClusterOperationResponse")({ClusterOperationInfo: Schema.optional(ClusterOperationInfo)}) {}
export class DescribeClusterOperationV2Response extends Schema.Class<DescribeClusterOperationV2Response>("DescribeClusterOperationV2Response")({ClusterOperationInfo: Schema.optional(ClusterOperationV2)}) {}
export class DescribeClusterResponse extends Schema.Class<DescribeClusterResponse>("DescribeClusterResponse")({ClusterInfo: Schema.optional(ClusterInfo)}) {}
export class UpdateConnectivityRequest extends Schema.Class<UpdateConnectivityRequest>("UpdateConnectivityRequest")({ClusterArn: Schema.String, ConnectivityInfo: ConnectivityInfo, CurrentVersion: Schema.String}) {}
export class UpdateConnectivityResponse extends Schema.Class<UpdateConnectivityResponse>("UpdateConnectivityResponse")({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)}) {}

//# Errors
export class BadRequestExceptionError extends Schema.TaggedError<BadRequestExceptionError>()("BadRequestException", BadRequestException.fields) {};
export class InternalServerErrorExceptionError extends Schema.TaggedError<InternalServerErrorExceptionError>()("InternalServerErrorException", InternalServerErrorException.fields) {};
export class ForbiddenExceptionError extends Schema.TaggedError<ForbiddenExceptionError>()("ForbiddenException", ForbiddenException.fields) {};
export class NotFoundExceptionError extends Schema.TaggedError<NotFoundExceptionError>()("NotFoundException", NotFoundException.fields) {};
export class ServiceUnavailableExceptionError extends Schema.TaggedError<ServiceUnavailableExceptionError>()("ServiceUnavailableException", ServiceUnavailableException.fields) {};
export class TooManyRequestsExceptionError extends Schema.TaggedError<TooManyRequestsExceptionError>()("TooManyRequestsException", TooManyRequestsException.fields) {};
export class UnauthorizedExceptionError extends Schema.TaggedError<UnauthorizedExceptionError>()("UnauthorizedException", UnauthorizedException.fields) {};
export class ConflictExceptionError extends Schema.TaggedError<ConflictExceptionError>()("ConflictException", ConflictException.fields) {};

//# Operations
export const deleteCluster = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteCluster" }, DeleteClusterRequest, DeleteClusterResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteClusterPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/policy", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteClusterPolicy" }, DeleteClusterPolicyRequest, DeleteClusterPolicyResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations/{Arn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteConfiguration" }, DeleteConfigurationRequest, DeleteConfigurationResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/vpc-connection/{Arn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteVpcConnection" }, DeleteVpcConnectionRequest, DeleteVpcConnectionResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations/{Arn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeConfiguration" }, DescribeConfigurationRequest, DescribeConfigurationResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeConfigurationRevision = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations/{Arn}/revisions/{Revision}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeConfigurationRevision" }, DescribeConfigurationRevisionRequest, DescribeConfigurationRevisionResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeTopic = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/topics/{TopicName}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeTopic" }, DescribeTopicRequest, DescribeTopicResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/vpc-connection/{Arn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeVpcConnection" }, DescribeVpcConnectionRequest, DescribeVpcConnectionResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getClusterPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/policy", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.GetClusterPolicy" }, GetClusterPolicyRequest, GetClusterPolicyResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listClusterOperations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/operations", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClusterOperations" }, ListClusterOperationsRequest, ListClusterOperationsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listClusters = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClusters" }, ListClustersRequest, ListClustersResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listClustersV2 = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/api/v2/clusters", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClustersV2" }, ListClustersV2Request, ListClustersV2Response, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listConfigurationRevisions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations/{Arn}/revisions", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListConfigurationRevisions" }, ListConfigurationRevisionsRequest, ListConfigurationRevisionsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listScramSecrets = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/scram-secrets", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListScramSecrets" }, ListScramSecretsRequest, ListScramSecretsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/tags/{ResourceArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, [BadRequestExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const putClusterPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/policy", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.PutClusterPolicy" }, PutClusterPolicyRequest, PutClusterPolicyResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const rebootBroker = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/reboot-broker", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.RebootBroker" }, RebootBrokerRequest, RebootBrokerResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const rejectClientVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/client-vpc-connection", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.RejectClientVpcConnection" }, RejectClientVpcConnectionRequest, RejectClientVpcConnectionResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const tagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/tags/{ResourceArn}", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.TagResource" }, TagResourceRequest, Schema.Struct({}), [BadRequestExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const untagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/tags/{ResourceArn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UntagResource" }, UntagResourceRequest, Schema.Struct({}), [BadRequestExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateBrokerCount = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/nodes/count", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateBrokerCount" }, UpdateBrokerCountRequest, UpdateBrokerCountResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateBrokerType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/nodes/type", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateBrokerType" }, UpdateBrokerTypeRequest, UpdateBrokerTypeResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateClusterConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/configuration", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateClusterConfiguration" }, UpdateClusterConfigurationRequest, UpdateClusterConfigurationResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateClusterKafkaVersion = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/version", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateClusterKafkaVersion" }, UpdateClusterKafkaVersionRequest, UpdateClusterKafkaVersionResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations/{Arn}", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateConfiguration" }, UpdateConfigurationRequest, UpdateConfigurationResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateMonitoring = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/monitoring", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateMonitoring" }, UpdateMonitoringRequest, UpdateMonitoringResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateRebalancing = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/rebalancing", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateRebalancing" }, UpdateRebalancingRequest, UpdateRebalancingResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateSecurity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/security", method: "PATCH", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateSecurity" }, UpdateSecurityRequest, UpdateSecurityResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const batchAssociateScramSecret = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/scram-secrets", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.BatchAssociateScramSecret" }, BatchAssociateScramSecretRequest, BatchAssociateScramSecretResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const batchDisassociateScramSecret = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/scram-secrets", method: "PATCH", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.BatchDisassociateScramSecret" }, BatchDisassociateScramSecretRequest, BatchDisassociateScramSecretResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateConfiguration" }, CreateConfigurationRequest, CreateConfigurationResponse, [BadRequestExceptionError, ConflictExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/vpc-connection", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateVpcConnection" }, CreateVpcConnectionRequest, CreateVpcConnectionResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteReplicator = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/replication/v1/replicators/{ReplicatorArn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteReplicator" }, DeleteReplicatorRequest, DeleteReplicatorResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeReplicator = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/replication/v1/replicators/{ReplicatorArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeReplicator" }, DescribeReplicatorRequest, DescribeReplicatorResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeTopicPartitions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/topics/{TopicName}/partitions", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeTopicPartitions" }, DescribeTopicPartitionsRequest, DescribeTopicPartitionsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getBootstrapBrokers = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/bootstrap-brokers", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.GetBootstrapBrokers" }, GetBootstrapBrokersRequest, GetBootstrapBrokersResponse, [BadRequestExceptionError, ConflictExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getCompatibleKafkaVersions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/compatible-kafka-versions", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.GetCompatibleKafkaVersions" }, GetCompatibleKafkaVersionsRequest, GetCompatibleKafkaVersionsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listClientVpcConnections = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/client-vpc-connections", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClientVpcConnections" }, ListClientVpcConnectionsRequest, ListClientVpcConnectionsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listClusterOperationsV2 = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/api/v2/clusters/{ClusterArn}/operations", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClusterOperationsV2" }, ListClusterOperationsV2Request, ListClusterOperationsV2Response, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/configurations", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListConfigurations" }, ListConfigurationsRequest, ListConfigurationsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listKafkaVersions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/kafka-versions", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListKafkaVersions" }, ListKafkaVersionsRequest, ListKafkaVersionsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listTopics = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/topics", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListTopics" }, ListTopicsRequest, ListTopicsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listVpcConnections = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/vpc-connections", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListVpcConnections" }, ListVpcConnectionsRequest, ListVpcConnectionsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateBrokerStorage = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/nodes/storage", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateBrokerStorage" }, UpdateBrokerStorageRequest, UpdateBrokerStorageResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateReplicationInfo = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/replication/v1/replicators/{ReplicatorArn}/replication-info", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateReplicationInfo" }, UpdateReplicationInfoRequest, UpdateReplicationInfoResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateStorage = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/storage", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateStorage" }, UpdateStorageRequest, UpdateStorageResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeClusterV2 = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/api/v2/clusters/{ClusterArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeClusterV2" }, DescribeClusterV2Request, DescribeClusterV2Response, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listNodes = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/nodes", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListNodes" }, ListNodesRequest, ListNodesResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listReplicators = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/replication/v1/replicators", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListReplicators" }, ListReplicatorsRequest, ListReplicatorsResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createCluster = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateCluster" }, CreateClusterRequest, CreateClusterResponse, [BadRequestExceptionError, ConflictExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createClusterV2 = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/api/v2/clusters", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateClusterV2" }, CreateClusterV2Request, CreateClusterV2Response, [BadRequestExceptionError, ConflictExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createReplicator = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/replication/v1/replicators", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateReplicator" }, CreateReplicatorRequest, CreateReplicatorResponse, [BadRequestExceptionError, ConflictExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeClusterOperation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/operations/{ClusterOperationArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeClusterOperation" }, DescribeClusterOperationRequest, DescribeClusterOperationResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeClusterOperationV2 = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/api/v2/operations/{ClusterOperationArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeClusterOperationV2" }, DescribeClusterOperationV2Request, DescribeClusterOperationV2Response, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, TooManyRequestsExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeCluster = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeCluster" }, DescribeClusterRequest, DescribeClusterResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateConnectivity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2018-11-14", uri: "/v1/clusters/{ClusterArn}/connectivity", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateConnectivity" }, UpdateConnectivityRequest, UpdateConnectivityResponse, [BadRequestExceptionError, ForbiddenExceptionError, InternalServerErrorExceptionError, NotFoundExceptionError, ServiceUnavailableExceptionError, UnauthorizedExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
