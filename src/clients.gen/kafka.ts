import { Schema} from "effect"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
export const __listOf__double = Schema.Array(Schema.Number);
export const ConflictException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const UnauthorizedException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const TooManyRequestsException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const ServiceUnavailableException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const ReplicationTopicNameConfiguration = Schema.Struct({Type: Schema.optional(Schema.String)});
export const ReplicationStartingPosition = Schema.Struct({Type: Schema.optional(Schema.String)});
export const UpdateBrokerStorageResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const UpdateReplicationInfoResponse = Schema.Struct({ReplicatorArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)});
export const VpcConnectivityTls = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)});
export const ReplicationInfoSummary = Schema.Struct({SourceKafkaClusterAlias: Schema.optional(Schema.String), TargetKafkaClusterAlias: Schema.optional(Schema.String)});
export const KafkaClusterSummary = Schema.Struct({AmazonMskCluster: Schema.optional(AmazonMskCluster), KafkaClusterAlias: Schema.optional(Schema.String)});
export const __listOfReplicationInfoSummary = Schema.Array(ReplicationInfoSummary);
export const UpdateStorageResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const __listOfKafkaClusterSummary = Schema.Array(KafkaClusterSummary);
export const ZookeeperNodeInfo = Schema.Struct({AttachedENIId: Schema.optional(Schema.String), ClientVpcIpAddress: Schema.optional(Schema.String), Endpoints: Schema.optional(__listOf__string), ZookeeperId: Schema.optional(Schema.Number), ZookeeperVersion: Schema.optional(Schema.String)});
export const ControllerNodeInfo = Schema.Struct({Endpoints: Schema.optional(__listOf__string)});
export const BrokerNodeInfo = Schema.Struct({AttachedENIId: Schema.optional(Schema.String), BrokerId: Schema.optional(Schema.Number), ClientSubnet: Schema.optional(Schema.String), ClientVpcIpAddress: Schema.optional(Schema.String), CurrentBrokerSoftwareInfo: Schema.optional(BrokerSoftwareInfo), Endpoints: Schema.optional(__listOf__string)});
export const Serverless = Schema.Struct({VpcConfigs: __listOfVpcConfig, ClientAuthentication: Schema.optional(ServerlessClientAuthentication)});
export const Provisioned = Schema.Struct({BrokerNodeGroupInfo: BrokerNodeGroupInfo, Rebalancing: Schema.optional(Rebalancing), CurrentBrokerSoftwareInfo: Schema.optional(BrokerSoftwareInfo), ClientAuthentication: Schema.optional(ClientAuthentication), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.Number, ZookeeperConnectString: Schema.optional(Schema.String), ZookeeperConnectStringTls: Schema.optional(Schema.String), StorageMode: Schema.optional(Schema.String), CustomerActionStatus: Schema.optional(Schema.String)});
export const VpcConnectionInfoServerless = Schema.Struct({CreationTime: Schema.optional(Schema.Date), Owner: Schema.optional(Schema.String), UserIdentity: Schema.optional(UserIdentity), VpcConnectionArn: Schema.optional(Schema.String)});
export const UserIdentity = Schema.Struct({Type: Schema.optional(Schema.String), PrincipalId: Schema.optional(Schema.String)});
export const BrokerCountUpdateInfo = Schema.Struct({CreatedBrokerIds: Schema.optional(__listOf__double), DeletedBrokerIds: Schema.optional(__listOf__double)});
export const ClusterOperationStepInfo = Schema.Struct({StepStatus: Schema.optional(Schema.String)});
export const ServerlessSasl = Schema.Struct({Iam: Schema.optional(Iam)});
export const ClusterOperationV2Provisioned = Schema.Struct({OperationSteps: Schema.optional(__listOfClusterOperationStep), SourceClusterInfo: Schema.optional(MutableClusterInfo), TargetClusterInfo: Schema.optional(MutableClusterInfo), VpcConnectionInfo: Schema.optional(VpcConnectionInfo)});
export const S3 = Schema.Struct({Bucket: Schema.optional(Schema.String), Enabled: Schema.Boolean, Prefix: Schema.optional(Schema.String)});
export const Firehose = Schema.Struct({DeliveryStream: Schema.optional(Schema.String), Enabled: Schema.Boolean});
export const CloudWatchLogs = Schema.Struct({Enabled: Schema.Boolean, LogGroup: Schema.optional(Schema.String)});
export const VpcConnectivityIam = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)});
export const VpcConnectivityScram = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)});
export const NodeExporterInfo = Schema.Struct({EnabledInBroker: Schema.Boolean});
export const ErrorInfo = Schema.Struct({ErrorCode: Schema.optional(Schema.String), ErrorString: Schema.optional(Schema.String)});
export const StateInfo = Schema.Struct({Code: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const NodeExporter = Schema.Struct({EnabledInBroker: Schema.Boolean});
export const JmxExporter = Schema.Struct({EnabledInBroker: Schema.Boolean});
export const JmxExporterInfo = Schema.Struct({EnabledInBroker: Schema.Boolean});
export const BrokerSoftwareInfo = Schema.Struct({ConfigurationArn: Schema.optional(Schema.String), ConfigurationRevision: Schema.optional(Schema.Number), KafkaVersion: Schema.optional(Schema.String)});
export const CreateClusterResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const CreateClusterV2Response = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), State: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String)});
export const CreateReplicatorResponse = Schema.Struct({ReplicatorArn: Schema.optional(Schema.String), ReplicatorName: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)});
export const Iam = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)});
export const Scram = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)});
export const EBSStorageInfo = Schema.Struct({ProvisionedThroughput: Schema.optional(ProvisionedThroughput), VolumeSize: Schema.optional(Schema.Number)});
export const __listOfVpcConnection = Schema.Array(VpcConnection);
export const VpcConnection = Schema.Struct({VpcConnectionArn: Schema.String, TargetClusterArn: Schema.String, CreationTime: Schema.optional(Schema.Date), Authentication: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const __listOfKafkaVersion = Schema.Array(KafkaVersion);
export const KafkaVersion = Schema.Struct({Version: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)});
export const VpcConnectivitySasl = Schema.Struct({Scram: Schema.optional(VpcConnectivityScram), Iam: Schema.optional(VpcConnectivityIam)});
export const Prometheus = Schema.Struct({JmxExporter: Schema.optional(JmxExporter), NodeExporter: Schema.optional(NodeExporter)});
export const __listOfConfiguration = Schema.Array(Configuration);
export const Configuration = Schema.Struct({Arn: Schema.String, CreationTime: Schema.Date, Description: Schema.String, KafkaVersions: __listOf__string, LatestRevision: ConfigurationRevision, Name: Schema.String, State: Schema.String});
export const UpdateConnectivityResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const __listOfClusterOperationV2Summary = Schema.Array(ClusterOperationV2Summary);
export const ClusterOperationV2Summary = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), OperationArn: Schema.optional(Schema.String), OperationState: Schema.optional(Schema.String), OperationType: Schema.optional(Schema.String)});
export const __listOfClientVpcConnection = Schema.Array(ClientVpcConnection);
export const ClientVpcConnection = Schema.Struct({Authentication: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), State: Schema.optional(Schema.String), VpcConnectionArn: Schema.String, Owner: Schema.optional(Schema.String)});
export const __listOfCompatibleKafkaVersion = Schema.Array(CompatibleKafkaVersion);
export const CompatibleKafkaVersion = Schema.Struct({SourceVersion: Schema.optional(Schema.String), TargetVersions: Schema.optional(__listOf__string)});
export const ReplicationStateInfo = Schema.Struct({Code: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const ClusterOperationV2Serverless = Schema.Struct({VpcConnectionInfo: Schema.optional(VpcConnectionInfoServerless)});
export const ClusterOperationStep = Schema.Struct({StepInfo: Schema.optional(ClusterOperationStepInfo), StepName: Schema.optional(Schema.String)});
export const VpcConnectionInfo = Schema.Struct({VpcConnectionArn: Schema.optional(Schema.String), Owner: Schema.optional(Schema.String), UserIdentity: Schema.optional(UserIdentity), CreationTime: Schema.optional(Schema.Date)});
export const MutableClusterInfo = Schema.Struct({BrokerEBSVolumeInfo: Schema.optional(__listOfBrokerEBSVolumeInfo), ConfigurationInfo: Schema.optional(ConfigurationInfo), NumberOfBrokerNodes: Schema.optional(Schema.Number), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoring), KafkaVersion: Schema.optional(Schema.String), LoggingInfo: Schema.optional(LoggingInfo), InstanceType: Schema.optional(Schema.String), ClientAuthentication: Schema.optional(ClientAuthentication), EncryptionInfo: Schema.optional(EncryptionInfo), ConnectivityInfo: Schema.optional(ConnectivityInfo), StorageMode: Schema.optional(Schema.String), BrokerCountUpdateInfo: Schema.optional(BrokerCountUpdateInfo), Rebalancing: Schema.optional(Rebalancing)});
export const __listOfReplicationInfoDescription = Schema.Array(ReplicationInfoDescription);
export const __listOfClusterOperationStep = Schema.Array(ClusterOperationStep);
export const ReplicationInfoDescription = Schema.Struct({ConsumerGroupReplication: Schema.optional(ConsumerGroupReplication), SourceKafkaClusterAlias: Schema.optional(Schema.String), TargetCompressionType: Schema.optional(Schema.String), TargetKafkaClusterAlias: Schema.optional(Schema.String), TopicReplication: Schema.optional(TopicReplication)});
export const __listOfKafkaClusterDescription = Schema.Array(KafkaClusterDescription);
export const KafkaClusterDescription = Schema.Struct({AmazonMskCluster: Schema.optional(AmazonMskCluster), KafkaClusterAlias: Schema.optional(Schema.String), VpcConfig: Schema.optional(KafkaClusterClientVpcConfig)});
export const ConfigurationRevision = Schema.Struct({CreationTime: Schema.Date, Description: Schema.optional(Schema.String), Revision: Schema.Number});
export const __listOfUnprocessedScramSecret = Schema.Array(UnprocessedScramSecret);
export const UnprocessedScramSecret = Schema.Struct({ErrorCode: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String), SecretArn: Schema.optional(Schema.String)});
export const PublicAccess = Schema.Struct({Type: Schema.optional(Schema.String)});
export const ConsumerGroupReplication = Schema.Struct({ConsumerGroupsToExclude: Schema.optional(__listOf__stringMax256), ConsumerGroupsToReplicate: __listOf__stringMax256, DetectAndCopyNewConsumerGroups: Schema.optional(Schema.Boolean), SynchroniseConsumerGroupOffsets: Schema.optional(Schema.Boolean)});
export const KafkaClusterClientVpcConfig = Schema.Struct({SecurityGroupIds: Schema.optional(__listOf__string), SubnetIds: __listOf__string});
export const AmazonMskCluster = Schema.Struct({MskClusterArn: Schema.String});
export const __listOfVpcConfig = Schema.Array(VpcConfig);
export const VpcConfig = Schema.Struct({SubnetIds: __listOf__string, SecurityGroupIds: Schema.optional(__listOf__string)});
export const UpdateRebalancingResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const OpenMonitoring = Schema.Struct({Prometheus: Prometheus});
export const EncryptionInTransit = Schema.Struct({ClientBroker: Schema.optional(Schema.String), InCluster: Schema.optional(Schema.Boolean)});
export const VpcConnectivityClientAuthentication = Schema.Struct({Sasl: Schema.optional(VpcConnectivitySasl), Tls: Schema.optional(VpcConnectivityTls)});
export const EncryptionAtRest = Schema.Struct({DataVolumeKMSKeyId: Schema.String});
export const ReplicatorSummary = Schema.Struct({CreationTime: Schema.optional(Schema.Date), CurrentVersion: Schema.optional(Schema.String), IsReplicatorReference: Schema.optional(Schema.Boolean), KafkaClustersSummary: Schema.optional(__listOfKafkaClusterSummary), ReplicationInfoSummaryList: Schema.optional(__listOfReplicationInfoSummary), ReplicatorArn: Schema.optional(Schema.String), ReplicatorName: Schema.optional(Schema.String), ReplicatorResourceArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)});
export const NodeInfo = Schema.Struct({AddedToClusterTime: Schema.optional(Schema.String), BrokerNodeInfo: Schema.optional(BrokerNodeInfo), ControllerNodeInfo: Schema.optional(ControllerNodeInfo), InstanceType: Schema.optional(Schema.String), NodeARN: Schema.optional(Schema.String), NodeType: Schema.optional(Schema.String), ZookeeperNodeInfo: Schema.optional(ZookeeperNodeInfo)});
export const __listOfReplicatorSummary = Schema.Array(ReplicatorSummary);
export const Unauthenticated = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)});
export const __listOfNodeInfo = Schema.Array(NodeInfo);
export const Tls = Schema.Struct({CertificateAuthorityArnList: Schema.optional(__listOf__string), Enabled: Schema.optional(Schema.Boolean)});
export const UpdateSecurityResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const UpdateMonitoringResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const UpdateConfigurationResponse = Schema.Struct({Arn: Schema.optional(Schema.String), LatestRevision: Schema.optional(ConfigurationRevision)});
export const UpdateClusterKafkaVersionResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const UpdateClusterConfigurationResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const UpdateBrokerTypeResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const UpdateBrokerCountResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const NotFoundException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const InternalServerErrorException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const ForbiddenException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const RebootBrokerResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterOperationArn: Schema.optional(Schema.String)});
export const PutClusterPolicyResponse = Schema.Struct({CurrentVersion: Schema.optional(Schema.String)});
export const ListTagsForResourceResponse = Schema.Struct({Tags: Schema.optional(__mapOf__string)});
export const ListScramSecretsResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), SecretArnList: Schema.optional(__listOf__string)});
export const ListConfigurationRevisionsResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), Revisions: Schema.optional(__listOfConfigurationRevision)});
export const ListClustersV2Response = Schema.Struct({ClusterInfoList: Schema.optional(__listOfCluster), NextToken: Schema.optional(Schema.String)});
export const ListClustersResponse = Schema.Struct({ClusterInfoList: Schema.optional(__listOfClusterInfo), NextToken: Schema.optional(Schema.String)});
export const ListClusterOperationsResponse = Schema.Struct({ClusterOperationInfoList: Schema.optional(__listOfClusterOperationInfo), NextToken: Schema.optional(Schema.String)});
export const Cluster = Schema.Struct({ActiveOperationArn: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String), ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), CurrentVersion: Schema.optional(Schema.String), State: Schema.optional(Schema.String), StateInfo: Schema.optional(StateInfo), Tags: Schema.optional(__mapOf__string), Provisioned: Schema.optional(Provisioned), Serverless: Schema.optional(Serverless)});
export const GetClusterPolicyResponse = Schema.Struct({CurrentVersion: Schema.optional(Schema.String), Policy: Schema.optional(Schema.String)});
export const GetBootstrapBrokersResponse = Schema.Struct({BootstrapBrokerString: Schema.optional(Schema.String), BootstrapBrokerStringTls: Schema.optional(Schema.String), BootstrapBrokerStringSaslScram: Schema.optional(Schema.String), BootstrapBrokerStringSaslIam: Schema.optional(Schema.String), BootstrapBrokerStringPublicTls: Schema.optional(Schema.String), BootstrapBrokerStringPublicSaslScram: Schema.optional(Schema.String), BootstrapBrokerStringPublicSaslIam: Schema.optional(Schema.String), BootstrapBrokerStringVpcConnectivityTls: Schema.optional(Schema.String), BootstrapBrokerStringVpcConnectivitySaslScram: Schema.optional(Schema.String), BootstrapBrokerStringVpcConnectivitySaslIam: Schema.optional(Schema.String)});
export const DescribeVpcConnectionResponse = Schema.Struct({VpcConnectionArn: Schema.optional(Schema.String), TargetClusterArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String), Authentication: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), Subnets: Schema.optional(__listOf__string), SecurityGroups: Schema.optional(__listOf__string), CreationTime: Schema.optional(Schema.Date), Tags: Schema.optional(__mapOf__string)});
export const TopicReplication = Schema.Struct({CopyAccessControlListsForTopics: Schema.optional(Schema.Boolean), CopyTopicConfigurations: Schema.optional(Schema.Boolean), DetectAndCopyNewTopics: Schema.optional(Schema.Boolean), StartingPosition: Schema.optional(ReplicationStartingPosition), TopicNameConfiguration: Schema.optional(ReplicationTopicNameConfiguration), TopicsToExclude: Schema.optional(__listOf__stringMax249), TopicsToReplicate: __listOf__stringMax249});
export const DescribeConfigurationRevisionResponse = Schema.Struct({Arn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), Description: Schema.optional(Schema.String), Revision: Schema.optional(Schema.Number), ServerProperties: Schema.optional(StreamBody())});
export const DescribeConfigurationResponse = Schema.Struct({Arn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), Description: Schema.optional(Schema.String), KafkaVersions: Schema.optional(__listOf__string), LatestRevision: Schema.optional(ConfigurationRevision), Name: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const DeleteVpcConnectionResponse = Schema.Struct({VpcConnectionArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const ServerlessClientAuthentication = Schema.Struct({Sasl: Schema.optional(ServerlessSasl)});
export const DeleteReplicatorResponse = Schema.Struct({ReplicatorArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String)});
export const DeleteConfigurationResponse = Schema.Struct({Arn: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const BrokerLogs = Schema.Struct({CloudWatchLogs: Schema.optional(CloudWatchLogs), Firehose: Schema.optional(Firehose), S3: Schema.optional(S3)});
export const ClusterOperationV2 = Schema.Struct({ClusterArn: Schema.optional(Schema.String), ClusterType: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), ErrorInfo: Schema.optional(ErrorInfo), OperationArn: Schema.optional(Schema.String), OperationState: Schema.optional(Schema.String), OperationType: Schema.optional(Schema.String), Provisioned: Schema.optional(ClusterOperationV2Provisioned), Serverless: Schema.optional(ClusterOperationV2Serverless)});
export const ClusterOperationInfo = Schema.Struct({ClientRequestId: Schema.optional(Schema.String), ClusterArn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), ErrorInfo: Schema.optional(ErrorInfo), OperationArn: Schema.optional(Schema.String), OperationState: Schema.optional(Schema.String), OperationSteps: Schema.optional(__listOfClusterOperationStep), OperationType: Schema.optional(Schema.String), SourceClusterInfo: Schema.optional(MutableClusterInfo), TargetClusterInfo: Schema.optional(MutableClusterInfo), VpcConnectionInfo: Schema.optional(VpcConnectionInfo)});
export const PrometheusInfo = Schema.Struct({JmxExporter: Schema.optional(JmxExporterInfo), NodeExporter: Schema.optional(NodeExporterInfo)});
export const BadRequestException = Schema.Struct({InvalidParameter: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const DeleteClusterResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const CreateVpcConnectionResponse = Schema.Struct({VpcConnectionArn: Schema.optional(Schema.String), State: Schema.optional(Schema.String), Authentication: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), ClientSubnets: Schema.optional(__listOf__string), SecurityGroups: Schema.optional(__listOf__string), CreationTime: Schema.optional(Schema.Date), Tags: Schema.optional(__mapOf__string)});
export const BatchDisassociateScramSecretResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), UnprocessedScramSecrets: Schema.optional(__listOfUnprocessedScramSecret)});
export const Sasl = Schema.Struct({Scram: Schema.optional(Scram), Iam: Schema.optional(Iam)});
export const StorageInfo = Schema.Struct({EbsStorageInfo: Schema.optional(EBSStorageInfo)});
export const ProvisionedThroughput = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), VolumeThroughput: Schema.optional(Schema.Number)});
export const TopicReplicationUpdate = Schema.Struct({CopyAccessControlListsForTopics: Schema.Boolean, CopyTopicConfigurations: Schema.Boolean, DetectAndCopyNewTopics: Schema.Boolean, TopicsToExclude: __listOf__stringMax249, TopicsToReplicate: __listOf__stringMax249});
export const ClusterInfo = Schema.Struct({ActiveOperationArn: Schema.optional(Schema.String), BrokerNodeGroupInfo: Schema.optional(BrokerNodeGroupInfo), Rebalancing: Schema.optional(Rebalancing), ClientAuthentication: Schema.optional(ClientAuthentication), ClusterArn: Schema.optional(Schema.String), ClusterName: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), CurrentBrokerSoftwareInfo: Schema.optional(BrokerSoftwareInfo), CurrentVersion: Schema.optional(Schema.String), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoring), LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.optional(Schema.Number), State: Schema.optional(Schema.String), StateInfo: Schema.optional(StateInfo), Tags: Schema.optional(__mapOf__string), ZookeeperConnectString: Schema.optional(Schema.String), ZookeeperConnectStringTls: Schema.optional(Schema.String), StorageMode: Schema.optional(Schema.String), CustomerActionStatus: Schema.optional(Schema.String)});
export const ConsumerGroupReplicationUpdate = Schema.Struct({ConsumerGroupsToExclude: __listOf__stringMax256, ConsumerGroupsToReplicate: __listOf__stringMax256, DetectAndCopyNewConsumerGroups: Schema.Boolean, SynchroniseConsumerGroupOffsets: Schema.Boolean});
export const __listOfBrokerEBSVolumeInfo = Schema.Array(BrokerEBSVolumeInfo);
export const BrokerEBSVolumeInfo = Schema.Struct({KafkaBrokerNodeId: Schema.String, ProvisionedThroughput: Schema.optional(ProvisionedThroughput), VolumeSizeGB: Schema.optional(Schema.Number)});
export const __listOfConfigurationRevision = Schema.Array(ConfigurationRevision);
export const __listOfCluster = Schema.Array(Cluster);
export const VpcConnectivity = Schema.Struct({ClientAuthentication: Schema.optional(VpcConnectivityClientAuthentication)});
export const __listOfClusterInfo = Schema.Array(ClusterInfo);
export const __listOfClusterOperationInfo = Schema.Array(ClusterOperationInfo);
export const ProvisionedRequest = Schema.Struct({BrokerNodeGroupInfo: BrokerNodeGroupInfo, Rebalancing: Schema.optional(Rebalancing), ClientAuthentication: Schema.optional(ClientAuthentication), ConfigurationInfo: Schema.optional(ConfigurationInfo), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), KafkaVersion: Schema.String, LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.Number, StorageMode: Schema.optional(Schema.String)});
export const ListVpcConnectionsResponse = Schema.Struct({VpcConnections: Schema.optional(__listOfVpcConnection), NextToken: Schema.optional(Schema.String)});
export const __mapOf__string = Schema.Record({key: Schema.String, value: Schema.String});
export const ConfigurationInfo = Schema.Struct({Arn: Schema.String, Revision: Schema.Number});
export const ListConfigurationsResponse = Schema.Struct({Configurations: Schema.optional(__listOfConfiguration), NextToken: Schema.optional(Schema.String)});
export const ListKafkaVersionsResponse = Schema.Struct({KafkaVersions: Schema.optional(__listOfKafkaVersion), NextToken: Schema.optional(Schema.String)});
export const Rebalancing = Schema.Struct({Status: Schema.optional(Schema.String)});
export const GetCompatibleKafkaVersionsResponse = Schema.Struct({CompatibleKafkaVersions: Schema.optional(__listOfCompatibleKafkaVersion)});
export const ListClusterOperationsV2Response = Schema.Struct({ClusterOperationInfoList: Schema.optional(__listOfClusterOperationV2Summary), NextToken: Schema.optional(Schema.String)});
export const ListClientVpcConnectionsResponse = Schema.Struct({ClientVpcConnections: Schema.optional(__listOfClientVpcConnection), NextToken: Schema.optional(Schema.String)});
export const __listOf__stringMax249 = Schema.Array(Schema.String);
export const DescribeReplicatorResponse = Schema.Struct({CreationTime: Schema.optional(Schema.Date), CurrentVersion: Schema.optional(Schema.String), IsReplicatorReference: Schema.optional(Schema.Boolean), KafkaClusters: Schema.optional(__listOfKafkaClusterDescription), ReplicationInfoList: Schema.optional(__listOfReplicationInfoDescription), ReplicatorArn: Schema.optional(Schema.String), ReplicatorDescription: Schema.optional(Schema.String), ReplicatorName: Schema.optional(Schema.String), ReplicatorResourceArn: Schema.optional(Schema.String), ReplicatorState: Schema.optional(Schema.String), ServiceExecutionRoleArn: Schema.optional(Schema.String), StateInfo: Schema.optional(ReplicationStateInfo), Tags: Schema.optional(__mapOf__string)});
export const __listOf__stringMax256 = Schema.Array(Schema.String);
export const UpdateSecurityRequest = Schema.Struct({ClientAuthentication: Schema.optional(ClientAuthentication), ClusterArn: Schema.String, CurrentVersion: Schema.String, EncryptionInfo: Schema.optional(EncryptionInfo)});
export const UpdateRebalancingRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, Rebalancing: Rebalancing});
export const UpdateMonitoringRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), LoggingInfo: Schema.optional(LoggingInfo)});
export const UpdateConfigurationRequest = Schema.Struct({Arn: Schema.String, Description: Schema.optional(Schema.String), ServerProperties: StreamBody()});
export const UpdateClusterKafkaVersionRequest = Schema.Struct({ClusterArn: Schema.String, ConfigurationInfo: Schema.optional(ConfigurationInfo), CurrentVersion: Schema.String, TargetKafkaVersion: Schema.String});
export const UpdateClusterConfigurationRequest = Schema.Struct({ClusterArn: Schema.String, ConfigurationInfo: ConfigurationInfo, CurrentVersion: Schema.String});
export const UpdateBrokerTypeRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, TargetInstanceType: Schema.String});
export const UpdateBrokerCountRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, TargetNumberOfBrokerNodes: Schema.Number});
export const BatchAssociateScramSecretResponse = Schema.Struct({ClusterArn: Schema.optional(Schema.String), UnprocessedScramSecrets: Schema.optional(__listOfUnprocessedScramSecret)});
export const ListNodesResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), NodeInfoList: Schema.optional(__listOfNodeInfo)});
export const ListReplicatorsResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), Replicators: Schema.optional(__listOfReplicatorSummary)});
export const CreateConfigurationResponse = Schema.Struct({Arn: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), LatestRevision: Schema.optional(ConfigurationRevision), Name: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const UntagResourceRequest = Schema.Struct({ResourceArn: Schema.String, TagKeys: __listOf__string});
export const TagResourceRequest = Schema.Struct({ResourceArn: Schema.String, Tags: __mapOf__string});
export const RejectClientVpcConnectionResponse = Schema.Struct({});
export const RejectClientVpcConnectionRequest = Schema.Struct({ClusterArn: Schema.String, VpcConnectionArn: Schema.String});
export const RebootBrokerRequest = Schema.Struct({BrokerIds: __listOf__string, ClusterArn: Schema.String});
export const PutClusterPolicyRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.optional(Schema.String), Policy: Schema.String});
export const ListVpcConnectionsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const KafkaCluster = Schema.Struct({AmazonMskCluster: AmazonMskCluster, VpcConfig: KafkaClusterClientVpcConfig});
export const ListTagsForResourceRequest = Schema.Struct({ResourceArn: Schema.String});
export const __listOfKafkaCluster = Schema.Array(KafkaCluster);
export const ListScramSecretsRequest = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListReplicatorsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String), ReplicatorNameFilter: Schema.optional(Schema.String)});
export const ListNodesRequest = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const DescribeClusterV2Response = Schema.Struct({ClusterInfo: Schema.optional(Cluster)});
export const ListKafkaVersionsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListConfigurationsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const EncryptionInfo = Schema.Struct({EncryptionAtRest: Schema.optional(EncryptionAtRest), EncryptionInTransit: Schema.optional(EncryptionInTransit)});
export const ListConfigurationRevisionsRequest = Schema.Struct({Arn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListClustersV2Request = Schema.Struct({ClusterNameFilter: Schema.optional(Schema.String), ClusterTypeFilter: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListClustersRequest = Schema.Struct({ClusterNameFilter: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListClusterOperationsV2Request = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListClusterOperationsRequest = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const DescribeClusterOperationResponse = Schema.Struct({ClusterOperationInfo: Schema.optional(ClusterOperationInfo)});
export const DescribeClusterOperationV2Response = Schema.Struct({ClusterOperationInfo: Schema.optional(ClusterOperationV2)});
export const UpdateStorageRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, ProvisionedThroughput: Schema.optional(ProvisionedThroughput), StorageMode: Schema.optional(Schema.String), VolumeSizeGB: Schema.optional(Schema.Number)});
export const UpdateReplicationInfoRequest = Schema.Struct({ConsumerGroupReplication: Schema.optional(ConsumerGroupReplicationUpdate), CurrentVersion: Schema.String, ReplicatorArn: Schema.String, SourceKafkaClusterArn: Schema.String, TargetKafkaClusterArn: Schema.String, TopicReplication: Schema.optional(TopicReplicationUpdate)});
export const ListClientVpcConnectionsRequest = Schema.Struct({ClusterArn: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const UpdateBrokerStorageRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.String, TargetBrokerEBSVolumeInfo: __listOfBrokerEBSVolumeInfo});
export const DescribeClusterResponse = Schema.Struct({ClusterInfo: Schema.optional(ClusterInfo)});
export const GetCompatibleKafkaVersionsRequest = Schema.Struct({ClusterArn: Schema.optional(Schema.String)});
export const GetClusterPolicyRequest = Schema.Struct({ClusterArn: Schema.String});
export const GetBootstrapBrokersRequest = Schema.Struct({ClusterArn: Schema.String});
export const ReplicationInfo = Schema.Struct({ConsumerGroupReplication: ConsumerGroupReplication, SourceKafkaClusterArn: Schema.String, TargetCompressionType: Schema.String, TargetKafkaClusterArn: Schema.String, TopicReplication: TopicReplication});
export const DescribeVpcConnectionRequest = Schema.Struct({Arn: Schema.String});
export const __listOfReplicationInfo = Schema.Array(ReplicationInfo);
export const DescribeReplicatorRequest = Schema.Struct({ReplicatorArn: Schema.String});
export const DescribeConfigurationRevisionRequest = Schema.Struct({Arn: Schema.String, Revision: Schema.Number});
export const ServerlessRequest = Schema.Struct({VpcConfigs: __listOfVpcConfig, ClientAuthentication: Schema.optional(ServerlessClientAuthentication)});
export const DescribeConfigurationRequest = Schema.Struct({Arn: Schema.String});
export const DescribeClusterV2Request = Schema.Struct({ClusterArn: Schema.String});
export const LoggingInfo = Schema.Struct({BrokerLogs: BrokerLogs});
export const OpenMonitoringInfo = Schema.Struct({Prometheus: PrometheusInfo});
export const ConnectivityInfo = Schema.Struct({PublicAccess: Schema.optional(PublicAccess), VpcConnectivity: Schema.optional(VpcConnectivity)});
export const DescribeClusterOperationV2Request = Schema.Struct({ClusterOperationArn: Schema.String});
export const DescribeClusterOperationRequest = Schema.Struct({ClusterOperationArn: Schema.String});
export const ClientAuthentication = Schema.Struct({Sasl: Schema.optional(Sasl), Tls: Schema.optional(Tls), Unauthenticated: Schema.optional(Unauthenticated)});
export const DescribeClusterRequest = Schema.Struct({ClusterArn: Schema.String});
export const BrokerNodeGroupInfo = Schema.Struct({BrokerAZDistribution: Schema.optional(Schema.String), ClientSubnets: __listOf__string, InstanceType: Schema.String, SecurityGroups: Schema.optional(__listOf__string), StorageInfo: Schema.optional(StorageInfo), ConnectivityInfo: Schema.optional(ConnectivityInfo), ZoneIds: Schema.optional(__listOf__string)});
export const DeleteVpcConnectionRequest = Schema.Struct({Arn: Schema.String});
export const DeleteReplicatorRequest = Schema.Struct({CurrentVersion: Schema.optional(Schema.String), ReplicatorArn: Schema.String});
export const DeleteConfigurationRequest = Schema.Struct({Arn: Schema.String});
export const DeleteClusterPolicyResponse = Schema.Struct({});
export const DeleteClusterPolicyRequest = Schema.Struct({ClusterArn: Schema.String});
export const DeleteClusterRequest = Schema.Struct({ClusterArn: Schema.String, CurrentVersion: Schema.optional(Schema.String)});
export const CreateVpcConnectionRequest = Schema.Struct({TargetClusterArn: Schema.String, Authentication: Schema.String, VpcId: Schema.String, ClientSubnets: __listOf__string, SecurityGroups: __listOf__string, Tags: Schema.optional(__mapOf__string)});
export const CreateConfigurationRequest = Schema.Struct({Description: Schema.optional(Schema.String), KafkaVersions: Schema.optional(__listOf__string), Name: Schema.String, ServerProperties: StreamBody()});
export const __listOf__string = Schema.Array(Schema.String);
export const BatchDisassociateScramSecretRequest = Schema.Struct({ClusterArn: Schema.String, SecretArnList: __listOf__string});
export const BatchAssociateScramSecretRequest = Schema.Struct({ClusterArn: Schema.String, SecretArnList: __listOf__string});
export const DeleteCluster = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteCluster" }, DeleteClusterRequest, DeleteClusterResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteClusterPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/policy", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteClusterPolicy" }, DeleteClusterPolicyRequest, DeleteClusterPolicyResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations/{Arn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteConfiguration" }, DeleteConfigurationRequest, DeleteConfigurationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/vpc-connection/{Arn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteVpcConnection" }, DeleteVpcConnectionRequest, DeleteVpcConnectionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations/{Arn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeConfiguration" }, DescribeConfigurationRequest, DescribeConfigurationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeConfigurationRevision = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations/{Arn}/revisions/{Revision}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeConfigurationRevision" }, DescribeConfigurationRevisionRequest, DescribeConfigurationRevisionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/vpc-connection/{Arn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeVpcConnection" }, DescribeVpcConnectionRequest, DescribeVpcConnectionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const GetClusterPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/policy", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.GetClusterPolicy" }, GetClusterPolicyRequest, GetClusterPolicyResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateConnectivityRequest = Schema.Struct({ClusterArn: Schema.String, ConnectivityInfo: ConnectivityInfo, CurrentVersion: Schema.String});
export const ListClusterOperations = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/operations", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClusterOperations" }, ListClusterOperationsRequest, ListClusterOperationsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListClusters = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClusters" }, ListClustersRequest, ListClustersResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListClustersV2 = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/api/v2/clusters", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClustersV2" }, ListClustersV2Request, ListClustersV2Response, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListConfigurationRevisions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations/{Arn}/revisions", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListConfigurationRevisions" }, ListConfigurationRevisionsRequest, ListConfigurationRevisionsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListScramSecrets = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/scram-secrets", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListScramSecrets" }, ListScramSecretsRequest, ListScramSecretsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/tags/{ResourceArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const PutClusterPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/policy", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.PutClusterPolicy" }, PutClusterPolicyRequest, PutClusterPolicyResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const RebootBroker = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/reboot-broker", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.RebootBroker" }, RebootBrokerRequest, RebootBrokerResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const RejectClientVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/client-vpc-connection", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.RejectClientVpcConnection" }, RejectClientVpcConnectionRequest, RejectClientVpcConnectionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const TagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/tags/{ResourceArn}", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.TagResource" }, TagResourceRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UntagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/tags/{ResourceArn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UntagResource" }, UntagResourceRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateBrokerCount = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/nodes/count", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateBrokerCount" }, UpdateBrokerCountRequest, UpdateBrokerCountResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateBrokerType = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/nodes/type", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateBrokerType" }, UpdateBrokerTypeRequest, UpdateBrokerTypeResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateClusterConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/configuration", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateClusterConfiguration" }, UpdateClusterConfigurationRequest, UpdateClusterConfigurationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateClusterKafkaVersion = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/version", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateClusterKafkaVersion" }, UpdateClusterKafkaVersionRequest, UpdateClusterKafkaVersionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations/{Arn}", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateConfiguration" }, UpdateConfigurationRequest, UpdateConfigurationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateMonitoring = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/monitoring", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateMonitoring" }, UpdateMonitoringRequest, UpdateMonitoringResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateRebalancing = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/rebalancing", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateRebalancing" }, UpdateRebalancingRequest, UpdateRebalancingResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateSecurity = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/security", method: "PATCH", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateSecurity" }, UpdateSecurityRequest, UpdateSecurityResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const BatchAssociateScramSecret = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/scram-secrets", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.BatchAssociateScramSecret" }, BatchAssociateScramSecretRequest, BatchAssociateScramSecretResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const BatchDisassociateScramSecret = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/scram-secrets", method: "PATCH", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.BatchDisassociateScramSecret" }, BatchDisassociateScramSecretRequest, BatchDisassociateScramSecretResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateConfiguration" }, CreateConfigurationRequest, CreateConfigurationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateVpcConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/vpc-connection", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateVpcConnection" }, CreateVpcConnectionRequest, CreateVpcConnectionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteReplicator = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/replication/v1/replicators/{ReplicatorArn}", method: "DELETE", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DeleteReplicator" }, DeleteReplicatorRequest, DeleteReplicatorResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeReplicator = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/replication/v1/replicators/{ReplicatorArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeReplicator" }, DescribeReplicatorRequest, DescribeReplicatorResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const GetBootstrapBrokers = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/bootstrap-brokers", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.GetBootstrapBrokers" }, GetBootstrapBrokersRequest, GetBootstrapBrokersResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const GetCompatibleKafkaVersions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/compatible-kafka-versions", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.GetCompatibleKafkaVersions" }, GetCompatibleKafkaVersionsRequest, GetCompatibleKafkaVersionsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListClientVpcConnections = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/client-vpc-connections", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClientVpcConnections" }, ListClientVpcConnectionsRequest, ListClientVpcConnectionsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListClusterOperationsV2 = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/api/v2/clusters/{ClusterArn}/operations", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListClusterOperationsV2" }, ListClusterOperationsV2Request, ListClusterOperationsV2Response, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/configurations", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListConfigurations" }, ListConfigurationsRequest, ListConfigurationsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListKafkaVersions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/kafka-versions", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListKafkaVersions" }, ListKafkaVersionsRequest, ListKafkaVersionsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListVpcConnections = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/vpc-connections", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListVpcConnections" }, ListVpcConnectionsRequest, ListVpcConnectionsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateReplicatorRequest = Schema.Struct({Description: Schema.optional(Schema.String), KafkaClusters: __listOfKafkaCluster, ReplicationInfoList: __listOfReplicationInfo, ReplicatorName: Schema.String, ServiceExecutionRoleArn: Schema.String, Tags: Schema.optional(__mapOf__string)});
export const UpdateBrokerStorage = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/nodes/storage", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateBrokerStorage" }, UpdateBrokerStorageRequest, UpdateBrokerStorageResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateClusterV2Request = Schema.Struct({ClusterName: Schema.String, Tags: Schema.optional(__mapOf__string), Provisioned: Schema.optional(ProvisionedRequest), Serverless: Schema.optional(ServerlessRequest)});
export const CreateClusterRequest = Schema.Struct({BrokerNodeGroupInfo: BrokerNodeGroupInfo, Rebalancing: Schema.optional(Rebalancing), ClientAuthentication: Schema.optional(ClientAuthentication), ClusterName: Schema.String, ConfigurationInfo: Schema.optional(ConfigurationInfo), EncryptionInfo: Schema.optional(EncryptionInfo), EnhancedMonitoring: Schema.optional(Schema.String), OpenMonitoring: Schema.optional(OpenMonitoringInfo), KafkaVersion: Schema.String, LoggingInfo: Schema.optional(LoggingInfo), NumberOfBrokerNodes: Schema.Number, Tags: Schema.optional(__mapOf__string), StorageMode: Schema.optional(Schema.String)});
export const UpdateReplicationInfo = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/replication/v1/replicators/{ReplicatorArn}/replication-info", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateReplicationInfo" }, UpdateReplicationInfoRequest, UpdateReplicationInfoResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateStorage = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/storage", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateStorage" }, UpdateStorageRequest, UpdateStorageResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeClusterV2 = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/api/v2/clusters/{ClusterArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeClusterV2" }, DescribeClusterV2Request, DescribeClusterV2Response, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListNodes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/nodes", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListNodes" }, ListNodesRequest, ListNodesResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListReplicators = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/replication/v1/replicators", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.ListReplicators" }, ListReplicatorsRequest, ListReplicatorsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateCluster = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateCluster" }, CreateClusterRequest, CreateClusterResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateClusterV2 = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/api/v2/clusters", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateClusterV2" }, CreateClusterV2Request, CreateClusterV2Response, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateReplicator = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/replication/v1/replicators", method: "POST", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.CreateReplicator" }, CreateReplicatorRequest, CreateReplicatorResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeClusterOperation = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/operations/{ClusterOperationArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeClusterOperation" }, DescribeClusterOperationRequest, DescribeClusterOperationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeClusterOperationV2 = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/api/v2/operations/{ClusterOperationArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeClusterOperationV2" }, DescribeClusterOperationV2Request, DescribeClusterOperationV2Response, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeCluster = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}", method: "GET", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.DescribeCluster" }, DescribeClusterRequest, DescribeClusterResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateConnectivity = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v1/clusters/{ClusterArn}/connectivity", method: "PUT", sdkId: "Kafka", sigV4ServiceName: "kafka", name: "Kafka.UpdateConnectivity" }, UpdateConnectivityRequest, UpdateConnectivityResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
