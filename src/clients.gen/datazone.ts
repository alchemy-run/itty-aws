import { Schema} from "effect"
import { FormatXMLRequest, FormatXMLResponse, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
const GovernedGlossaryTerms = Schema.Array(Schema.String)
const GlossaryTerms = Schema.Array(Schema.String)
const AuthorizedPrincipalIdentifiers = Schema.Array(Schema.String)
const ApplicableAssetTypes = Schema.Array(Schema.String)
const NotificationSubjects = Schema.Array(Schema.String)
const SearchOutputAdditionalAttributes = Schema.Array(Schema.String)
const TagKeyList = Schema.Array(Schema.String)
const AssociateEnvironmentRoleInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String, environmentRoleArn: Schema.String})
const AssociateEnvironmentRoleOutput = Schema.Struct({})
const AssociateGovernedTermsInput = Schema.Struct({domainIdentifier: Schema.String, entityIdentifier: Schema.String, entityType: Schema.String, governedGlossaryTerms: GovernedGlossaryTerms})
const AssociateGovernedTermsOutput = Schema.Struct({})
const CancelSubscriptionInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const CreateEnvironmentProfileInput = Schema.Struct({domainIdentifier: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), environmentBlueprintIdentifier: Schema.String, projectIdentifier: Schema.String, userParameters: Schema.optional(EnvironmentParametersList), awsAccountId: Schema.optional(Schema.String), awsAccountRegion: Schema.optional(Schema.String)})
const CreateGroupProfileInput = Schema.Struct({domainIdentifier: Schema.String, groupIdentifier: Schema.String, clientToken: Schema.optional(Schema.String)})
const CreateListingChangeSetInput = Schema.Struct({domainIdentifier: Schema.String, entityIdentifier: Schema.String, entityType: Schema.String, entityRevision: Schema.optional(Schema.String), action: Schema.String, clientToken: Schema.optional(Schema.String)})
const CreateUserProfileInput = Schema.Struct({domainIdentifier: Schema.String, userIdentifier: Schema.String, userType: Schema.optional(Schema.String), clientToken: Schema.optional(Schema.String)})
const DeleteAccountPoolInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const DeleteAccountPoolOutput = Schema.Struct({})
const DeleteAssetFilterInput = Schema.Struct({domainIdentifier: Schema.String, assetIdentifier: Schema.String, identifier: Schema.String})
const DeleteConnectionInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const DeleteEnvironmentInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const DeleteEnvironmentActionInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String, identifier: Schema.String})
const DeleteEnvironmentBlueprintInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
export const DeleteEnvironmentBlueprint = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environment-blueprints/{identifier}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteEnvironmentBlueprint" }, DeleteEnvironmentBlueprintInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteEnvironmentProfileInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
export const DeleteEnvironmentProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environment-profiles/{identifier}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteEnvironmentProfile" }, DeleteEnvironmentProfileInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteProjectInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, skipDeletionCheck: Schema.optional(Schema.Boolean)})
const DeleteProjectOutput = Schema.Struct({})
export const DeleteProject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/projects/{identifier}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteProject" }, DeleteProjectInput, DeleteProjectOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteProjectMembershipInput = Schema.Struct({domainIdentifier: Schema.String, projectIdentifier: Schema.String, member: Member})
const DeleteProjectMembershipOutput = Schema.Struct({})
const DeleteProjectProfileInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const DeleteProjectProfileOutput = Schema.Struct({})
export const DeleteProjectProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/project-profiles/{identifier}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteProjectProfile" }, DeleteProjectProfileInput, DeleteProjectProfileOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteSubscriptionGrantInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const DeleteSubscriptionRequestInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
export const DeleteSubscriptionRequest = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteSubscriptionRequest" }, DeleteSubscriptionRequestInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteSubscriptionTargetInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String, identifier: Schema.String})
export const DeleteSubscriptionTarget = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets/{identifier}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteSubscriptionTarget" }, DeleteSubscriptionTargetInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteTimeSeriesDataPointsInput = Schema.Struct({domainIdentifier: Schema.String, entityIdentifier: Schema.String, entityType: Schema.String, formName: Schema.String, clientToken: Schema.optional(Schema.String)})
const DeleteTimeSeriesDataPointsOutput = Schema.Struct({})
export const DeleteTimeSeriesDataPoints = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/time-series-data-points", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteTimeSeriesDataPoints" }, DeleteTimeSeriesDataPointsInput, DeleteTimeSeriesDataPointsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DisassociateEnvironmentRoleInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String, environmentRoleArn: Schema.String})
const DisassociateEnvironmentRoleOutput = Schema.Struct({})
export const DisassociateEnvironmentRole = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/roles/{environmentRoleArn}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DisassociateEnvironmentRole" }, DisassociateEnvironmentRoleInput, DisassociateEnvironmentRoleOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DisassociateGovernedTermsInput = Schema.Struct({domainIdentifier: Schema.String, entityIdentifier: Schema.String, entityType: Schema.String, governedGlossaryTerms: GovernedGlossaryTerms})
const DisassociateGovernedTermsOutput = Schema.Struct({})
export const DisassociateGovernedTerms = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/disassociate-governed-terms", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DisassociateGovernedTerms" }, DisassociateGovernedTermsInput, DisassociateGovernedTermsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetAccountPoolInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const GetAssetFilterInput = Schema.Struct({domainIdentifier: Schema.String, assetIdentifier: Schema.String, identifier: Schema.String})
const GetConnectionInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, withSecret: Schema.optional(Schema.Boolean)})
const GetEnvironmentInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const GetEnvironmentActionInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String, identifier: Schema.String})
const GetEnvironmentBlueprintInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const GetEnvironmentCredentialsInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String})
const GetEnvironmentProfileInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const GetGroupProfileInput = Schema.Struct({domainIdentifier: Schema.String, groupIdentifier: Schema.String})
const GetIamPortalLoginUrlInput = Schema.Struct({domainIdentifier: Schema.String})
const GetJobRunInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const GetLineageEventInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const GetLineageNodeInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, eventTimestamp: Schema.optional(Schema.Date)})
const GetProjectInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const GetProjectProfileInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const GetSubscriptionInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const GetSubscriptionGrantInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const GetSubscriptionRequestDetailsInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String})
const GetSubscriptionTargetInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String, identifier: Schema.String})
const GetTimeSeriesDataPointInput = Schema.Struct({domainIdentifier: Schema.String, entityIdentifier: Schema.String, entityType: Schema.String, identifier: Schema.String, formName: Schema.String})
const GetUserProfileInput = Schema.Struct({domainIdentifier: Schema.String, userIdentifier: Schema.String, type: Schema.optional(Schema.String)})
const ListAccountPoolsInput = Schema.Struct({domainIdentifier: Schema.String, name: Schema.optional(Schema.String), sortBy: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListAccountsInAccountPoolInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListAssetFiltersInput = Schema.Struct({domainIdentifier: Schema.String, assetIdentifier: Schema.String, status: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListAssetRevisionsInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListConnectionsInput = Schema.Struct({domainIdentifier: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), sortBy: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String), name: Schema.optional(Schema.String), environmentIdentifier: Schema.optional(Schema.String), projectIdentifier: Schema.optional(Schema.String), type: Schema.optional(Schema.String), scope: Schema.optional(Schema.String)})
const ListDataProductRevisionsInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)})
const ListDataSourceRunActivitiesInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, status: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListEntityOwnersInput = Schema.Struct({domainIdentifier: Schema.String, entityType: Schema.String, entityIdentifier: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)})
const ListEnvironmentActionsInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListEnvironmentBlueprintsInput = Schema.Struct({domainIdentifier: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), name: Schema.optional(Schema.String), managed: Schema.optional(Schema.Boolean)})
const ListEnvironmentProfilesInput = Schema.Struct({domainIdentifier: Schema.String, awsAccountId: Schema.optional(Schema.String), awsAccountRegion: Schema.optional(Schema.String), environmentBlueprintIdentifier: Schema.optional(Schema.String), projectIdentifier: Schema.optional(Schema.String), name: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListEnvironmentsInput = Schema.Struct({domainIdentifier: Schema.String, awsAccountId: Schema.optional(Schema.String), status: Schema.optional(Schema.String), awsAccountRegion: Schema.optional(Schema.String), projectIdentifier: Schema.String, environmentProfileIdentifier: Schema.optional(Schema.String), environmentBlueprintIdentifier: Schema.optional(Schema.String), provider: Schema.optional(Schema.String), name: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)})
const ListJobRunsInput = Schema.Struct({domainIdentifier: Schema.String, jobIdentifier: Schema.String, status: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListLineageEventsInput = Schema.Struct({domainIdentifier: Schema.String, maxResults: Schema.optional(Schema.Number), timestampAfter: Schema.optional(Schema.Date), timestampBefore: Schema.optional(Schema.Date), processingStatus: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String)})
const ListLineageNodeHistoryInput = Schema.Struct({domainIdentifier: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), identifier: Schema.String, direction: Schema.optional(Schema.String), eventTimestampGTE: Schema.optional(Schema.Date), eventTimestampLTE: Schema.optional(Schema.Date), sortOrder: Schema.optional(Schema.String)})
const ListNotificationsInput = Schema.Struct({domainIdentifier: Schema.String, type: Schema.String, afterTimestamp: Schema.optional(Schema.Date), beforeTimestamp: Schema.optional(Schema.Date), subjects: Schema.optional(NotificationSubjects), taskStatus: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)})
const ListPolicyGrantsInput = Schema.Struct({domainIdentifier: Schema.String, entityType: Schema.String, entityIdentifier: Schema.String, policyType: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)})
const ListProjectMembershipsInput = Schema.Struct({domainIdentifier: Schema.String, projectIdentifier: Schema.String, sortBy: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListProjectProfilesInput = Schema.Struct({domainIdentifier: Schema.String, name: Schema.optional(Schema.String), sortBy: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListProjectsInput = Schema.Struct({domainIdentifier: Schema.String, userIdentifier: Schema.optional(Schema.String), groupIdentifier: Schema.optional(Schema.String), name: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListSubscriptionGrantsInput = Schema.Struct({domainIdentifier: Schema.String, environmentId: Schema.optional(Schema.String), subscriptionTargetId: Schema.optional(Schema.String), subscribedListingId: Schema.optional(Schema.String), subscriptionId: Schema.optional(Schema.String), owningProjectId: Schema.optional(Schema.String), owningUserId: Schema.optional(Schema.String), owningGroupId: Schema.optional(Schema.String), sortBy: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)})
const ListSubscriptionRequestsInput = Schema.Struct({domainIdentifier: Schema.String, status: Schema.optional(Schema.String), subscribedListingId: Schema.optional(Schema.String), owningProjectId: Schema.optional(Schema.String), approverProjectId: Schema.optional(Schema.String), owningUserId: Schema.optional(Schema.String), owningGroupId: Schema.optional(Schema.String), sortBy: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)})
const ListSubscriptionsInput = Schema.Struct({domainIdentifier: Schema.String, subscriptionRequestIdentifier: Schema.optional(Schema.String), status: Schema.optional(Schema.String), subscribedListingId: Schema.optional(Schema.String), owningProjectId: Schema.optional(Schema.String), owningUserId: Schema.optional(Schema.String), owningGroupId: Schema.optional(Schema.String), approverProjectId: Schema.optional(Schema.String), sortBy: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)})
const ListSubscriptionTargetsInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String, sortBy: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)})
const ListTagsForResourceRequest = Schema.Struct({resourceArn: Schema.String})
const ListTimeSeriesDataPointsInput = Schema.Struct({domainIdentifier: Schema.String, entityIdentifier: Schema.String, entityType: Schema.String, formName: Schema.String, startedAt: Schema.optional(Schema.Date), endedAt: Schema.optional(Schema.Date), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const PostLineageEventInput = Schema.Struct({domainIdentifier: Schema.String, event: Body("undefined", StreamBody()), clientToken: Schema.optional(Header("Client-Token"))})
const RejectSubscriptionRequestInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, decisionComment: Schema.optional(Schema.String)})
const RemoveEntityOwnerInput = Schema.Struct({domainIdentifier: Schema.String, entityType: Schema.String, entityIdentifier: Schema.String, owner: OwnerProperties, clientToken: Schema.optional(Schema.String)})
const RemoveEntityOwnerOutput = Schema.Struct({})
export const RemoveEntityOwner = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/removeOwner", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "RemoveEntityOwner" }, RemoveEntityOwnerInput, RemoveEntityOwnerOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const RemovePolicyGrantInput = Schema.Struct({domainIdentifier: Schema.String, entityType: Schema.String, entityIdentifier: Schema.String, policyType: Schema.String, principal: PolicyGrantPrincipal, grantIdentifier: Schema.optional(Schema.String), clientToken: Schema.optional(Schema.String)})
const RemovePolicyGrantOutput = Schema.Struct({})
export const RemovePolicyGrant = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/policies/managed/{entityType}/{entityIdentifier}/removeGrant", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "RemovePolicyGrant" }, RemovePolicyGrantInput, RemovePolicyGrantOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const RevokeSubscriptionInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, retainPermissions: Schema.optional(Schema.Boolean)})
const SearchGroupProfilesInput = Schema.Struct({domainIdentifier: Schema.String, groupType: Schema.String, searchText: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)})
const SearchTypesInput = Schema.Struct({domainIdentifier: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), searchScope: Schema.String, searchText: Schema.optional(Schema.String), searchIn: Schema.optional(SearchInList), filters: Schema.optional(FilterClause), sort: Schema.optional(SearchSort), managed: Schema.Boolean})
const SearchUserProfilesInput = Schema.Struct({domainIdentifier: Schema.String, userType: Schema.String, searchText: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)})
const TagResourceRequest = Schema.Struct({resourceArn: Schema.String, tags: Tags})
const TagResourceResponse = Schema.Struct({})
export const TagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/tags/{resourceArn}", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "TagResource" }, TagResourceRequest, TagResourceResponse, Schema.Union(ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UntagResourceRequest = Schema.Struct({resourceArn: Schema.String, tagKeys: TagKeyList})
const UntagResourceResponse = Schema.Struct({})
export const UntagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/tags/{resourceArn}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UntagResource" }, UntagResourceRequest, UntagResourceResponse, Schema.Union(ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateAccountPoolInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), resolutionStrategy: Schema.optional(Schema.String), accountSource: Schema.optional(AccountSource)})
const UpdateAssetFilterInput = Schema.Struct({domainIdentifier: Schema.String, assetIdentifier: Schema.String, identifier: Schema.String, name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), configuration: Schema.optional(AssetFilterConfiguration)})
const UpdateEnvironmentInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), glossaryTerms: Schema.optional(GlossaryTerms), blueprintVersion: Schema.optional(Schema.String), userParameters: Schema.optional(EnvironmentParametersList)})
const UpdateEnvironmentActionInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String, identifier: Schema.String, parameters: Schema.optional(ActionParameters), name: Schema.optional(Schema.String), description: Schema.optional(Schema.String)})
const UpdateEnvironmentBlueprintInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, description: Schema.optional(Schema.String), provisioningProperties: Schema.optional(ProvisioningProperties), userParameters: Schema.optional(CustomParameterList)})
const UpdateEnvironmentProfileInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), userParameters: Schema.optional(EnvironmentParametersList), awsAccountId: Schema.optional(Schema.String), awsAccountRegion: Schema.optional(Schema.String)})
const UpdateGroupProfileInput = Schema.Struct({domainIdentifier: Schema.String, groupIdentifier: Schema.String, status: Schema.String})
const UpdateProjectProfileInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), status: Schema.optional(Schema.String), projectResourceTags: Schema.optional(ProjectResourceTagParameters), allowCustomProjectResourceTags: Schema.optional(Schema.Boolean), projectResourceTagsDescription: Schema.optional(Schema.String), environmentConfigurations: Schema.optional(EnvironmentConfigurationsList), domainUnitIdentifier: Schema.optional(Schema.String)})
const UpdateSubscriptionRequestInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, requestReason: Schema.String})
const UpdateSubscriptionTargetInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String, identifier: Schema.String, name: Schema.optional(Schema.String), authorizedPrincipals: Schema.optional(AuthorizedPrincipalIdentifiers), applicableAssetTypes: Schema.optional(ApplicableAssetTypes), subscriptionTargetConfig: Schema.optional(SubscriptionTargetForms), manageAccessRole: Schema.optional(Schema.String), provider: Schema.optional(Schema.String)})
const UpdateUserProfileInput = Schema.Struct({domainIdentifier: Schema.String, userIdentifier: Schema.String, type: Schema.optional(Schema.String), status: Schema.String})
const FilterIds = Schema.Array(Schema.String)
const Unit = Schema.Struct({})
const AccountPoolList = Schema.Array(Schema.String)
const PredictionChoices = Schema.Array(Schema.Number)
const FilterList = Schema.Array(FilterClause)
const AcceptRule = Schema.Struct({rule: Schema.optional(Schema.String), threshold: Schema.optional(Schema.Number)})
const AcceptChoice = Schema.Struct({predictionTarget: Schema.String, predictionChoice: Schema.optional(Schema.Number), editedValue: Schema.optional(Schema.String)})
const AcceptChoices = Schema.Array(AcceptChoice)
const AcceptedAssetScope = Schema.Struct({assetId: Schema.String, filterIds: FilterIds})
const AcceptedAssetScopes = Schema.Array(AcceptedAssetScope)
const AwsLocation = Schema.Struct({accessRole: Schema.optional(Schema.String), awsAccountId: Schema.optional(Schema.String), awsRegion: Schema.optional(Schema.String), iamConnectionId: Schema.optional(Schema.String)})
const EnvironmentParameter = Schema.Struct({name: Schema.optional(Schema.String), value: Schema.optional(Schema.String)})
const EnvironmentParametersList = Schema.Array(EnvironmentParameter)
const CustomParameter = Schema.Struct({keyName: Schema.String, description: Schema.optional(Schema.String), fieldType: Schema.String, defaultValue: Schema.optional(Schema.String), isEditable: Schema.optional(Schema.Boolean), isOptional: Schema.optional(Schema.Boolean), isUpdateSupported: Schema.optional(Schema.Boolean)})
const CustomParameterList = Schema.Array(CustomParameter)
const Tags = Schema.Record({key: Schema.String, value: Schema.String})
const Member = Schema.Union(Schema.String, Schema.String)
const ResourceTagParameter = Schema.Struct({key: Schema.String, value: Schema.String, isValueEditable: Schema.Boolean})
const ProjectResourceTagParameters = Schema.Array(ResourceTagParameter)
const AssetTargetNameMap = Schema.Struct({assetId: Schema.String, targetName: Schema.String})
const AssetTargetNames = Schema.Array(AssetTargetNameMap)
const SubscribedListingInput = Schema.Struct({identifier: Schema.String})
const SubscribedListingInputs = Schema.Array(SubscribedListingInput)
const FormInput = Schema.Struct({formName: Schema.String, typeIdentifier: Schema.optional(Schema.String), typeRevision: Schema.optional(Schema.String), content: Schema.optional(Schema.String)})
const MetadataFormInputs = Schema.Array(FormInput)
const SubscriptionTargetForm = Schema.Struct({formName: Schema.String, content: Schema.String})
const SubscriptionTargetForms = Schema.Array(SubscriptionTargetForm)
const ColumnNameList = Schema.Array(Schema.String)
const SubscribedPrincipals = Schema.Array(SubscribedPrincipal)
const SubscribedListings = Schema.Array(SubscribedListing)
const MetadataForms = Schema.Array(FormOutput)
const TimeSeriesDataPointFormInput = Schema.Struct({formName: Schema.String, typeIdentifier: Schema.String, typeRevision: Schema.optional(Schema.String), timestamp: Schema.Date, content: Schema.optional(Schema.String)})
const TimeSeriesDataPointFormInputList = Schema.Array(TimeSeriesDataPointFormInput)
const RejectRule = Schema.Struct({rule: Schema.optional(Schema.String), threshold: Schema.optional(Schema.Number)})
const RejectChoice = Schema.Struct({predictionTarget: Schema.String, predictionChoices: Schema.optional(PredictionChoices)})
const RejectChoices = Schema.Array(RejectChoice)
const SearchInItem = Schema.Struct({attribute: Schema.String})
const SearchInList = Schema.Array(SearchInItem)
const SearchSort = Schema.Struct({attribute: Schema.String, order: Schema.optional(Schema.String)})
const AggregationListItem = Schema.Struct({attribute: Schema.String, displayValue: Schema.optional(Schema.String)})
const AggregationList = Schema.Array(AggregationListItem)
const FailureCause = Schema.Struct({message: Schema.optional(Schema.String)})
const S3Permissions = Schema.Array(Schema.String)
const AllUsersGrantFilter = Schema.Struct({})
const ProjectProfileList = Schema.Array(Schema.String)
const AwsRegionList = Schema.Array(Schema.String)
const AcceptPredictionsInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, revision: Schema.optional(Schema.String), acceptRule: Schema.optional(AcceptRule), acceptChoices: Schema.optional(AcceptChoices), clientToken: Schema.optional(Schema.String)})
const AccessDeniedException = Schema.Struct({message: Schema.String})
export const AssociateEnvironmentRole = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/roles/{environmentRoleArn}", method: "PUT", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "AssociateEnvironmentRole" }, AssociateEnvironmentRoleInput, AssociateEnvironmentRoleOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ConflictException = Schema.Struct({message: Schema.String})
export const AssociateGovernedTerms = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/associate-governed-terms", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "AssociateGovernedTerms" }, AssociateGovernedTermsInput, AssociateGovernedTermsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateEnvironmentInput = Schema.Struct({projectIdentifier: Schema.String, domainIdentifier: Schema.String, description: Schema.optional(Schema.String), name: Schema.String, environmentProfileIdentifier: Schema.optional(Schema.String), userParameters: Schema.optional(EnvironmentParametersList), glossaryTerms: Schema.optional(GlossaryTerms), environmentAccountIdentifier: Schema.optional(Schema.String), environmentAccountRegion: Schema.optional(Schema.String), environmentBlueprintIdentifier: Schema.optional(Schema.String), deploymentOrder: Schema.optional(Schema.Number), environmentConfigurationId: Schema.optional(Schema.String)})
const CreateEnvironmentProfileOutput = Schema.Struct({id: Schema.String, domainId: Schema.String, awsAccountId: Schema.optional(Schema.String), awsAccountRegion: Schema.optional(Schema.String), createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date), name: Schema.String, description: Schema.optional(Schema.String), environmentBlueprintId: Schema.String, projectId: Schema.optional(Schema.String), userParameters: Schema.optional(CustomParameterList)})
export const CreateEnvironmentProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environment-profiles", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateEnvironmentProfile" }, CreateEnvironmentProfileInput, CreateEnvironmentProfileOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateGroupProfileOutput = Schema.Struct({domainId: Schema.optional(Schema.String), id: Schema.optional(Schema.String), status: Schema.optional(Schema.String), groupName: Schema.optional(Schema.String)})
export const CreateGroupProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/group-profiles", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateGroupProfile" }, CreateGroupProfileInput, CreateGroupProfileOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateListingChangeSetOutput = Schema.Struct({listingId: Schema.String, listingRevision: Schema.String, status: Schema.String})
export const CreateListingChangeSet = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/listings/change-set", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateListingChangeSet" }, CreateListingChangeSetInput, CreateListingChangeSetOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateProjectMembershipInput = Schema.Struct({domainIdentifier: Schema.String, projectIdentifier: Schema.String, member: Member, designation: Schema.String})
const CreateProjectMembershipOutput = Schema.Struct({})
export const CreateProjectMembership = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/projects/{projectIdentifier}/createMembership", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateProjectMembership" }, CreateProjectMembershipInput, CreateProjectMembershipOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateSubscriptionTargetInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String, name: Schema.String, type: Schema.String, subscriptionTargetConfig: SubscriptionTargetForms, authorizedPrincipals: AuthorizedPrincipalIdentifiers, manageAccessRole: Schema.String, applicableAssetTypes: ApplicableAssetTypes, provider: Schema.optional(Schema.String), clientToken: Schema.optional(Schema.String)})
const InternalServerException = Schema.Struct({message: Schema.String})
export const DeleteAccountPool = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/account-pools/{identifier}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteAccountPool" }, DeleteAccountPoolInput, DeleteAccountPoolOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ResourceNotFoundException = Schema.Struct({message: Schema.String})
export const DeleteAssetFilter = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/assets/{assetIdentifier}/filters/{identifier}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteAssetFilter" }, DeleteAssetFilterInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteConnectionOutput = Schema.Struct({status: Schema.optional(Schema.String)})
export const DeleteConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/connections/{identifier}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteConnection" }, DeleteConnectionInput, DeleteConnectionOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ThrottlingException = Schema.Struct({message: Schema.String})
export const DeleteEnvironment = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{identifier}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteEnvironment" }, DeleteEnvironmentInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ValidationException = Schema.Struct({message: Schema.String})
export const DeleteEnvironmentAction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/actions/{identifier}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteEnvironmentAction" }, DeleteEnvironmentActionInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ServiceQuotaExceededException = Schema.Struct({message: Schema.String})
export const DeleteProjectMembership = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/projects/{projectIdentifier}/deleteMembership", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteProjectMembership" }, DeleteProjectMembershipInput, DeleteProjectMembershipOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetAccountPoolOutput = Schema.Struct({domainId: Schema.optional(Schema.String), name: Schema.optional(Schema.String), id: Schema.optional(Schema.String), description: Schema.optional(Schema.String), resolutionStrategy: Schema.optional(Schema.String), accountSource: AccountSource, createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), updatedBy: Schema.optional(Schema.String), domainUnitId: Schema.optional(Schema.String)})
export const GetAccountPool = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/account-pools/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetAccountPool" }, GetAccountPoolInput, GetAccountPoolOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetAssetFilterOutput = Schema.Struct({id: Schema.String, domainId: Schema.String, assetId: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), status: Schema.optional(Schema.String), configuration: AssetFilterConfiguration, createdAt: Schema.optional(Schema.Date), errorMessage: Schema.optional(Schema.String), effectiveColumnNames: Schema.optional(ColumnNameList), effectiveRowFilter: Schema.optional(Schema.String)})
export const GetAssetFilter = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/assets/{assetIdentifier}/filters/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetAssetFilter" }, GetAssetFilterInput, GetAssetFilterOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetEnvironmentActionOutput = Schema.Struct({domainId: Schema.String, environmentId: Schema.String, id: Schema.String, name: Schema.String, parameters: ActionParameters, description: Schema.optional(Schema.String)})
export const GetEnvironmentAction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/actions/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetEnvironmentAction" }, GetEnvironmentActionInput, GetEnvironmentActionOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetEnvironmentBlueprintOutput = Schema.Struct({id: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), provider: Schema.String, provisioningProperties: ProvisioningProperties, deploymentProperties: Schema.optional(DeploymentProperties), userParameters: Schema.optional(CustomParameterList), glossaryTerms: Schema.optional(GlossaryTerms), createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date)})
export const GetEnvironmentBlueprint = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environment-blueprints/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetEnvironmentBlueprint" }, GetEnvironmentBlueprintInput, GetEnvironmentBlueprintOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetEnvironmentCredentialsOutput = Schema.Struct({accessKeyId: Schema.optional(Schema.String), secretAccessKey: Schema.optional(Schema.String), sessionToken: Schema.optional(Schema.String), expiration: Schema.optional(Schema.Date)})
export const GetEnvironmentCredentials = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/credentials", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetEnvironmentCredentials" }, GetEnvironmentCredentialsInput, GetEnvironmentCredentialsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetEnvironmentProfileOutput = Schema.Struct({id: Schema.String, domainId: Schema.String, awsAccountId: Schema.optional(Schema.String), awsAccountRegion: Schema.optional(Schema.String), createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date), name: Schema.String, description: Schema.optional(Schema.String), environmentBlueprintId: Schema.String, projectId: Schema.optional(Schema.String), userParameters: Schema.optional(CustomParameterList)})
export const GetEnvironmentProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environment-profiles/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetEnvironmentProfile" }, GetEnvironmentProfileInput, GetEnvironmentProfileOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetGroupProfileOutput = Schema.Struct({domainId: Schema.optional(Schema.String), id: Schema.optional(Schema.String), status: Schema.optional(Schema.String), groupName: Schema.optional(Schema.String)})
export const GetGroupProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/group-profiles/{groupIdentifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetGroupProfile" }, GetGroupProfileInput, GetGroupProfileOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetIamPortalLoginUrlOutput = Schema.Struct({authCodeUrl: Schema.optional(Schema.String), userProfileId: Schema.String})
export const GetIamPortalLoginUrl = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/get-portal-login-url", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetIamPortalLoginUrl" }, GetIamPortalLoginUrlInput, GetIamPortalLoginUrlOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetLineageEventOutput = Schema.Struct({domainId: Schema.optional(Header("Domain-Id")), id: Schema.optional(Header("Id")), event: Schema.optional(Body("undefined", StreamBody())), createdBy: Schema.optional(Header("Created-By")), processingStatus: Schema.optional(Header("Processing-Status")), eventTime: Schema.optional(Header("Event-Time", Schema.Date)), createdAt: Schema.optional(Header("Created-At", Schema.Date))})
export const GetLineageEvent = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/lineage/events/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetLineageEvent" }, GetLineageEventInput, GetLineageEventOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetProjectProfileOutput = Schema.Struct({domainId: Schema.String, id: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), status: Schema.optional(Schema.String), projectResourceTags: Schema.optional(ProjectResourceTagParameters), allowCustomProjectResourceTags: Schema.optional(Schema.Boolean), projectResourceTagsDescription: Schema.optional(Schema.String), environmentConfigurations: Schema.optional(EnvironmentConfigurationsList), createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), domainUnitId: Schema.optional(Schema.String)})
export const GetProjectProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/project-profiles/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetProjectProfile" }, GetProjectProfileInput, GetProjectProfileOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetSubscriptionOutput = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, status: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, subscribedPrincipal: SubscribedPrincipal, subscribedListing: SubscribedListing, subscriptionRequestId: Schema.optional(Schema.String), retainPermissions: Schema.optional(Schema.Boolean)})
export const GetSubscription = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscriptions/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetSubscription" }, GetSubscriptionInput, GetSubscriptionOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetSubscriptionGrantOutput = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, environmentId: Schema.optional(Schema.String), subscriptionTargetId: Schema.String, grantedEntity: GrantedEntity, status: Schema.String, assets: Schema.optional(SubscribedAssets), subscriptionId: Schema.optional(Schema.String)})
export const GetSubscriptionGrant = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscription-grants/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetSubscriptionGrant" }, GetSubscriptionGrantInput, GetSubscriptionGrantOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetSubscriptionRequestDetailsOutput = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, status: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, requestReason: Schema.String, subscribedPrincipals: SubscribedPrincipals, subscribedListings: SubscribedListings, reviewerId: Schema.optional(Schema.String), decisionComment: Schema.optional(Schema.String), existingSubscriptionId: Schema.optional(Schema.String), metadataForms: Schema.optional(MetadataForms)})
export const GetSubscriptionRequestDetails = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetSubscriptionRequestDetails" }, GetSubscriptionRequestDetailsInput, GetSubscriptionRequestDetailsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetSubscriptionTargetOutput = Schema.Struct({id: Schema.String, authorizedPrincipals: AuthorizedPrincipalIdentifiers, domainId: Schema.String, projectId: Schema.String, environmentId: Schema.String, name: Schema.String, type: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), createdAt: Schema.Date, updatedAt: Schema.optional(Schema.Date), manageAccessRole: Schema.optional(Schema.String), applicableAssetTypes: ApplicableAssetTypes, subscriptionTargetConfig: SubscriptionTargetForms, provider: Schema.String})
export const GetSubscriptionTarget = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetSubscriptionTarget" }, GetSubscriptionTargetInput, GetSubscriptionTargetOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetUserProfileOutput = Schema.Struct({domainId: Schema.optional(Schema.String), id: Schema.optional(Schema.String), type: Schema.optional(Schema.String), status: Schema.optional(Schema.String), details: Schema.optional(UserProfileDetails)})
export const GetUserProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/user-profiles/{userIdentifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetUserProfile" }, GetUserProfileInput, GetUserProfileOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListAccountsInAccountPoolOutput = Schema.Struct({items: Schema.optional(AccountInfoList), nextToken: Schema.optional(Schema.String)})
export const ListAccountsInAccountPool = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/account-pools/{identifier}/accounts", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListAccountsInAccountPool" }, ListAccountsInAccountPoolInput, ListAccountsInAccountPoolOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListTagsForResourceResponse = Schema.Struct({tags: Schema.optional(Tags)})
export const ListTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/tags/{resourceArn}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, Schema.Union(ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PostLineageEventOutput = Schema.Struct({id: Schema.optional(Schema.String), domainId: Schema.optional(Schema.String)})
export const PostLineageEvent = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/lineage/events", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "PostLineageEvent" }, PostLineageEventInput, PostLineageEventOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PostTimeSeriesDataPointsInput = Schema.Struct({domainIdentifier: Schema.String, entityIdentifier: Schema.String, entityType: Schema.String, forms: TimeSeriesDataPointFormInputList, clientToken: Schema.optional(Schema.String)})
const RejectPredictionsInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, revision: Schema.optional(Schema.String), rejectRule: Schema.optional(RejectRule), rejectChoices: Schema.optional(RejectChoices), clientToken: Schema.optional(Schema.String)})
const RejectSubscriptionRequestOutput = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, status: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, requestReason: Schema.String, subscribedPrincipals: SubscribedPrincipals, subscribedListings: SubscribedListings, reviewerId: Schema.optional(Schema.String), decisionComment: Schema.optional(Schema.String), existingSubscriptionId: Schema.optional(Schema.String), metadataForms: Schema.optional(MetadataForms)})
export const RejectSubscriptionRequest = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}/reject", method: "PUT", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "RejectSubscriptionRequest" }, RejectSubscriptionRequestInput, RejectSubscriptionRequestOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const RevokeSubscriptionOutput = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, status: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, subscribedPrincipal: SubscribedPrincipal, subscribedListing: SubscribedListing, subscriptionRequestId: Schema.optional(Schema.String), retainPermissions: Schema.optional(Schema.Boolean)})
export const RevokeSubscription = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscriptions/{identifier}/revoke", method: "PUT", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "RevokeSubscription" }, RevokeSubscriptionInput, RevokeSubscriptionOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const SearchListingsInput = Schema.Struct({domainIdentifier: Schema.String, searchText: Schema.optional(Schema.String), searchIn: Schema.optional(SearchInList), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), filters: Schema.optional(FilterClause), aggregations: Schema.optional(AggregationList), sort: Schema.optional(SearchSort), additionalAttributes: Schema.optional(SearchOutputAdditionalAttributes)})
const UpdateAccountPoolOutput = Schema.Struct({domainId: Schema.optional(Schema.String), name: Schema.optional(Schema.String), id: Schema.optional(Schema.String), description: Schema.optional(Schema.String), resolutionStrategy: Schema.optional(Schema.String), accountSource: AccountSource, createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), updatedBy: Schema.optional(Schema.String), domainUnitId: Schema.optional(Schema.String)})
export const UpdateAccountPool = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/account-pools/{identifier}", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateAccountPool" }, UpdateAccountPoolInput, UpdateAccountPoolOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateAssetFilterOutput = Schema.Struct({id: Schema.String, domainId: Schema.String, assetId: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), status: Schema.optional(Schema.String), configuration: AssetFilterConfiguration, createdAt: Schema.optional(Schema.Date), errorMessage: Schema.optional(Schema.String), effectiveColumnNames: Schema.optional(ColumnNameList), effectiveRowFilter: Schema.optional(Schema.String)})
export const UpdateAssetFilter = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/assets/{assetIdentifier}/filters/{identifier}", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateAssetFilter" }, UpdateAssetFilterInput, UpdateAssetFilterOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateEnvironmentOutput = Schema.Struct({projectId: Schema.String, id: Schema.optional(Schema.String), domainId: Schema.String, createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date), name: Schema.String, description: Schema.optional(Schema.String), environmentProfileId: Schema.optional(Schema.String), awsAccountId: Schema.optional(Schema.String), awsAccountRegion: Schema.optional(Schema.String), provider: Schema.String, provisionedResources: Schema.optional(ResourceList), status: Schema.optional(Schema.String), environmentActions: Schema.optional(EnvironmentActionList), glossaryTerms: Schema.optional(GlossaryTerms), userParameters: Schema.optional(CustomParameterList), lastDeployment: Schema.optional(Deployment), provisioningProperties: Schema.optional(ProvisioningProperties), deploymentProperties: Schema.optional(DeploymentProperties), environmentBlueprintId: Schema.optional(Schema.String), environmentConfigurationId: Schema.optional(Schema.String)})
export const UpdateEnvironment = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{identifier}", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateEnvironment" }, UpdateEnvironmentInput, UpdateEnvironmentOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateEnvironmentActionOutput = Schema.Struct({domainId: Schema.String, environmentId: Schema.String, id: Schema.String, name: Schema.String, parameters: ActionParameters, description: Schema.optional(Schema.String)})
export const UpdateEnvironmentAction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/actions/{identifier}", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateEnvironmentAction" }, UpdateEnvironmentActionInput, UpdateEnvironmentActionOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateEnvironmentBlueprintOutput = Schema.Struct({id: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), provider: Schema.String, provisioningProperties: ProvisioningProperties, deploymentProperties: Schema.optional(DeploymentProperties), userParameters: Schema.optional(CustomParameterList), glossaryTerms: Schema.optional(GlossaryTerms), createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date)})
export const UpdateEnvironmentBlueprint = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environment-blueprints/{identifier}", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateEnvironmentBlueprint" }, UpdateEnvironmentBlueprintInput, UpdateEnvironmentBlueprintOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateEnvironmentProfileOutput = Schema.Struct({id: Schema.String, domainId: Schema.String, awsAccountId: Schema.optional(Schema.String), awsAccountRegion: Schema.optional(Schema.String), createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date), name: Schema.String, description: Schema.optional(Schema.String), environmentBlueprintId: Schema.String, projectId: Schema.optional(Schema.String), userParameters: Schema.optional(CustomParameterList)})
export const UpdateEnvironmentProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environment-profiles/{identifier}", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateEnvironmentProfile" }, UpdateEnvironmentProfileInput, UpdateEnvironmentProfileOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateGroupProfileOutput = Schema.Struct({domainId: Schema.optional(Schema.String), id: Schema.optional(Schema.String), status: Schema.optional(Schema.String), groupName: Schema.optional(Schema.String)})
export const UpdateGroupProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/group-profiles/{groupIdentifier}", method: "PUT", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateGroupProfile" }, UpdateGroupProfileInput, UpdateGroupProfileOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateProjectProfileOutput = Schema.Struct({domainId: Schema.String, id: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), status: Schema.optional(Schema.String), projectResourceTags: Schema.optional(ProjectResourceTagParameters), allowCustomProjectResourceTags: Schema.optional(Schema.Boolean), projectResourceTagsDescription: Schema.optional(Schema.String), environmentConfigurations: Schema.optional(EnvironmentConfigurationsList), createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), domainUnitId: Schema.optional(Schema.String)})
export const UpdateProjectProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/project-profiles/{identifier}", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateProjectProfile" }, UpdateProjectProfileInput, UpdateProjectProfileOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateSubscriptionGrantStatusInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, assetIdentifier: Schema.String, status: Schema.String, failureCause: Schema.optional(FailureCause), targetName: Schema.optional(Schema.String)})
const UpdateSubscriptionRequestOutput = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, status: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, requestReason: Schema.String, subscribedPrincipals: SubscribedPrincipals, subscribedListings: SubscribedListings, reviewerId: Schema.optional(Schema.String), decisionComment: Schema.optional(Schema.String), existingSubscriptionId: Schema.optional(Schema.String), metadataForms: Schema.optional(MetadataForms)})
export const UpdateSubscriptionRequest = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateSubscriptionRequest" }, UpdateSubscriptionRequestInput, UpdateSubscriptionRequestOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateSubscriptionTargetOutput = Schema.Struct({id: Schema.String, authorizedPrincipals: AuthorizedPrincipalIdentifiers, domainId: Schema.String, projectId: Schema.String, environmentId: Schema.String, name: Schema.String, type: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), createdAt: Schema.Date, updatedAt: Schema.optional(Schema.Date), manageAccessRole: Schema.optional(Schema.String), applicableAssetTypes: ApplicableAssetTypes, subscriptionTargetConfig: SubscriptionTargetForms, provider: Schema.String})
export const UpdateSubscriptionTarget = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets/{identifier}", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateSubscriptionTarget" }, UpdateSubscriptionTargetInput, UpdateSubscriptionTargetOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateUserProfileOutput = Schema.Struct({domainId: Schema.optional(Schema.String), id: Schema.optional(Schema.String), type: Schema.optional(Schema.String), status: Schema.optional(Schema.String), details: Schema.optional(UserProfileDetails)})
export const UpdateUserProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/user-profiles/{userIdentifier}", method: "PUT", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateUserProfile" }, UpdateUserProfileInput, UpdateUserProfileOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const Permissions = Schema.Union(S3Permissions)
const OwnerUserProperties = Schema.Struct({userIdentifier: Schema.String})
const OwnerGroupProperties = Schema.Struct({groupIdentifier: Schema.String})
const UserPolicyGrantPrincipal = Schema.Union(Schema.String, AllUsersGrantFilter)
const GroupPolicyGrantPrincipal = Schema.Union(Schema.String)
const CreateDomainUnitPolicyGrantDetail = Schema.Struct({includeChildDomainUnits: Schema.optional(Schema.Boolean)})
const OverrideDomainUnitOwnersPolicyGrantDetail = Schema.Struct({includeChildDomainUnits: Schema.optional(Schema.Boolean)})
const AddToProjectMemberPoolPolicyGrantDetail = Schema.Struct({includeChildDomainUnits: Schema.optional(Schema.Boolean)})
const OverrideProjectOwnersPolicyGrantDetail = Schema.Struct({includeChildDomainUnits: Schema.optional(Schema.Boolean)})
const CreateGlossaryPolicyGrantDetail = Schema.Struct({includeChildDomainUnits: Schema.optional(Schema.Boolean)})
const CreateFormTypePolicyGrantDetail = Schema.Struct({includeChildDomainUnits: Schema.optional(Schema.Boolean)})
const CreateAssetTypePolicyGrantDetail = Schema.Struct({includeChildDomainUnits: Schema.optional(Schema.Boolean)})
const CreateProjectPolicyGrantDetail = Schema.Struct({includeChildDomainUnits: Schema.optional(Schema.Boolean)})
const CreateEnvironmentProfilePolicyGrantDetail = Schema.Struct({domainUnitId: Schema.optional(Schema.String)})
const CreateProjectFromProjectProfilePolicyGrantDetail = Schema.Struct({includeChildDomainUnits: Schema.optional(Schema.Boolean), projectProfiles: Schema.optional(ProjectProfileList)})
const UseAssetTypePolicyGrantDetail = Schema.Struct({domainUnitId: Schema.optional(Schema.String)})
const AccountInfo = Schema.Struct({awsAccountId: Schema.String, supportedRegions: AwsRegionList, awsAccountName: Schema.optional(Schema.String)})
const AccountInfoList = Schema.Array(AccountInfo)
const CustomAccountPoolHandler = Schema.Struct({lambdaFunctionArn: Schema.String, lambdaExecutionRoleArn: Schema.optional(Schema.String)})
const ColumnFilterConfiguration = Schema.Struct({includedColumnNames: Schema.optional(ColumnNameList)})
const AthenaPropertiesInput = Schema.Struct({workgroupName: Schema.optional(Schema.String)})
const HyperPodPropertiesInput = Schema.Struct({clusterName: Schema.String})
const IamPropertiesInput = Schema.Struct({glueLineageSyncEnabled: Schema.optional(Schema.Boolean)})
const SparkEmrPropertiesInput = Schema.Struct({computeArn: Schema.optional(Schema.String), instanceProfileArn: Schema.optional(Schema.String), javaVirtualEnv: Schema.optional(Schema.String), logUri: Schema.optional(Schema.String), pythonVirtualEnv: Schema.optional(Schema.String), runtimeRole: Schema.optional(Schema.String), trustedCertificatesS3Uri: Schema.optional(Schema.String), managedEndpointArn: Schema.optional(Schema.String)})
const S3PropertiesInput = Schema.Struct({s3Uri: Schema.String, s3AccessGrantLocationId: Schema.optional(Schema.String)})
const AmazonQPropertiesInput = Schema.Struct({isEnabled: Schema.Boolean, profileArn: Schema.optional(Schema.String), authMode: Schema.optional(Schema.String)})
const MlflowPropertiesInput = Schema.Struct({trackingServerArn: Schema.optional(Schema.String)})
const AwsConsoleLinkParameters = Schema.Struct({uri: Schema.optional(Schema.String)})
const CloudFormationProperties = Schema.Struct({templateUrl: Schema.String})
const EnvironmentResolvedAccount = Schema.Struct({awsAccountId: Schema.String, regionName: Schema.String, sourceAccountPoolId: Schema.optional(Schema.String)})
const AwsAccount = Schema.Union(Schema.String, Schema.String)
const Region = Schema.Union(Schema.String, Schema.String)
const ListingRevisionInput = Schema.Struct({identifier: Schema.String, revision: Schema.String})
const SubscribedProjectInput = Schema.Struct({identifier: Schema.optional(Schema.String)})
const SubscribedUserInput = Schema.Struct({identifier: Schema.optional(Schema.String)})
const SubscribedGroupInput = Schema.Struct({identifier: Schema.optional(Schema.String)})
const DeploymentMessagesList = Schema.Array(Schema.String)
const Filter = Schema.Struct({attribute: Schema.String, value: Schema.String})
const AthenaPropertiesPatch = Schema.Struct({workgroupName: Schema.optional(Schema.String)})
const IamPropertiesPatch = Schema.Struct({glueLineageSyncEnabled: Schema.optional(Schema.Boolean)})
const RedshiftPropertiesPatch = Schema.Struct({storage: Schema.optional(RedshiftStorageProperties), databaseName: Schema.optional(Schema.String), host: Schema.optional(Schema.String), port: Schema.optional(Schema.Number), credentials: Schema.optional(RedshiftCredentials), lineageSync: Schema.optional(RedshiftLineageSyncConfigurationInput)})
const SparkEmrPropertiesPatch = Schema.Struct({computeArn: Schema.optional(Schema.String), instanceProfileArn: Schema.optional(Schema.String), javaVirtualEnv: Schema.optional(Schema.String), logUri: Schema.optional(Schema.String), pythonVirtualEnv: Schema.optional(Schema.String), runtimeRole: Schema.optional(Schema.String), trustedCertificatesS3Uri: Schema.optional(Schema.String), managedEndpointArn: Schema.optional(Schema.String)})
const S3PropertiesPatch = Schema.Struct({s3Uri: Schema.String, s3AccessGrantLocationId: Schema.optional(Schema.String)})
const AmazonQPropertiesPatch = Schema.Struct({isEnabled: Schema.Boolean, profileArn: Schema.optional(Schema.String), authMode: Schema.optional(Schema.String)})
const MlflowPropertiesPatch = Schema.Struct({trackingServerArn: Schema.optional(Schema.String)})
const AllDomainUnitsGrantFilter = Schema.Struct({})
const RowFilterList = Schema.Array(RowFilter)
const ComputeEnvironmentsList = Schema.Array(Schema.String)
const AssetPermission = Schema.Struct({assetId: Schema.String, permissions: Permissions})
const AssetPermissions = Schema.Array(AssetPermission)
const OwnerProperties = Schema.Union(OwnerUserProperties, OwnerGroupProperties)
const PolicyGrantDetail = Schema.Union(CreateDomainUnitPolicyGrantDetail, OverrideDomainUnitOwnersPolicyGrantDetail, AddToProjectMemberPoolPolicyGrantDetail, OverrideProjectOwnersPolicyGrantDetail, CreateGlossaryPolicyGrantDetail, CreateFormTypePolicyGrantDetail, CreateAssetTypePolicyGrantDetail, CreateProjectPolicyGrantDetail, CreateEnvironmentProfilePolicyGrantDetail, Unit, Unit, Unit, CreateProjectFromProjectProfilePolicyGrantDetail, UseAssetTypePolicyGrantDetail)
const AccountSource = Schema.Union(AccountInfoList, CustomAccountPoolHandler)
const ActionParameters = Schema.Union(AwsConsoleLinkParameters)
const ProvisioningProperties = Schema.Union(CloudFormationProperties)
const EnvironmentConfigurationUserParameter = Schema.Struct({environmentId: Schema.optional(Schema.String), environmentResolvedAccount: Schema.optional(EnvironmentResolvedAccount), environmentConfigurationName: Schema.optional(Schema.String), environmentParameters: Schema.optional(EnvironmentParametersList)})
const EnvironmentConfigurationUserParametersList = Schema.Array(EnvironmentConfigurationUserParameter)
const GrantedEntityInput = Schema.Union(ListingRevisionInput)
const SubscribedPrincipalInput = Schema.Union(SubscribedProjectInput, SubscribedUserInput, SubscribedGroupInput)
const SubscribedPrincipalInputs = Schema.Array(SubscribedPrincipalInput)
const ConnectionCredentials = Schema.Struct({accessKeyId: Schema.optional(Schema.String), secretAccessKey: Schema.optional(Schema.String), sessionToken: Schema.optional(Schema.String), expiration: Schema.optional(Schema.Date)})
const Resource = Schema.Struct({provider: Schema.optional(Schema.String), name: Schema.optional(Schema.String), value: Schema.String, type: Schema.String})
const ResourceList = Schema.Array(Resource)
const Deployment = Schema.Struct({deploymentId: Schema.optional(Schema.String), deploymentType: Schema.optional(Schema.String), deploymentStatus: Schema.optional(Schema.String), failureReason: Schema.optional(EnvironmentError), messages: Schema.optional(DeploymentMessagesList), isDeploymentComplete: Schema.optional(Schema.Boolean)})
const DeploymentProperties = Schema.Struct({startTimeoutMinutes: Schema.optional(Schema.Number), endTimeoutMinutes: Schema.optional(Schema.Number)})
const JobRunError = Schema.Struct({message: Schema.String})
const FormOutput = Schema.Struct({formName: Schema.String, typeName: Schema.optional(Schema.String), typeRevision: Schema.optional(Schema.String), content: Schema.optional(Schema.String)})
const FormOutputList = Schema.Array(FormOutput)
const LineageNodeReference = Schema.Struct({id: Schema.optional(Schema.String), eventTimestamp: Schema.optional(Schema.Date)})
const LineageNodeReferenceList = Schema.Array(LineageNodeReference)
const ProjectDeletionError = Schema.Struct({code: Schema.optional(Schema.String), message: Schema.optional(Schema.String)})
const FailureReasons = Schema.Array(ProjectDeletionError)
const ResourceTag = Schema.Struct({key: Schema.String, value: Schema.String, source: Schema.String})
const ResourceTags = Schema.Array(ResourceTag)
const TimeSeriesDataPointFormOutput = Schema.Struct({formName: Schema.String, typeIdentifier: Schema.String, typeRevision: Schema.optional(Schema.String), timestamp: Schema.Date, content: Schema.optional(Schema.String), id: Schema.optional(Schema.String)})
const AccountPoolSummary = Schema.Struct({domainId: Schema.optional(Schema.String), id: Schema.optional(Schema.String), name: Schema.optional(Schema.String), resolutionStrategy: Schema.optional(Schema.String), domainUnitId: Schema.optional(Schema.String), createdBy: Schema.optional(Schema.String), updatedBy: Schema.optional(Schema.String)})
const AccountPoolSummaries = Schema.Array(AccountPoolSummary)
const AssetFilterSummary = Schema.Struct({id: Schema.String, domainId: Schema.String, assetId: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), status: Schema.optional(Schema.String), effectiveColumnNames: Schema.optional(ColumnNameList), effectiveRowFilter: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), errorMessage: Schema.optional(Schema.String)})
const AssetFilters = Schema.Array(AssetFilterSummary)
const AssetRevision = Schema.Struct({domainId: Schema.optional(Schema.String), id: Schema.optional(Schema.String), revision: Schema.optional(Schema.String), createdBy: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date)})
const AssetRevisions = Schema.Array(AssetRevision)
const ConnectionSummary = Schema.Struct({connectionId: Schema.String, domainId: Schema.String, domainUnitId: Schema.String, environmentId: Schema.optional(Schema.String), name: Schema.String, physicalEndpoints: PhysicalEndpoints, projectId: Schema.optional(Schema.String), props: Schema.optional(ConnectionPropertiesOutput), type: Schema.String, scope: Schema.optional(Schema.String)})
const ConnectionSummaries = Schema.Array(ConnectionSummary)
const DataProductRevision = Schema.Struct({domainId: Schema.optional(Schema.String), id: Schema.optional(Schema.String), revision: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), createdBy: Schema.optional(Schema.String)})
const DataProductRevisions = Schema.Array(DataProductRevision)
const EnvironmentActionSummary = Schema.Struct({domainId: Schema.String, environmentId: Schema.String, id: Schema.String, name: Schema.String, parameters: ActionParameters, description: Schema.optional(Schema.String)})
const ListEnvironmentActionSummaries = Schema.Array(EnvironmentActionSummary)
const EnvironmentBlueprintSummary = Schema.Struct({id: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), provider: Schema.String, provisioningProperties: ProvisioningProperties, createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date)})
const EnvironmentBlueprintSummaries = Schema.Array(EnvironmentBlueprintSummary)
const EnvironmentProfileSummary = Schema.Struct({id: Schema.String, domainId: Schema.String, awsAccountId: Schema.optional(Schema.String), awsAccountRegion: Schema.optional(Schema.String), createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date), name: Schema.String, description: Schema.optional(Schema.String), environmentBlueprintId: Schema.String, projectId: Schema.optional(Schema.String)})
const EnvironmentProfileSummaries = Schema.Array(EnvironmentProfileSummary)
const EnvironmentSummary = Schema.Struct({projectId: Schema.String, id: Schema.optional(Schema.String), domainId: Schema.String, createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date), name: Schema.String, description: Schema.optional(Schema.String), environmentProfileId: Schema.optional(Schema.String), awsAccountId: Schema.optional(Schema.String), awsAccountRegion: Schema.optional(Schema.String), provider: Schema.String, status: Schema.optional(Schema.String), environmentConfigurationId: Schema.optional(Schema.String)})
const EnvironmentSummaries = Schema.Array(EnvironmentSummary)
const JobRunSummary = Schema.Struct({domainId: Schema.optional(Schema.String), jobId: Schema.optional(Schema.String), jobType: Schema.optional(Schema.String), runId: Schema.optional(Schema.String), runMode: Schema.optional(Schema.String), status: Schema.optional(Schema.String), error: Schema.optional(JobRunError), createdBy: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), startTime: Schema.optional(Schema.Date), endTime: Schema.optional(Schema.Date)})
const JobRunSummaries = Schema.Array(JobRunSummary)
const LineageNodeSummary = Schema.Struct({domainId: Schema.String, name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), createdBy: Schema.optional(Schema.String), updatedAt: Schema.optional(Schema.Date), updatedBy: Schema.optional(Schema.String), id: Schema.String, typeName: Schema.String, typeRevision: Schema.optional(Schema.String), sourceIdentifier: Schema.optional(Schema.String), eventTimestamp: Schema.optional(Schema.Date)})
const LineageNodeSummaries = Schema.Array(LineageNodeSummary)
const PolicyGrantMember = Schema.Struct({principal: Schema.optional(PolicyGrantPrincipal), detail: Schema.optional(PolicyGrantDetail), createdAt: Schema.optional(Schema.Date), createdBy: Schema.optional(Schema.String), grantId: Schema.optional(Schema.String)})
const PolicyGrantList = Schema.Array(PolicyGrantMember)
const ProjectProfileSummary = Schema.Struct({domainId: Schema.String, id: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), status: Schema.optional(Schema.String), createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), domainUnitId: Schema.optional(Schema.String)})
const ProjectProfileSummaries = Schema.Array(ProjectProfileSummary)
const ProjectSummary = Schema.Struct({domainId: Schema.String, id: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), projectStatus: Schema.optional(Schema.String), failureReasons: Schema.optional(FailureReasons), createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date), domainUnitId: Schema.optional(Schema.String)})
const ProjectSummaries = Schema.Array(ProjectSummary)
const SubscriptionGrantSummary = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, environmentId: Schema.optional(Schema.String), subscriptionTargetId: Schema.String, grantedEntity: GrantedEntity, status: Schema.String, assets: Schema.optional(SubscribedAssets), subscriptionId: Schema.optional(Schema.String)})
const SubscriptionGrants = Schema.Array(SubscriptionGrantSummary)
const SubscriptionSummary = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, status: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, subscribedPrincipal: SubscribedPrincipal, subscribedListing: SubscribedListing, subscriptionRequestId: Schema.optional(Schema.String), retainPermissions: Schema.optional(Schema.Boolean)})
const Subscriptions = Schema.Array(SubscriptionSummary)
const SubscriptionTargetSummary = Schema.Struct({id: Schema.String, authorizedPrincipals: AuthorizedPrincipalIdentifiers, domainId: Schema.String, projectId: Schema.String, environmentId: Schema.String, name: Schema.String, type: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), createdAt: Schema.Date, updatedAt: Schema.optional(Schema.Date), manageAccessRole: Schema.optional(Schema.String), applicableAssetTypes: ApplicableAssetTypes, subscriptionTargetConfig: SubscriptionTargetForms, provider: Schema.String})
const SubscriptionTargets = Schema.Array(SubscriptionTargetSummary)
const TimeSeriesDataPointSummaryFormOutput = Schema.Struct({formName: Schema.String, typeIdentifier: Schema.String, typeRevision: Schema.optional(Schema.String), timestamp: Schema.Date, contentSummary: Schema.optional(Schema.String), id: Schema.optional(Schema.String)})
const TimeSeriesDataPointSummaryFormOutputList = Schema.Array(TimeSeriesDataPointSummaryFormOutput)
const TimeSeriesDataPointFormOutputList = Schema.Array(TimeSeriesDataPointFormOutput)
const FilterClause = Schema.Union(Filter, FilterList, FilterList)
const GroupProfileSummary = Schema.Struct({domainId: Schema.optional(Schema.String), id: Schema.optional(Schema.String), status: Schema.optional(Schema.String), groupName: Schema.optional(Schema.String)})
const GroupProfileSummaries = Schema.Array(GroupProfileSummary)
const UserProfileSummary = Schema.Struct({domainId: Schema.optional(Schema.String), id: Schema.optional(Schema.String), type: Schema.optional(Schema.String), status: Schema.optional(Schema.String), details: Schema.optional(UserProfileDetails)})
const UserProfileSummaries = Schema.Array(UserProfileSummary)
const DomainUnitGrantFilter = Schema.Union(AllDomainUnitsGrantFilter)
const RedshiftStorageProperties = Schema.Union(Schema.String, Schema.String)
const SparkGlueArgs = Schema.Struct({connection: Schema.optional(Schema.String)})
const EnvironmentConfigurationParameter = Schema.Struct({name: Schema.optional(Schema.String), value: Schema.optional(Schema.String), isEditable: Schema.optional(Schema.Boolean)})
const EnvironmentConfigurationParametersList = Schema.Array(EnvironmentConfigurationParameter)
const MatchCriteria = Schema.Array(Schema.String)
const EnvironmentError = Schema.Struct({code: Schema.optional(Schema.String), message: Schema.String})
const EnvironmentFailureReasonsList = Schema.Array(EnvironmentError)
const AcceptPredictionsOutput = Schema.Struct({domainId: Schema.String, assetId: Schema.String, revision: Schema.String})
export const AcceptPredictions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/assets/{identifier}/accept-predictions", method: "PUT", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "AcceptPredictions" }, AcceptPredictionsInput, AcceptPredictionsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const AcceptSubscriptionRequestInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, decisionComment: Schema.optional(Schema.String), assetScopes: Schema.optional(AcceptedAssetScopes), assetPermissions: Schema.optional(AssetPermissions)})
const AddEntityOwnerInput = Schema.Struct({domainIdentifier: Schema.String, entityType: Schema.String, entityIdentifier: Schema.String, owner: OwnerProperties, clientToken: Schema.optional(Schema.String)})
const AddEntityOwnerOutput = Schema.Struct({})
export const AddEntityOwner = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/addOwner", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "AddEntityOwner" }, AddEntityOwnerInput, AddEntityOwnerOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateAccountPoolInput = Schema.Struct({domainIdentifier: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), resolutionStrategy: Schema.String, accountSource: AccountSource})
const SubnetIdList = Schema.Array(Schema.String)
const SecurityGroupIdList = Schema.Array(Schema.String)
const CreateEnvironmentOutput = Schema.Struct({projectId: Schema.String, id: Schema.optional(Schema.String), domainId: Schema.String, createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date), name: Schema.String, description: Schema.optional(Schema.String), environmentProfileId: Schema.optional(Schema.String), awsAccountId: Schema.optional(Schema.String), awsAccountRegion: Schema.optional(Schema.String), provider: Schema.String, provisionedResources: Schema.optional(ResourceList), status: Schema.optional(Schema.String), environmentActions: Schema.optional(EnvironmentActionList), glossaryTerms: Schema.optional(GlossaryTerms), userParameters: Schema.optional(CustomParameterList), lastDeployment: Schema.optional(Deployment), provisioningProperties: Schema.optional(ProvisioningProperties), deploymentProperties: Schema.optional(DeploymentProperties), environmentBlueprintId: Schema.optional(Schema.String), environmentConfigurationId: Schema.optional(Schema.String)})
export const CreateEnvironment = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateEnvironment" }, CreateEnvironmentInput, CreateEnvironmentOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateEnvironmentActionInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String, name: Schema.String, parameters: ActionParameters, description: Schema.optional(Schema.String)})
const CreateEnvironmentBlueprintInput = Schema.Struct({domainIdentifier: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), provisioningProperties: ProvisioningProperties, userParameters: Schema.optional(CustomParameterList)})
const CreateProjectInput = Schema.Struct({domainIdentifier: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), resourceTags: Schema.optional(Tags), glossaryTerms: Schema.optional(GlossaryTerms), domainUnitId: Schema.optional(Schema.String), projectProfileId: Schema.optional(Schema.String), userParameters: Schema.optional(EnvironmentConfigurationUserParametersList)})
const CreateSubscriptionGrantInput = Schema.Struct({domainIdentifier: Schema.String, environmentIdentifier: Schema.String, subscriptionTargetIdentifier: Schema.optional(Schema.String), grantedEntity: GrantedEntityInput, assetTargetNames: Schema.optional(AssetTargetNames), clientToken: Schema.optional(Schema.String)})
const CreateSubscriptionRequestInput = Schema.Struct({domainIdentifier: Schema.String, subscribedPrincipals: SubscribedPrincipalInputs, subscribedListings: SubscribedListingInputs, requestReason: Schema.String, clientToken: Schema.optional(Schema.String), metadataForms: Schema.optional(MetadataFormInputs), assetPermissions: Schema.optional(AssetPermissions), assetScopes: Schema.optional(AcceptedAssetScopes)})
const CreateSubscriptionTargetOutput = Schema.Struct({id: Schema.String, authorizedPrincipals: AuthorizedPrincipalIdentifiers, domainId: Schema.String, projectId: Schema.String, environmentId: Schema.String, name: Schema.String, type: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), createdAt: Schema.Date, updatedAt: Schema.optional(Schema.Date), manageAccessRole: Schema.optional(Schema.String), applicableAssetTypes: ApplicableAssetTypes, subscriptionTargetConfig: SubscriptionTargetForms, provider: Schema.String})
export const CreateSubscriptionTarget = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateSubscriptionTarget" }, CreateSubscriptionTargetInput, CreateSubscriptionTargetOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetLineageNodeOutput = Schema.Struct({domainId: Schema.String, name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), createdBy: Schema.optional(Schema.String), updatedAt: Schema.optional(Schema.Date), updatedBy: Schema.optional(Schema.String), id: Schema.String, typeName: Schema.String, typeRevision: Schema.optional(Schema.String), sourceIdentifier: Schema.optional(Schema.String), eventTimestamp: Schema.optional(Schema.Date), formsOutput: Schema.optional(FormOutputList), upstreamNodes: Schema.optional(LineageNodeReferenceList), downstreamNodes: Schema.optional(LineageNodeReferenceList)})
export const GetLineageNode = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/lineage/nodes/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetLineageNode" }, GetLineageNodeInput, GetLineageNodeOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetProjectOutput = Schema.Struct({domainId: Schema.String, id: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), projectStatus: Schema.optional(Schema.String), failureReasons: Schema.optional(FailureReasons), createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), resourceTags: Schema.optional(ResourceTags), glossaryTerms: Schema.optional(GlossaryTerms), domainUnitId: Schema.optional(Schema.String), projectProfileId: Schema.optional(Schema.String), userParameters: Schema.optional(EnvironmentConfigurationUserParametersList), environmentDeploymentDetails: Schema.optional(EnvironmentDeploymentDetails)})
export const GetProject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/projects/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetProject" }, GetProjectInput, GetProjectOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetTimeSeriesDataPointOutput = Schema.Struct({domainId: Schema.optional(Schema.String), entityId: Schema.optional(Schema.String), entityType: Schema.optional(Schema.String), formName: Schema.optional(Schema.String), form: Schema.optional(TimeSeriesDataPointFormOutput)})
export const GetTimeSeriesDataPoint = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/time-series-data-points/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetTimeSeriesDataPoint" }, GetTimeSeriesDataPointInput, GetTimeSeriesDataPointOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListAccountPoolsOutput = Schema.Struct({items: Schema.optional(AccountPoolSummaries), nextToken: Schema.optional(Schema.String)})
export const ListAccountPools = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/account-pools", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListAccountPools" }, ListAccountPoolsInput, ListAccountPoolsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListAssetFiltersOutput = Schema.Struct({items: AssetFilters, nextToken: Schema.optional(Schema.String)})
export const ListAssetFilters = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/assets/{assetIdentifier}/filters", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListAssetFilters" }, ListAssetFiltersInput, ListAssetFiltersOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListAssetRevisionsOutput = Schema.Struct({items: Schema.optional(AssetRevisions), nextToken: Schema.optional(Schema.String)})
export const ListAssetRevisions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/assets/{identifier}/revisions", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListAssetRevisions" }, ListAssetRevisionsInput, ListAssetRevisionsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListConnectionsOutput = Schema.Struct({items: ConnectionSummaries, nextToken: Schema.optional(Schema.String)})
export const ListConnections = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/connections", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListConnections" }, ListConnectionsInput, ListConnectionsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDataProductRevisionsOutput = Schema.Struct({items: DataProductRevisions, nextToken: Schema.optional(Schema.String)})
export const ListDataProductRevisions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/data-products/{identifier}/revisions", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListDataProductRevisions" }, ListDataProductRevisionsInput, ListDataProductRevisionsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListEnvironmentActionsOutput = Schema.Struct({items: Schema.optional(ListEnvironmentActionSummaries), nextToken: Schema.optional(Schema.String)})
export const ListEnvironmentActions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/actions", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListEnvironmentActions" }, ListEnvironmentActionsInput, ListEnvironmentActionsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListEnvironmentBlueprintsOutput = Schema.Struct({items: EnvironmentBlueprintSummaries, nextToken: Schema.optional(Schema.String)})
export const ListEnvironmentBlueprints = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environment-blueprints", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListEnvironmentBlueprints" }, ListEnvironmentBlueprintsInput, ListEnvironmentBlueprintsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListEnvironmentProfilesOutput = Schema.Struct({items: EnvironmentProfileSummaries, nextToken: Schema.optional(Schema.String)})
export const ListEnvironmentProfiles = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environment-profiles", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListEnvironmentProfiles" }, ListEnvironmentProfilesInput, ListEnvironmentProfilesOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListEnvironmentsOutput = Schema.Struct({items: EnvironmentSummaries, nextToken: Schema.optional(Schema.String)})
export const ListEnvironments = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListEnvironments" }, ListEnvironmentsInput, ListEnvironmentsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListJobRunsOutput = Schema.Struct({items: Schema.optional(JobRunSummaries), nextToken: Schema.optional(Schema.String)})
export const ListJobRuns = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/jobs/{jobIdentifier}/runs", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListJobRuns" }, ListJobRunsInput, ListJobRunsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListLineageNodeHistoryOutput = Schema.Struct({nodes: Schema.optional(LineageNodeSummaries), nextToken: Schema.optional(Schema.String)})
export const ListLineageNodeHistory = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/lineage/nodes/{identifier}/history", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListLineageNodeHistory" }, ListLineageNodeHistoryInput, ListLineageNodeHistoryOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListPolicyGrantsOutput = Schema.Struct({grantList: PolicyGrantList, nextToken: Schema.optional(Schema.String)})
export const ListPolicyGrants = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/policies/managed/{entityType}/{entityIdentifier}/grants", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListPolicyGrants" }, ListPolicyGrantsInput, ListPolicyGrantsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListProjectProfilesOutput = Schema.Struct({items: Schema.optional(ProjectProfileSummaries), nextToken: Schema.optional(Schema.String)})
export const ListProjectProfiles = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/project-profiles", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListProjectProfiles" }, ListProjectProfilesInput, ListProjectProfilesOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListProjectsOutput = Schema.Struct({items: Schema.optional(ProjectSummaries), nextToken: Schema.optional(Schema.String)})
export const ListProjects = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/projects", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListProjects" }, ListProjectsInput, ListProjectsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListSubscriptionGrantsOutput = Schema.Struct({items: SubscriptionGrants, nextToken: Schema.optional(Schema.String)})
export const ListSubscriptionGrants = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscription-grants", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListSubscriptionGrants" }, ListSubscriptionGrantsInput, ListSubscriptionGrantsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListSubscriptionsOutput = Schema.Struct({items: Subscriptions, nextToken: Schema.optional(Schema.String)})
export const ListSubscriptions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscriptions", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListSubscriptions" }, ListSubscriptionsInput, ListSubscriptionsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListSubscriptionTargetsOutput = Schema.Struct({items: SubscriptionTargets, nextToken: Schema.optional(Schema.String)})
export const ListSubscriptionTargets = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListSubscriptionTargets" }, ListSubscriptionTargetsInput, ListSubscriptionTargetsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListTimeSeriesDataPointsOutput = Schema.Struct({items: Schema.optional(TimeSeriesDataPointSummaryFormOutputList), nextToken: Schema.optional(Schema.String)})
export const ListTimeSeriesDataPoints = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/time-series-data-points", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListTimeSeriesDataPoints" }, ListTimeSeriesDataPointsInput, ListTimeSeriesDataPointsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PostTimeSeriesDataPointsOutput = Schema.Struct({domainId: Schema.optional(Schema.String), entityId: Schema.optional(Schema.String), entityType: Schema.optional(Schema.String), forms: Schema.optional(TimeSeriesDataPointFormOutputList)})
export const PostTimeSeriesDataPoints = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/time-series-data-points", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "PostTimeSeriesDataPoints" }, PostTimeSeriesDataPointsInput, PostTimeSeriesDataPointsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const RejectPredictionsOutput = Schema.Struct({domainId: Schema.String, assetId: Schema.String, assetRevision: Schema.String})
export const RejectPredictions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/assets/{identifier}/reject-predictions", method: "PUT", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "RejectPredictions" }, RejectPredictionsInput, RejectPredictionsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const SearchInput = Schema.Struct({domainIdentifier: Schema.String, owningProjectIdentifier: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), searchScope: Schema.String, searchText: Schema.optional(Schema.String), searchIn: Schema.optional(SearchInList), filters: Schema.optional(FilterClause), sort: Schema.optional(SearchSort), additionalAttributes: Schema.optional(SearchOutputAdditionalAttributes)})
const SearchGroupProfilesOutput = Schema.Struct({items: Schema.optional(GroupProfileSummaries), nextToken: Schema.optional(Schema.String)})
export const SearchGroupProfiles = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/search-group-profiles", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "SearchGroupProfiles" }, SearchGroupProfilesInput, SearchGroupProfilesOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const SearchUserProfilesOutput = Schema.Struct({items: Schema.optional(UserProfileSummaries), nextToken: Schema.optional(Schema.String)})
export const SearchUserProfiles = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/search-user-profiles", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "SearchUserProfiles" }, SearchUserProfilesInput, SearchUserProfilesOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateSubscriptionGrantStatusOutput = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, environmentId: Schema.optional(Schema.String), subscriptionTargetId: Schema.String, grantedEntity: GrantedEntity, status: Schema.String, assets: Schema.optional(SubscribedAssets), subscriptionId: Schema.optional(Schema.String)})
export const UpdateSubscriptionGrantStatus = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscription-grants/{identifier}/status/{assetIdentifier}", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateSubscriptionGrantStatus" }, UpdateSubscriptionGrantStatusInput, UpdateSubscriptionGrantStatusOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DomainUnitPolicyGrantPrincipal = Schema.Struct({domainUnitDesignation: Schema.String, domainUnitIdentifier: Schema.optional(Schema.String), domainUnitGrantFilter: Schema.optional(DomainUnitGrantFilter)})
const SubscribedProject = Schema.Struct({id: Schema.optional(Schema.String), name: Schema.optional(Schema.String)})
const SubscribedUser = Schema.Struct({id: Schema.optional(Schema.String), details: Schema.optional(UserProfileDetails)})
const SubscribedGroup = Schema.Struct({id: Schema.optional(Schema.String), name: Schema.optional(Schema.String)})
const SparkGluePropertiesInput = Schema.Struct({additionalArgs: Schema.optional(SparkGlueArgs), glueConnectionName: Schema.optional(Schema.String), glueVersion: Schema.optional(Schema.String), idleTimeout: Schema.optional(Schema.Number), javaVirtualEnv: Schema.optional(Schema.String), numberOfWorkers: Schema.optional(Schema.Number), pythonVirtualEnv: Schema.optional(Schema.String), workerType: Schema.optional(Schema.String)})
const EnvironmentConfigurationParametersDetails = Schema.Struct({ssmPath: Schema.optional(Schema.String), parameterOverrides: Schema.optional(EnvironmentConfigurationParametersList), resolvedParameters: Schema.optional(EnvironmentConfigurationParametersList)})
const IamUserProfileDetails = Schema.Struct({arn: Schema.optional(Schema.String), principalId: Schema.optional(Schema.String)})
const SsoUserProfileDetails = Schema.Struct({username: Schema.optional(Schema.String), firstName: Schema.optional(Schema.String), lastName: Schema.optional(Schema.String)})
const ListingRevision = Schema.Struct({id: Schema.String, revision: Schema.String})
const AssetScope = Schema.Struct({assetId: Schema.String, filterIds: FilterIds, status: Schema.String, errorMessage: Schema.optional(Schema.String)})
const AthenaPropertiesOutput = Schema.Struct({workgroupName: Schema.optional(Schema.String)})
const GluePropertiesOutput = Schema.Struct({status: Schema.optional(Schema.String), errorMessage: Schema.optional(Schema.String)})
const HyperPodPropertiesOutput = Schema.Struct({clusterName: Schema.String, clusterArn: Schema.optional(Schema.String), orchestrator: Schema.optional(Schema.String)})
const IamPropertiesOutput = Schema.Struct({environmentId: Schema.optional(Schema.String), glueLineageSyncEnabled: Schema.optional(Schema.Boolean)})
const SparkGluePropertiesOutput = Schema.Struct({additionalArgs: Schema.optional(SparkGlueArgs), glueConnectionName: Schema.optional(Schema.String), glueVersion: Schema.optional(Schema.String), idleTimeout: Schema.optional(Schema.Number), javaVirtualEnv: Schema.optional(Schema.String), numberOfWorkers: Schema.optional(Schema.Number), pythonVirtualEnv: Schema.optional(Schema.String), workerType: Schema.optional(Schema.String)})
const S3PropertiesOutput = Schema.Struct({s3Uri: Schema.String, s3AccessGrantLocationId: Schema.optional(Schema.String), status: Schema.optional(Schema.String), errorMessage: Schema.optional(Schema.String)})
const AmazonQPropertiesOutput = Schema.Struct({isEnabled: Schema.Boolean, profileArn: Schema.optional(Schema.String), authMode: Schema.optional(Schema.String)})
const MlflowPropertiesOutput = Schema.Struct({trackingServerArn: Schema.optional(Schema.String)})
const ConfigurableActionParameter = Schema.Struct({key: Schema.optional(Schema.String), value: Schema.optional(Schema.String)})
const ConfigurableActionParameterList = Schema.Array(ConfigurableActionParameter)
const DataSourceErrorMessage = Schema.Struct({errorType: Schema.String, errorDetail: Schema.optional(Schema.String)})
const LineageInfo = Schema.Struct({eventId: Schema.optional(Schema.String), eventStatus: Schema.optional(Schema.String), errorMessage: Schema.optional(Schema.String)})
const OwnerUserPropertiesOutput = Schema.Struct({userId: Schema.optional(Schema.String)})
const OwnerGroupPropertiesOutput = Schema.Struct({groupId: Schema.optional(Schema.String)})
const MetadataMap = Schema.Record({key: Schema.String, value: Schema.String})
const MetadataFormSummary = Schema.Struct({formName: Schema.optional(Schema.String), typeName: Schema.String, typeRevision: Schema.String})
const MetadataFormsSummary = Schema.Array(MetadataFormSummary)
const LineageNodeTypeItem = Schema.Struct({domainId: Schema.String, name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), createdBy: Schema.optional(Schema.String), updatedAt: Schema.optional(Schema.Date), updatedBy: Schema.optional(Schema.String), revision: Schema.String, formsOutput: FormsOutputMap})
const EnvironmentFailureReasons = Schema.Record({key: Schema.String, value: EnvironmentFailureReasonsList})
const DomainUnitFilterForProject = Schema.Struct({domainUnit: Schema.String, includeChildDomainUnits: Schema.optional(Schema.Boolean)})
const ConnectionProperties = Schema.Record({key: Schema.String, value: Schema.String})
const PhysicalConnectionRequirements = Schema.Struct({subnetId: Schema.optional(Schema.String), subnetIdList: Schema.optional(SubnetIdList), securityGroupIdList: Schema.optional(SecurityGroupIdList), availabilityZone: Schema.optional(Schema.String)})
const PropertyMap = Schema.Record({key: Schema.String, value: Schema.String})
const UsernamePassword = Schema.Struct({password: Schema.String, username: Schema.String})
const LineageSyncSchedule = Schema.Struct({schedule: Schema.optional(Schema.String)})
const FailedQueryProcessingErrorMessages = Schema.Array(Schema.String)
const NameIdentifiers = Schema.Array(NameIdentifier)
const AuthenticationConfigurationPatch = Schema.Struct({secretArn: Schema.optional(Schema.String), basicAuthenticationCredentials: Schema.optional(BasicAuthenticationCredentials)})
const SubscribedPrincipal = Schema.Union(SubscribedProject, SubscribedUser, SubscribedGroup)
const StringList = Schema.Array(Schema.String)
const EnvironmentConfiguration = Schema.Struct({name: Schema.String, id: Schema.optional(Schema.String), environmentBlueprintId: Schema.String, description: Schema.optional(Schema.String), deploymentMode: Schema.optional(Schema.String), configurationParameters: Schema.optional(EnvironmentConfigurationParametersDetails), awsAccount: Schema.optional(AwsAccount), accountPools: Schema.optional(AccountPoolList), awsRegion: Schema.optional(Region), deploymentOrder: Schema.optional(Schema.Number)})
const EnvironmentConfigurationsList = Schema.Array(EnvironmentConfiguration)
const UserProfileDetails = Schema.Union(IamUserProfileDetails, SsoUserProfileDetails)
const GrantedEntity = Schema.Union(ListingRevision)
const SubscribedAsset = Schema.Struct({assetId: Schema.String, assetRevision: Schema.String, status: Schema.String, targetName: Schema.optional(Schema.String), failureCause: Schema.optional(FailureCause), grantedTimestamp: Schema.optional(Schema.Date), failureTimestamp: Schema.optional(Schema.Date), assetScope: Schema.optional(AssetScope), permissions: Schema.optional(Permissions)})
const SubscribedAssets = Schema.Array(SubscribedAsset)
const ConfigurableEnvironmentAction = Schema.Struct({type: Schema.String, auth: Schema.optional(Schema.String), parameters: ConfigurableActionParameterList})
const EnvironmentActionList = Schema.Array(ConfigurableEnvironmentAction)
const DataSourceRunActivity = Schema.Struct({database: Schema.String, dataSourceRunId: Schema.String, technicalName: Schema.String, dataAssetStatus: Schema.String, projectId: Schema.String, dataAssetId: Schema.optional(Schema.String), technicalDescription: Schema.optional(Schema.String), errorMessage: Schema.optional(DataSourceErrorMessage), lineageSummary: Schema.optional(LineageInfo), createdAt: Schema.Date, updatedAt: Schema.Date})
const DataSourceRunActivities = Schema.Array(DataSourceRunActivity)
const OwnerPropertiesOutput = Schema.Union(OwnerUserPropertiesOutput, OwnerGroupPropertiesOutput)
const EntityOwners = Schema.Array(OwnerPropertiesOutput)
const SubscriptionRequestSummary = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, status: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, requestReason: Schema.String, subscribedPrincipals: SubscribedPrincipals, subscribedListings: SubscribedListings, reviewerId: Schema.optional(Schema.String), decisionComment: Schema.optional(Schema.String), existingSubscriptionId: Schema.optional(Schema.String), metadataFormsSummary: Schema.optional(MetadataFormsSummary)})
const SubscriptionRequests = Schema.Array(SubscriptionRequestSummary)
const EnvironmentDeploymentDetails = Schema.Struct({overallDeploymentStatus: Schema.optional(Schema.String), environmentFailureReasons: Schema.optional(EnvironmentFailureReasons)})
const ProjectGrantFilter = Schema.Union(DomainUnitFilterForProject)
const RedshiftCredentials = Schema.Union(Schema.String, UsernamePassword)
const RedshiftLineageSyncConfigurationInput = Schema.Struct({enabled: Schema.optional(Schema.Boolean), schedule: Schema.optional(LineageSyncSchedule)})
const AuthenticationConfiguration = Schema.Struct({authenticationType: Schema.optional(Schema.String), secretArn: Schema.optional(Schema.String), oAuth2Properties: Schema.optional(OAuth2Properties)})
const RedshiftLineageSyncConfigurationOutput = Schema.Struct({lineageJobId: Schema.optional(Schema.String), enabled: Schema.optional(Schema.Boolean), schedule: Schema.optional(LineageSyncSchedule)})
const ManagedEndpointCredentials = Schema.Struct({id: Schema.optional(Schema.String), token: Schema.optional(Schema.String)})
const LineageSqlQueryRunDetails = Schema.Struct({queryStartTime: Schema.optional(Schema.Date), queryEndTime: Schema.optional(Schema.Date), totalQueriesProcessed: Schema.optional(Schema.Number), numQueriesFailed: Schema.optional(Schema.Number), errorMessages: Schema.optional(FailedQueryProcessingErrorMessages)})
const NotificationResource = Schema.Struct({type: Schema.String, id: Schema.String, name: Schema.optional(Schema.String)})
const UserDetails = Schema.Struct({userId: Schema.String})
const GroupDetails = Schema.Struct({groupId: Schema.String})
const Model = Schema.Union(Schema.String)
const Import = Schema.Struct({name: Schema.String, revision: Schema.String})
const ImportList = Schema.Array(Import)
const GlueConnectionPatch = Schema.Struct({description: Schema.optional(Schema.String), connectionProperties: Schema.optional(ConnectionProperties), authenticationConfiguration: Schema.optional(AuthenticationConfigurationPatch)})
const AcceptSubscriptionRequestOutput = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, status: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, requestReason: Schema.String, subscribedPrincipals: SubscribedPrincipals, subscribedListings: SubscribedListings, reviewerId: Schema.optional(Schema.String), decisionComment: Schema.optional(Schema.String), existingSubscriptionId: Schema.optional(Schema.String), metadataForms: Schema.optional(MetadataForms)})
export const AcceptSubscriptionRequest = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}/accept", method: "PUT", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "AcceptSubscriptionRequest" }, AcceptSubscriptionRequestInput, AcceptSubscriptionRequestOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateAccountPoolOutput = Schema.Struct({domainId: Schema.optional(Schema.String), name: Schema.optional(Schema.String), id: Schema.optional(Schema.String), description: Schema.optional(Schema.String), resolutionStrategy: Schema.optional(Schema.String), accountSource: AccountSource, createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), updatedBy: Schema.optional(Schema.String), domainUnitId: Schema.optional(Schema.String)})
export const CreateAccountPool = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/account-pools", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateAccountPool" }, CreateAccountPoolInput, CreateAccountPoolOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const EqualToExpression = Schema.Struct({columnName: Schema.String, value: Schema.String})
const NotEqualToExpression = Schema.Struct({columnName: Schema.String, value: Schema.String})
const GreaterThanExpression = Schema.Struct({columnName: Schema.String, value: Schema.String})
const LessThanExpression = Schema.Struct({columnName: Schema.String, value: Schema.String})
const GreaterThanOrEqualToExpression = Schema.Struct({columnName: Schema.String, value: Schema.String})
const LessThanOrEqualToExpression = Schema.Struct({columnName: Schema.String, value: Schema.String})
const IsNullExpression = Schema.Struct({columnName: Schema.String})
const IsNotNullExpression = Schema.Struct({columnName: Schema.String})
const InExpression = Schema.Struct({columnName: Schema.String, values: StringList})
const NotInExpression = Schema.Struct({columnName: Schema.String, values: StringList})
const LikeExpression = Schema.Struct({columnName: Schema.String, value: Schema.String})
const NotLikeExpression = Schema.Struct({columnName: Schema.String, value: Schema.String})
const BasicAuthenticationCredentials = Schema.Struct({userName: Schema.optional(Schema.String), password: Schema.optional(Schema.String)})
const CredentialMap = Schema.Record({key: Schema.String, value: Schema.String})
const CreateEnvironmentActionOutput = Schema.Struct({domainId: Schema.String, environmentId: Schema.String, id: Schema.String, name: Schema.String, parameters: ActionParameters, description: Schema.optional(Schema.String)})
export const CreateEnvironmentAction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/actions", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateEnvironmentAction" }, CreateEnvironmentActionInput, CreateEnvironmentActionOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateEnvironmentBlueprintOutput = Schema.Struct({id: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), provider: Schema.String, provisioningProperties: ProvisioningProperties, deploymentProperties: Schema.optional(DeploymentProperties), userParameters: Schema.optional(CustomParameterList), glossaryTerms: Schema.optional(GlossaryTerms), createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date)})
export const CreateEnvironmentBlueprint = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environment-blueprints", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateEnvironmentBlueprint" }, CreateEnvironmentBlueprintInput, CreateEnvironmentBlueprintOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateProjectOutput = Schema.Struct({domainId: Schema.String, id: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), projectStatus: Schema.optional(Schema.String), failureReasons: Schema.optional(FailureReasons), createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), resourceTags: Schema.optional(ResourceTags), glossaryTerms: Schema.optional(GlossaryTerms), domainUnitId: Schema.optional(Schema.String), projectProfileId: Schema.optional(Schema.String), userParameters: Schema.optional(EnvironmentConfigurationUserParametersList), environmentDeploymentDetails: Schema.optional(EnvironmentDeploymentDetails)})
export const CreateProject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/projects", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateProject" }, CreateProjectInput, CreateProjectOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateProjectProfileInput = Schema.Struct({domainIdentifier: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), status: Schema.optional(Schema.String), projectResourceTags: Schema.optional(ProjectResourceTagParameters), allowCustomProjectResourceTags: Schema.optional(Schema.Boolean), projectResourceTagsDescription: Schema.optional(Schema.String), environmentConfigurations: Schema.optional(EnvironmentConfigurationsList), domainUnitIdentifier: Schema.optional(Schema.String)})
const CreateSubscriptionGrantOutput = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, environmentId: Schema.optional(Schema.String), subscriptionTargetId: Schema.String, grantedEntity: GrantedEntity, status: Schema.String, assets: Schema.optional(SubscribedAssets), subscriptionId: Schema.optional(Schema.String)})
export const CreateSubscriptionGrant = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscription-grants", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateSubscriptionGrant" }, CreateSubscriptionGrantInput, CreateSubscriptionGrantOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateSubscriptionRequestOutput = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, status: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, requestReason: Schema.String, subscribedPrincipals: SubscribedPrincipals, subscribedListings: SubscribedListings, reviewerId: Schema.optional(Schema.String), decisionComment: Schema.optional(Schema.String), existingSubscriptionId: Schema.optional(Schema.String), metadataForms: Schema.optional(MetadataForms)})
export const CreateSubscriptionRequest = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscription-requests", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateSubscriptionRequest" }, CreateSubscriptionRequestInput, CreateSubscriptionRequestOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateUserProfileOutput = Schema.Struct({domainId: Schema.optional(Schema.String), id: Schema.optional(Schema.String), type: Schema.optional(Schema.String), status: Schema.optional(Schema.String), details: Schema.optional(UserProfileDetails)})
export const CreateUserProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/user-profiles", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateUserProfile" }, CreateUserProfileInput, CreateUserProfileOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteSubscriptionGrantOutput = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, environmentId: Schema.optional(Schema.String), subscriptionTargetId: Schema.String, grantedEntity: GrantedEntity, status: Schema.String, assets: Schema.optional(SubscribedAssets), subscriptionId: Schema.optional(Schema.String)})
export const DeleteSubscriptionGrant = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscription-grants/{identifier}", method: "DELETE", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "DeleteSubscriptionGrant" }, DeleteSubscriptionGrantInput, DeleteSubscriptionGrantOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetEnvironmentOutput = Schema.Struct({projectId: Schema.String, id: Schema.optional(Schema.String), domainId: Schema.String, createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), updatedAt: Schema.optional(Schema.Date), name: Schema.String, description: Schema.optional(Schema.String), environmentProfileId: Schema.optional(Schema.String), awsAccountId: Schema.optional(Schema.String), awsAccountRegion: Schema.optional(Schema.String), provider: Schema.String, provisionedResources: Schema.optional(ResourceList), status: Schema.optional(Schema.String), environmentActions: Schema.optional(EnvironmentActionList), glossaryTerms: Schema.optional(GlossaryTerms), userParameters: Schema.optional(CustomParameterList), lastDeployment: Schema.optional(Deployment), provisioningProperties: Schema.optional(ProvisioningProperties), deploymentProperties: Schema.optional(DeploymentProperties), environmentBlueprintId: Schema.optional(Schema.String), environmentConfigurationId: Schema.optional(Schema.String)})
export const GetEnvironment = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/environments/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetEnvironment" }, GetEnvironmentInput, GetEnvironmentOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDataSourceRunActivitiesOutput = Schema.Struct({items: DataSourceRunActivities, nextToken: Schema.optional(Schema.String)})
export const ListDataSourceRunActivities = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/data-source-runs/{identifier}/activities", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListDataSourceRunActivities" }, ListDataSourceRunActivitiesInput, ListDataSourceRunActivitiesOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListEntityOwnersOutput = Schema.Struct({owners: EntityOwners, nextToken: Schema.optional(Schema.String)})
export const ListEntityOwners = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/owners", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListEntityOwners" }, ListEntityOwnersInput, ListEntityOwnersOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListSubscriptionRequestsOutput = Schema.Struct({items: SubscriptionRequests, nextToken: Schema.optional(Schema.String)})
export const ListSubscriptionRequests = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscription-requests", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListSubscriptionRequests" }, ListSubscriptionRequestsInput, ListSubscriptionRequestsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateProjectInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), resourceTags: Schema.optional(Tags), glossaryTerms: Schema.optional(GlossaryTerms), domainUnitId: Schema.optional(Schema.String), environmentDeploymentDetails: Schema.optional(EnvironmentDeploymentDetails), userParameters: Schema.optional(EnvironmentConfigurationUserParametersList), projectProfileVersion: Schema.optional(Schema.String)})
const ProjectPolicyGrantPrincipal = Schema.Struct({projectDesignation: Schema.String, projectIdentifier: Schema.optional(Schema.String), projectGrantFilter: Schema.optional(ProjectGrantFilter)})
const RedshiftPropertiesInput = Schema.Struct({storage: Schema.optional(RedshiftStorageProperties), databaseName: Schema.optional(Schema.String), host: Schema.optional(Schema.String), port: Schema.optional(Schema.Number), credentials: Schema.optional(RedshiftCredentials), lineageSync: Schema.optional(RedshiftLineageSyncConfigurationInput)})
const GlueConnection = Schema.Struct({name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), connectionType: Schema.optional(Schema.String), matchCriteria: Schema.optional(MatchCriteria), connectionProperties: Schema.optional(ConnectionProperties), sparkProperties: Schema.optional(PropertyMap), athenaProperties: Schema.optional(PropertyMap), pythonProperties: Schema.optional(PropertyMap), physicalConnectionRequirements: Schema.optional(PhysicalConnectionRequirements), creationTime: Schema.optional(Schema.Date), lastUpdatedTime: Schema.optional(Schema.Date), lastUpdatedBy: Schema.optional(Schema.String), status: Schema.optional(Schema.String), statusReason: Schema.optional(Schema.String), lastConnectionValidationTime: Schema.optional(Schema.Date), authenticationConfiguration: Schema.optional(AuthenticationConfiguration), connectionSchemaVersion: Schema.optional(Schema.Number), compatibleComputeEnvironments: Schema.optional(ComputeEnvironmentsList)})
const RedshiftPropertiesOutput = Schema.Struct({storage: Schema.optional(RedshiftStorageProperties), credentials: Schema.optional(RedshiftCredentials), isProvisionedSecret: Schema.optional(Schema.Boolean), jdbcIamUrl: Schema.optional(Schema.String), jdbcUrl: Schema.optional(Schema.String), redshiftTempDir: Schema.optional(Schema.String), lineageSync: Schema.optional(RedshiftLineageSyncConfigurationOutput), status: Schema.optional(Schema.String), databaseName: Schema.optional(Schema.String)})
const SparkEmrPropertiesOutput = Schema.Struct({computeArn: Schema.optional(Schema.String), credentials: Schema.optional(UsernamePassword), credentialsExpiration: Schema.optional(Schema.Date), governanceType: Schema.optional(Schema.String), instanceProfileArn: Schema.optional(Schema.String), javaVirtualEnv: Schema.optional(Schema.String), livyEndpoint: Schema.optional(Schema.String), logUri: Schema.optional(Schema.String), pythonVirtualEnv: Schema.optional(Schema.String), runtimeRole: Schema.optional(Schema.String), trustedCertificatesS3Uri: Schema.optional(Schema.String), certificateData: Schema.optional(Schema.String), managedEndpointArn: Schema.optional(Schema.String), managedEndpointCredentials: Schema.optional(ManagedEndpointCredentials)})
const LineageRunDetails = Schema.Struct({sqlQueryRunDetails: Schema.optional(LineageSqlQueryRunDetails)})
const Topic = Schema.Struct({subject: Schema.String, resource: NotificationResource, role: Schema.String})
const MemberDetails = Schema.Union(UserDetails, GroupDetails)
const AggregationOutputItem = Schema.Struct({value: Schema.optional(Schema.String), count: Schema.optional(Schema.Number), displayValue: Schema.optional(Schema.String)})
const AggregationOutputItems = Schema.Array(AggregationOutputItem)
const FormTypeData = Schema.Struct({domainId: Schema.String, name: Schema.String, revision: Schema.String, model: Schema.optional(Model), status: Schema.optional(Schema.String), owningProjectId: Schema.optional(Schema.String), originDomainId: Schema.optional(Schema.String), originProjectId: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), createdBy: Schema.optional(Schema.String), description: Schema.optional(Schema.String), imports: Schema.optional(ImportList)})
const GluePropertiesPatch = Schema.Struct({glueConnectionInput: Schema.optional(GlueConnectionPatch)})
const DetailedGlossaryTerm = Schema.Struct({name: Schema.optional(Schema.String), shortDescription: Schema.optional(Schema.String)})
const DetailedGlossaryTerms = Schema.Array(DetailedGlossaryTerm)
const AssetInDataProductListingItem = Schema.Struct({entityId: Schema.optional(Schema.String), entityRevision: Schema.optional(Schema.String), entityType: Schema.optional(Schema.String)})
const AssetInDataProductListingItems = Schema.Array(AssetInDataProductListingItem)
const RowFilterExpression = Schema.Union(EqualToExpression, NotEqualToExpression, GreaterThanExpression, LessThanExpression, GreaterThanOrEqualToExpression, LessThanOrEqualToExpression, IsNullExpression, IsNotNullExpression, InExpression, NotInExpression, LikeExpression, NotLikeExpression)
const NameIdentifier = Schema.Struct({name: Schema.optional(Schema.String), namespace: Schema.optional(Schema.String)})
const FormEntryOutput = Schema.Struct({typeName: Schema.String, typeRevision: Schema.String, required: Schema.optional(Schema.Boolean)})
const PolicyGrantPrincipal = Schema.Union(UserPolicyGrantPrincipal, GroupPolicyGrantPrincipal, ProjectPolicyGrantPrincipal, DomainUnitPolicyGrantPrincipal)
const OAuth2ClientApplication = Schema.Struct({userManagedClientApplicationClientId: Schema.optional(Schema.String), aWSManagedClientApplicationReference: Schema.optional(Schema.String)})
const TokenUrlParametersMap = Schema.Record({key: Schema.String, value: Schema.String})
const AuthorizationCodeProperties = Schema.Struct({authorizationCode: Schema.optional(Schema.String), redirectUri: Schema.optional(Schema.String)})
const GlueOAuth2Credentials = Schema.Struct({userManagedClientApplicationClientSecret: Schema.optional(Schema.String), accessToken: Schema.optional(Schema.String), refreshToken: Schema.optional(Schema.String), jwtToken: Schema.optional(Schema.String)})
const PhysicalEndpoint = Schema.Struct({awsLocation: Schema.optional(AwsLocation), glueConnectionName: Schema.optional(Schema.String), glueConnection: Schema.optional(GlueConnection), enableTrustedIdentityPropagation: Schema.optional(Schema.Boolean), host: Schema.optional(Schema.String), port: Schema.optional(Schema.Number), protocol: Schema.optional(Schema.String), stage: Schema.optional(Schema.String)})
const PhysicalEndpoints = Schema.Array(PhysicalEndpoint)
const ConnectionPropertiesOutput = Schema.Union(AthenaPropertiesOutput, GluePropertiesOutput, HyperPodPropertiesOutput, IamPropertiesOutput, RedshiftPropertiesOutput, SparkEmrPropertiesOutput, SparkGluePropertiesOutput, S3PropertiesOutput, AmazonQPropertiesOutput, MlflowPropertiesOutput)
const JobRunDetails = Schema.Union(LineageRunDetails)
const NotificationOutput = Schema.Struct({identifier: Schema.String, domainIdentifier: Schema.String, type: Schema.String, topic: Topic, title: Schema.String, message: Schema.String, status: Schema.optional(Schema.String), actionLink: Schema.String, creationTimestamp: Schema.Date, lastUpdatedTimestamp: Schema.Date, metadata: Schema.optional(MetadataMap)})
const NotificationsList = Schema.Array(NotificationOutput)
const ProjectMember = Schema.Struct({memberDetails: MemberDetails, designation: Schema.String})
const ProjectMembers = Schema.Array(ProjectMember)
const AggregationOutput = Schema.Struct({attribute: Schema.optional(Schema.String), displayValue: Schema.optional(Schema.String), items: Schema.optional(AggregationOutputItems)})
const AggregationOutputList = Schema.Array(AggregationOutput)
const ConnectionPropertiesPatch = Schema.Union(AthenaPropertiesPatch, GluePropertiesPatch, IamPropertiesPatch, RedshiftPropertiesPatch, SparkEmrPropertiesPatch, S3PropertiesPatch, AmazonQPropertiesPatch, MlflowPropertiesPatch)
const SubscribedAssetListing = Schema.Struct({entityId: Schema.optional(Schema.String), entityRevision: Schema.optional(Schema.String), entityType: Schema.optional(Schema.String), forms: Schema.optional(Schema.String), glossaryTerms: Schema.optional(DetailedGlossaryTerms), assetScope: Schema.optional(AssetScope), permissions: Schema.optional(Permissions)})
const SubscribedProductListing = Schema.Struct({entityId: Schema.optional(Schema.String), entityRevision: Schema.optional(Schema.String), glossaryTerms: Schema.optional(DetailedGlossaryTerms), name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), assetListings: Schema.optional(AssetInDataProductListingItems)})
const RowFilter = Schema.Union(RowFilterExpression, RowFilterList, RowFilterList)
const OpenLineageRunEventSummary = Schema.Struct({eventType: Schema.optional(Schema.String), runId: Schema.optional(Schema.String), job: Schema.optional(NameIdentifier), inputs: Schema.optional(NameIdentifiers), outputs: Schema.optional(NameIdentifiers)})
const GlossaryUsageRestrictions = Schema.Array(Schema.String)
const DataProductListingItemAdditionalAttributes = Schema.Struct({forms: Schema.optional(Schema.String), matchRationale: Schema.optional(MatchRationale)})
const ListingSummaryItem = Schema.Struct({listingId: Schema.optional(Schema.String), listingRevision: Schema.optional(Schema.String), glossaryTerms: Schema.optional(DetailedGlossaryTerms)})
const ListingSummaryItems = Schema.Array(ListingSummaryItem)
const FormsOutputMap = Schema.Record({key: Schema.String, value: FormEntryOutput})
const AddPolicyGrantInput = Schema.Struct({domainIdentifier: Schema.String, entityType: Schema.String, entityIdentifier: Schema.String, policyType: Schema.String, principal: PolicyGrantPrincipal, detail: PolicyGrantDetail, clientToken: Schema.optional(Schema.String)})
const OAuth2Properties = Schema.Struct({oAuth2GrantType: Schema.optional(Schema.String), oAuth2ClientApplication: Schema.optional(OAuth2ClientApplication), tokenUrl: Schema.optional(Schema.String), tokenUrlParametersMap: Schema.optional(TokenUrlParametersMap), authorizationCodeProperties: Schema.optional(AuthorizationCodeProperties), oAuth2Credentials: Schema.optional(GlueOAuth2Credentials)})
const CreateProjectProfileOutput = Schema.Struct({domainId: Schema.String, id: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), status: Schema.optional(Schema.String), projectResourceTags: Schema.optional(ProjectResourceTagParameters), allowCustomProjectResourceTags: Schema.optional(Schema.Boolean), projectResourceTagsDescription: Schema.optional(Schema.String), environmentConfigurations: Schema.optional(EnvironmentConfigurationsList), createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), domainUnitId: Schema.optional(Schema.String)})
export const CreateProjectProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/project-profiles", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateProjectProfile" }, CreateProjectProfileInput, CreateProjectProfileOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetConnectionOutput = Schema.Struct({connectionCredentials: Schema.optional(ConnectionCredentials), connectionId: Schema.String, description: Schema.optional(Schema.String), domainId: Schema.String, domainUnitId: Schema.String, environmentId: Schema.optional(Schema.String), environmentUserRole: Schema.optional(Schema.String), name: Schema.String, physicalEndpoints: PhysicalEndpoints, projectId: Schema.optional(Schema.String), props: Schema.optional(ConnectionPropertiesOutput), type: Schema.String, scope: Schema.optional(Schema.String)})
export const GetConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/connections/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetConnection" }, GetConnectionInput, GetConnectionOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetJobRunOutput = Schema.Struct({domainId: Schema.optional(Schema.String), id: Schema.optional(Schema.String), jobId: Schema.optional(Schema.String), jobType: Schema.optional(Schema.String), runMode: Schema.optional(Schema.String), details: Schema.optional(JobRunDetails), status: Schema.optional(Schema.String), error: Schema.optional(JobRunError), createdBy: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), startTime: Schema.optional(Schema.Date), endTime: Schema.optional(Schema.Date)})
export const GetJobRun = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/jobRuns/{identifier}", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "GetJobRun" }, GetJobRunInput, GetJobRunOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListNotificationsOutput = Schema.Struct({notifications: Schema.optional(NotificationsList), nextToken: Schema.optional(Schema.String)})
export const ListNotifications = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/notifications", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListNotifications" }, ListNotificationsInput, ListNotificationsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListProjectMembershipsOutput = Schema.Struct({members: ProjectMembers, nextToken: Schema.optional(Schema.String)})
export const ListProjectMemberships = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/projects/{projectIdentifier}/memberships", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListProjectMemberships" }, ListProjectMembershipsInput, ListProjectMembershipsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateConnectionInput = Schema.Struct({domainIdentifier: Schema.String, identifier: Schema.String, description: Schema.optional(Schema.String), awsLocation: Schema.optional(AwsLocation), props: Schema.optional(ConnectionPropertiesPatch)})
const UpdateProjectOutput = Schema.Struct({domainId: Schema.String, id: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), projectStatus: Schema.optional(Schema.String), failureReasons: Schema.optional(FailureReasons), createdBy: Schema.String, createdAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), resourceTags: Schema.optional(ResourceTags), glossaryTerms: Schema.optional(GlossaryTerms), domainUnitId: Schema.optional(Schema.String), projectProfileId: Schema.optional(Schema.String), userParameters: Schema.optional(EnvironmentConfigurationUserParametersList), environmentDeploymentDetails: Schema.optional(EnvironmentDeploymentDetails)})
export const UpdateProject = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/projects/{identifier}", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateProject" }, UpdateProjectInput, UpdateProjectOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const SubscribedListingItem = Schema.Union(SubscribedAssetListing, SubscribedProductListing)
const RowFilterConfiguration = Schema.Struct({rowFilter: RowFilter, sensitive: Schema.optional(Schema.Boolean)})
const EventSummary = Schema.Union(OpenLineageRunEventSummary)
const DataProductListingItem = Schema.Struct({listingId: Schema.optional(Schema.String), listingRevision: Schema.optional(Schema.String), name: Schema.optional(Schema.String), entityId: Schema.optional(Schema.String), entityRevision: Schema.optional(Schema.String), description: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), listingCreatedBy: Schema.optional(Schema.String), listingUpdatedBy: Schema.optional(Schema.String), glossaryTerms: Schema.optional(DetailedGlossaryTerms), owningProjectId: Schema.optional(Schema.String), additionalAttributes: Schema.optional(DataProductListingItemAdditionalAttributes), items: Schema.optional(ListingSummaryItems)})
const AssetTypeItem = Schema.Struct({domainId: Schema.String, name: Schema.String, revision: Schema.String, description: Schema.optional(Schema.String), formsOutput: FormsOutputMap, owningProjectId: Schema.String, originDomainId: Schema.optional(Schema.String), originProjectId: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), createdBy: Schema.optional(Schema.String), updatedAt: Schema.optional(Schema.Date), updatedBy: Schema.optional(Schema.String)})
const AuthenticationConfigurationInput = Schema.Struct({authenticationType: Schema.optional(Schema.String), oAuth2Properties: Schema.optional(OAuth2Properties), secretArn: Schema.optional(Schema.String), kmsKeyArn: Schema.optional(Schema.String), basicAuthenticationCredentials: Schema.optional(BasicAuthenticationCredentials), customAuthenticationCredentials: Schema.optional(CredentialMap)})
const SubscribedListing = Schema.Struct({id: Schema.String, revision: Schema.optional(Schema.String), name: Schema.String, description: Schema.String, item: SubscribedListingItem, ownerProjectId: Schema.String, ownerProjectName: Schema.optional(Schema.String)})
const AssetFilterConfiguration = Schema.Union(ColumnFilterConfiguration, RowFilterConfiguration)
const LineageEventSummary = Schema.Struct({id: Schema.optional(Schema.String), domainId: Schema.optional(Schema.String), processingStatus: Schema.optional(Schema.String), eventTime: Schema.optional(Schema.Date), eventSummary: Schema.optional(EventSummary), createdBy: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date)})
const LineageEventSummaries = Schema.Array(LineageEventSummary)
const SearchTypesResultItem = Schema.Union(AssetTypeItem, FormTypeData, LineageNodeTypeItem)
const SearchTypesResultItems = Schema.Array(SearchTypesResultItem)
const GlueConnectionInput = Schema.Struct({connectionProperties: Schema.optional(ConnectionProperties), physicalConnectionRequirements: Schema.optional(PhysicalConnectionRequirements), name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), connectionType: Schema.optional(Schema.String), matchCriteria: Schema.optional(Schema.String), validateCredentials: Schema.optional(Schema.Boolean), validateForComputeEnvironments: Schema.optional(ComputeEnvironmentsList), sparkProperties: Schema.optional(PropertyMap), athenaProperties: Schema.optional(PropertyMap), pythonProperties: Schema.optional(PropertyMap), authenticationConfiguration: Schema.optional(AuthenticationConfigurationInput)})
const GlossaryItemAdditionalAttributes = Schema.Struct({matchRationale: Schema.optional(MatchRationale)})
const TermRelations = Schema.Struct({isA: Schema.optional(GlossaryTerms), classifies: Schema.optional(GlossaryTerms)})
const GlossaryTermItemAdditionalAttributes = Schema.Struct({matchRationale: Schema.optional(MatchRationale)})
const AssetItemAdditionalAttributes = Schema.Struct({formsOutput: Schema.optional(FormOutputList), readOnlyFormsOutput: Schema.optional(FormOutputList), latestTimeSeriesDataPointFormsOutput: Schema.optional(TimeSeriesDataPointSummaryFormOutputList), matchRationale: Schema.optional(MatchRationale)})
const DataProductItemAdditionalAttributes = Schema.Struct({matchRationale: Schema.optional(MatchRationale)})
const AddPolicyGrantOutput = Schema.Struct({grantId: Schema.optional(Schema.String)})
export const AddPolicyGrant = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/policies/managed/{entityType}/{entityIdentifier}/addGrant", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "AddPolicyGrant" }, AddPolicyGrantInput, AddPolicyGrantOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CancelSubscriptionOutput = Schema.Struct({id: Schema.String, createdBy: Schema.String, updatedBy: Schema.optional(Schema.String), domainId: Schema.String, status: Schema.String, createdAt: Schema.Date, updatedAt: Schema.Date, subscribedPrincipal: SubscribedPrincipal, subscribedListing: SubscribedListing, subscriptionRequestId: Schema.optional(Schema.String), retainPermissions: Schema.optional(Schema.Boolean)})
export const CancelSubscription = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/subscriptions/{identifier}/cancel", method: "PUT", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CancelSubscription" }, CancelSubscriptionInput, CancelSubscriptionOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateAssetFilterInput = Schema.Struct({domainIdentifier: Schema.String, assetIdentifier: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), configuration: AssetFilterConfiguration, clientToken: Schema.optional(Schema.String)})
const ListLineageEventsOutput = Schema.Struct({items: Schema.optional(LineageEventSummaries), nextToken: Schema.optional(Schema.String)})
export const ListLineageEvents = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/lineage/events", method: "GET", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "ListLineageEvents" }, ListLineageEventsInput, ListLineageEventsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const SearchTypesOutput = Schema.Struct({items: Schema.optional(SearchTypesResultItems), nextToken: Schema.optional(Schema.String), totalMatchCount: Schema.optional(Schema.Number)})
export const SearchTypes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/types-search", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "SearchTypes" }, SearchTypesInput, SearchTypesOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateConnectionOutput = Schema.Struct({connectionId: Schema.String, description: Schema.optional(Schema.String), domainId: Schema.String, domainUnitId: Schema.String, environmentId: Schema.optional(Schema.String), name: Schema.String, physicalEndpoints: PhysicalEndpoints, projectId: Schema.optional(Schema.String), props: Schema.optional(ConnectionPropertiesOutput), type: Schema.String, scope: Schema.optional(Schema.String)})
export const UpdateConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/connections/{identifier}", method: "PATCH", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "UpdateConnection" }, UpdateConnectionInput, UpdateConnectionOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GluePropertiesInput = Schema.Struct({glueConnectionInput: Schema.optional(GlueConnectionInput)})
const GlossaryItem = Schema.Struct({domainId: Schema.String, id: Schema.String, name: Schema.String, owningProjectId: Schema.String, description: Schema.optional(Schema.String), status: Schema.String, usageRestrictions: Schema.optional(GlossaryUsageRestrictions), createdAt: Schema.optional(Schema.Date), createdBy: Schema.optional(Schema.String), updatedAt: Schema.optional(Schema.Date), updatedBy: Schema.optional(Schema.String), additionalAttributes: Schema.optional(GlossaryItemAdditionalAttributes)})
const GlossaryTermItem = Schema.Struct({domainId: Schema.String, glossaryId: Schema.String, id: Schema.String, name: Schema.String, shortDescription: Schema.optional(Schema.String), usageRestrictions: Schema.optional(GlossaryUsageRestrictions), longDescription: Schema.optional(Schema.String), termRelations: Schema.optional(TermRelations), status: Schema.String, createdAt: Schema.optional(Schema.Date), createdBy: Schema.optional(Schema.String), updatedAt: Schema.optional(Schema.Date), updatedBy: Schema.optional(Schema.String), additionalAttributes: Schema.optional(GlossaryTermItemAdditionalAttributes)})
const AssetItem = Schema.Struct({domainId: Schema.String, identifier: Schema.String, name: Schema.String, typeIdentifier: Schema.String, typeRevision: Schema.String, externalIdentifier: Schema.optional(Schema.String), description: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), createdBy: Schema.optional(Schema.String), firstRevisionCreatedAt: Schema.optional(Schema.Date), firstRevisionCreatedBy: Schema.optional(Schema.String), glossaryTerms: Schema.optional(GlossaryTerms), owningProjectId: Schema.String, additionalAttributes: Schema.optional(AssetItemAdditionalAttributes), governedGlossaryTerms: Schema.optional(GovernedGlossaryTerms)})
const DataProductResultItem = Schema.Struct({domainId: Schema.String, id: Schema.String, name: Schema.String, owningProjectId: Schema.String, description: Schema.optional(Schema.String), glossaryTerms: Schema.optional(GlossaryTerms), createdAt: Schema.optional(Schema.Date), createdBy: Schema.optional(Schema.String), firstRevisionCreatedAt: Schema.optional(Schema.Date), firstRevisionCreatedBy: Schema.optional(Schema.String), additionalAttributes: Schema.optional(DataProductItemAdditionalAttributes)})
const ConnectionPropertiesInput = Schema.Union(AthenaPropertiesInput, GluePropertiesInput, HyperPodPropertiesInput, IamPropertiesInput, RedshiftPropertiesInput, SparkEmrPropertiesInput, SparkGluePropertiesInput, S3PropertiesInput, AmazonQPropertiesInput, MlflowPropertiesInput)
const SearchInventoryResultItem = Schema.Union(GlossaryItem, GlossaryTermItem, AssetItem, DataProductResultItem)
const SearchInventoryResultItems = Schema.Array(SearchInventoryResultItem)
const MatchOffset = Schema.Struct({startOffset: Schema.optional(Schema.Number), endOffset: Schema.optional(Schema.Number)})
const MatchOffsets = Schema.Array(MatchOffset)
const CreateAssetFilterOutput = Schema.Struct({id: Schema.String, domainId: Schema.String, assetId: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), status: Schema.optional(Schema.String), configuration: AssetFilterConfiguration, createdAt: Schema.optional(Schema.Date), errorMessage: Schema.optional(Schema.String), effectiveColumnNames: Schema.optional(ColumnNameList), effectiveRowFilter: Schema.optional(Schema.String)})
export const CreateAssetFilter = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/assets/{assetIdentifier}/filters", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateAssetFilter" }, CreateAssetFilterInput, CreateAssetFilterOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateConnectionInput = Schema.Struct({awsLocation: Schema.optional(AwsLocation), clientToken: Schema.optional(Schema.String), description: Schema.optional(Schema.String), domainIdentifier: Schema.String, environmentIdentifier: Schema.optional(Schema.String), name: Schema.String, props: Schema.optional(ConnectionPropertiesInput), enableTrustedIdentityPropagation: Schema.optional(Schema.Boolean), scope: Schema.optional(Schema.String)})
const SearchOutput = Schema.Struct({items: Schema.optional(SearchInventoryResultItems), nextToken: Schema.optional(Schema.String), totalMatchCount: Schema.optional(Schema.Number)})
export const Search = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/search", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "Search" }, SearchInput, SearchOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TextMatchItem = Schema.Struct({attribute: Schema.optional(Schema.String), text: Schema.optional(Schema.String), matchOffsets: Schema.optional(MatchOffsets)})
const TextMatches = Schema.Array(TextMatchItem)
const MatchRationaleItem = Schema.Union(TextMatches)
const MatchRationale = Schema.Array(MatchRationaleItem)
const AssetListingItemAdditionalAttributes = Schema.Struct({forms: Schema.optional(Schema.String), matchRationale: Schema.optional(MatchRationale), latestTimeSeriesDataPointForms: Schema.optional(TimeSeriesDataPointSummaryFormOutputList)})
const CreateConnectionOutput = Schema.Struct({connectionId: Schema.String, description: Schema.optional(Schema.String), domainId: Schema.String, domainUnitId: Schema.String, environmentId: Schema.optional(Schema.String), name: Schema.String, physicalEndpoints: PhysicalEndpoints, projectId: Schema.optional(Schema.String), props: Schema.optional(ConnectionPropertiesOutput), type: Schema.String, scope: Schema.optional(Schema.String)})
export const CreateConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/connections", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "CreateConnection" }, CreateConnectionInput, CreateConnectionOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const AssetListingItem = Schema.Struct({listingId: Schema.optional(Schema.String), listingRevision: Schema.optional(Schema.String), name: Schema.optional(Schema.String), entityId: Schema.optional(Schema.String), entityRevision: Schema.optional(Schema.String), entityType: Schema.optional(Schema.String), description: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), listingCreatedBy: Schema.optional(Schema.String), listingUpdatedBy: Schema.optional(Schema.String), glossaryTerms: Schema.optional(DetailedGlossaryTerms), governedGlossaryTerms: Schema.optional(DetailedGlossaryTerms), owningProjectId: Schema.optional(Schema.String), additionalAttributes: Schema.optional(AssetListingItemAdditionalAttributes)})
const SearchResultItem = Schema.Union(AssetListingItem, DataProductListingItem)
const SearchResultItems = Schema.Array(SearchResultItem)
const SearchListingsOutput = Schema.Struct({items: Schema.optional(SearchResultItems), nextToken: Schema.optional(Schema.String), totalMatchCount: Schema.optional(Schema.Number), aggregates: Schema.optional(AggregationOutputList)})
export const SearchListings = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/v2/domains/{domainIdentifier}/listings/search", method: "POST", sdkId: "DataZone", sigV4ServiceName: "datazone", name: "SearchListings" }, SearchListingsInput, SearchListingsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
