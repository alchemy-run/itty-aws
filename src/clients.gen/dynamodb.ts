import { Schema} from "effect"
import { FormatAwsJSON10Request,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
export const DescribeEndpointsRequest = Schema.Struct({});
export const DescribeLimitsInput = Schema.Struct({});
export const AttributeNameList = Schema.Array(Schema.String);
export const TagKeyList = Schema.Array(Schema.String);
export const CreateBackupInput = Schema.Struct({TableName: Schema.String, BackupName: Schema.String});
export const DeleteBackupInput = Schema.Struct({BackupArn: Schema.String});
export const DeleteResourcePolicyInput = Schema.Struct({ResourceArn: Schema.String, ExpectedRevisionId: Schema.optional(Schema.String)});
export const DeleteTableInput = Schema.Struct({TableName: Schema.String});
export const DescribeBackupInput = Schema.Struct({BackupArn: Schema.String});
export const DescribeContinuousBackupsInput = Schema.Struct({TableName: Schema.String});
export const DescribeContributorInsightsInput = Schema.Struct({TableName: Schema.String, IndexName: Schema.optional(Schema.String)});
export const DescribeExportInput = Schema.Struct({ExportArn: Schema.String});
export const DescribeGlobalTableInput = Schema.Struct({GlobalTableName: Schema.String});
export const DescribeGlobalTableSettingsInput = Schema.Struct({GlobalTableName: Schema.String});
export const DescribeImportInput = Schema.Struct({ImportArn: Schema.String});
export const DescribeKinesisStreamingDestinationInput = Schema.Struct({TableName: Schema.String});
export const DescribeLimitsOutput = Schema.Struct({AccountMaxReadCapacityUnits: Schema.optional(Schema.Number), AccountMaxWriteCapacityUnits: Schema.optional(Schema.Number), TableMaxReadCapacityUnits: Schema.optional(Schema.Number), TableMaxWriteCapacityUnits: Schema.optional(Schema.Number)});
export const DescribeTableInput = Schema.Struct({TableName: Schema.String});
export const DescribeTableReplicaAutoScalingInput = Schema.Struct({TableName: Schema.String});
export const DescribeTimeToLiveInput = Schema.Struct({TableName: Schema.String});
export const EnableKinesisStreamingConfiguration = Schema.Struct({ApproximateCreationDateTimePrecision: Schema.optional(Schema.String)});
export const KinesisStreamingDestinationOutput = Schema.Struct({TableName: Schema.optional(Schema.String), StreamArn: Schema.optional(Schema.String), DestinationStatus: Schema.optional(Schema.String), EnableKinesisStreamingConfiguration: Schema.optional(EnableKinesisStreamingConfiguration)});
export const StringSetAttributeValue = Schema.Array(Schema.String);
export const NumberSetAttributeValue = Schema.Array(Schema.String);
export const BinarySetAttributeValue = Schema.Array(StreamBody());
export const MapAttributeValue = Schema.Record({key: Schema.String, value: AttributeValue});
export const ListAttributeValue = Schema.Array(AttributeValue);
export const AttributeValue = Schema.Union(Schema.String, Schema.String, StreamBody(), StringSetAttributeValue, NumberSetAttributeValue, BinarySetAttributeValue, MapAttributeValue, ListAttributeValue, Schema.Boolean, Schema.Boolean);
export const Key = Schema.Record({key: Schema.String, value: AttributeValue});
export const ExpressionAttributeNameMap = Schema.Record({key: Schema.String, value: Schema.String});
export const GetItemInput = Schema.Struct({TableName: Schema.String, Key: Key, AttributesToGet: Schema.optional(AttributeNameList), ConsistentRead: Schema.optional(Schema.Boolean), ReturnConsumedCapacity: Schema.optional(Schema.String), ProjectionExpression: Schema.optional(Schema.String), ExpressionAttributeNames: Schema.optional(ExpressionAttributeNameMap)});
export const GetResourcePolicyInput = Schema.Struct({ResourceArn: Schema.String});
export const ListBackupsInput = Schema.Struct({TableName: Schema.optional(Schema.String), Limit: Schema.optional(Schema.Number), TimeRangeLowerBound: Schema.optional(Schema.Date), TimeRangeUpperBound: Schema.optional(Schema.Date), ExclusiveStartBackupArn: Schema.optional(Schema.String), BackupType: Schema.optional(Schema.String)});
export const ListContributorInsightsInput = Schema.Struct({TableName: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const ListExportsInput = Schema.Struct({TableArn: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListGlobalTablesInput = Schema.Struct({ExclusiveStartGlobalTableName: Schema.optional(Schema.String), Limit: Schema.optional(Schema.Number), RegionName: Schema.optional(Schema.String)});
export const ListImportsInput = Schema.Struct({TableArn: Schema.optional(Schema.String), PageSize: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListTablesInput = Schema.Struct({ExclusiveStartTableName: Schema.optional(Schema.String), Limit: Schema.optional(Schema.Number)});
export const ListTagsOfResourceInput = Schema.Struct({ResourceArn: Schema.String, NextToken: Schema.optional(Schema.String)});
export const PutResourcePolicyInput = Schema.Struct({ResourceArn: Schema.String, Policy: Schema.String, ExpectedRevisionId: Schema.optional(Schema.String), ConfirmRemoveSelfResourceAccess: Schema.optional(Header("x-amz-confirm-remove-self-resource-access", Schema.Boolean))});
export const KeySchemaElement = Schema.Struct({AttributeName: Schema.String, KeyType: Schema.String});
export const KeySchema = Schema.Array(KeySchemaElement);
export const NonKeyAttributeNameList = Schema.Array(Schema.String);
export const Projection = Schema.Struct({ProjectionType: Schema.optional(Schema.String), NonKeyAttributes: Schema.optional(NonKeyAttributeNameList)});
export const ProvisionedThroughput = Schema.Struct({ReadCapacityUnits: Schema.Number, WriteCapacityUnits: Schema.Number});
export const OnDemandThroughput = Schema.Struct({MaxReadRequestUnits: Schema.optional(Schema.Number), MaxWriteRequestUnits: Schema.optional(Schema.Number)});
export const WarmThroughput = Schema.Struct({ReadUnitsPerSecond: Schema.optional(Schema.Number), WriteUnitsPerSecond: Schema.optional(Schema.Number)});
export const GlobalSecondaryIndex = Schema.Struct({IndexName: Schema.String, KeySchema: KeySchema, Projection: Projection, ProvisionedThroughput: Schema.optional(ProvisionedThroughput), OnDemandThroughput: Schema.optional(OnDemandThroughput), WarmThroughput: Schema.optional(WarmThroughput)});
export const GlobalSecondaryIndexList = Schema.Array(GlobalSecondaryIndex);
export const LocalSecondaryIndex = Schema.Struct({IndexName: Schema.String, KeySchema: KeySchema, Projection: Projection});
export const LocalSecondaryIndexList = Schema.Array(LocalSecondaryIndex);
export const SSESpecification = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), SSEType: Schema.optional(Schema.String), KMSMasterKeyId: Schema.optional(Schema.String)});
export const RestoreTableFromBackupInput = Schema.Struct({TargetTableName: Schema.String, BackupArn: Schema.String, BillingModeOverride: Schema.optional(Schema.String), GlobalSecondaryIndexOverride: Schema.optional(GlobalSecondaryIndexList), LocalSecondaryIndexOverride: Schema.optional(LocalSecondaryIndexList), ProvisionedThroughputOverride: Schema.optional(ProvisionedThroughput), OnDemandThroughputOverride: Schema.optional(OnDemandThroughput), SSESpecificationOverride: Schema.optional(SSESpecification)});
export const RestoreTableToPointInTimeInput = Schema.Struct({SourceTableArn: Schema.optional(Schema.String), SourceTableName: Schema.optional(Schema.String), TargetTableName: Schema.String, UseLatestRestorableTime: Schema.optional(Schema.Boolean), RestoreDateTime: Schema.optional(Schema.Date), BillingModeOverride: Schema.optional(Schema.String), GlobalSecondaryIndexOverride: Schema.optional(GlobalSecondaryIndexList), LocalSecondaryIndexOverride: Schema.optional(LocalSecondaryIndexList), ProvisionedThroughputOverride: Schema.optional(ProvisionedThroughput), OnDemandThroughputOverride: Schema.optional(OnDemandThroughput), SSESpecificationOverride: Schema.optional(SSESpecification)});
export const AttributeValueList = Schema.Array(AttributeValue);
export const Condition = Schema.Struct({AttributeValueList: Schema.optional(AttributeValueList), ComparisonOperator: Schema.String});
export const FilterConditionMap = Schema.Record({key: Schema.String, value: Condition});
export const ExpressionAttributeValueMap = Schema.Record({key: Schema.String, value: AttributeValue});
export const ScanInput = Schema.Struct({TableName: Schema.String, IndexName: Schema.optional(Schema.String), AttributesToGet: Schema.optional(AttributeNameList), Limit: Schema.optional(Schema.Number), Select: Schema.optional(Schema.String), ScanFilter: Schema.optional(FilterConditionMap), ConditionalOperator: Schema.optional(Schema.String), ExclusiveStartKey: Schema.optional(Key), ReturnConsumedCapacity: Schema.optional(Schema.String), TotalSegments: Schema.optional(Schema.Number), Segment: Schema.optional(Schema.Number), ProjectionExpression: Schema.optional(Schema.String), FilterExpression: Schema.optional(Schema.String), ExpressionAttributeNames: Schema.optional(ExpressionAttributeNameMap), ExpressionAttributeValues: Schema.optional(ExpressionAttributeValueMap), ConsistentRead: Schema.optional(Schema.Boolean)});
export const Tag = Schema.Struct({Key: Schema.String, Value: Schema.String});
export const TagList = Schema.Array(Tag);
export const TagResourceInput = Schema.Struct({ResourceArn: Schema.String, Tags: TagList});
export const UntagResourceInput = Schema.Struct({ResourceArn: Schema.String, TagKeys: TagKeyList});
export const UpdateContributorInsightsInput = Schema.Struct({TableName: Schema.String, IndexName: Schema.optional(Schema.String), ContributorInsightsAction: Schema.String, ContributorInsightsMode: Schema.optional(Schema.String)});
export const PreparedStatementParameters = Schema.Array(AttributeValue);
export const BatchStatementRequest = Schema.Struct({Statement: Schema.String, Parameters: Schema.optional(PreparedStatementParameters), ConsistentRead: Schema.optional(Schema.Boolean), ReturnValuesOnConditionCheckFailure: Schema.optional(Schema.String)});
export const PartiQLBatchRequest = Schema.Array(BatchStatementRequest);
export const Replica = Schema.Struct({RegionName: Schema.optional(Schema.String)});
export const ReplicaList = Schema.Array(Replica);
export const AttributeDefinition = Schema.Struct({AttributeName: Schema.String, AttributeType: Schema.String});
export const AttributeDefinitions = Schema.Array(AttributeDefinition);
export const StreamSpecification = Schema.Struct({StreamEnabled: Schema.Boolean, StreamViewType: Schema.optional(Schema.String)});
export const ContributorInsightsRuleList = Schema.Array(Schema.String);
export const Endpoint = Schema.Struct({Address: Schema.String, CachePeriodInMinutes: Schema.Number});
export const Endpoints = Schema.Array(Endpoint);
export const ParameterizedStatement = Schema.Struct({Statement: Schema.String, Parameters: Schema.optional(PreparedStatementParameters), ReturnValuesOnConditionCheckFailure: Schema.optional(Schema.String)});
export const ParameterizedStatements = Schema.Array(ParameterizedStatement);
export const IncrementalExportSpecification = Schema.Struct({ExportFromTime: Schema.optional(Schema.Date), ExportToTime: Schema.optional(Schema.Date), ExportViewType: Schema.optional(Schema.String)});
export const S3BucketSource = Schema.Struct({S3BucketOwner: Schema.optional(Schema.String), S3Bucket: Schema.String, S3KeyPrefix: Schema.optional(Schema.String)});
export const TableCreationParameters = Schema.Struct({TableName: Schema.String, AttributeDefinitions: AttributeDefinitions, KeySchema: KeySchema, BillingMode: Schema.optional(Schema.String), ProvisionedThroughput: Schema.optional(ProvisionedThroughput), OnDemandThroughput: Schema.optional(OnDemandThroughput), SSESpecification: Schema.optional(SSESpecification), GlobalSecondaryIndexes: Schema.optional(GlobalSecondaryIndexList)});
export const TableNameList = Schema.Array(Schema.String);
export const PutItemInputAttributeMap = Schema.Record({key: Schema.String, value: AttributeValue});
export const AttributeMap = Schema.Record({key: Schema.String, value: AttributeValue});
export const ItemList = Schema.Array(AttributeMap);
export const PointInTimeRecoverySpecification = Schema.Struct({PointInTimeRecoveryEnabled: Schema.Boolean, RecoveryPeriodInDays: Schema.optional(Schema.Number)});
export const AutoScalingTargetTrackingScalingPolicyConfigurationUpdate = Schema.Struct({DisableScaleIn: Schema.optional(Schema.Boolean), ScaleInCooldown: Schema.optional(Schema.Number), ScaleOutCooldown: Schema.optional(Schema.Number), TargetValue: Schema.Number});
export const AutoScalingPolicyUpdate = Schema.Struct({PolicyName: Schema.optional(Schema.String), TargetTrackingScalingPolicyConfiguration: AutoScalingTargetTrackingScalingPolicyConfigurationUpdate});
export const AutoScalingSettingsUpdate = Schema.Struct({MinimumUnits: Schema.optional(Schema.Number), MaximumUnits: Schema.optional(Schema.Number), AutoScalingDisabled: Schema.optional(Schema.Boolean), AutoScalingRoleArn: Schema.optional(Schema.String), ScalingPolicyUpdate: Schema.optional(AutoScalingPolicyUpdate)});
export const GlobalTableGlobalSecondaryIndexSettingsUpdate = Schema.Struct({IndexName: Schema.String, ProvisionedWriteCapacityUnits: Schema.optional(Schema.Number), ProvisionedWriteCapacityAutoScalingSettingsUpdate: Schema.optional(AutoScalingSettingsUpdate)});
export const GlobalTableGlobalSecondaryIndexSettingsUpdateList = Schema.Array(GlobalTableGlobalSecondaryIndexSettingsUpdate);
export const UpdateKinesisStreamingConfiguration = Schema.Struct({ApproximateCreationDateTimePrecision: Schema.optional(Schema.String)});
export const GlobalSecondaryIndexAutoScalingUpdate = Schema.Struct({IndexName: Schema.optional(Schema.String), ProvisionedWriteCapacityAutoScalingUpdate: Schema.optional(AutoScalingSettingsUpdate)});
export const GlobalSecondaryIndexAutoScalingUpdateList = Schema.Array(GlobalSecondaryIndexAutoScalingUpdate);
export const TimeToLiveSpecification = Schema.Struct({Enabled: Schema.Boolean, AttributeName: Schema.String});
export const KeyList = Schema.Array(Key);
export const CsvHeaderList = Schema.Array(Schema.String);
export const BatchExecuteStatementInput = Schema.Struct({Statements: PartiQLBatchRequest, ReturnConsumedCapacity: Schema.optional(Schema.String)});
export const CreateGlobalTableInput = Schema.Struct({GlobalTableName: Schema.String, ReplicationGroup: ReplicaList});
export const DeleteResourcePolicyOutput = Schema.Struct({RevisionId: Schema.optional(Schema.String)});
export const BackupDetails = Schema.Struct({BackupArn: Schema.String, BackupName: Schema.String, BackupSizeBytes: Schema.optional(Schema.Number), BackupStatus: Schema.String, BackupType: Schema.String, BackupCreationDateTime: Schema.Date, BackupExpiryDateTime: Schema.optional(Schema.Date)});
export const SourceTableDetails = Schema.Struct({TableName: Schema.String, TableId: Schema.String, TableArn: Schema.optional(Schema.String), TableSizeBytes: Schema.optional(Schema.Number), KeySchema: KeySchema, TableCreationDateTime: Schema.Date, ProvisionedThroughput: ProvisionedThroughput, OnDemandThroughput: Schema.optional(OnDemandThroughput), ItemCount: Schema.optional(Schema.Number), BillingMode: Schema.optional(Schema.String)});
export const LocalSecondaryIndexInfo = Schema.Struct({IndexName: Schema.optional(Schema.String), KeySchema: Schema.optional(KeySchema), Projection: Schema.optional(Projection)});
export const LocalSecondaryIndexes = Schema.Array(LocalSecondaryIndexInfo);
export const GlobalSecondaryIndexInfo = Schema.Struct({IndexName: Schema.optional(Schema.String), KeySchema: Schema.optional(KeySchema), Projection: Schema.optional(Projection), ProvisionedThroughput: Schema.optional(ProvisionedThroughput), OnDemandThroughput: Schema.optional(OnDemandThroughput)});
export const GlobalSecondaryIndexes = Schema.Array(GlobalSecondaryIndexInfo);
export const TimeToLiveDescription = Schema.Struct({TimeToLiveStatus: Schema.optional(Schema.String), AttributeName: Schema.optional(Schema.String)});
export const SSEDescription = Schema.Struct({Status: Schema.optional(Schema.String), SSEType: Schema.optional(Schema.String), KMSMasterKeyArn: Schema.optional(Schema.String), InaccessibleEncryptionDateTime: Schema.optional(Schema.Date)});
export const SourceTableFeatureDetails = Schema.Struct({LocalSecondaryIndexes: Schema.optional(LocalSecondaryIndexes), GlobalSecondaryIndexes: Schema.optional(GlobalSecondaryIndexes), StreamDescription: Schema.optional(StreamSpecification), TimeToLiveDescription: Schema.optional(TimeToLiveDescription), SSEDescription: Schema.optional(SSEDescription)});
export const BackupDescription = Schema.Struct({BackupDetails: Schema.optional(BackupDetails), SourceTableDetails: Schema.optional(SourceTableDetails), SourceTableFeatureDetails: Schema.optional(SourceTableFeatureDetails)});
export const DescribeBackupOutput = Schema.Struct({BackupDescription: Schema.optional(BackupDescription)});
export const DescribeEndpointsResponse = Schema.Struct({Endpoints: Endpoints});
export const InternalServerError = Schema.Struct({message: Schema.optional(Schema.String)});
export const ProvisionedThroughputDescription = Schema.Struct({LastIncreaseDateTime: Schema.optional(Schema.Date), LastDecreaseDateTime: Schema.optional(Schema.Date), NumberOfDecreasesToday: Schema.optional(Schema.Number), ReadCapacityUnits: Schema.optional(Schema.Number), WriteCapacityUnits: Schema.optional(Schema.Number)});
export const BillingModeSummary = Schema.Struct({BillingMode: Schema.optional(Schema.String), LastUpdateToPayPerRequestDateTime: Schema.optional(Schema.Date)});
export const LocalSecondaryIndexDescription = Schema.Struct({IndexName: Schema.optional(Schema.String), KeySchema: Schema.optional(KeySchema), Projection: Schema.optional(Projection), IndexSizeBytes: Schema.optional(Schema.Number), ItemCount: Schema.optional(Schema.Number), IndexArn: Schema.optional(Schema.String)});
export const LocalSecondaryIndexDescriptionList = Schema.Array(LocalSecondaryIndexDescription);
export const GlobalSecondaryIndexWarmThroughputDescription = Schema.Struct({ReadUnitsPerSecond: Schema.optional(Schema.Number), WriteUnitsPerSecond: Schema.optional(Schema.Number), Status: Schema.optional(Schema.String)});
export const GlobalSecondaryIndexDescription = Schema.Struct({IndexName: Schema.optional(Schema.String), KeySchema: Schema.optional(KeySchema), Projection: Schema.optional(Projection), IndexStatus: Schema.optional(Schema.String), Backfilling: Schema.optional(Schema.Boolean), ProvisionedThroughput: Schema.optional(ProvisionedThroughputDescription), IndexSizeBytes: Schema.optional(Schema.Number), ItemCount: Schema.optional(Schema.Number), IndexArn: Schema.optional(Schema.String), OnDemandThroughput: Schema.optional(OnDemandThroughput), WarmThroughput: Schema.optional(GlobalSecondaryIndexWarmThroughputDescription)});
export const GlobalSecondaryIndexDescriptionList = Schema.Array(GlobalSecondaryIndexDescription);
export const ProvisionedThroughputOverride = Schema.Struct({ReadCapacityUnits: Schema.optional(Schema.Number)});
export const OnDemandThroughputOverride = Schema.Struct({MaxReadRequestUnits: Schema.optional(Schema.Number)});
export const TableWarmThroughputDescription = Schema.Struct({ReadUnitsPerSecond: Schema.optional(Schema.Number), WriteUnitsPerSecond: Schema.optional(Schema.Number), Status: Schema.optional(Schema.String)});
export const ReplicaGlobalSecondaryIndexDescription = Schema.Struct({IndexName: Schema.optional(Schema.String), ProvisionedThroughputOverride: Schema.optional(ProvisionedThroughputOverride), OnDemandThroughputOverride: Schema.optional(OnDemandThroughputOverride), WarmThroughput: Schema.optional(GlobalSecondaryIndexWarmThroughputDescription)});
export const ReplicaGlobalSecondaryIndexDescriptionList = Schema.Array(ReplicaGlobalSecondaryIndexDescription);
export const TableClassSummary = Schema.Struct({TableClass: Schema.optional(Schema.String), LastUpdateDateTime: Schema.optional(Schema.Date)});
export const ReplicaDescription = Schema.Struct({RegionName: Schema.optional(Schema.String), ReplicaStatus: Schema.optional(Schema.String), ReplicaStatusDescription: Schema.optional(Schema.String), ReplicaStatusPercentProgress: Schema.optional(Schema.String), KMSMasterKeyId: Schema.optional(Schema.String), ProvisionedThroughputOverride: Schema.optional(ProvisionedThroughputOverride), OnDemandThroughputOverride: Schema.optional(OnDemandThroughputOverride), WarmThroughput: Schema.optional(TableWarmThroughputDescription), GlobalSecondaryIndexes: Schema.optional(ReplicaGlobalSecondaryIndexDescriptionList), ReplicaInaccessibleDateTime: Schema.optional(Schema.Date), ReplicaTableClassSummary: Schema.optional(TableClassSummary)});
export const ReplicaDescriptionList = Schema.Array(ReplicaDescription);
export const GlobalTableWitnessDescription = Schema.Struct({RegionName: Schema.optional(Schema.String), WitnessStatus: Schema.optional(Schema.String)});
export const GlobalTableWitnessDescriptionList = Schema.Array(GlobalTableWitnessDescription);
export const RestoreSummary = Schema.Struct({SourceBackupArn: Schema.optional(Schema.String), SourceTableArn: Schema.optional(Schema.String), RestoreDateTime: Schema.Date, RestoreInProgress: Schema.Boolean});
export const ArchivalSummary = Schema.Struct({ArchivalDateTime: Schema.optional(Schema.Date), ArchivalReason: Schema.optional(Schema.String), ArchivalBackupArn: Schema.optional(Schema.String)});
export const TableDescription = Schema.Struct({AttributeDefinitions: Schema.optional(AttributeDefinitions), TableName: Schema.optional(Schema.String), KeySchema: Schema.optional(KeySchema), TableStatus: Schema.optional(Schema.String), CreationDateTime: Schema.optional(Schema.Date), ProvisionedThroughput: Schema.optional(ProvisionedThroughputDescription), TableSizeBytes: Schema.optional(Schema.Number), ItemCount: Schema.optional(Schema.Number), TableArn: Schema.optional(Schema.String), TableId: Schema.optional(Schema.String), BillingModeSummary: Schema.optional(BillingModeSummary), LocalSecondaryIndexes: Schema.optional(LocalSecondaryIndexDescriptionList), GlobalSecondaryIndexes: Schema.optional(GlobalSecondaryIndexDescriptionList), StreamSpecification: Schema.optional(StreamSpecification), LatestStreamLabel: Schema.optional(Schema.String), LatestStreamArn: Schema.optional(Schema.String), GlobalTableVersion: Schema.optional(Schema.String), Replicas: Schema.optional(ReplicaDescriptionList), GlobalTableWitnesses: Schema.optional(GlobalTableWitnessDescriptionList), RestoreSummary: Schema.optional(RestoreSummary), SSEDescription: Schema.optional(SSEDescription), ArchivalSummary: Schema.optional(ArchivalSummary), TableClassSummary: Schema.optional(TableClassSummary), DeletionProtectionEnabled: Schema.optional(Schema.Boolean), OnDemandThroughput: Schema.optional(OnDemandThroughput), WarmThroughput: Schema.optional(TableWarmThroughputDescription), MultiRegionConsistency: Schema.optional(Schema.String)});
export const DescribeTableOutput = Schema.Struct({Table: Schema.optional(TableDescription)});
export const KinesisStreamingDestinationInput = Schema.Struct({TableName: Schema.String, StreamArn: Schema.String, EnableKinesisStreamingConfiguration: Schema.optional(EnableKinesisStreamingConfiguration)});
export const InvalidEndpointException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ExecuteTransactionInput = Schema.Struct({TransactStatements: ParameterizedStatements, ClientRequestToken: Schema.optional(Schema.String), ReturnConsumedCapacity: Schema.optional(Schema.String)});
export const ExportTableToPointInTimeInput = Schema.Struct({TableArn: Schema.String, ExportTime: Schema.optional(Schema.Date), ClientToken: Schema.optional(Schema.String), S3Bucket: Schema.String, S3BucketOwner: Schema.optional(Schema.String), S3Prefix: Schema.optional(Schema.String), S3SseAlgorithm: Schema.optional(Schema.String), S3SseKmsKeyId: Schema.optional(Schema.String), ExportFormat: Schema.optional(Schema.String), ExportType: Schema.optional(Schema.String), IncrementalExportSpecification: Schema.optional(IncrementalExportSpecification)});
export const GetResourcePolicyOutput = Schema.Struct({Policy: Schema.optional(Schema.String), RevisionId: Schema.optional(Schema.String)});
export const ListTablesOutput = Schema.Struct({TableNames: Schema.optional(TableNameList), LastEvaluatedTableName: Schema.optional(Schema.String)});
export const ListTagsOfResourceOutput = Schema.Struct({Tags: Schema.optional(TagList), NextToken: Schema.optional(Schema.String)});
export const ExpectedAttributeValue = Schema.Struct({Value: Schema.optional(AttributeValue), Exists: Schema.optional(Schema.Boolean), ComparisonOperator: Schema.optional(Schema.String), AttributeValueList: Schema.optional(AttributeValueList)});
export const ExpectedAttributeMap = Schema.Record({key: Schema.String, value: ExpectedAttributeValue});
export const PutItemInput = Schema.Struct({TableName: Schema.String, Item: PutItemInputAttributeMap, Expected: Schema.optional(ExpectedAttributeMap), ReturnValues: Schema.optional(Schema.String), ReturnConsumedCapacity: Schema.optional(Schema.String), ReturnItemCollectionMetrics: Schema.optional(Schema.String), ConditionalOperator: Schema.optional(Schema.String), ConditionExpression: Schema.optional(Schema.String), ExpressionAttributeNames: Schema.optional(ExpressionAttributeNameMap), ExpressionAttributeValues: Schema.optional(ExpressionAttributeValueMap), ReturnValuesOnConditionCheckFailure: Schema.optional(Schema.String)});
export const PutResourcePolicyOutput = Schema.Struct({RevisionId: Schema.optional(Schema.String)});
export const RestoreTableFromBackupOutput = Schema.Struct({TableDescription: Schema.optional(TableDescription)});
export const RestoreTableToPointInTimeOutput = Schema.Struct({TableDescription: Schema.optional(TableDescription)});
export const Capacity = Schema.Struct({ReadCapacityUnits: Schema.optional(Schema.Number), WriteCapacityUnits: Schema.optional(Schema.Number), CapacityUnits: Schema.optional(Schema.Number)});
export const SecondaryIndexesCapacityMap = Schema.Record({key: Schema.String, value: Capacity});
export const ConsumedCapacity = Schema.Struct({TableName: Schema.optional(Schema.String), CapacityUnits: Schema.optional(Schema.Number), ReadCapacityUnits: Schema.optional(Schema.Number), WriteCapacityUnits: Schema.optional(Schema.Number), Table: Schema.optional(Capacity), LocalSecondaryIndexes: Schema.optional(SecondaryIndexesCapacityMap), GlobalSecondaryIndexes: Schema.optional(SecondaryIndexesCapacityMap)});
export const ScanOutput = Schema.Struct({Items: Schema.optional(ItemList), Count: Schema.optional(Schema.Number), ScannedCount: Schema.optional(Schema.Number), LastEvaluatedKey: Schema.optional(Key), ConsumedCapacity: Schema.optional(ConsumedCapacity)});
export const LimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ResourceInUseException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdateContinuousBackupsInput = Schema.Struct({TableName: Schema.String, PointInTimeRecoverySpecification: PointInTimeRecoverySpecification});
export const UpdateContributorInsightsOutput = Schema.Struct({TableName: Schema.optional(Schema.String), IndexName: Schema.optional(Schema.String), ContributorInsightsStatus: Schema.optional(Schema.String), ContributorInsightsMode: Schema.optional(Schema.String)});
export const UpdateKinesisStreamingDestinationInput = Schema.Struct({TableName: Schema.String, StreamArn: Schema.String, UpdateKinesisStreamingConfiguration: Schema.optional(UpdateKinesisStreamingConfiguration)});
export const UpdateTimeToLiveInput = Schema.Struct({TableName: Schema.String, TimeToLiveSpecification: TimeToLiveSpecification});
export const KeysAndAttributes = Schema.Struct({Keys: KeyList, AttributesToGet: Schema.optional(AttributeNameList), ConsistentRead: Schema.optional(Schema.Boolean), ProjectionExpression: Schema.optional(Schema.String), ExpressionAttributeNames: Schema.optional(ExpressionAttributeNameMap)});
export const CsvOptions = Schema.Struct({Delimiter: Schema.optional(Schema.String), HeaderList: Schema.optional(CsvHeaderList)});
export const Get = Schema.Struct({Key: Key, TableName: Schema.String, ProjectionExpression: Schema.optional(Schema.String), ExpressionAttributeNames: Schema.optional(ExpressionAttributeNameMap)});
export const ConditionCheck = Schema.Struct({Key: Key, TableName: Schema.String, ConditionExpression: Schema.String, ExpressionAttributeNames: Schema.optional(ExpressionAttributeNameMap), ExpressionAttributeValues: Schema.optional(ExpressionAttributeValueMap), ReturnValuesOnConditionCheckFailure: Schema.optional(Schema.String)});
export const Put = Schema.Struct({Item: PutItemInputAttributeMap, TableName: Schema.String, ConditionExpression: Schema.optional(Schema.String), ExpressionAttributeNames: Schema.optional(ExpressionAttributeNameMap), ExpressionAttributeValues: Schema.optional(ExpressionAttributeValueMap), ReturnValuesOnConditionCheckFailure: Schema.optional(Schema.String)});
export const Delete = Schema.Struct({Key: Key, TableName: Schema.String, ConditionExpression: Schema.optional(Schema.String), ExpressionAttributeNames: Schema.optional(ExpressionAttributeNameMap), ExpressionAttributeValues: Schema.optional(ExpressionAttributeValueMap), ReturnValuesOnConditionCheckFailure: Schema.optional(Schema.String)});
export const Update = Schema.Struct({Key: Key, UpdateExpression: Schema.String, TableName: Schema.String, ConditionExpression: Schema.optional(Schema.String), ExpressionAttributeNames: Schema.optional(ExpressionAttributeNameMap), ExpressionAttributeValues: Schema.optional(ExpressionAttributeValueMap), ReturnValuesOnConditionCheckFailure: Schema.optional(Schema.String)});
export const CreateReplicaAction = Schema.Struct({RegionName: Schema.String});
export const DeleteReplicaAction = Schema.Struct({RegionName: Schema.String});
export const ReplicaGlobalSecondaryIndexSettingsUpdate = Schema.Struct({IndexName: Schema.String, ProvisionedReadCapacityUnits: Schema.optional(Schema.Number), ProvisionedReadCapacityAutoScalingSettingsUpdate: Schema.optional(AutoScalingSettingsUpdate)});
export const ReplicaGlobalSecondaryIndexSettingsUpdateList = Schema.Array(ReplicaGlobalSecondaryIndexSettingsUpdate);
export const AttributeValueUpdate = Schema.Struct({Value: Schema.optional(AttributeValue), Action: Schema.optional(Schema.String)});
export const UpdateGlobalSecondaryIndexAction = Schema.Struct({IndexName: Schema.String, ProvisionedThroughput: Schema.optional(ProvisionedThroughput), OnDemandThroughput: Schema.optional(OnDemandThroughput), WarmThroughput: Schema.optional(WarmThroughput)});
export const CreateGlobalSecondaryIndexAction = Schema.Struct({IndexName: Schema.String, KeySchema: KeySchema, Projection: Projection, ProvisionedThroughput: Schema.optional(ProvisionedThroughput), OnDemandThroughput: Schema.optional(OnDemandThroughput), WarmThroughput: Schema.optional(WarmThroughput)});
export const DeleteGlobalSecondaryIndexAction = Schema.Struct({IndexName: Schema.String});
export const ReplicaGlobalSecondaryIndex = Schema.Struct({IndexName: Schema.String, ProvisionedThroughputOverride: Schema.optional(ProvisionedThroughputOverride), OnDemandThroughputOverride: Schema.optional(OnDemandThroughputOverride)});
export const ReplicaGlobalSecondaryIndexList = Schema.Array(ReplicaGlobalSecondaryIndex);
export const UpdateReplicationGroupMemberAction = Schema.Struct({RegionName: Schema.String, KMSMasterKeyId: Schema.optional(Schema.String), ProvisionedThroughputOverride: Schema.optional(ProvisionedThroughputOverride), OnDemandThroughputOverride: Schema.optional(OnDemandThroughputOverride), GlobalSecondaryIndexes: Schema.optional(ReplicaGlobalSecondaryIndexList), TableClassOverride: Schema.optional(Schema.String)});
export const DeleteReplicationGroupMemberAction = Schema.Struct({RegionName: Schema.String});
export const CreateGlobalTableWitnessGroupMemberAction = Schema.Struct({RegionName: Schema.String});
export const DeleteGlobalTableWitnessGroupMemberAction = Schema.Struct({RegionName: Schema.String});
export const ReplicaGlobalSecondaryIndexAutoScalingUpdate = Schema.Struct({IndexName: Schema.optional(Schema.String), ProvisionedReadCapacityAutoScalingUpdate: Schema.optional(AutoScalingSettingsUpdate)});
export const ReplicaGlobalSecondaryIndexAutoScalingUpdateList = Schema.Array(ReplicaGlobalSecondaryIndexAutoScalingUpdate);
export const ConsumedCapacityMultiple = Schema.Array(ConsumedCapacity);
export const BatchGetRequestMap = Schema.Record({key: Schema.String, value: KeysAndAttributes});
export const FailureException = Schema.Struct({ExceptionName: Schema.optional(Schema.String), ExceptionDescription: Schema.optional(Schema.String)});
export const ExportDescription = Schema.Struct({ExportArn: Schema.optional(Schema.String), ExportStatus: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), ExportManifest: Schema.optional(Schema.String), TableArn: Schema.optional(Schema.String), TableId: Schema.optional(Schema.String), ExportTime: Schema.optional(Schema.Date), ClientToken: Schema.optional(Schema.String), S3Bucket: Schema.optional(Schema.String), S3BucketOwner: Schema.optional(Schema.String), S3Prefix: Schema.optional(Schema.String), S3SseAlgorithm: Schema.optional(Schema.String), S3SseKmsKeyId: Schema.optional(Schema.String), FailureCode: Schema.optional(Schema.String), FailureMessage: Schema.optional(Schema.String), ExportFormat: Schema.optional(Schema.String), BilledSizeBytes: Schema.optional(Schema.Number), ItemCount: Schema.optional(Schema.Number), ExportType: Schema.optional(Schema.String), IncrementalExportSpecification: Schema.optional(IncrementalExportSpecification)});
export const GlobalTableDescription = Schema.Struct({ReplicationGroup: Schema.optional(ReplicaDescriptionList), GlobalTableArn: Schema.optional(Schema.String), CreationDateTime: Schema.optional(Schema.Date), GlobalTableStatus: Schema.optional(Schema.String), GlobalTableName: Schema.optional(Schema.String)});
export const InputFormatOptions = Schema.Struct({Csv: Schema.optional(CsvOptions)});
export const ImportTableDescription = Schema.Struct({ImportArn: Schema.optional(Schema.String), ImportStatus: Schema.optional(Schema.String), TableArn: Schema.optional(Schema.String), TableId: Schema.optional(Schema.String), ClientToken: Schema.optional(Schema.String), S3BucketSource: Schema.optional(S3BucketSource), ErrorCount: Schema.optional(Schema.Number), CloudWatchLogGroupArn: Schema.optional(Schema.String), InputFormat: Schema.optional(Schema.String), InputFormatOptions: Schema.optional(InputFormatOptions), InputCompressionType: Schema.optional(Schema.String), TableCreationParameters: Schema.optional(TableCreationParameters), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), ProcessedSizeBytes: Schema.optional(Schema.Number), ProcessedItemCount: Schema.optional(Schema.Number), ImportedItemCount: Schema.optional(Schema.Number), FailureCode: Schema.optional(Schema.String), FailureMessage: Schema.optional(Schema.String)});
export const KinesisDataStreamDestination = Schema.Struct({StreamArn: Schema.optional(Schema.String), DestinationStatus: Schema.optional(Schema.String), DestinationStatusDescription: Schema.optional(Schema.String), ApproximateCreationDateTimePrecision: Schema.optional(Schema.String)});
export const KinesisDataStreamDestinations = Schema.Array(KinesisDataStreamDestination);
export const BackupSummary = Schema.Struct({TableName: Schema.optional(Schema.String), TableId: Schema.optional(Schema.String), TableArn: Schema.optional(Schema.String), BackupArn: Schema.optional(Schema.String), BackupName: Schema.optional(Schema.String), BackupCreationDateTime: Schema.optional(Schema.Date), BackupExpiryDateTime: Schema.optional(Schema.Date), BackupStatus: Schema.optional(Schema.String), BackupType: Schema.optional(Schema.String), BackupSizeBytes: Schema.optional(Schema.Number)});
export const BackupSummaries = Schema.Array(BackupSummary);
export const ContributorInsightsSummary = Schema.Struct({TableName: Schema.optional(Schema.String), IndexName: Schema.optional(Schema.String), ContributorInsightsStatus: Schema.optional(Schema.String), ContributorInsightsMode: Schema.optional(Schema.String)});
export const ContributorInsightsSummaries = Schema.Array(ContributorInsightsSummary);
export const ExportSummary = Schema.Struct({ExportArn: Schema.optional(Schema.String), ExportStatus: Schema.optional(Schema.String), ExportType: Schema.optional(Schema.String)});
export const ExportSummaries = Schema.Array(ExportSummary);
export const GlobalTable = Schema.Struct({GlobalTableName: Schema.optional(Schema.String), ReplicationGroup: Schema.optional(ReplicaList)});
export const GlobalTableList = Schema.Array(GlobalTable);
export const ImportSummary = Schema.Struct({ImportArn: Schema.optional(Schema.String), ImportStatus: Schema.optional(Schema.String), TableArn: Schema.optional(Schema.String), S3BucketSource: Schema.optional(S3BucketSource), CloudWatchLogGroupArn: Schema.optional(Schema.String), InputFormat: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date)});
export const ImportSummaryList = Schema.Array(ImportSummary);
export const KeyConditions = Schema.Record({key: Schema.String, value: Condition});
export const TransactGetItem = Schema.Struct({Get: Get});
export const TransactGetItemList = Schema.Array(TransactGetItem);
export const TransactWriteItem = Schema.Struct({ConditionCheck: Schema.optional(ConditionCheck), Put: Schema.optional(Put), Delete: Schema.optional(Delete), Update: Schema.optional(Update)});
export const TransactWriteItemList = Schema.Array(TransactWriteItem);
export const ReplicaUpdate = Schema.Struct({Create: Schema.optional(CreateReplicaAction), Delete: Schema.optional(DeleteReplicaAction)});
export const ReplicaUpdateList = Schema.Array(ReplicaUpdate);
export const ReplicaSettingsUpdate = Schema.Struct({RegionName: Schema.String, ReplicaProvisionedReadCapacityUnits: Schema.optional(Schema.Number), ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate: Schema.optional(AutoScalingSettingsUpdate), ReplicaGlobalSecondaryIndexSettingsUpdate: Schema.optional(ReplicaGlobalSecondaryIndexSettingsUpdateList), ReplicaTableClass: Schema.optional(Schema.String)});
export const ReplicaSettingsUpdateList = Schema.Array(ReplicaSettingsUpdate);
export const AttributeUpdates = Schema.Record({key: Schema.String, value: AttributeValueUpdate});
export const GlobalSecondaryIndexUpdate = Schema.Struct({Update: Schema.optional(UpdateGlobalSecondaryIndexAction), Create: Schema.optional(CreateGlobalSecondaryIndexAction), Delete: Schema.optional(DeleteGlobalSecondaryIndexAction)});
export const GlobalSecondaryIndexUpdateList = Schema.Array(GlobalSecondaryIndexUpdate);
export const GlobalTableWitnessGroupUpdate = Schema.Struct({Create: Schema.optional(CreateGlobalTableWitnessGroupMemberAction), Delete: Schema.optional(DeleteGlobalTableWitnessGroupMemberAction)});
export const GlobalTableWitnessGroupUpdateList = Schema.Array(GlobalTableWitnessGroupUpdate);
export const ReplicaAutoScalingUpdate = Schema.Struct({RegionName: Schema.String, ReplicaGlobalSecondaryIndexUpdates: Schema.optional(ReplicaGlobalSecondaryIndexAutoScalingUpdateList), ReplicaProvisionedReadCapacityAutoScalingUpdate: Schema.optional(AutoScalingSettingsUpdate)});
export const ReplicaAutoScalingUpdateList = Schema.Array(ReplicaAutoScalingUpdate);
export const PutRequest = Schema.Struct({Item: PutItemInputAttributeMap});
export const DeleteRequest = Schema.Struct({Key: Key});
export const BatchGetItemInput = Schema.Struct({RequestItems: BatchGetRequestMap, ReturnConsumedCapacity: Schema.optional(Schema.String)});
export const CreateBackupOutput = Schema.Struct({BackupDetails: Schema.optional(BackupDetails)});
export const CreateGlobalTableOutput = Schema.Struct({GlobalTableDescription: Schema.optional(GlobalTableDescription)});
export const CreateTableInput = Schema.Struct({AttributeDefinitions: AttributeDefinitions, TableName: Schema.String, KeySchema: KeySchema, LocalSecondaryIndexes: Schema.optional(LocalSecondaryIndexList), GlobalSecondaryIndexes: Schema.optional(GlobalSecondaryIndexList), BillingMode: Schema.optional(Schema.String), ProvisionedThroughput: Schema.optional(ProvisionedThroughput), StreamSpecification: Schema.optional(StreamSpecification), SSESpecification: Schema.optional(SSESpecification), Tags: Schema.optional(TagList), TableClass: Schema.optional(Schema.String), DeletionProtectionEnabled: Schema.optional(Schema.Boolean), WarmThroughput: Schema.optional(WarmThroughput), ResourcePolicy: Schema.optional(Schema.String), OnDemandThroughput: Schema.optional(OnDemandThroughput)});
export const DeleteItemInput = Schema.Struct({TableName: Schema.String, Key: Key, Expected: Schema.optional(ExpectedAttributeMap), ConditionalOperator: Schema.optional(Schema.String), ReturnValues: Schema.optional(Schema.String), ReturnConsumedCapacity: Schema.optional(Schema.String), ReturnItemCollectionMetrics: Schema.optional(Schema.String), ConditionExpression: Schema.optional(Schema.String), ExpressionAttributeNames: Schema.optional(ExpressionAttributeNameMap), ExpressionAttributeValues: Schema.optional(ExpressionAttributeValueMap), ReturnValuesOnConditionCheckFailure: Schema.optional(Schema.String)});
export const PolicyNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const BackupNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeContributorInsightsOutput = Schema.Struct({TableName: Schema.optional(Schema.String), IndexName: Schema.optional(Schema.String), ContributorInsightsRuleList: Schema.optional(ContributorInsightsRuleList), ContributorInsightsStatus: Schema.optional(Schema.String), LastUpdateDateTime: Schema.optional(Schema.Date), FailureException: Schema.optional(FailureException), ContributorInsightsMode: Schema.optional(Schema.String)});
export const DescribeExportOutput = Schema.Struct({ExportDescription: Schema.optional(ExportDescription)});
export const DescribeGlobalTableOutput = Schema.Struct({GlobalTableDescription: Schema.optional(GlobalTableDescription)});
export const DescribeImportOutput = Schema.Struct({ImportTableDescription: ImportTableDescription});
export const DescribeKinesisStreamingDestinationOutput = Schema.Struct({TableName: Schema.optional(Schema.String), KinesisDataStreamDestinations: Schema.optional(KinesisDataStreamDestinations)});
export const ResourceNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeTimeToLiveOutput = Schema.Struct({TimeToLiveDescription: Schema.optional(TimeToLiveDescription)});
export const ExecuteStatementInput = Schema.Struct({Statement: Schema.String, Parameters: Schema.optional(PreparedStatementParameters), ConsistentRead: Schema.optional(Schema.Boolean), NextToken: Schema.optional(Schema.String), ReturnConsumedCapacity: Schema.optional(Schema.String), Limit: Schema.optional(Schema.Number), ReturnValuesOnConditionCheckFailure: Schema.optional(Schema.String)});
export const ExportTableToPointInTimeOutput = Schema.Struct({ExportDescription: Schema.optional(ExportDescription)});
export const ImportTableInput = Schema.Struct({ClientToken: Schema.optional(Schema.String), S3BucketSource: S3BucketSource, InputFormat: Schema.String, InputFormatOptions: Schema.optional(InputFormatOptions), InputCompressionType: Schema.optional(Schema.String), TableCreationParameters: TableCreationParameters});
export const ListBackupsOutput = Schema.Struct({BackupSummaries: Schema.optional(BackupSummaries), LastEvaluatedBackupArn: Schema.optional(Schema.String)});
export const ListContributorInsightsOutput = Schema.Struct({ContributorInsightsSummaries: Schema.optional(ContributorInsightsSummaries), NextToken: Schema.optional(Schema.String)});
export const ListExportsOutput = Schema.Struct({ExportSummaries: Schema.optional(ExportSummaries), NextToken: Schema.optional(Schema.String)});
export const ListGlobalTablesOutput = Schema.Struct({GlobalTables: Schema.optional(GlobalTableList), LastEvaluatedGlobalTableName: Schema.optional(Schema.String)});
export const ListImportsOutput = Schema.Struct({ImportSummaryList: Schema.optional(ImportSummaryList), NextToken: Schema.optional(Schema.String)});
export const QueryInput = Schema.Struct({TableName: Schema.String, IndexName: Schema.optional(Schema.String), Select: Schema.optional(Schema.String), AttributesToGet: Schema.optional(AttributeNameList), Limit: Schema.optional(Schema.Number), ConsistentRead: Schema.optional(Schema.Boolean), KeyConditions: Schema.optional(KeyConditions), QueryFilter: Schema.optional(FilterConditionMap), ConditionalOperator: Schema.optional(Schema.String), ScanIndexForward: Schema.optional(Schema.Boolean), ExclusiveStartKey: Schema.optional(Key), ReturnConsumedCapacity: Schema.optional(Schema.String), ProjectionExpression: Schema.optional(Schema.String), FilterExpression: Schema.optional(Schema.String), KeyConditionExpression: Schema.optional(Schema.String), ExpressionAttributeNames: Schema.optional(ExpressionAttributeNameMap), ExpressionAttributeValues: Schema.optional(ExpressionAttributeValueMap)});
export const BackupInUseException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRestoreTimeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TransactGetItemsInput = Schema.Struct({TransactItems: TransactGetItemList, ReturnConsumedCapacity: Schema.optional(Schema.String)});
export const TransactWriteItemsInput = Schema.Struct({TransactItems: TransactWriteItemList, ReturnConsumedCapacity: Schema.optional(Schema.String), ReturnItemCollectionMetrics: Schema.optional(Schema.String), ClientRequestToken: Schema.optional(Schema.String)});
export const PointInTimeRecoveryDescription = Schema.Struct({PointInTimeRecoveryStatus: Schema.optional(Schema.String), RecoveryPeriodInDays: Schema.optional(Schema.Number), EarliestRestorableDateTime: Schema.optional(Schema.Date), LatestRestorableDateTime: Schema.optional(Schema.Date)});
export const ContinuousBackupsDescription = Schema.Struct({ContinuousBackupsStatus: Schema.String, PointInTimeRecoveryDescription: Schema.optional(PointInTimeRecoveryDescription)});
export const UpdateContinuousBackupsOutput = Schema.Struct({ContinuousBackupsDescription: Schema.optional(ContinuousBackupsDescription)});
export const UpdateGlobalTableInput = Schema.Struct({GlobalTableName: Schema.String, ReplicaUpdates: ReplicaUpdateList});
export const UpdateItemInput = Schema.Struct({TableName: Schema.String, Key: Key, AttributeUpdates: Schema.optional(AttributeUpdates), Expected: Schema.optional(ExpectedAttributeMap), ConditionalOperator: Schema.optional(Schema.String), ReturnValues: Schema.optional(Schema.String), ReturnConsumedCapacity: Schema.optional(Schema.String), ReturnItemCollectionMetrics: Schema.optional(Schema.String), UpdateExpression: Schema.optional(Schema.String), ConditionExpression: Schema.optional(Schema.String), ExpressionAttributeNames: Schema.optional(ExpressionAttributeNameMap), ExpressionAttributeValues: Schema.optional(ExpressionAttributeValueMap), ReturnValuesOnConditionCheckFailure: Schema.optional(Schema.String)});
export const UpdateKinesisStreamingDestinationOutput = Schema.Struct({TableName: Schema.optional(Schema.String), StreamArn: Schema.optional(Schema.String), DestinationStatus: Schema.optional(Schema.String), UpdateKinesisStreamingConfiguration: Schema.optional(UpdateKinesisStreamingConfiguration)});
export const UpdateTableReplicaAutoScalingInput = Schema.Struct({GlobalSecondaryIndexUpdates: Schema.optional(GlobalSecondaryIndexAutoScalingUpdateList), TableName: Schema.String, ProvisionedWriteCapacityAutoScalingUpdate: Schema.optional(AutoScalingSettingsUpdate), ReplicaUpdates: Schema.optional(ReplicaAutoScalingUpdateList)});
export const UpdateTimeToLiveOutput = Schema.Struct({TimeToLiveSpecification: Schema.optional(TimeToLiveSpecification)});
export const WriteRequest = Schema.Struct({PutRequest: Schema.optional(PutRequest), DeleteRequest: Schema.optional(DeleteRequest)});
export const WriteRequests = Schema.Array(WriteRequest);
export const AutoScalingTargetTrackingScalingPolicyConfigurationDescription = Schema.Struct({DisableScaleIn: Schema.optional(Schema.Boolean), ScaleInCooldown: Schema.optional(Schema.Number), ScaleOutCooldown: Schema.optional(Schema.Number), TargetValue: Schema.Number});
export const AutoScalingPolicyDescription = Schema.Struct({PolicyName: Schema.optional(Schema.String), TargetTrackingScalingPolicyConfiguration: Schema.optional(AutoScalingTargetTrackingScalingPolicyConfigurationDescription)});
export const AutoScalingPolicyDescriptionList = Schema.Array(AutoScalingPolicyDescription);
export const AutoScalingSettingsDescription = Schema.Struct({MinimumUnits: Schema.optional(Schema.Number), MaximumUnits: Schema.optional(Schema.Number), AutoScalingDisabled: Schema.optional(Schema.Boolean), AutoScalingRoleArn: Schema.optional(Schema.String), ScalingPolicies: Schema.optional(AutoScalingPolicyDescriptionList)});
export const ReplicaGlobalSecondaryIndexSettingsDescription = Schema.Struct({IndexName: Schema.String, IndexStatus: Schema.optional(Schema.String), ProvisionedReadCapacityUnits: Schema.optional(Schema.Number), ProvisionedReadCapacityAutoScalingSettings: Schema.optional(AutoScalingSettingsDescription), ProvisionedWriteCapacityUnits: Schema.optional(Schema.Number), ProvisionedWriteCapacityAutoScalingSettings: Schema.optional(AutoScalingSettingsDescription)});
export const ReplicaGlobalSecondaryIndexSettingsDescriptionList = Schema.Array(ReplicaGlobalSecondaryIndexSettingsDescription);
export const ItemCollectionSizeEstimateRange = Schema.Array(Schema.Number);
export const CreateReplicationGroupMemberAction = Schema.Struct({RegionName: Schema.String, KMSMasterKeyId: Schema.optional(Schema.String), ProvisionedThroughputOverride: Schema.optional(ProvisionedThroughputOverride), OnDemandThroughputOverride: Schema.optional(OnDemandThroughputOverride), GlobalSecondaryIndexes: Schema.optional(ReplicaGlobalSecondaryIndexList), TableClassOverride: Schema.optional(Schema.String)});
export const BatchWriteItemRequestMap = Schema.Record({key: Schema.String, value: WriteRequests});
export const ItemResponse = Schema.Struct({Item: Schema.optional(AttributeMap)});
export const ItemResponseList = Schema.Array(ItemResponse);
export const ThrottlingReason = Schema.Struct({reason: Schema.optional(Schema.String), resource: Schema.optional(Schema.String)});
export const ThrottlingReasonList = Schema.Array(ThrottlingReason);
export const ReplicationGroupUpdate = Schema.Struct({Create: Schema.optional(CreateReplicationGroupMemberAction), Update: Schema.optional(UpdateReplicationGroupMemberAction), Delete: Schema.optional(DeleteReplicationGroupMemberAction)});
export const ReplicationGroupUpdateList = Schema.Array(ReplicationGroupUpdate);
export const ReplicaGlobalSecondaryIndexAutoScalingDescription = Schema.Struct({IndexName: Schema.optional(Schema.String), IndexStatus: Schema.optional(Schema.String), ProvisionedReadCapacityAutoScalingSettings: Schema.optional(AutoScalingSettingsDescription), ProvisionedWriteCapacityAutoScalingSettings: Schema.optional(AutoScalingSettingsDescription)});
export const ReplicaGlobalSecondaryIndexAutoScalingDescriptionList = Schema.Array(ReplicaGlobalSecondaryIndexAutoScalingDescription);
export const BatchWriteItemInput = Schema.Struct({RequestItems: BatchWriteItemRequestMap, ReturnConsumedCapacity: Schema.optional(Schema.String), ReturnItemCollectionMetrics: Schema.optional(Schema.String)});
export const ContinuousBackupsUnavailableException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GlobalTableAlreadyExistsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreateTableOutput = Schema.Struct({TableDescription: Schema.optional(TableDescription)});
export const ItemCollectionKeyAttributeMap = Schema.Record({key: Schema.String, value: AttributeValue});
export const ItemCollectionMetrics = Schema.Struct({ItemCollectionKey: Schema.optional(ItemCollectionKeyAttributeMap), SizeEstimateRangeGB: Schema.optional(ItemCollectionSizeEstimateRange)});
export const DeleteItemOutput = Schema.Struct({Attributes: Schema.optional(AttributeMap), ConsumedCapacity: Schema.optional(ConsumedCapacity), ItemCollectionMetrics: Schema.optional(ItemCollectionMetrics)});
export const DescribeContinuousBackupsOutput = Schema.Struct({ContinuousBackupsDescription: Schema.optional(ContinuousBackupsDescription)});
export const ExportNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GlobalTableNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ImportNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ExecuteStatementOutput = Schema.Struct({Items: Schema.optional(ItemList), NextToken: Schema.optional(Schema.String), ConsumedCapacity: Schema.optional(ConsumedCapacity), LastEvaluatedKey: Schema.optional(Key)});
export const ExecuteTransactionOutput = Schema.Struct({Responses: Schema.optional(ItemResponseList), ConsumedCapacity: Schema.optional(ConsumedCapacityMultiple)});
export const ExportConflictException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GetItemOutput = Schema.Struct({Item: Schema.optional(AttributeMap), ConsumedCapacity: Schema.optional(ConsumedCapacity)});
export const ImportTableOutput = Schema.Struct({ImportTableDescription: ImportTableDescription});
export const QueryOutput = Schema.Struct({Items: Schema.optional(ItemList), Count: Schema.optional(Schema.Number), ScannedCount: Schema.optional(Schema.Number), LastEvaluatedKey: Schema.optional(Key), ConsumedCapacity: Schema.optional(ConsumedCapacity)});
export const TableAlreadyExistsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PointInTimeRecoveryUnavailableException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ProvisionedThroughputExceededException = Schema.Struct({message: Schema.optional(Schema.String), ThrottlingReasons: Schema.optional(ThrottlingReasonList)});
export const TransactGetItemsOutput = Schema.Struct({ConsumedCapacity: Schema.optional(ConsumedCapacityMultiple), Responses: Schema.optional(ItemResponseList)});
export const TableNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdateGlobalTableOutput = Schema.Struct({GlobalTableDescription: Schema.optional(GlobalTableDescription)});
export const UpdateGlobalTableSettingsInput = Schema.Struct({GlobalTableName: Schema.String, GlobalTableBillingMode: Schema.optional(Schema.String), GlobalTableProvisionedWriteCapacityUnits: Schema.optional(Schema.Number), GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate: Schema.optional(AutoScalingSettingsUpdate), GlobalTableGlobalSecondaryIndexSettingsUpdate: Schema.optional(GlobalTableGlobalSecondaryIndexSettingsUpdateList), ReplicaSettingsUpdate: Schema.optional(ReplicaSettingsUpdateList)});
export const UpdateItemOutput = Schema.Struct({Attributes: Schema.optional(AttributeMap), ConsumedCapacity: Schema.optional(ConsumedCapacity), ItemCollectionMetrics: Schema.optional(ItemCollectionMetrics)});
export const UpdateTableInput = Schema.Struct({AttributeDefinitions: Schema.optional(AttributeDefinitions), TableName: Schema.String, BillingMode: Schema.optional(Schema.String), ProvisionedThroughput: Schema.optional(ProvisionedThroughput), GlobalSecondaryIndexUpdates: Schema.optional(GlobalSecondaryIndexUpdateList), StreamSpecification: Schema.optional(StreamSpecification), SSESpecification: Schema.optional(SSESpecification), ReplicaUpdates: Schema.optional(ReplicationGroupUpdateList), TableClass: Schema.optional(Schema.String), DeletionProtectionEnabled: Schema.optional(Schema.Boolean), MultiRegionConsistency: Schema.optional(Schema.String), GlobalTableWitnessUpdates: Schema.optional(GlobalTableWitnessGroupUpdateList), OnDemandThroughput: Schema.optional(OnDemandThroughput), WarmThroughput: Schema.optional(WarmThroughput)});
export const ReplicaAutoScalingDescription = Schema.Struct({RegionName: Schema.optional(Schema.String), GlobalSecondaryIndexes: Schema.optional(ReplicaGlobalSecondaryIndexAutoScalingDescriptionList), ReplicaProvisionedReadCapacityAutoScalingSettings: Schema.optional(AutoScalingSettingsDescription), ReplicaProvisionedWriteCapacityAutoScalingSettings: Schema.optional(AutoScalingSettingsDescription), ReplicaStatus: Schema.optional(Schema.String)});
export const ReplicaAutoScalingDescriptionList = Schema.Array(ReplicaAutoScalingDescription);
export const TableAutoScalingDescription = Schema.Struct({TableName: Schema.optional(Schema.String), TableStatus: Schema.optional(Schema.String), Replicas: Schema.optional(ReplicaAutoScalingDescriptionList)});
export const UpdateTableReplicaAutoScalingOutput = Schema.Struct({TableAutoScalingDescription: Schema.optional(TableAutoScalingDescription)});
export const BatchStatementError = Schema.Struct({Code: Schema.optional(Schema.String), Message: Schema.optional(Schema.String), Item: Schema.optional(AttributeMap)});
export const ItemCollectionMetricsMultiple = Schema.Array(ItemCollectionMetrics);
export const BatchStatementResponse = Schema.Struct({Error: Schema.optional(BatchStatementError), TableName: Schema.optional(Schema.String), Item: Schema.optional(AttributeMap)});
export const PartiQLBatchResponse = Schema.Array(BatchStatementResponse);
export const BatchGetResponseMap = Schema.Record({key: Schema.String, value: ItemList});
export const ItemCollectionMetricsPerTable = Schema.Record({key: Schema.String, value: ItemCollectionMetricsMultiple});
export const BatchExecuteStatementOutput = Schema.Struct({Responses: Schema.optional(PartiQLBatchResponse), ConsumedCapacity: Schema.optional(ConsumedCapacityMultiple)});
export const BatchGetItemOutput = Schema.Struct({Responses: Schema.optional(BatchGetResponseMap), UnprocessedKeys: Schema.optional(BatchGetRequestMap), ConsumedCapacity: Schema.optional(ConsumedCapacityMultiple)});
export const BatchWriteItemOutput = Schema.Struct({UnprocessedItems: Schema.optional(BatchWriteItemRequestMap), ItemCollectionMetrics: Schema.optional(ItemCollectionMetricsPerTable), ConsumedCapacity: Schema.optional(ConsumedCapacityMultiple)});
export const TableInUseException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DeleteBackupOutput = Schema.Struct({BackupDescription: Schema.optional(BackupDescription)});
export const ConditionalCheckFailedException = Schema.Struct({message: Schema.optional(Schema.String), Item: Schema.optional(AttributeMap)});
export const DeleteTableOutput = Schema.Struct({TableDescription: Schema.optional(TableDescription)});
export const DescribeTableReplicaAutoScalingOutput = Schema.Struct({TableAutoScalingDescription: Schema.optional(TableAutoScalingDescription)});
export const DuplicateItemException = Schema.Struct({message: Schema.optional(Schema.String)});
export const IdempotentParameterMismatchException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidExportTimeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RequestLimitExceeded = Schema.Struct({message: Schema.optional(Schema.String), ThrottlingReasons: Schema.optional(ThrottlingReasonList)});
export const ImportConflictException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PutItemOutput = Schema.Struct({Attributes: Schema.optional(AttributeMap), ConsumedCapacity: Schema.optional(ConsumedCapacity), ItemCollectionMetrics: Schema.optional(ItemCollectionMetrics)});
export const ThrottlingException = Schema.Struct({message: Schema.optional(Schema.String), throttlingReasons: Schema.optional(ThrottlingReasonList)});
export const TransactWriteItemsOutput = Schema.Struct({ConsumedCapacity: Schema.optional(ConsumedCapacityMultiple), ItemCollectionMetrics: Schema.optional(ItemCollectionMetricsPerTable)});
export const ReplicaAlreadyExistsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReplicaSettingsDescription = Schema.Struct({RegionName: Schema.String, ReplicaStatus: Schema.optional(Schema.String), ReplicaBillingModeSummary: Schema.optional(BillingModeSummary), ReplicaProvisionedReadCapacityUnits: Schema.optional(Schema.Number), ReplicaProvisionedReadCapacityAutoScalingSettings: Schema.optional(AutoScalingSettingsDescription), ReplicaProvisionedWriteCapacityUnits: Schema.optional(Schema.Number), ReplicaProvisionedWriteCapacityAutoScalingSettings: Schema.optional(AutoScalingSettingsDescription), ReplicaGlobalSecondaryIndexSettings: Schema.optional(ReplicaGlobalSecondaryIndexSettingsDescriptionList), ReplicaTableClassSummary: Schema.optional(TableClassSummary)});
export const ReplicaSettingsDescriptionList = Schema.Array(ReplicaSettingsDescription);
export const UpdateGlobalTableSettingsOutput = Schema.Struct({GlobalTableName: Schema.optional(Schema.String), ReplicaSettings: Schema.optional(ReplicaSettingsDescriptionList)});
export const ItemCollectionSizeLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdateTableOutput = Schema.Struct({TableDescription: Schema.optional(TableDescription)});
export const CancellationReason = Schema.Struct({Item: Schema.optional(AttributeMap), Code: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const CancellationReasonList = Schema.Array(CancellationReason);
export const ReplicatedWriteConflictException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TransactionConflictException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeGlobalTableSettingsOutput = Schema.Struct({GlobalTableName: Schema.optional(Schema.String), ReplicaSettings: Schema.optional(ReplicaSettingsDescriptionList)});
export const TransactionInProgressException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TransactionCanceledException = Schema.Struct({Message: Schema.optional(Schema.String), CancellationReasons: Schema.optional(CancellationReasonList)});
export const ReplicaNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const IndexNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeEndpoints = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DescribeEndpoints" }, DescribeEndpointsRequest, DescribeEndpointsResponse, Schema.Void), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeLimits = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DescribeLimits" }, DescribeLimitsInput, DescribeLimitsOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DisableKinesisStreamingDestination = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DisableKinesisStreamingDestination" }, KinesisStreamingDestinationInput, KinesisStreamingDestinationOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const EnableKinesisStreamingDestination = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.EnableKinesisStreamingDestination" }, KinesisStreamingDestinationInput, KinesisStreamingDestinationOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.GetResourcePolicy" }, GetResourcePolicyInput, GetResourcePolicyOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("PolicyNotFoundException", PolicyNotFoundException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTables = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.ListTables" }, ListTablesInput, ListTablesOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTagsOfResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.ListTagsOfResource" }, ListTagsOfResourceInput, ListTagsOfResourceOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PutResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.PutResourcePolicy" }, PutResourcePolicyInput, PutResourcePolicyOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("PolicyNotFoundException", PolicyNotFoundException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const TagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.TagResource" }, TagResourceInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UntagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.UntagResource" }, UntagResourceInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateContributorInsights = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.UpdateContributorInsights" }, UpdateContributorInsightsInput, UpdateContributorInsightsOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DeleteResourcePolicy" }, DeleteResourcePolicyInput, DeleteResourcePolicyOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("PolicyNotFoundException", PolicyNotFoundException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeBackup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DescribeBackup" }, DescribeBackupInput, DescribeBackupOutput, Schema.Union(ErrorAnnotation("BackupNotFoundException", BackupNotFoundException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeContributorInsights = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DescribeContributorInsights" }, DescribeContributorInsightsInput, DescribeContributorInsightsOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeKinesisStreamingDestination = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DescribeKinesisStreamingDestination" }, DescribeKinesisStreamingDestinationInput, DescribeKinesisStreamingDestinationOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DescribeTable" }, DescribeTableInput, DescribeTableOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeTimeToLive = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DescribeTimeToLive" }, DescribeTimeToLiveInput, DescribeTimeToLiveOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListBackups = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.ListBackups" }, ListBackupsInput, ListBackupsOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListContributorInsights = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.ListContributorInsights" }, ListContributorInsightsInput, ListContributorInsightsOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListExports = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.ListExports" }, ListExportsInput, ListExportsOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("LimitExceededException", LimitExceededException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListGlobalTables = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.ListGlobalTables" }, ListGlobalTablesInput, ListGlobalTablesOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListImports = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.ListImports" }, ListImportsInput, ListImportsOutput, ErrorAnnotation("LimitExceededException", LimitExceededException)), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateKinesisStreamingDestination = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.UpdateKinesisStreamingDestination" }, UpdateKinesisStreamingDestinationInput, UpdateKinesisStreamingDestinationOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateTimeToLive = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.UpdateTimeToLive" }, UpdateTimeToLiveInput, UpdateTimeToLiveOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateGlobalTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.CreateGlobalTable" }, CreateGlobalTableInput, CreateGlobalTableOutput, Schema.Union(ErrorAnnotation("GlobalTableAlreadyExistsException", GlobalTableAlreadyExistsException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("TableNotFoundException", TableNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.CreateTable" }, CreateTableInput, CreateTableOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeContinuousBackups = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DescribeContinuousBackups" }, DescribeContinuousBackupsInput, DescribeContinuousBackupsOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("TableNotFoundException", TableNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeExport = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DescribeExport" }, DescribeExportInput, DescribeExportOutput, Schema.Union(ErrorAnnotation("ExportNotFoundException", ExportNotFoundException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("LimitExceededException", LimitExceededException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeGlobalTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DescribeGlobalTable" }, DescribeGlobalTableInput, DescribeGlobalTableOutput, Schema.Union(ErrorAnnotation("GlobalTableNotFoundException", GlobalTableNotFoundException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeImport = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DescribeImport" }, DescribeImportInput, DescribeImportOutput, ErrorAnnotation("ImportNotFoundException", ImportNotFoundException)), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const RestoreTableFromBackup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.RestoreTableFromBackup" }, RestoreTableFromBackupInput, RestoreTableFromBackupOutput, Schema.Union(ErrorAnnotation("BackupInUseException", BackupInUseException), ErrorAnnotation("BackupNotFoundException", BackupNotFoundException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("TableAlreadyExistsException", TableAlreadyExistsException), ErrorAnnotation("TableInUseException", TableInUseException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const RestoreTableToPointInTime = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.RestoreTableToPointInTime" }, RestoreTableToPointInTimeInput, RestoreTableToPointInTimeOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("InvalidRestoreTimeException", InvalidRestoreTimeException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("PointInTimeRecoveryUnavailableException", PointInTimeRecoveryUnavailableException), ErrorAnnotation("TableAlreadyExistsException", TableAlreadyExistsException), ErrorAnnotation("TableInUseException", TableInUseException), ErrorAnnotation("TableNotFoundException", TableNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const Scan = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.Scan" }, ScanInput, ScanOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ProvisionedThroughputExceededException", ProvisionedThroughputExceededException), ErrorAnnotation("RequestLimitExceeded", RequestLimitExceeded), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateContinuousBackups = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.UpdateContinuousBackups" }, UpdateContinuousBackupsInput, UpdateContinuousBackupsOutput, Schema.Union(ErrorAnnotation("ContinuousBackupsUnavailableException", ContinuousBackupsUnavailableException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("TableNotFoundException", TableNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateTableReplicaAutoScaling = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.UpdateTableReplicaAutoScaling" }, UpdateTableReplicaAutoScalingInput, UpdateTableReplicaAutoScalingOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const BatchExecuteStatement = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.BatchExecuteStatement" }, BatchExecuteStatementInput, BatchExecuteStatementOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("RequestLimitExceeded", RequestLimitExceeded), ErrorAnnotation("ThrottlingException", ThrottlingException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const BatchGetItem = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.BatchGetItem" }, BatchGetItemInput, BatchGetItemOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ProvisionedThroughputExceededException", ProvisionedThroughputExceededException), ErrorAnnotation("RequestLimitExceeded", RequestLimitExceeded), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateBackup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.CreateBackup" }, CreateBackupInput, CreateBackupOutput, Schema.Union(ErrorAnnotation("BackupInUseException", BackupInUseException), ErrorAnnotation("ContinuousBackupsUnavailableException", ContinuousBackupsUnavailableException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("TableInUseException", TableInUseException), ErrorAnnotation("TableNotFoundException", TableNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteBackup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DeleteBackup" }, DeleteBackupInput, DeleteBackupOutput, Schema.Union(ErrorAnnotation("BackupInUseException", BackupInUseException), ErrorAnnotation("BackupNotFoundException", BackupNotFoundException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DeleteTable" }, DeleteTableInput, DeleteTableOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeTableReplicaAutoScaling = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DescribeTableReplicaAutoScaling" }, DescribeTableReplicaAutoScalingInput, DescribeTableReplicaAutoScalingOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ExecuteStatement = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.ExecuteStatement" }, ExecuteStatementInput, ExecuteStatementOutput, Schema.Union(ErrorAnnotation("ConditionalCheckFailedException", ConditionalCheckFailedException), ErrorAnnotation("DuplicateItemException", DuplicateItemException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("ItemCollectionSizeLimitExceededException", ItemCollectionSizeLimitExceededException), ErrorAnnotation("ProvisionedThroughputExceededException", ProvisionedThroughputExceededException), ErrorAnnotation("RequestLimitExceeded", RequestLimitExceeded), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("TransactionConflictException", TransactionConflictException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ExportTableToPointInTime = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.ExportTableToPointInTime" }, ExportTableToPointInTimeInput, ExportTableToPointInTimeOutput, Schema.Union(ErrorAnnotation("ExportConflictException", ExportConflictException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidExportTimeException", InvalidExportTimeException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("PointInTimeRecoveryUnavailableException", PointInTimeRecoveryUnavailableException), ErrorAnnotation("TableNotFoundException", TableNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetItem = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.GetItem" }, GetItemInput, GetItemOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ProvisionedThroughputExceededException", ProvisionedThroughputExceededException), ErrorAnnotation("RequestLimitExceeded", RequestLimitExceeded), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ImportTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.ImportTable" }, ImportTableInput, ImportTableOutput, Schema.Union(ErrorAnnotation("ImportConflictException", ImportConflictException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PutItem = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.PutItem" }, PutItemInput, PutItemOutput, Schema.Union(ErrorAnnotation("ConditionalCheckFailedException", ConditionalCheckFailedException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ItemCollectionSizeLimitExceededException", ItemCollectionSizeLimitExceededException), ErrorAnnotation("ProvisionedThroughputExceededException", ProvisionedThroughputExceededException), ErrorAnnotation("ReplicatedWriteConflictException", ReplicatedWriteConflictException), ErrorAnnotation("RequestLimitExceeded", RequestLimitExceeded), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("TransactionConflictException", TransactionConflictException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const Query = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.Query" }, QueryInput, QueryOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ProvisionedThroughputExceededException", ProvisionedThroughputExceededException), ErrorAnnotation("RequestLimitExceeded", RequestLimitExceeded), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const TransactWriteItems = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.TransactWriteItems" }, TransactWriteItemsInput, TransactWriteItemsOutput, Schema.Union(ErrorAnnotation("IdempotentParameterMismatchException", IdempotentParameterMismatchException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ProvisionedThroughputExceededException", ProvisionedThroughputExceededException), ErrorAnnotation("RequestLimitExceeded", RequestLimitExceeded), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("TransactionCanceledException", TransactionCanceledException), ErrorAnnotation("TransactionInProgressException", TransactionInProgressException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateItem = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.UpdateItem" }, UpdateItemInput, UpdateItemOutput, Schema.Union(ErrorAnnotation("ConditionalCheckFailedException", ConditionalCheckFailedException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ItemCollectionSizeLimitExceededException", ItemCollectionSizeLimitExceededException), ErrorAnnotation("ProvisionedThroughputExceededException", ProvisionedThroughputExceededException), ErrorAnnotation("ReplicatedWriteConflictException", ReplicatedWriteConflictException), ErrorAnnotation("RequestLimitExceeded", RequestLimitExceeded), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("TransactionConflictException", TransactionConflictException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.UpdateTable" }, UpdateTableInput, UpdateTableOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const BatchWriteItem = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.BatchWriteItem" }, BatchWriteItemInput, BatchWriteItemOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ItemCollectionSizeLimitExceededException", ItemCollectionSizeLimitExceededException), ErrorAnnotation("ProvisionedThroughputExceededException", ProvisionedThroughputExceededException), ErrorAnnotation("ReplicatedWriteConflictException", ReplicatedWriteConflictException), ErrorAnnotation("RequestLimitExceeded", RequestLimitExceeded), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteItem = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DeleteItem" }, DeleteItemInput, DeleteItemOutput, Schema.Union(ErrorAnnotation("ConditionalCheckFailedException", ConditionalCheckFailedException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ItemCollectionSizeLimitExceededException", ItemCollectionSizeLimitExceededException), ErrorAnnotation("ProvisionedThroughputExceededException", ProvisionedThroughputExceededException), ErrorAnnotation("ReplicatedWriteConflictException", ReplicatedWriteConflictException), ErrorAnnotation("RequestLimitExceeded", RequestLimitExceeded), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("TransactionConflictException", TransactionConflictException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeGlobalTableSettings = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.DescribeGlobalTableSettings" }, DescribeGlobalTableSettingsInput, DescribeGlobalTableSettingsOutput, Schema.Union(ErrorAnnotation("GlobalTableNotFoundException", GlobalTableNotFoundException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ExecuteTransaction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.ExecuteTransaction" }, ExecuteTransactionInput, ExecuteTransactionOutput, Schema.Union(ErrorAnnotation("IdempotentParameterMismatchException", IdempotentParameterMismatchException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("ProvisionedThroughputExceededException", ProvisionedThroughputExceededException), ErrorAnnotation("RequestLimitExceeded", RequestLimitExceeded), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("TransactionCanceledException", TransactionCanceledException), ErrorAnnotation("TransactionInProgressException", TransactionInProgressException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const TransactGetItems = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.TransactGetItems" }, TransactGetItemsInput, TransactGetItemsOutput, Schema.Union(ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ProvisionedThroughputExceededException", ProvisionedThroughputExceededException), ErrorAnnotation("RequestLimitExceeded", RequestLimitExceeded), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("TransactionCanceledException", TransactionCanceledException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateGlobalTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.UpdateGlobalTable" }, UpdateGlobalTableInput, UpdateGlobalTableOutput, Schema.Union(ErrorAnnotation("GlobalTableNotFoundException", GlobalTableNotFoundException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("ReplicaAlreadyExistsException", ReplicaAlreadyExistsException), ErrorAnnotation("ReplicaNotFoundException", ReplicaNotFoundException), ErrorAnnotation("TableNotFoundException", TableNotFoundException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateGlobalTableSettings = /*#__PURE__*/ makeOperation(() => Operation({ version: "2012-08-10", uri: "/", method: "POST", sdkId: "DynamoDB", sigV4ServiceName: "dynamodb", name: "DynamoDB_20120810.UpdateGlobalTableSettings" }, UpdateGlobalTableSettingsInput, UpdateGlobalTableSettingsOutput, Schema.Union(ErrorAnnotation("GlobalTableNotFoundException", GlobalTableNotFoundException), ErrorAnnotation("IndexNotFoundException", IndexNotFoundException), ErrorAnnotation("InternalServerError", InternalServerError), ErrorAnnotation("InvalidEndpointException", InvalidEndpointException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ReplicaNotFoundException", ReplicaNotFoundException), ErrorAnnotation("ResourceInUseException", ResourceInUseException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
