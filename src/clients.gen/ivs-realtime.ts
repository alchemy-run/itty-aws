import { Schema} from "effect"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const ParticipantTokenCapabilities = Schema.Array(Schema.String);
export const TagKeyList = Schema.Array(Schema.String);
export const DeleteEncoderConfigurationRequest = Schema.Struct({arn: Schema.String});
export const DeleteEncoderConfigurationResponse = Schema.Struct({});
export const DeleteIngestConfigurationRequest = Schema.Struct({arn: Schema.String, force: Schema.optional(Schema.Boolean)});
export const DeleteIngestConfigurationResponse = Schema.Struct({});
export const DeletePublicKeyRequest = Schema.Struct({arn: Schema.String});
export const DeletePublicKeyResponse = Schema.Struct({});
export const DeleteStageRequest = Schema.Struct({arn: Schema.String});
export const DeleteStageResponse = Schema.Struct({});
export const DeleteStorageConfigurationRequest = Schema.Struct({arn: Schema.String});
export const DeleteStorageConfigurationResponse = Schema.Struct({});
export const DisconnectParticipantRequest = Schema.Struct({stageArn: Schema.String, participantId: Schema.String, reason: Schema.optional(Schema.String)});
export const DisconnectParticipantResponse = Schema.Struct({});
export const GetCompositionRequest = Schema.Struct({arn: Schema.String});
export const GetEncoderConfigurationRequest = Schema.Struct({arn: Schema.String});
export const GetIngestConfigurationRequest = Schema.Struct({arn: Schema.String});
export const GetParticipantRequest = Schema.Struct({stageArn: Schema.String, sessionId: Schema.String, participantId: Schema.String});
export const GetPublicKeyRequest = Schema.Struct({arn: Schema.String});
export const GetStageRequest = Schema.Struct({arn: Schema.String});
export const GetStageSessionRequest = Schema.Struct({stageArn: Schema.String, sessionId: Schema.String});
export const GetStorageConfigurationRequest = Schema.Struct({arn: Schema.String});
export const Tags = Schema.Record({key: Schema.String, value: Schema.String});
export const ImportPublicKeyRequest = Schema.Struct({publicKeyMaterial: Schema.String, name: Schema.optional(Schema.String), tags: Schema.optional(Tags)});
export const ListCompositionsRequest = Schema.Struct({filterByStageArn: Schema.optional(Schema.String), filterByEncoderConfigurationArn: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListEncoderConfigurationsRequest = Schema.Struct({nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListIngestConfigurationsRequest = Schema.Struct({filterByStageArn: Schema.optional(Schema.String), filterByState: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListParticipantEventsRequest = Schema.Struct({stageArn: Schema.String, sessionId: Schema.String, participantId: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListParticipantReplicasRequest = Schema.Struct({sourceStageArn: Schema.String, participantId: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListParticipantsRequest = Schema.Struct({stageArn: Schema.String, sessionId: Schema.String, filterByUserId: Schema.optional(Schema.String), filterByPublished: Schema.optional(Schema.Boolean), filterByState: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), filterByRecordingState: Schema.optional(Schema.String)});
export const ListPublicKeysRequest = Schema.Struct({nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListStagesRequest = Schema.Struct({nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListStageSessionsRequest = Schema.Struct({stageArn: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListStorageConfigurationsRequest = Schema.Struct({nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListTagsForResourceRequest = Schema.Struct({resourceArn: Schema.String});
export const ParticipantAttributes = Schema.Record({key: Schema.String, value: Schema.String});
export const StartParticipantReplicationRequest = Schema.Struct({sourceStageArn: Schema.String, destinationStageArn: Schema.String, participantId: Schema.String, reconnectWindowSeconds: Schema.optional(Schema.Number), attributes: Schema.optional(ParticipantAttributes)});
export const StopCompositionRequest = Schema.Struct({arn: Schema.String});
export const StopCompositionResponse = Schema.Struct({});
export const StopParticipantReplicationRequest = Schema.Struct({sourceStageArn: Schema.String, destinationStageArn: Schema.String, participantId: Schema.String});
export const TagResourceRequest = Schema.Struct({resourceArn: Schema.String, tags: Tags});
export const TagResourceResponse = Schema.Struct({});
export const UntagResourceRequest = Schema.Struct({resourceArn: Schema.String, tagKeys: TagKeyList});
export const UntagResourceResponse = Schema.Struct({});
export const UpdateIngestConfigurationRequest = Schema.Struct({arn: Schema.String, stageArn: Schema.optional(Schema.String)});
export const ParticipantRecordingMediaTypeList = Schema.Array(Schema.String);
export const ThumbnailStorageTypeList = Schema.Array(Schema.String);
export const ParticipantThumbnailConfiguration = Schema.Struct({targetIntervalSeconds: Schema.optional(Schema.Number), storage: Schema.optional(ThumbnailStorageTypeList), recordingMode: Schema.optional(Schema.String)});
export const ParticipantRecordingHlsConfiguration = Schema.Struct({targetSegmentDurationSeconds: Schema.optional(Schema.Number)});
export const AutoParticipantRecordingConfiguration = Schema.Struct({storageConfigurationArn: Schema.String, mediaTypes: Schema.optional(ParticipantRecordingMediaTypeList), thumbnailConfiguration: Schema.optional(ParticipantThumbnailConfiguration), recordingReconnectWindowSeconds: Schema.optional(Schema.Number), hlsConfiguration: Schema.optional(ParticipantRecordingHlsConfiguration), recordParticipantReplicas: Schema.optional(Schema.Boolean)});
export const UpdateStageRequest = Schema.Struct({arn: Schema.String, name: Schema.optional(Schema.String), autoParticipantRecordingConfiguration: Schema.optional(AutoParticipantRecordingConfiguration)});
export const Video = Schema.Struct({width: Schema.optional(Schema.Number), height: Schema.optional(Schema.Number), framerate: Schema.optional(Schema.Number), bitrate: Schema.optional(Schema.Number)});
export const ParticipantTokenAttributes = Schema.Record({key: Schema.String, value: Schema.String});
export const ParticipantTokenConfiguration = Schema.Struct({duration: Schema.optional(Schema.Number), userId: Schema.optional(Schema.String), attributes: Schema.optional(ParticipantTokenAttributes), capabilities: Schema.optional(ParticipantTokenCapabilities)});
export const ParticipantTokenConfigurations = Schema.Array(ParticipantTokenConfiguration);
export const S3StorageConfiguration = Schema.Struct({bucketName: Schema.String});
export const EncoderConfigurationArnList = Schema.Array(Schema.String);
export const CreateEncoderConfigurationRequest = Schema.Struct({name: Schema.optional(Schema.String), video: Schema.optional(Video), tags: Schema.optional(Tags)});
export const CreateIngestConfigurationRequest = Schema.Struct({name: Schema.optional(Schema.String), stageArn: Schema.optional(Schema.String), userId: Schema.optional(Schema.String), attributes: Schema.optional(ParticipantAttributes), ingestProtocol: Schema.String, insecureIngest: Schema.optional(Schema.Boolean), tags: Schema.optional(Tags)});
export const CreateParticipantTokenRequest = Schema.Struct({stageArn: Schema.String, duration: Schema.optional(Schema.Number), userId: Schema.optional(Schema.String), attributes: Schema.optional(ParticipantTokenAttributes), capabilities: Schema.optional(ParticipantTokenCapabilities)});
export const CreateStorageConfigurationRequest = Schema.Struct({name: Schema.optional(Schema.String), s3: S3StorageConfiguration, tags: Schema.optional(Tags)});
export const AccessDeniedException = Schema.Struct({accessControlAllowOrigin: Schema.optional(Header("Access-Control-Allow-Origin")), accessControlExposeHeaders: Schema.optional(Header("Access-Control-Expose-Headers")), cacheControl: Schema.optional(Header("Cache-Control")), contentSecurityPolicy: Schema.optional(Header("Content-Security-Policy")), strictTransportSecurity: Schema.optional(Header("Strict-Transport-Security")), xContentTypeOptions: Schema.optional(Header("X-Content-Type-Options")), xFrameOptions: Schema.optional(Header("X-Frame-Options")), xAmznErrorType: Schema.optional(Header("x-amzn-ErrorType")), exceptionMessage: Schema.optional(Schema.String)});
export const ConflictException = Schema.Struct({accessControlAllowOrigin: Schema.optional(Header("Access-Control-Allow-Origin")), accessControlExposeHeaders: Schema.optional(Header("Access-Control-Expose-Headers")), cacheControl: Schema.optional(Header("Cache-Control")), contentSecurityPolicy: Schema.optional(Header("Content-Security-Policy")), strictTransportSecurity: Schema.optional(Header("Strict-Transport-Security")), xContentTypeOptions: Schema.optional(Header("X-Content-Type-Options")), xFrameOptions: Schema.optional(Header("X-Frame-Options")), xAmznErrorType: Schema.optional(Header("x-amzn-ErrorType")), exceptionMessage: Schema.optional(Schema.String)});
export const PendingVerification = Schema.Struct({accessControlAllowOrigin: Schema.optional(Header("Access-Control-Allow-Origin")), accessControlExposeHeaders: Schema.optional(Header("Access-Control-Expose-Headers")), cacheControl: Schema.optional(Header("Cache-Control")), contentSecurityPolicy: Schema.optional(Header("Content-Security-Policy")), strictTransportSecurity: Schema.optional(Header("Strict-Transport-Security")), xContentTypeOptions: Schema.optional(Header("X-Content-Type-Options")), xFrameOptions: Schema.optional(Header("X-Frame-Options")), xAmznErrorType: Schema.optional(Header("x-amzn-ErrorType")), exceptionMessage: Schema.optional(Schema.String)});
export const ResourceNotFoundException = Schema.Struct({accessControlAllowOrigin: Schema.optional(Header("Access-Control-Allow-Origin")), accessControlExposeHeaders: Schema.optional(Header("Access-Control-Expose-Headers")), cacheControl: Schema.optional(Header("Cache-Control")), contentSecurityPolicy: Schema.optional(Header("Content-Security-Policy")), strictTransportSecurity: Schema.optional(Header("Strict-Transport-Security")), xContentTypeOptions: Schema.optional(Header("X-Content-Type-Options")), xFrameOptions: Schema.optional(Header("X-Frame-Options")), xAmznErrorType: Schema.optional(Header("x-amzn-ErrorType")), exceptionMessage: Schema.optional(Schema.String)});
export const InternalServerException = Schema.Struct({accessControlAllowOrigin: Schema.optional(Header("Access-Control-Allow-Origin")), accessControlExposeHeaders: Schema.optional(Header("Access-Control-Expose-Headers")), cacheControl: Schema.optional(Header("Cache-Control")), contentSecurityPolicy: Schema.optional(Header("Content-Security-Policy")), strictTransportSecurity: Schema.optional(Header("Strict-Transport-Security")), xContentTypeOptions: Schema.optional(Header("X-Content-Type-Options")), xFrameOptions: Schema.optional(Header("X-Frame-Options")), xAmznErrorType: Schema.optional(Header("x-amzn-ErrorType")), exceptionMessage: Schema.optional(Schema.String)});
export const ValidationException = Schema.Struct({accessControlAllowOrigin: Schema.optional(Header("Access-Control-Allow-Origin")), accessControlExposeHeaders: Schema.optional(Header("Access-Control-Expose-Headers")), cacheControl: Schema.optional(Header("Cache-Control")), contentSecurityPolicy: Schema.optional(Header("Content-Security-Policy")), strictTransportSecurity: Schema.optional(Header("Strict-Transport-Security")), xContentTypeOptions: Schema.optional(Header("X-Content-Type-Options")), xFrameOptions: Schema.optional(Header("X-Frame-Options")), xAmznErrorType: Schema.optional(Header("x-amzn-ErrorType")), exceptionMessage: Schema.optional(Schema.String)});
export const PublicKey = Schema.Struct({arn: Schema.optional(Schema.String), name: Schema.optional(Schema.String), publicKeyMaterial: Schema.optional(Schema.String), fingerprint: Schema.optional(Schema.String), tags: Schema.optional(Tags)});
export const ImportPublicKeyResponse = Schema.Struct({publicKey: Schema.optional(PublicKey)});
export const ListTagsForResourceResponse = Schema.Struct({tags: Tags});
export const StartParticipantReplicationResponse = Schema.Struct({accessControlAllowOrigin: Schema.optional(Header("Access-Control-Allow-Origin")), accessControlExposeHeaders: Schema.optional(Header("Access-Control-Expose-Headers")), cacheControl: Schema.optional(Header("Cache-Control")), contentSecurityPolicy: Schema.optional(Header("Content-Security-Policy")), strictTransportSecurity: Schema.optional(Header("Strict-Transport-Security")), xContentTypeOptions: Schema.optional(Header("X-Content-Type-Options")), xFrameOptions: Schema.optional(Header("X-Frame-Options"))});
export const ServiceQuotaExceededException = Schema.Struct({accessControlAllowOrigin: Schema.optional(Header("Access-Control-Allow-Origin")), accessControlExposeHeaders: Schema.optional(Header("Access-Control-Expose-Headers")), cacheControl: Schema.optional(Header("Cache-Control")), contentSecurityPolicy: Schema.optional(Header("Content-Security-Policy")), strictTransportSecurity: Schema.optional(Header("Strict-Transport-Security")), xContentTypeOptions: Schema.optional(Header("X-Content-Type-Options")), xFrameOptions: Schema.optional(Header("X-Frame-Options")), xAmznErrorType: Schema.optional(Header("x-amzn-ErrorType")), exceptionMessage: Schema.optional(Schema.String)});
export const StopParticipantReplicationResponse = Schema.Struct({accessControlAllowOrigin: Schema.optional(Header("Access-Control-Allow-Origin")), accessControlExposeHeaders: Schema.optional(Header("Access-Control-Expose-Headers")), cacheControl: Schema.optional(Header("Cache-Control")), contentSecurityPolicy: Schema.optional(Header("Content-Security-Policy")), strictTransportSecurity: Schema.optional(Header("Strict-Transport-Security")), xContentTypeOptions: Schema.optional(Header("X-Content-Type-Options")), xFrameOptions: Schema.optional(Header("X-Frame-Options"))});
export const IngestConfiguration = Schema.Struct({name: Schema.optional(Schema.String), arn: Schema.String, ingestProtocol: Schema.String, streamKey: Schema.String, stageArn: Schema.String, participantId: Schema.String, state: Schema.String, userId: Schema.optional(Schema.String), attributes: Schema.optional(ParticipantAttributes), tags: Schema.optional(Tags)});
export const UpdateIngestConfigurationResponse = Schema.Struct({ingestConfiguration: Schema.optional(IngestConfiguration)});
export const StageEndpoints = Schema.Struct({events: Schema.optional(Schema.String), whip: Schema.optional(Schema.String), rtmp: Schema.optional(Schema.String), rtmps: Schema.optional(Schema.String)});
export const Stage = Schema.Struct({arn: Schema.String, name: Schema.optional(Schema.String), activeSessionId: Schema.optional(Schema.String), tags: Schema.optional(Tags), autoParticipantRecordingConfiguration: Schema.optional(AutoParticipantRecordingConfiguration), endpoints: Schema.optional(StageEndpoints)});
export const UpdateStageResponse = Schema.Struct({stage: Schema.optional(Stage)});
export const GridConfiguration = Schema.Struct({featuredParticipantAttribute: Schema.optional(Schema.String), omitStoppedVideo: Schema.optional(Schema.Boolean), videoAspectRatio: Schema.optional(Schema.String), videoFillMode: Schema.optional(Schema.String), gridGap: Schema.optional(Schema.Number), participantOrderAttribute: Schema.optional(Schema.String)});
export const PipConfiguration = Schema.Struct({featuredParticipantAttribute: Schema.optional(Schema.String), omitStoppedVideo: Schema.optional(Schema.Boolean), videoFillMode: Schema.optional(Schema.String), gridGap: Schema.optional(Schema.Number), pipParticipantAttribute: Schema.optional(Schema.String), pipBehavior: Schema.optional(Schema.String), pipOffset: Schema.optional(Schema.Number), pipPosition: Schema.optional(Schema.String), pipWidth: Schema.optional(Schema.Number), pipHeight: Schema.optional(Schema.Number), participantOrderAttribute: Schema.optional(Schema.String)});
export const ChannelDestinationConfiguration = Schema.Struct({channelArn: Schema.String, encoderConfigurationArn: Schema.optional(Schema.String)});
export const EncoderConfiguration = Schema.Struct({arn: Schema.String, name: Schema.optional(Schema.String), video: Schema.optional(Video), tags: Schema.optional(Tags)});
export const Participant = Schema.Struct({participantId: Schema.optional(Schema.String), userId: Schema.optional(Schema.String), state: Schema.optional(Schema.String), firstJoinTime: Schema.optional(Schema.Date), attributes: Schema.optional(ParticipantAttributes), published: Schema.optional(Schema.Boolean), ispName: Schema.optional(Schema.String), osName: Schema.optional(Schema.String), osVersion: Schema.optional(Schema.String), browserName: Schema.optional(Schema.String), browserVersion: Schema.optional(Schema.String), sdkVersion: Schema.optional(Schema.String), recordingS3BucketName: Schema.optional(Schema.String), recordingS3Prefix: Schema.optional(Schema.String), recordingState: Schema.optional(Schema.String), protocol: Schema.optional(Schema.String), replicationType: Schema.optional(Schema.String), replicationState: Schema.optional(Schema.String), sourceStageArn: Schema.optional(Schema.String), sourceSessionId: Schema.optional(Schema.String)});
export const StageSession = Schema.Struct({sessionId: Schema.optional(Schema.String), startTime: Schema.optional(Schema.Date), endTime: Schema.optional(Schema.Date)});
export const StorageConfiguration = Schema.Struct({arn: Schema.String, name: Schema.optional(Schema.String), s3: Schema.optional(S3StorageConfiguration), tags: Schema.optional(Tags)});
export const EncoderConfigurationSummary = Schema.Struct({arn: Schema.String, name: Schema.optional(Schema.String), tags: Schema.optional(Tags)});
export const EncoderConfigurationSummaryList = Schema.Array(EncoderConfigurationSummary);
export const IngestConfigurationSummary = Schema.Struct({name: Schema.optional(Schema.String), arn: Schema.String, ingestProtocol: Schema.String, stageArn: Schema.String, participantId: Schema.String, state: Schema.String, userId: Schema.optional(Schema.String)});
export const IngestConfigurationList = Schema.Array(IngestConfigurationSummary);
export const Event = Schema.Struct({name: Schema.optional(Schema.String), participantId: Schema.optional(Schema.String), eventTime: Schema.optional(Schema.Date), remoteParticipantId: Schema.optional(Schema.String), errorCode: Schema.optional(Schema.String), destinationStageArn: Schema.optional(Schema.String), destinationSessionId: Schema.optional(Schema.String), replica: Schema.optional(Schema.Boolean)});
export const EventList = Schema.Array(Event);
export const ParticipantReplica = Schema.Struct({sourceStageArn: Schema.String, participantId: Schema.String, sourceSessionId: Schema.String, destinationStageArn: Schema.String, destinationSessionId: Schema.String, replicationState: Schema.String});
export const ParticipantReplicaList = Schema.Array(ParticipantReplica);
export const ParticipantSummary = Schema.Struct({participantId: Schema.optional(Schema.String), userId: Schema.optional(Schema.String), state: Schema.optional(Schema.String), firstJoinTime: Schema.optional(Schema.Date), published: Schema.optional(Schema.Boolean), recordingState: Schema.optional(Schema.String), replicationType: Schema.optional(Schema.String), replicationState: Schema.optional(Schema.String), sourceStageArn: Schema.optional(Schema.String), sourceSessionId: Schema.optional(Schema.String)});
export const ParticipantList = Schema.Array(ParticipantSummary);
export const PublicKeySummary = Schema.Struct({arn: Schema.optional(Schema.String), name: Schema.optional(Schema.String), tags: Schema.optional(Tags)});
export const PublicKeyList = Schema.Array(PublicKeySummary);
export const StageSummary = Schema.Struct({arn: Schema.String, name: Schema.optional(Schema.String), activeSessionId: Schema.optional(Schema.String), tags: Schema.optional(Tags)});
export const StageSummaryList = Schema.Array(StageSummary);
export const StageSessionSummary = Schema.Struct({sessionId: Schema.optional(Schema.String), startTime: Schema.optional(Schema.Date), endTime: Schema.optional(Schema.Date)});
export const StageSessionList = Schema.Array(StageSessionSummary);
export const StorageConfigurationSummary = Schema.Struct({arn: Schema.String, name: Schema.optional(Schema.String), s3: Schema.optional(S3StorageConfiguration), tags: Schema.optional(Tags)});
export const StorageConfigurationSummaryList = Schema.Array(StorageConfigurationSummary);
export const LayoutConfiguration = Schema.Struct({grid: Schema.optional(GridConfiguration), pip: Schema.optional(PipConfiguration)});
export const CompositionThumbnailConfiguration = Schema.Struct({targetIntervalSeconds: Schema.optional(Schema.Number), storage: Schema.optional(ThumbnailStorageTypeList)});
export const CompositionThumbnailConfigurationList = Schema.Array(CompositionThumbnailConfiguration);
export const CreateEncoderConfigurationResponse = Schema.Struct({encoderConfiguration: Schema.optional(EncoderConfiguration)});
export const CreateIngestConfigurationResponse = Schema.Struct({ingestConfiguration: Schema.optional(IngestConfiguration)});
export const CreateStageRequest = Schema.Struct({name: Schema.optional(Schema.String), participantTokenConfigurations: Schema.optional(ParticipantTokenConfigurations), tags: Schema.optional(Tags), autoParticipantRecordingConfiguration: Schema.optional(AutoParticipantRecordingConfiguration)});
export const CreateStorageConfigurationResponse = Schema.Struct({storageConfiguration: Schema.optional(StorageConfiguration)});
export const GetEncoderConfigurationResponse = Schema.Struct({encoderConfiguration: Schema.optional(EncoderConfiguration)});
export const GetIngestConfigurationResponse = Schema.Struct({ingestConfiguration: Schema.optional(IngestConfiguration)});
export const GetParticipantResponse = Schema.Struct({participant: Schema.optional(Participant)});
export const GetPublicKeyResponse = Schema.Struct({publicKey: Schema.optional(PublicKey)});
export const GetStageSessionResponse = Schema.Struct({stageSession: Schema.optional(StageSession)});
export const GetStorageConfigurationResponse = Schema.Struct({storageConfiguration: Schema.optional(StorageConfiguration)});
export const ListEncoderConfigurationsResponse = Schema.Struct({encoderConfigurations: EncoderConfigurationSummaryList, nextToken: Schema.optional(Schema.String)});
export const ListIngestConfigurationsResponse = Schema.Struct({ingestConfigurations: IngestConfigurationList, nextToken: Schema.optional(Schema.String)});
export const ListParticipantEventsResponse = Schema.Struct({events: EventList, nextToken: Schema.optional(Schema.String)});
export const ListParticipantReplicasResponse = Schema.Struct({replicas: ParticipantReplicaList, nextToken: Schema.optional(Schema.String)});
export const ListParticipantsResponse = Schema.Struct({participants: ParticipantList, nextToken: Schema.optional(Schema.String)});
export const ListPublicKeysResponse = Schema.Struct({publicKeys: PublicKeyList, nextToken: Schema.optional(Schema.String)});
export const ListStagesResponse = Schema.Struct({stages: StageSummaryList, nextToken: Schema.optional(Schema.String)});
export const ListStageSessionsResponse = Schema.Struct({stageSessions: StageSessionList, nextToken: Schema.optional(Schema.String)});
export const ListStorageConfigurationsResponse = Schema.Struct({storageConfigurations: StorageConfigurationSummaryList, nextToken: Schema.optional(Schema.String)});
export const DestinationSummary = Schema.Struct({id: Schema.String, state: Schema.String, startTime: Schema.optional(Schema.Date), endTime: Schema.optional(Schema.Date)});
export const DestinationSummaryList = Schema.Array(DestinationSummary);
export const CompositionRecordingHlsConfiguration = Schema.Struct({targetSegmentDurationSeconds: Schema.optional(Schema.Number)});
export const ParticipantToken = Schema.Struct({participantId: Schema.optional(Schema.String), token: Schema.optional(Schema.String), userId: Schema.optional(Schema.String), attributes: Schema.optional(ParticipantTokenAttributes), duration: Schema.optional(Schema.Number), capabilities: Schema.optional(ParticipantTokenCapabilities), expirationTime: Schema.optional(Schema.Date)});
export const ParticipantTokenList = Schema.Array(ParticipantToken);
export const CompositionSummary = Schema.Struct({arn: Schema.String, stageArn: Schema.String, destinations: DestinationSummaryList, state: Schema.String, tags: Schema.optional(Tags), startTime: Schema.optional(Schema.Date), endTime: Schema.optional(Schema.Date)});
export const CompositionSummaryList = Schema.Array(CompositionSummary);
export const RecordingConfiguration = Schema.Struct({hlsConfiguration: Schema.optional(CompositionRecordingHlsConfiguration), format: Schema.optional(Schema.String)});
export const CreateParticipantTokenResponse = Schema.Struct({participantToken: Schema.optional(ParticipantToken)});
export const CreateStageResponse = Schema.Struct({stage: Schema.optional(Stage), participantTokens: Schema.optional(ParticipantTokenList)});
export const GetStageResponse = Schema.Struct({stage: Schema.optional(Stage)});
export const ListCompositionsResponse = Schema.Struct({compositions: CompositionSummaryList, nextToken: Schema.optional(Schema.String)});
export const S3DestinationConfiguration = Schema.Struct({storageConfigurationArn: Schema.String, encoderConfigurationArns: EncoderConfigurationArnList, recordingConfiguration: Schema.optional(RecordingConfiguration), thumbnailConfigurations: Schema.optional(CompositionThumbnailConfigurationList)});
export const S3Detail = Schema.Struct({recordingPrefix: Schema.String});
export const DestinationConfiguration = Schema.Struct({name: Schema.optional(Schema.String), channel: Schema.optional(ChannelDestinationConfiguration), s3: Schema.optional(S3DestinationConfiguration)});
export const DestinationConfigurationList = Schema.Array(DestinationConfiguration);
export const DestinationDetail = Schema.Struct({s3: Schema.optional(S3Detail)});
export const StartCompositionRequest = Schema.Struct({stageArn: Schema.String, idempotencyToken: Schema.optional(Schema.String), layout: Schema.optional(LayoutConfiguration), destinations: DestinationConfigurationList, tags: Schema.optional(Tags)});
export const Destination = Schema.Struct({id: Schema.String, state: Schema.String, startTime: Schema.optional(Schema.Date), endTime: Schema.optional(Schema.Date), configuration: DestinationConfiguration, detail: Schema.optional(DestinationDetail)});
export const DestinationList = Schema.Array(Destination);
export const Composition = Schema.Struct({arn: Schema.String, stageArn: Schema.String, state: Schema.String, layout: LayoutConfiguration, destinations: DestinationList, tags: Schema.optional(Tags), startTime: Schema.optional(Schema.Date), endTime: Schema.optional(Schema.Date)});
export const GetCompositionResponse = Schema.Struct({composition: Schema.optional(Composition)});
export const StartCompositionResponse = Schema.Struct({composition: Schema.optional(Composition)});

//# Errors
export class AccessDeniedExceptionError extends Schema.TaggedError<AccessDeniedExceptionError>()("AccessDeniedException", AccessDeniedException) {};
export class ConflictExceptionError extends Schema.TaggedError<ConflictExceptionError>()("ConflictException", ConflictException) {};
export class PendingVerificationError extends Schema.TaggedError<PendingVerificationError>()("PendingVerification", PendingVerification) {};
export class ResourceNotFoundExceptionError extends Schema.TaggedError<ResourceNotFoundExceptionError>()("ResourceNotFoundException", ResourceNotFoundException) {};
export class InternalServerExceptionError extends Schema.TaggedError<InternalServerExceptionError>()("InternalServerException", InternalServerException) {};
export class ValidationExceptionError extends Schema.TaggedError<ValidationExceptionError>()("ValidationException", ValidationException) {};
export class ServiceQuotaExceededExceptionError extends Schema.TaggedError<ServiceQuotaExceededExceptionError>()("ServiceQuotaExceededException", ServiceQuotaExceededException) {};

//# Operations
export const tagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/tags/{resourceArn}", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.TagResource" }, TagResourceRequest, TagResourceResponse, [InternalServerExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const untagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/tags/{resourceArn}", method: "DELETE", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.UntagResource" }, UntagResourceRequest, UntagResourceResponse, [InternalServerExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteEncoderConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/DeleteEncoderConfiguration", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.DeleteEncoderConfiguration" }, DeleteEncoderConfigurationRequest, DeleteEncoderConfigurationResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteIngestConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/DeleteIngestConfiguration", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.DeleteIngestConfiguration" }, DeleteIngestConfigurationRequest, DeleteIngestConfigurationResponse, [AccessDeniedExceptionError, ConflictExceptionError, PendingVerificationError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deletePublicKey = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/DeletePublicKey", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.DeletePublicKey" }, DeletePublicKeyRequest, DeletePublicKeyResponse, [AccessDeniedExceptionError, ConflictExceptionError, PendingVerificationError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteStage = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/DeleteStage", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.DeleteStage" }, DeleteStageRequest, DeleteStageResponse, [AccessDeniedExceptionError, ConflictExceptionError, PendingVerificationError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteStorageConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/DeleteStorageConfiguration", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.DeleteStorageConfiguration" }, DeleteStorageConfigurationRequest, DeleteStorageConfigurationResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const disconnectParticipant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/DisconnectParticipant", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.DisconnectParticipant" }, DisconnectParticipantRequest, DisconnectParticipantResponse, [AccessDeniedExceptionError, PendingVerificationError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const importPublicKey = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/ImportPublicKey", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.ImportPublicKey" }, ImportPublicKeyRequest, ImportPublicKeyResponse, [AccessDeniedExceptionError, ConflictExceptionError, PendingVerificationError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/tags/{resourceArn}", method: "GET", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, [InternalServerExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const startParticipantReplication = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/StartParticipantReplication", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.StartParticipantReplication" }, StartParticipantReplicationRequest, StartParticipantReplicationResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, PendingVerificationError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const stopComposition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/StopComposition", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.StopComposition" }, StopCompositionRequest, StopCompositionResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const stopParticipantReplication = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/StopParticipantReplication", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.StopParticipantReplication" }, StopParticipantReplicationRequest, StopParticipantReplicationResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateIngestConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/UpdateIngestConfiguration", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.UpdateIngestConfiguration" }, UpdateIngestConfigurationRequest, UpdateIngestConfigurationResponse, [AccessDeniedExceptionError, ConflictExceptionError, PendingVerificationError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateStage = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/UpdateStage", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.UpdateStage" }, UpdateStageRequest, UpdateStageResponse, [AccessDeniedExceptionError, ConflictExceptionError, PendingVerificationError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createEncoderConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/CreateEncoderConfiguration", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.CreateEncoderConfiguration" }, CreateEncoderConfigurationRequest, CreateEncoderConfigurationResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, PendingVerificationError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createIngestConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/CreateIngestConfiguration", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.CreateIngestConfiguration" }, CreateIngestConfigurationRequest, CreateIngestConfigurationResponse, [AccessDeniedExceptionError, PendingVerificationError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createStorageConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/CreateStorageConfiguration", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.CreateStorageConfiguration" }, CreateStorageConfigurationRequest, CreateStorageConfigurationResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, PendingVerificationError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getEncoderConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/GetEncoderConfiguration", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.GetEncoderConfiguration" }, GetEncoderConfigurationRequest, GetEncoderConfigurationResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getIngestConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/GetIngestConfiguration", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.GetIngestConfiguration" }, GetIngestConfigurationRequest, GetIngestConfigurationResponse, [AccessDeniedExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getParticipant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/GetParticipant", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.GetParticipant" }, GetParticipantRequest, GetParticipantResponse, [AccessDeniedExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getPublicKey = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/GetPublicKey", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.GetPublicKey" }, GetPublicKeyRequest, GetPublicKeyResponse, [AccessDeniedExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getStageSession = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/GetStageSession", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.GetStageSession" }, GetStageSessionRequest, GetStageSessionResponse, [AccessDeniedExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getStorageConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/GetStorageConfiguration", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.GetStorageConfiguration" }, GetStorageConfigurationRequest, GetStorageConfigurationResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listEncoderConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/ListEncoderConfigurations", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.ListEncoderConfigurations" }, ListEncoderConfigurationsRequest, ListEncoderConfigurationsResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listIngestConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/ListIngestConfigurations", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.ListIngestConfigurations" }, ListIngestConfigurationsRequest, ListIngestConfigurationsResponse, [AccessDeniedExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listParticipantEvents = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/ListParticipantEvents", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.ListParticipantEvents" }, ListParticipantEventsRequest, ListParticipantEventsResponse, [AccessDeniedExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listParticipantReplicas = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/ListParticipantReplicas", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.ListParticipantReplicas" }, ListParticipantReplicasRequest, ListParticipantReplicasResponse, [AccessDeniedExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listParticipants = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/ListParticipants", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.ListParticipants" }, ListParticipantsRequest, ListParticipantsResponse, [AccessDeniedExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listPublicKeys = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/ListPublicKeys", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.ListPublicKeys" }, ListPublicKeysRequest, ListPublicKeysResponse, [AccessDeniedExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listStages = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/ListStages", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.ListStages" }, ListStagesRequest, ListStagesResponse, [AccessDeniedExceptionError, ConflictExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listStageSessions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/ListStageSessions", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.ListStageSessions" }, ListStageSessionsRequest, ListStageSessionsResponse, [AccessDeniedExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listStorageConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/ListStorageConfigurations", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.ListStorageConfigurations" }, ListStorageConfigurationsRequest, ListStorageConfigurationsResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createParticipantToken = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/CreateParticipantToken", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.CreateParticipantToken" }, CreateParticipantTokenRequest, CreateParticipantTokenResponse, [AccessDeniedExceptionError, PendingVerificationError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createStage = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/CreateStage", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.CreateStage" }, CreateStageRequest, CreateStageResponse, [AccessDeniedExceptionError, PendingVerificationError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getStage = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/GetStage", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.GetStage" }, GetStageRequest, GetStageResponse, [AccessDeniedExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listCompositions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/ListCompositions", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.ListCompositions" }, ListCompositionsRequest, ListCompositionsResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getComposition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/GetComposition", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.GetComposition" }, GetCompositionRequest, GetCompositionResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const startComposition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-07-14", uri: "/StartComposition", method: "POST", sdkId: "IVS RealTime", sigV4ServiceName: "ivs", name: "AmazonInteractiveVideoServiceRealTime.StartComposition" }, StartCompositionRequest, StartCompositionResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, PendingVerificationError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
