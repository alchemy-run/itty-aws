import { Schema} from "effect"
import { FormatAwsJSON11Request,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const TagKeyList = Schema.Array(Schema.String);
export const AcknowledgeJobInput = Schema.Struct({jobId: Schema.String, nonce: Schema.String});
export const AcknowledgeThirdPartyJobInput = Schema.Struct({jobId: Schema.String, nonce: Schema.String, clientToken: Schema.String});
export const DeleteCustomActionTypeInput = Schema.Struct({category: Schema.String, provider: Schema.String, version: Schema.String});
export const DeletePipelineInput = Schema.Struct({name: Schema.String});
export const DeleteWebhookInput = Schema.Struct({name: Schema.String});
export const DeleteWebhookOutput = Schema.Struct({});
export const DeregisterWebhookWithThirdPartyInput = Schema.Struct({webhookName: Schema.optional(Schema.String)});
export const DeregisterWebhookWithThirdPartyOutput = Schema.Struct({});
export const WebhookNotFoundException = Schema.Struct({});
export const DisableStageTransitionInput = Schema.Struct({pipelineName: Schema.String, stageName: Schema.String, transitionType: Schema.String, reason: Schema.String});
export const EnableStageTransitionInput = Schema.Struct({pipelineName: Schema.String, stageName: Schema.String, transitionType: Schema.String});
export const GetActionTypeInput = Schema.Struct({category: Schema.String, owner: Schema.String, provider: Schema.String, version: Schema.String});
export const GetJobDetailsInput = Schema.Struct({jobId: Schema.String});
export const GetPipelineInput = Schema.Struct({name: Schema.String, version: Schema.optional(Schema.Number)});
export const GetPipelineExecutionInput = Schema.Struct({pipelineName: Schema.String, pipelineExecutionId: Schema.String});
export const GetPipelineStateInput = Schema.Struct({name: Schema.String});
export const GetThirdPartyJobDetailsInput = Schema.Struct({jobId: Schema.String, clientToken: Schema.String});
export const ListActionTypesInput = Schema.Struct({actionOwnerFilter: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), regionFilter: Schema.optional(Schema.String)});
export const ListPipelinesInput = Schema.Struct({nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListRuleTypesInput = Schema.Struct({ruleOwnerFilter: Schema.optional(Schema.String), regionFilter: Schema.optional(Schema.String)});
export const ListTagsForResourceInput = Schema.Struct({resourceArn: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListWebhooksInput = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const OverrideStageConditionInput = Schema.Struct({pipelineName: Schema.String, stageName: Schema.String, pipelineExecutionId: Schema.String, conditionType: Schema.String});
export const ActionTypeId = Schema.Struct({category: Schema.String, owner: Schema.String, provider: Schema.String, version: Schema.String});
export const PollForThirdPartyJobsInput = Schema.Struct({actionTypeId: ActionTypeId, maxBatchSize: Schema.optional(Schema.Number)});
export const FailureDetails = Schema.Struct({type: Schema.String, message: Schema.String, externalExecutionId: Schema.optional(Schema.String)});
export const PutThirdPartyJobFailureResultInput = Schema.Struct({jobId: Schema.String, clientToken: Schema.String, failureDetails: FailureDetails});
export const CurrentRevision = Schema.Struct({revision: Schema.String, changeIdentifier: Schema.String, created: Schema.optional(Schema.Date), revisionSummary: Schema.optional(Schema.String)});
export const ExecutionDetails = Schema.Struct({summary: Schema.optional(Schema.String), externalExecutionId: Schema.optional(Schema.String), percentComplete: Schema.optional(Schema.Number)});
export const PutThirdPartyJobSuccessResultInput = Schema.Struct({jobId: Schema.String, clientToken: Schema.String, currentRevision: Schema.optional(CurrentRevision), continuationToken: Schema.optional(Schema.String), executionDetails: Schema.optional(ExecutionDetails)});
export const RegisterWebhookWithThirdPartyInput = Schema.Struct({webhookName: Schema.optional(Schema.String)});
export const RegisterWebhookWithThirdPartyOutput = Schema.Struct({});
export const RetryStageExecutionInput = Schema.Struct({pipelineName: Schema.String, stageName: Schema.String, pipelineExecutionId: Schema.String, retryMode: Schema.String});
export const RollbackStageInput = Schema.Struct({pipelineName: Schema.String, stageName: Schema.String, targetPipelineExecutionId: Schema.String});
export const StopPipelineExecutionInput = Schema.Struct({pipelineName: Schema.String, pipelineExecutionId: Schema.String, abandon: Schema.optional(Schema.Boolean), reason: Schema.optional(Schema.String)});
export const Tag = Schema.Struct({key: Schema.String, value: Schema.String});
export const TagList = Schema.Array(Tag);
export const TagResourceInput = Schema.Struct({resourceArn: Schema.String, tags: TagList});
export const TagResourceOutput = Schema.Struct({});
export const UntagResourceInput = Schema.Struct({resourceArn: Schema.String, tagKeys: TagKeyList});
export const UntagResourceOutput = Schema.Struct({});
export const EncryptionKey = Schema.Struct({id: Schema.String, type: Schema.String});
export const ArtifactStore = Schema.Struct({type: Schema.String, location: Schema.String, encryptionKey: Schema.optional(EncryptionKey)});
export const ArtifactStoreMap = Schema.Record({key: Schema.String, value: ArtifactStore});
export const BlockerDeclaration = Schema.Struct({name: Schema.String, type: Schema.String});
export const StageBlockerDeclarationList = Schema.Array(BlockerDeclaration);
export const ActionConfigurationMap = Schema.Record({key: Schema.String, value: Schema.String});
export const CommandList = Schema.Array(Schema.String);
export const FilePathList = Schema.Array(Schema.String);
export const OutputArtifact = Schema.Struct({name: Schema.String, files: Schema.optional(FilePathList)});
export const OutputArtifactList = Schema.Array(OutputArtifact);
export const InputArtifact = Schema.Struct({name: Schema.String});
export const InputArtifactList = Schema.Array(InputArtifact);
export const OutputVariableList = Schema.Array(Schema.String);
export const EnvironmentVariable = Schema.Struct({name: Schema.String, value: Schema.String, type: Schema.optional(Schema.String)});
export const EnvironmentVariableList = Schema.Array(EnvironmentVariable);
export const ActionDeclaration = Schema.Struct({name: Schema.String, actionTypeId: ActionTypeId, runOrder: Schema.optional(Schema.Number), configuration: Schema.optional(ActionConfigurationMap), commands: Schema.optional(CommandList), outputArtifacts: Schema.optional(OutputArtifactList), inputArtifacts: Schema.optional(InputArtifactList), outputVariables: Schema.optional(OutputVariableList), roleArn: Schema.optional(Schema.String), region: Schema.optional(Schema.String), namespace: Schema.optional(Schema.String), timeoutInMinutes: Schema.optional(Schema.Number), environmentVariables: Schema.optional(EnvironmentVariableList)});
export const StageActionDeclarationList = Schema.Array(ActionDeclaration);
export const RetryConfiguration = Schema.Struct({retryMode: Schema.optional(Schema.String)});
export const RuleTypeId = Schema.Struct({category: Schema.String, owner: Schema.optional(Schema.String), provider: Schema.String, version: Schema.optional(Schema.String)});
export const RuleConfigurationMap = Schema.Record({key: Schema.String, value: Schema.String});
export const RuleDeclaration = Schema.Struct({name: Schema.String, ruleTypeId: RuleTypeId, configuration: Schema.optional(RuleConfigurationMap), commands: Schema.optional(CommandList), inputArtifacts: Schema.optional(InputArtifactList), roleArn: Schema.optional(Schema.String), region: Schema.optional(Schema.String), timeoutInMinutes: Schema.optional(Schema.Number)});
export const RuleDeclarationList = Schema.Array(RuleDeclaration);
export const Condition = Schema.Struct({result: Schema.optional(Schema.String), rules: Schema.optional(RuleDeclarationList)});
export const ConditionList = Schema.Array(Condition);
export const FailureConditions = Schema.Struct({result: Schema.optional(Schema.String), retryConfiguration: Schema.optional(RetryConfiguration), conditions: Schema.optional(ConditionList)});
export const SuccessConditions = Schema.Struct({conditions: ConditionList});
export const BeforeEntryConditions = Schema.Struct({conditions: ConditionList});
export const StageDeclaration = Schema.Struct({name: Schema.String, blockers: Schema.optional(StageBlockerDeclarationList), actions: StageActionDeclarationList, onFailure: Schema.optional(FailureConditions), onSuccess: Schema.optional(SuccessConditions), beforeEntry: Schema.optional(BeforeEntryConditions)});
export const PipelineStageDeclarationList = Schema.Array(StageDeclaration);
export const PipelineVariableDeclaration = Schema.Struct({name: Schema.String, defaultValue: Schema.optional(Schema.String), description: Schema.optional(Schema.String)});
export const PipelineVariableDeclarationList = Schema.Array(PipelineVariableDeclaration);
export const GitTagPatternList = Schema.Array(Schema.String);
export const GitTagFilterCriteria = Schema.Struct({includes: Schema.optional(GitTagPatternList), excludes: Schema.optional(GitTagPatternList)});
export const GitBranchPatternList = Schema.Array(Schema.String);
export const GitBranchFilterCriteria = Schema.Struct({includes: Schema.optional(GitBranchPatternList), excludes: Schema.optional(GitBranchPatternList)});
export const GitFilePathPatternList = Schema.Array(Schema.String);
export const GitFilePathFilterCriteria = Schema.Struct({includes: Schema.optional(GitFilePathPatternList), excludes: Schema.optional(GitFilePathPatternList)});
export const GitPushFilter = Schema.Struct({tags: Schema.optional(GitTagFilterCriteria), branches: Schema.optional(GitBranchFilterCriteria), filePaths: Schema.optional(GitFilePathFilterCriteria)});
export const GitPushFilterList = Schema.Array(GitPushFilter);
export const GitPullRequestEventTypeList = Schema.Array(Schema.String);
export const GitPullRequestFilter = Schema.Struct({events: Schema.optional(GitPullRequestEventTypeList), branches: Schema.optional(GitBranchFilterCriteria), filePaths: Schema.optional(GitFilePathFilterCriteria)});
export const GitPullRequestFilterList = Schema.Array(GitPullRequestFilter);
export const GitConfiguration = Schema.Struct({sourceActionName: Schema.String, push: Schema.optional(GitPushFilterList), pullRequest: Schema.optional(GitPullRequestFilterList)});
export const PipelineTriggerDeclaration = Schema.Struct({providerType: Schema.String, gitConfiguration: GitConfiguration});
export const PipelineTriggerDeclarationList = Schema.Array(PipelineTriggerDeclaration);
export const PipelineDeclaration = Schema.Struct({name: Schema.String, roleArn: Schema.String, artifactStore: Schema.optional(ArtifactStore), artifactStores: Schema.optional(ArtifactStoreMap), stages: PipelineStageDeclarationList, version: Schema.optional(Schema.Number), executionMode: Schema.optional(Schema.String), pipelineType: Schema.optional(Schema.String), variables: Schema.optional(PipelineVariableDeclarationList), triggers: Schema.optional(PipelineTriggerDeclarationList)});
export const UpdatePipelineInput = Schema.Struct({pipeline: PipelineDeclaration});
export const TargetFilterValueList = Schema.Array(Schema.String);
export const ActionTypeSettings = Schema.Struct({thirdPartyConfigurationUrl: Schema.optional(Schema.String), entityUrlTemplate: Schema.optional(Schema.String), executionUrlTemplate: Schema.optional(Schema.String), revisionUrlTemplate: Schema.optional(Schema.String)});
export const ActionConfigurationProperty = Schema.Struct({name: Schema.String, required: Schema.Boolean, key: Schema.Boolean, secret: Schema.Boolean, queryable: Schema.optional(Schema.Boolean), description: Schema.optional(Schema.String), type: Schema.optional(Schema.String)});
export const ActionConfigurationPropertyList = Schema.Array(ActionConfigurationProperty);
export const ArtifactDetails = Schema.Struct({minimumCount: Schema.Number, maximumCount: Schema.Number});
export const TargetFilter = Schema.Struct({name: Schema.optional(Schema.String), values: Schema.optional(TargetFilterValueList)});
export const TargetFilterList = Schema.Array(TargetFilter);
export const LatestInPipelineExecutionFilter = Schema.Struct({pipelineExecutionId: Schema.String, startTimeRange: Schema.String});
export const RuleExecutionFilter = Schema.Struct({pipelineExecutionId: Schema.optional(Schema.String), latestInPipelineExecution: Schema.optional(LatestInPipelineExecutionFilter)});
export const QueryParamMap = Schema.Record({key: Schema.String, value: Schema.String});
export const ActionRevision = Schema.Struct({revisionId: Schema.String, revisionChangeId: Schema.String, created: Schema.Date});
export const ApprovalResult = Schema.Struct({summary: Schema.String, status: Schema.String});
export const OutputVariablesMap = Schema.Record({key: Schema.String, value: Schema.String});
export const PipelineVariable = Schema.Struct({name: Schema.String, value: Schema.String});
export const PipelineVariableList = Schema.Array(PipelineVariable);
export const SourceRevisionOverride = Schema.Struct({actionName: Schema.String, revisionType: Schema.String, revisionValue: Schema.String});
export const SourceRevisionOverrideList = Schema.Array(SourceRevisionOverride);
export const AllowedAccounts = Schema.Array(Schema.String);
export const AcknowledgeJobOutput = Schema.Struct({status: Schema.optional(Schema.String)});
export const AcknowledgeThirdPartyJobOutput = Schema.Struct({status: Schema.optional(Schema.String)});
export const CreateCustomActionTypeInput = Schema.Struct({category: Schema.String, provider: Schema.String, version: Schema.String, settings: Schema.optional(ActionTypeSettings), configurationProperties: Schema.optional(ActionConfigurationPropertyList), inputArtifactDetails: ArtifactDetails, outputArtifactDetails: ArtifactDetails, tags: Schema.optional(TagList)});
export const ConcurrentModificationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ValidationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PipelineNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const StageNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const LambdaExecutorConfiguration = Schema.Struct({lambdaFunctionArn: Schema.String});
export const PollingAccountList = Schema.Array(Schema.String);
export const PollingServicePrincipalList = Schema.Array(Schema.String);
export const JobWorkerExecutorConfiguration = Schema.Struct({pollingAccounts: Schema.optional(PollingAccountList), pollingServicePrincipals: Schema.optional(PollingServicePrincipalList)});
export const ExecutorConfiguration = Schema.Struct({lambdaExecutorConfiguration: Schema.optional(LambdaExecutorConfiguration), jobWorkerExecutorConfiguration: Schema.optional(JobWorkerExecutorConfiguration)});
export const ActionTypeExecutor = Schema.Struct({configuration: ExecutorConfiguration, type: Schema.String, policyStatementsTemplate: Schema.optional(Schema.String), jobTimeout: Schema.optional(Schema.Number)});
export const ActionTypeIdentifier = Schema.Struct({category: Schema.String, owner: Schema.String, provider: Schema.String, version: Schema.String});
export const ActionTypeArtifactDetails = Schema.Struct({minimumCount: Schema.Number, maximumCount: Schema.Number});
export const ActionTypePermissions = Schema.Struct({allowedAccounts: AllowedAccounts});
export const ActionTypeProperty = Schema.Struct({name: Schema.String, optional: Schema.Boolean, key: Schema.Boolean, noEcho: Schema.Boolean, queryable: Schema.optional(Schema.Boolean), description: Schema.optional(Schema.String)});
export const ActionTypeProperties = Schema.Array(ActionTypeProperty);
export const ActionTypeUrls = Schema.Struct({configurationUrl: Schema.optional(Schema.String), entityUrlTemplate: Schema.optional(Schema.String), executionUrlTemplate: Schema.optional(Schema.String), revisionUrlTemplate: Schema.optional(Schema.String)});
export const ActionTypeDeclaration = Schema.Struct({description: Schema.optional(Schema.String), executor: ActionTypeExecutor, id: ActionTypeIdentifier, inputArtifactDetails: ActionTypeArtifactDetails, outputArtifactDetails: ActionTypeArtifactDetails, permissions: Schema.optional(ActionTypePermissions), properties: Schema.optional(ActionTypeProperties), urls: Schema.optional(ActionTypeUrls)});
export const GetActionTypeOutput = Schema.Struct({actionType: Schema.optional(ActionTypeDeclaration)});
export const ListDeployActionExecutionTargetsInput = Schema.Struct({pipelineName: Schema.optional(Schema.String), actionExecutionId: Schema.String, filters: Schema.optional(TargetFilterList), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListRuleExecutionsInput = Schema.Struct({pipelineName: Schema.String, filter: Schema.optional(RuleExecutionFilter), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListTagsForResourceOutput = Schema.Struct({tags: Schema.optional(TagList), nextToken: Schema.optional(Schema.String)});
export const ConcurrentPipelineExecutionsLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PollForJobsInput = Schema.Struct({actionTypeId: ActionTypeId, maxBatchSize: Schema.optional(Schema.Number), queryParam: Schema.optional(QueryParamMap)});
export const PutActionRevisionInput = Schema.Struct({pipelineName: Schema.String, stageName: Schema.String, actionName: Schema.String, actionRevision: ActionRevision});
export const PutApprovalResultInput = Schema.Struct({pipelineName: Schema.String, stageName: Schema.String, actionName: Schema.String, result: ApprovalResult, token: Schema.String});
export const PutJobFailureResultInput = Schema.Struct({jobId: Schema.String, failureDetails: FailureDetails});
export const PutJobSuccessResultInput = Schema.Struct({jobId: Schema.String, currentRevision: Schema.optional(CurrentRevision), continuationToken: Schema.optional(Schema.String), executionDetails: Schema.optional(ExecutionDetails), outputVariables: Schema.optional(OutputVariablesMap)});
export const InvalidClientTokenException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidJobStateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RetryStageExecutionOutput = Schema.Struct({pipelineExecutionId: Schema.optional(Schema.String)});
export const RollbackStageOutput = Schema.Struct({pipelineExecutionId: Schema.String});
export const StartPipelineExecutionInput = Schema.Struct({name: Schema.String, variables: Schema.optional(PipelineVariableList), clientRequestToken: Schema.optional(Schema.String), sourceRevisions: Schema.optional(SourceRevisionOverrideList)});
export const StopPipelineExecutionOutput = Schema.Struct({pipelineExecutionId: Schema.optional(Schema.String)});
export const InvalidArnException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTagsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdatePipelineOutput = Schema.Struct({pipeline: Schema.optional(PipelineDeclaration)});
export const StageExecution = Schema.Struct({pipelineExecutionId: Schema.String, status: Schema.String, type: Schema.optional(Schema.String)});
export const StageExecutionList = Schema.Array(StageExecution);
export const SucceededInStageFilter = Schema.Struct({stageName: Schema.optional(Schema.String)});
export const WebhookFilterRule = Schema.Struct({jsonPath: Schema.String, matchEquals: Schema.optional(Schema.String)});
export const WebhookFilters = Schema.Array(WebhookFilterRule);
export const WebhookAuthConfiguration = Schema.Struct({AllowedIPRange: Schema.optional(Schema.String), SecretToken: Schema.optional(Schema.String)});
export const PipelineMetadata = Schema.Struct({pipelineArn: Schema.optional(Schema.String), created: Schema.optional(Schema.Date), updated: Schema.optional(Schema.Date), pollingDisabledAt: Schema.optional(Schema.Date)});
export const ActionExecutionFilter = Schema.Struct({pipelineExecutionId: Schema.optional(Schema.String), latestInPipelineExecution: Schema.optional(LatestInPipelineExecutionFilter)});
export const ActionType = Schema.Struct({id: ActionTypeId, settings: Schema.optional(ActionTypeSettings), actionConfigurationProperties: Schema.optional(ActionConfigurationPropertyList), inputArtifactDetails: ArtifactDetails, outputArtifactDetails: ArtifactDetails});
export const ActionTypeList = Schema.Array(ActionType);
export const PipelineExecutionFilter = Schema.Struct({succeededInStage: Schema.optional(SucceededInStageFilter)});
export const PipelineSummary = Schema.Struct({name: Schema.optional(Schema.String), version: Schema.optional(Schema.Number), pipelineType: Schema.optional(Schema.String), executionMode: Schema.optional(Schema.String), created: Schema.optional(Schema.Date), updated: Schema.optional(Schema.Date)});
export const PipelineList = Schema.Array(PipelineSummary);
export const WebhookDefinition = Schema.Struct({name: Schema.String, targetPipeline: Schema.String, targetAction: Schema.String, filters: WebhookFilters, authentication: Schema.String, authenticationConfiguration: WebhookAuthConfiguration});
export const ListWebhookItem = Schema.Struct({definition: WebhookDefinition, url: Schema.String, errorMessage: Schema.optional(Schema.String), errorCode: Schema.optional(Schema.String), lastTriggered: Schema.optional(Schema.Date), arn: Schema.optional(Schema.String), tags: Schema.optional(TagList)});
export const WebhookList = Schema.Array(ListWebhookItem);
export const ThirdPartyJob = Schema.Struct({clientId: Schema.optional(Schema.String), jobId: Schema.optional(Schema.String)});
export const ThirdPartyJobList = Schema.Array(ThirdPartyJob);
export const InvalidNonceException = Schema.Struct({message: Schema.optional(Schema.String)});
export const JobNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreateCustomActionTypeOutput = Schema.Struct({actionType: ActionType, tags: Schema.optional(TagList)});
export const ActionTypeNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GetPipelineOutput = Schema.Struct({pipeline: Schema.optional(PipelineDeclaration), metadata: Schema.optional(PipelineMetadata)});
export const ListActionExecutionsInput = Schema.Struct({pipelineName: Schema.String, filter: Schema.optional(ActionExecutionFilter), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListActionTypesOutput = Schema.Struct({actionTypes: ActionTypeList, nextToken: Schema.optional(Schema.String)});
export const ListPipelineExecutionsInput = Schema.Struct({pipelineName: Schema.String, maxResults: Schema.optional(Schema.Number), filter: Schema.optional(PipelineExecutionFilter), nextToken: Schema.optional(Schema.String)});
export const ListPipelinesOutput = Schema.Struct({pipelines: Schema.optional(PipelineList), nextToken: Schema.optional(Schema.String)});
export const InvalidNextTokenException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ListWebhooksOutput = Schema.Struct({webhooks: Schema.optional(WebhookList), NextToken: Schema.optional(Schema.String)});
export const ConditionNotOverridableException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PollForThirdPartyJobsOutput = Schema.Struct({jobs: Schema.optional(ThirdPartyJobList)});
export const PutActionRevisionOutput = Schema.Struct({newRevision: Schema.optional(Schema.Boolean), pipelineExecutionId: Schema.optional(Schema.String)});
export const PutApprovalResultOutput = Schema.Struct({approvedAt: Schema.optional(Schema.Date)});
export const OutputVariablesSizeExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PutWebhookInput = Schema.Struct({webhook: WebhookDefinition, tags: Schema.optional(TagList)});
export const ConflictException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PipelineExecutionNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const StartPipelineExecutionOutput = Schema.Struct({pipelineExecutionId: Schema.optional(Schema.String)});
export const DuplicatedStopRequestException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ResourceNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidActionDeclarationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ArtifactRevision = Schema.Struct({name: Schema.optional(Schema.String), revisionId: Schema.optional(Schema.String), revisionChangeIdentifier: Schema.optional(Schema.String), revisionSummary: Schema.optional(Schema.String), created: Schema.optional(Schema.Date), revisionUrl: Schema.optional(Schema.String)});
export const ArtifactRevisionList = Schema.Array(ArtifactRevision);
export const ResolvedPipelineVariable = Schema.Struct({name: Schema.optional(Schema.String), resolvedValue: Schema.optional(Schema.String)});
export const ResolvedPipelineVariableList = Schema.Array(ResolvedPipelineVariable);
export const ExecutionTrigger = Schema.Struct({triggerType: Schema.optional(Schema.String), triggerDetail: Schema.optional(Schema.String)});
export const PipelineRollbackMetadata = Schema.Struct({rollbackTargetPipelineExecutionId: Schema.optional(Schema.String)});
export const TransitionState = Schema.Struct({enabled: Schema.optional(Schema.Boolean), lastChangedBy: Schema.optional(Schema.String), lastChangedAt: Schema.optional(Schema.Date), disabledReason: Schema.optional(Schema.String)});
export const RetryStageMetadata = Schema.Struct({autoStageRetryAttempt: Schema.optional(Schema.Number), manualStageRetryAttempt: Schema.optional(Schema.Number), latestRetryTrigger: Schema.optional(Schema.String)});
export const ActionConfiguration = Schema.Struct({configuration: Schema.optional(ActionConfigurationMap)});
export const StageContext = Schema.Struct({name: Schema.optional(Schema.String)});
export const ActionContext = Schema.Struct({name: Schema.optional(Schema.String), actionExecutionId: Schema.optional(Schema.String)});
export const PipelineContext = Schema.Struct({pipelineName: Schema.optional(Schema.String), stage: Schema.optional(StageContext), action: Schema.optional(ActionContext), pipelineArn: Schema.optional(Schema.String), pipelineExecutionId: Schema.optional(Schema.String)});
export const S3ArtifactLocation = Schema.Struct({bucketName: Schema.String, objectKey: Schema.String});
export const ArtifactLocation = Schema.Struct({type: Schema.optional(Schema.String), s3Location: Schema.optional(S3ArtifactLocation)});
export const Artifact = Schema.Struct({name: Schema.optional(Schema.String), revision: Schema.optional(Schema.String), location: Schema.optional(ArtifactLocation)});
export const ArtifactList = Schema.Array(Artifact);
export const AWSSessionCredentials = Schema.Struct({accessKeyId: Schema.String, secretAccessKey: Schema.String, sessionToken: Schema.String});
export const ThirdPartyJobData = Schema.Struct({actionTypeId: Schema.optional(ActionTypeId), actionConfiguration: Schema.optional(ActionConfiguration), pipelineContext: Schema.optional(PipelineContext), inputArtifacts: Schema.optional(ArtifactList), outputArtifacts: Schema.optional(ArtifactList), artifactCredentials: Schema.optional(AWSSessionCredentials), continuationToken: Schema.optional(Schema.String), encryptionKey: Schema.optional(EncryptionKey)});
export const RuleTypeSettings = Schema.Struct({thirdPartyConfigurationUrl: Schema.optional(Schema.String), entityUrlTemplate: Schema.optional(Schema.String), executionUrlTemplate: Schema.optional(Schema.String), revisionUrlTemplate: Schema.optional(Schema.String)});
export const RuleConfigurationProperty = Schema.Struct({name: Schema.String, required: Schema.Boolean, key: Schema.Boolean, secret: Schema.Boolean, queryable: Schema.optional(Schema.Boolean), description: Schema.optional(Schema.String), type: Schema.optional(Schema.String)});
export const RuleConfigurationPropertyList = Schema.Array(RuleConfigurationProperty);
export const PipelineExecution = Schema.Struct({pipelineName: Schema.optional(Schema.String), pipelineVersion: Schema.optional(Schema.Number), pipelineExecutionId: Schema.optional(Schema.String), status: Schema.optional(Schema.String), statusSummary: Schema.optional(Schema.String), artifactRevisions: Schema.optional(ArtifactRevisionList), variables: Schema.optional(ResolvedPipelineVariableList), trigger: Schema.optional(ExecutionTrigger), executionMode: Schema.optional(Schema.String), executionType: Schema.optional(Schema.String), rollbackMetadata: Schema.optional(PipelineRollbackMetadata)});
export const ThirdPartyJobDetails = Schema.Struct({id: Schema.optional(Schema.String), data: Schema.optional(ThirdPartyJobData), nonce: Schema.optional(Schema.String)});
export const RuleType = Schema.Struct({id: RuleTypeId, settings: Schema.optional(RuleTypeSettings), ruleConfigurationProperties: Schema.optional(RuleConfigurationPropertyList), inputArtifactDetails: ArtifactDetails});
export const RuleTypeList = Schema.Array(RuleType);
export const JobData = Schema.Struct({actionTypeId: Schema.optional(ActionTypeId), actionConfiguration: Schema.optional(ActionConfiguration), pipelineContext: Schema.optional(PipelineContext), inputArtifacts: Schema.optional(ArtifactList), outputArtifacts: Schema.optional(ArtifactList), artifactCredentials: Schema.optional(AWSSessionCredentials), continuationToken: Schema.optional(Schema.String), encryptionKey: Schema.optional(EncryptionKey)});
export const Job = Schema.Struct({id: Schema.optional(Schema.String), data: Schema.optional(JobData), nonce: Schema.optional(Schema.String), accountId: Schema.optional(Schema.String)});
export const JobList = Schema.Array(Job);
export const StageConditionsExecution = Schema.Struct({status: Schema.optional(Schema.String), summary: Schema.optional(Schema.String)});
export const LimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PipelineVersionNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GetPipelineExecutionOutput = Schema.Struct({pipelineExecution: Schema.optional(PipelineExecution)});
export const GetThirdPartyJobDetailsOutput = Schema.Struct({jobDetails: Schema.optional(ThirdPartyJobDetails)});
export const ListRuleTypesOutput = Schema.Struct({ruleTypes: RuleTypeList});
export const NotLatestPipelineExecutionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PollForJobsOutput = Schema.Struct({jobs: Schema.optional(JobList)});
export const ActionNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalAlreadyCompletedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PutWebhookOutput = Schema.Struct({webhook: Schema.optional(ListWebhookItem)});
export const StageNotRetryableException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PipelineExecutionOutdatedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PipelineExecutionNotStoppableException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TooManyTagsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidBlockerDeclarationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ErrorDetails = Schema.Struct({code: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const ConditionExecution = Schema.Struct({status: Schema.optional(Schema.String), summary: Schema.optional(Schema.String), lastStatusChange: Schema.optional(Schema.Date)});
export const ActionExecution = Schema.Struct({actionExecutionId: Schema.optional(Schema.String), status: Schema.optional(Schema.String), summary: Schema.optional(Schema.String), lastStatusChange: Schema.optional(Schema.Date), token: Schema.optional(Schema.String), lastUpdatedBy: Schema.optional(Schema.String), externalExecutionId: Schema.optional(Schema.String), externalExecutionUrl: Schema.optional(Schema.String), percentComplete: Schema.optional(Schema.Number), errorDetails: Schema.optional(ErrorDetails), logStreamARN: Schema.optional(Schema.String)});
export const DeployTargetEventContext = Schema.Struct({ssmCommandId: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const ResolvedRuleConfigurationMap = Schema.Record({key: Schema.String, value: Schema.String});
export const RuleExecutionResult = Schema.Struct({externalExecutionId: Schema.optional(Schema.String), externalExecutionSummary: Schema.optional(Schema.String), externalExecutionUrl: Schema.optional(Schema.String), errorDetails: Schema.optional(ErrorDetails)});
export const RuleRevision = Schema.Struct({revisionId: Schema.String, revisionChangeId: Schema.String, created: Schema.Date});
export const RuleExecution = Schema.Struct({ruleExecutionId: Schema.optional(Schema.String), status: Schema.optional(Schema.String), summary: Schema.optional(Schema.String), lastStatusChange: Schema.optional(Schema.Date), token: Schema.optional(Schema.String), lastUpdatedBy: Schema.optional(Schema.String), externalExecutionId: Schema.optional(Schema.String), externalExecutionUrl: Schema.optional(Schema.String), errorDetails: Schema.optional(ErrorDetails)});
export const InvalidJobException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidApprovalTokenException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidWebhookAuthenticationParametersException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UnableToRollbackStageException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdateActionTypeInput = Schema.Struct({actionType: ActionTypeDeclaration});
export const InvalidStageDeclarationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ActionState = Schema.Struct({actionName: Schema.optional(Schema.String), currentRevision: Schema.optional(ActionRevision), latestExecution: Schema.optional(ActionExecution), entityUrl: Schema.optional(Schema.String), revisionUrl: Schema.optional(Schema.String)});
export const ActionStateList = Schema.Array(ActionState);
export const DeployTargetEvent = Schema.Struct({name: Schema.optional(Schema.String), status: Schema.optional(Schema.String), startTime: Schema.optional(Schema.Date), endTime: Schema.optional(Schema.Date), context: Schema.optional(DeployTargetEventContext)});
export const DeployTargetEventList = Schema.Array(DeployTargetEvent);
export const SourceRevision = Schema.Struct({actionName: Schema.String, revisionId: Schema.optional(Schema.String), revisionSummary: Schema.optional(Schema.String), revisionUrl: Schema.optional(Schema.String)});
export const SourceRevisionList = Schema.Array(SourceRevision);
export const StopExecutionTrigger = Schema.Struct({reason: Schema.optional(Schema.String)});
export const RuleExecutionOutput = Schema.Struct({executionResult: Schema.optional(RuleExecutionResult)});
export const RuleState = Schema.Struct({ruleName: Schema.optional(Schema.String), currentRevision: Schema.optional(RuleRevision), latestExecution: Schema.optional(RuleExecution), entityUrl: Schema.optional(Schema.String), revisionUrl: Schema.optional(Schema.String)});
export const RuleStateList = Schema.Array(RuleState);
export const S3Location = Schema.Struct({bucket: Schema.optional(Schema.String), key: Schema.optional(Schema.String)});
export const DeployActionExecutionTarget = Schema.Struct({targetId: Schema.optional(Schema.String), targetType: Schema.optional(Schema.String), status: Schema.optional(Schema.String), startTime: Schema.optional(Schema.Date), endTime: Schema.optional(Schema.Date), events: Schema.optional(DeployTargetEventList)});
export const DeployActionExecutionTargetList = Schema.Array(DeployActionExecutionTarget);
export const PipelineExecutionSummary = Schema.Struct({pipelineExecutionId: Schema.optional(Schema.String), status: Schema.optional(Schema.String), statusSummary: Schema.optional(Schema.String), startTime: Schema.optional(Schema.Date), lastUpdateTime: Schema.optional(Schema.Date), sourceRevisions: Schema.optional(SourceRevisionList), trigger: Schema.optional(ExecutionTrigger), stopTrigger: Schema.optional(StopExecutionTrigger), executionMode: Schema.optional(Schema.String), executionType: Schema.optional(Schema.String), rollbackMetadata: Schema.optional(PipelineRollbackMetadata)});
export const PipelineExecutionSummaryList = Schema.Array(PipelineExecutionSummary);
export const ConditionState = Schema.Struct({latestExecution: Schema.optional(ConditionExecution), ruleStates: Schema.optional(RuleStateList)});
export const ConditionStateList = Schema.Array(ConditionState);
export const ResolvedActionConfigurationMap = Schema.Record({key: Schema.String, value: Schema.String});
export const ActionExecutionResult = Schema.Struct({externalExecutionId: Schema.optional(Schema.String), externalExecutionSummary: Schema.optional(Schema.String), externalExecutionUrl: Schema.optional(Schema.String), errorDetails: Schema.optional(ErrorDetails), logStreamARN: Schema.optional(Schema.String)});
export const ArtifactDetail = Schema.Struct({name: Schema.optional(Schema.String), s3location: Schema.optional(S3Location)});
export const ArtifactDetailList = Schema.Array(ArtifactDetail);
export const ListDeployActionExecutionTargetsOutput = Schema.Struct({targets: Schema.optional(DeployActionExecutionTargetList), nextToken: Schema.optional(Schema.String)});
export const ListPipelineExecutionsOutput = Schema.Struct({pipelineExecutionSummaries: Schema.optional(PipelineExecutionSummaryList), nextToken: Schema.optional(Schema.String)});
export const InvalidWebhookFilterPatternException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RequestFailedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidStructureException = Schema.Struct({message: Schema.optional(Schema.String)});
export const StageConditionState = Schema.Struct({latestExecution: Schema.optional(StageConditionsExecution), conditionStates: Schema.optional(ConditionStateList)});
export const ActionExecutionInput = Schema.Struct({actionTypeId: Schema.optional(ActionTypeId), configuration: Schema.optional(ActionConfigurationMap), resolvedConfiguration: Schema.optional(ResolvedActionConfigurationMap), roleArn: Schema.optional(Schema.String), region: Schema.optional(Schema.String), inputArtifacts: Schema.optional(ArtifactDetailList), namespace: Schema.optional(Schema.String)});
export const ActionExecutionOutput = Schema.Struct({outputArtifacts: Schema.optional(ArtifactDetailList), executionResult: Schema.optional(ActionExecutionResult), outputVariables: Schema.optional(OutputVariablesMap)});
export const RuleExecutionInput = Schema.Struct({ruleTypeId: Schema.optional(RuleTypeId), configuration: Schema.optional(RuleConfigurationMap), resolvedConfiguration: Schema.optional(ResolvedRuleConfigurationMap), roleArn: Schema.optional(Schema.String), region: Schema.optional(Schema.String), inputArtifacts: Schema.optional(ArtifactDetailList)});
export const JobDetails = Schema.Struct({id: Schema.optional(Schema.String), data: Schema.optional(JobData), accountId: Schema.optional(Schema.String)});
export const StageState = Schema.Struct({stageName: Schema.optional(Schema.String), inboundExecution: Schema.optional(StageExecution), inboundExecutions: Schema.optional(StageExecutionList), inboundTransitionState: Schema.optional(TransitionState), actionStates: Schema.optional(ActionStateList), latestExecution: Schema.optional(StageExecution), beforeEntryConditionState: Schema.optional(StageConditionState), onSuccessConditionState: Schema.optional(StageConditionState), onFailureConditionState: Schema.optional(StageConditionState), retryStageMetadata: Schema.optional(RetryStageMetadata)});
export const StageStateList = Schema.Array(StageState);
export const ActionExecutionDetail = Schema.Struct({pipelineExecutionId: Schema.optional(Schema.String), actionExecutionId: Schema.optional(Schema.String), pipelineVersion: Schema.optional(Schema.Number), stageName: Schema.optional(Schema.String), actionName: Schema.optional(Schema.String), startTime: Schema.optional(Schema.Date), lastUpdateTime: Schema.optional(Schema.Date), updatedBy: Schema.optional(Schema.String), status: Schema.optional(Schema.String), input: Schema.optional(ActionExecutionInput), output: Schema.optional(ActionExecutionOutput)});
export const ActionExecutionDetailList = Schema.Array(ActionExecutionDetail);
export const RuleExecutionDetail = Schema.Struct({pipelineExecutionId: Schema.optional(Schema.String), ruleExecutionId: Schema.optional(Schema.String), pipelineVersion: Schema.optional(Schema.Number), stageName: Schema.optional(Schema.String), ruleName: Schema.optional(Schema.String), startTime: Schema.optional(Schema.Date), lastUpdateTime: Schema.optional(Schema.Date), updatedBy: Schema.optional(Schema.String), status: Schema.optional(Schema.String), input: Schema.optional(RuleExecutionInput), output: Schema.optional(RuleExecutionOutput)});
export const RuleExecutionDetailList = Schema.Array(RuleExecutionDetail);
export const CreatePipelineInput = Schema.Struct({pipeline: PipelineDeclaration, tags: Schema.optional(TagList)});
export const GetJobDetailsOutput = Schema.Struct({jobDetails: Schema.optional(JobDetails)});
export const GetPipelineStateOutput = Schema.Struct({pipelineName: Schema.optional(Schema.String), pipelineVersion: Schema.optional(Schema.Number), stageStates: Schema.optional(StageStateList), created: Schema.optional(Schema.Date), updated: Schema.optional(Schema.Date)});
export const ListActionExecutionsOutput = Schema.Struct({actionExecutionDetails: Schema.optional(ActionExecutionDetailList), nextToken: Schema.optional(Schema.String)});
export const ActionExecutionNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ListRuleExecutionsOutput = Schema.Struct({ruleExecutionDetails: Schema.optional(RuleExecutionDetailList), nextToken: Schema.optional(Schema.String)});
export const CreatePipelineOutput = Schema.Struct({pipeline: Schema.optional(PipelineDeclaration), tags: Schema.optional(TagList)});
export const PipelineNameInUseException = Schema.Struct({message: Schema.optional(Schema.String)});

//# Errors
export class ConcurrentModificationExceptionError extends Schema.TaggedError<ConcurrentModificationExceptionError>()("ConcurrentModificationException", ConcurrentModificationException) {};
export class ValidationExceptionError extends Schema.TaggedError<ValidationExceptionError>()("ValidationException", ValidationException) {};
export class WebhookNotFoundExceptionError extends Schema.TaggedError<WebhookNotFoundExceptionError>()("WebhookNotFoundException", WebhookNotFoundException) {};
export class PipelineNotFoundExceptionError extends Schema.TaggedError<PipelineNotFoundExceptionError>()("PipelineNotFoundException", PipelineNotFoundException) {};
export class InvalidClientTokenExceptionError extends Schema.TaggedError<InvalidClientTokenExceptionError>()("InvalidClientTokenException", InvalidClientTokenException) {};
export class InvalidArnExceptionError extends Schema.TaggedError<InvalidArnExceptionError>()("InvalidArnException", InvalidArnException) {};
export class InvalidNonceExceptionError extends Schema.TaggedError<InvalidNonceExceptionError>()("InvalidNonceException", InvalidNonceException) {};
export class StageNotFoundExceptionError extends Schema.TaggedError<StageNotFoundExceptionError>()("StageNotFoundException", StageNotFoundException) {};
export class ConcurrentPipelineExecutionsLimitExceededExceptionError extends Schema.TaggedError<ConcurrentPipelineExecutionsLimitExceededExceptionError>()("ConcurrentPipelineExecutionsLimitExceededException", ConcurrentPipelineExecutionsLimitExceededException) {};
export class InvalidJobStateExceptionError extends Schema.TaggedError<InvalidJobStateExceptionError>()("InvalidJobStateException", InvalidJobStateException) {};
export class JobNotFoundExceptionError extends Schema.TaggedError<JobNotFoundExceptionError>()("JobNotFoundException", JobNotFoundException) {};
export class ConflictExceptionError extends Schema.TaggedError<ConflictExceptionError>()("ConflictException", ConflictException) {};
export class InvalidTagsExceptionError extends Schema.TaggedError<InvalidTagsExceptionError>()("InvalidTagsException", InvalidTagsException) {};
export class ResourceNotFoundExceptionError extends Schema.TaggedError<ResourceNotFoundExceptionError>()("ResourceNotFoundException", ResourceNotFoundException) {};
export class ActionTypeNotFoundExceptionError extends Schema.TaggedError<ActionTypeNotFoundExceptionError>()("ActionTypeNotFoundException", ActionTypeNotFoundException) {};
export class InvalidNextTokenExceptionError extends Schema.TaggedError<InvalidNextTokenExceptionError>()("InvalidNextTokenException", InvalidNextTokenException) {};
export class ConditionNotOverridableExceptionError extends Schema.TaggedError<ConditionNotOverridableExceptionError>()("ConditionNotOverridableException", ConditionNotOverridableException) {};
export class ActionNotFoundExceptionError extends Schema.TaggedError<ActionNotFoundExceptionError>()("ActionNotFoundException", ActionNotFoundException) {};
export class OutputVariablesSizeExceededExceptionError extends Schema.TaggedError<OutputVariablesSizeExceededExceptionError>()("OutputVariablesSizeExceededException", OutputVariablesSizeExceededException) {};
export class NotLatestPipelineExecutionExceptionError extends Schema.TaggedError<NotLatestPipelineExecutionExceptionError>()("NotLatestPipelineExecutionException", NotLatestPipelineExecutionException) {};
export class PipelineExecutionNotFoundExceptionError extends Schema.TaggedError<PipelineExecutionNotFoundExceptionError>()("PipelineExecutionNotFoundException", PipelineExecutionNotFoundException) {};
export class DuplicatedStopRequestExceptionError extends Schema.TaggedError<DuplicatedStopRequestExceptionError>()("DuplicatedStopRequestException", DuplicatedStopRequestException) {};
export class InvalidActionDeclarationExceptionError extends Schema.TaggedError<InvalidActionDeclarationExceptionError>()("InvalidActionDeclarationException", InvalidActionDeclarationException) {};
export class LimitExceededExceptionError extends Schema.TaggedError<LimitExceededExceptionError>()("LimitExceededException", LimitExceededException) {};
export class TooManyTagsExceptionError extends Schema.TaggedError<TooManyTagsExceptionError>()("TooManyTagsException", TooManyTagsException) {};
export class PipelineVersionNotFoundExceptionError extends Schema.TaggedError<PipelineVersionNotFoundExceptionError>()("PipelineVersionNotFoundException", PipelineVersionNotFoundException) {};
export class ApprovalAlreadyCompletedExceptionError extends Schema.TaggedError<ApprovalAlreadyCompletedExceptionError>()("ApprovalAlreadyCompletedException", ApprovalAlreadyCompletedException) {};
export class StageNotRetryableExceptionError extends Schema.TaggedError<StageNotRetryableExceptionError>()("StageNotRetryableException", StageNotRetryableException) {};
export class PipelineExecutionOutdatedExceptionError extends Schema.TaggedError<PipelineExecutionOutdatedExceptionError>()("PipelineExecutionOutdatedException", PipelineExecutionOutdatedException) {};
export class PipelineExecutionNotStoppableExceptionError extends Schema.TaggedError<PipelineExecutionNotStoppableExceptionError>()("PipelineExecutionNotStoppableException", PipelineExecutionNotStoppableException) {};
export class InvalidBlockerDeclarationExceptionError extends Schema.TaggedError<InvalidBlockerDeclarationExceptionError>()("InvalidBlockerDeclarationException", InvalidBlockerDeclarationException) {};
export class InvalidJobExceptionError extends Schema.TaggedError<InvalidJobExceptionError>()("InvalidJobException", InvalidJobException) {};
export class InvalidApprovalTokenExceptionError extends Schema.TaggedError<InvalidApprovalTokenExceptionError>()("InvalidApprovalTokenException", InvalidApprovalTokenException) {};
export class InvalidWebhookAuthenticationParametersExceptionError extends Schema.TaggedError<InvalidWebhookAuthenticationParametersExceptionError>()("InvalidWebhookAuthenticationParametersException", InvalidWebhookAuthenticationParametersException) {};
export class UnableToRollbackStageExceptionError extends Schema.TaggedError<UnableToRollbackStageExceptionError>()("UnableToRollbackStageException", UnableToRollbackStageException) {};
export class InvalidStageDeclarationExceptionError extends Schema.TaggedError<InvalidStageDeclarationExceptionError>()("InvalidStageDeclarationException", InvalidStageDeclarationException) {};
export class InvalidWebhookFilterPatternExceptionError extends Schema.TaggedError<InvalidWebhookFilterPatternExceptionError>()("InvalidWebhookFilterPatternException", InvalidWebhookFilterPatternException) {};
export class RequestFailedExceptionError extends Schema.TaggedError<RequestFailedExceptionError>()("RequestFailedException", RequestFailedException) {};
export class InvalidStructureExceptionError extends Schema.TaggedError<InvalidStructureExceptionError>()("InvalidStructureException", InvalidStructureException) {};
export class ActionExecutionNotFoundExceptionError extends Schema.TaggedError<ActionExecutionNotFoundExceptionError>()("ActionExecutionNotFoundException", ActionExecutionNotFoundException) {};
export class PipelineNameInUseExceptionError extends Schema.TaggedError<PipelineNameInUseExceptionError>()("PipelineNameInUseException", PipelineNameInUseException) {};

//# Operations
export const deleteWebhook = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.DeleteWebhook" }, DeleteWebhookInput, DeleteWebhookOutput, [ConcurrentModificationExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deregisterWebhookWithThirdParty = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.DeregisterWebhookWithThirdParty" }, DeregisterWebhookWithThirdPartyInput, DeregisterWebhookWithThirdPartyOutput, [ValidationExceptionError, WebhookNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const registerWebhookWithThirdParty = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.RegisterWebhookWithThirdParty" }, RegisterWebhookWithThirdPartyInput, RegisterWebhookWithThirdPartyOutput, [ValidationExceptionError, WebhookNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteCustomActionType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.DeleteCustomActionType" }, DeleteCustomActionTypeInput, Schema.Struct({}), [ConcurrentModificationExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deletePipeline = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.DeletePipeline" }, DeletePipelineInput, Schema.Struct({}), [ConcurrentModificationExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const disableStageTransition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.DisableStageTransition" }, DisableStageTransitionInput, Schema.Struct({}), [PipelineNotFoundExceptionError, StageNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const enableStageTransition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.EnableStageTransition" }, EnableStageTransitionInput, Schema.Struct({}), [PipelineNotFoundExceptionError, StageNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putJobFailureResult = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.PutJobFailureResult" }, PutJobFailureResultInput, Schema.Struct({}), [InvalidJobStateExceptionError, JobNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putThirdPartyJobFailureResult = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.PutThirdPartyJobFailureResult" }, PutThirdPartyJobFailureResultInput, Schema.Struct({}), [InvalidClientTokenExceptionError, InvalidJobStateExceptionError, JobNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putThirdPartyJobSuccessResult = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.PutThirdPartyJobSuccessResult" }, PutThirdPartyJobSuccessResultInput, Schema.Struct({}), [InvalidClientTokenExceptionError, InvalidJobStateExceptionError, JobNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const untagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.UntagResource" }, UntagResourceInput, UntagResourceOutput, [ConcurrentModificationExceptionError, InvalidArnExceptionError, InvalidTagsExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const acknowledgeJob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.AcknowledgeJob" }, AcknowledgeJobInput, AcknowledgeJobOutput, [InvalidNonceExceptionError, JobNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const acknowledgeThirdPartyJob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.AcknowledgeThirdPartyJob" }, AcknowledgeThirdPartyJobInput, AcknowledgeThirdPartyJobOutput, [InvalidClientTokenExceptionError, InvalidNonceExceptionError, JobNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getActionType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.GetActionType" }, GetActionTypeInput, GetActionTypeOutput, [ActionTypeNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listActionTypes = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.ListActionTypes" }, ListActionTypesInput, ListActionTypesOutput, [InvalidNextTokenExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listPipelines = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.ListPipelines" }, ListPipelinesInput, ListPipelinesOutput, [InvalidNextTokenExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.ListTagsForResource" }, ListTagsForResourceInput, ListTagsForResourceOutput, [InvalidArnExceptionError, InvalidNextTokenExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listWebhooks = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.ListWebhooks" }, ListWebhooksInput, ListWebhooksOutput, [InvalidNextTokenExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const pollForThirdPartyJobs = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.PollForThirdPartyJobs" }, PollForThirdPartyJobsInput, PollForThirdPartyJobsOutput, [ActionTypeNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putJobSuccessResult = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.PutJobSuccessResult" }, PutJobSuccessResultInput, Schema.Struct({}), [InvalidJobStateExceptionError, JobNotFoundExceptionError, OutputVariablesSizeExceededExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startPipelineExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.StartPipelineExecution" }, StartPipelineExecutionInput, StartPipelineExecutionOutput, [ConcurrentPipelineExecutionsLimitExceededExceptionError, ConflictExceptionError, PipelineNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createCustomActionType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.CreateCustomActionType" }, CreateCustomActionTypeInput, CreateCustomActionTypeOutput, [ConcurrentModificationExceptionError, InvalidTagsExceptionError, LimitExceededExceptionError, TooManyTagsExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getPipeline = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.GetPipeline" }, GetPipelineInput, GetPipelineOutput, [PipelineNotFoundExceptionError, PipelineVersionNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getPipelineExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.GetPipelineExecution" }, GetPipelineExecutionInput, GetPipelineExecutionOutput, [PipelineExecutionNotFoundExceptionError, PipelineNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listRuleTypes = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.ListRuleTypes" }, ListRuleTypesInput, ListRuleTypesOutput, [InvalidNextTokenExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const overrideStageCondition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.OverrideStageCondition" }, OverrideStageConditionInput, Schema.Struct({}), [ConcurrentPipelineExecutionsLimitExceededExceptionError, ConditionNotOverridableExceptionError, ConflictExceptionError, NotLatestPipelineExecutionExceptionError, PipelineNotFoundExceptionError, StageNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const pollForJobs = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.PollForJobs" }, PollForJobsInput, PollForJobsOutput, [ActionTypeNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putActionRevision = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.PutActionRevision" }, PutActionRevisionInput, PutActionRevisionOutput, [ActionNotFoundExceptionError, ConcurrentPipelineExecutionsLimitExceededExceptionError, PipelineNotFoundExceptionError, StageNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const retryStageExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.RetryStageExecution" }, RetryStageExecutionInput, RetryStageExecutionOutput, [ConcurrentPipelineExecutionsLimitExceededExceptionError, ConflictExceptionError, NotLatestPipelineExecutionExceptionError, PipelineNotFoundExceptionError, StageNotFoundExceptionError, StageNotRetryableExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const stopPipelineExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.StopPipelineExecution" }, StopPipelineExecutionInput, StopPipelineExecutionOutput, [ConflictExceptionError, DuplicatedStopRequestExceptionError, PipelineExecutionNotStoppableExceptionError, PipelineNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const tagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.TagResource" }, TagResourceInput, TagResourceOutput, [ConcurrentModificationExceptionError, InvalidArnExceptionError, InvalidTagsExceptionError, ResourceNotFoundExceptionError, TooManyTagsExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getThirdPartyJobDetails = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.GetThirdPartyJobDetails" }, GetThirdPartyJobDetailsInput, GetThirdPartyJobDetailsOutput, [InvalidClientTokenExceptionError, InvalidJobExceptionError, JobNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putApprovalResult = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.PutApprovalResult" }, PutApprovalResultInput, PutApprovalResultOutput, [ActionNotFoundExceptionError, ApprovalAlreadyCompletedExceptionError, InvalidApprovalTokenExceptionError, PipelineNotFoundExceptionError, StageNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const rollbackStage = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.RollbackStage" }, RollbackStageInput, RollbackStageOutput, [ConflictExceptionError, PipelineExecutionNotFoundExceptionError, PipelineExecutionOutdatedExceptionError, PipelineNotFoundExceptionError, StageNotFoundExceptionError, UnableToRollbackStageExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listPipelineExecutions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.ListPipelineExecutions" }, ListPipelineExecutionsInput, ListPipelineExecutionsOutput, [InvalidNextTokenExceptionError, PipelineNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putWebhook = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.PutWebhook" }, PutWebhookInput, PutWebhookOutput, [ConcurrentModificationExceptionError, InvalidTagsExceptionError, InvalidWebhookAuthenticationParametersExceptionError, InvalidWebhookFilterPatternExceptionError, LimitExceededExceptionError, PipelineNotFoundExceptionError, TooManyTagsExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateActionType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.UpdateActionType" }, UpdateActionTypeInput, Schema.Struct({}), [ActionTypeNotFoundExceptionError, RequestFailedExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updatePipeline = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.UpdatePipeline" }, UpdatePipelineInput, UpdatePipelineOutput, [InvalidActionDeclarationExceptionError, InvalidBlockerDeclarationExceptionError, InvalidStageDeclarationExceptionError, InvalidStructureExceptionError, LimitExceededExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getJobDetails = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.GetJobDetails" }, GetJobDetailsInput, GetJobDetailsOutput, [JobNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getPipelineState = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.GetPipelineState" }, GetPipelineStateInput, GetPipelineStateOutput, [PipelineNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listActionExecutions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.ListActionExecutions" }, ListActionExecutionsInput, ListActionExecutionsOutput, [InvalidNextTokenExceptionError, PipelineExecutionNotFoundExceptionError, PipelineNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listDeployActionExecutionTargets = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.ListDeployActionExecutionTargets" }, ListDeployActionExecutionTargetsInput, ListDeployActionExecutionTargetsOutput, [ActionExecutionNotFoundExceptionError, InvalidNextTokenExceptionError, PipelineNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listRuleExecutions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.ListRuleExecutions" }, ListRuleExecutionsInput, ListRuleExecutionsOutput, [InvalidNextTokenExceptionError, PipelineExecutionNotFoundExceptionError, PipelineNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createPipeline = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-07-09", uri: "/", method: "POST", sdkId: "CodePipeline", sigV4ServiceName: "codepipeline", name: "CodePipeline_20150709.CreatePipeline" }, CreatePipelineInput, CreatePipelineOutput, [ConcurrentModificationExceptionError, InvalidActionDeclarationExceptionError, InvalidBlockerDeclarationExceptionError, InvalidStageDeclarationExceptionError, InvalidStructureExceptionError, InvalidTagsExceptionError, LimitExceededExceptionError, PipelineNameInUseExceptionError, TooManyTagsExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
