import { Schema} from "effect"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const DeleteGroupingConfigurationOutput = Schema.Struct({});
export const StartDiscoveryInput = Schema.Struct({});
export const StartDiscoveryOutput = Schema.Struct({});
export const ServiceLevelObjectiveIds = Schema.Array(Schema.String);
export const Auditors = Schema.Array(Schema.String);
export const TagKeyList = Schema.Array(Schema.String);
export const BatchGetServiceLevelObjectiveBudgetReportInput = Schema.Struct({Timestamp: Schema.Date, SloIds: ServiceLevelObjectiveIds});
export const AccessDeniedException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ListGroupingAttributeDefinitionsInput = Schema.Struct({NextToken: Schema.optional(Schema.String)});
export const Attributes = Schema.Record({key: Schema.String, value: Schema.String});
export const ListServiceDependenciesInput = Schema.Struct({StartTime: Schema.Date, EndTime: Schema.Date, KeyAttributes: Attributes, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListServiceDependentsInput = Schema.Struct({StartTime: Schema.Date, EndTime: Schema.Date, KeyAttributes: Attributes, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListServiceLevelObjectiveExclusionWindowsInput = Schema.Struct({Id: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListServiceOperationsInput = Schema.Struct({StartTime: Schema.Date, EndTime: Schema.Date, KeyAttributes: Attributes, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListServicesInput = Schema.Struct({StartTime: Schema.Date, EndTime: Schema.Date, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String), IncludeLinkedAccounts: Schema.optional(Schema.Boolean), AwsAccountId: Schema.optional(Schema.String)});
export const ListTagsForResourceRequest = Schema.Struct({ResourceArn: Schema.String});
export const ThrottlingException = Schema.Struct({Message: Schema.String});
export const UntagResourceRequest = Schema.Struct({ResourceArn: Schema.String, TagKeys: TagKeyList});
export const UntagResourceResponse = Schema.Struct({});
export const AttributeFilterValues = Schema.Array(Schema.String);
export const GroupingSourceKeyStringList = Schema.Array(Schema.String);
export const AttributeFilter = Schema.Struct({AttributeFilterName: Schema.String, AttributeFilterValues: AttributeFilterValues});
export const AttributeFilters = Schema.Array(AttributeFilter);
export const GroupingAttributeDefinition = Schema.Struct({GroupingName: Schema.String, GroupingSourceKeys: Schema.optional(GroupingSourceKeyStringList), DefaultGroupingValue: Schema.optional(Schema.String)});
export const GroupingAttributeDefinitions = Schema.Array(GroupingAttributeDefinition);
export const Tag = Schema.Struct({Key: Schema.String, Value: Schema.String});
export const TagList = Schema.Array(Tag);
export const ValidationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GetServiceInput = Schema.Struct({StartTime: Schema.Date, EndTime: Schema.Date, KeyAttributes: Attributes});
export const ListGroupingAttributeDefinitionsOutput = Schema.Struct({GroupingAttributeDefinitions: GroupingAttributeDefinitions, UpdatedAt: Schema.optional(Schema.Date), NextToken: Schema.optional(Schema.String)});
export const Window = Schema.Struct({DurationUnit: Schema.String, Duration: Schema.Number});
export const RecurrenceRule = Schema.Struct({Expression: Schema.String});
export const ExclusionWindow = Schema.Struct({Window: Window, StartTime: Schema.optional(Schema.Date), RecurrenceRule: Schema.optional(RecurrenceRule), Reason: Schema.optional(Schema.String)});
export const ExclusionWindows = Schema.Array(ExclusionWindow);
export const ListServiceLevelObjectiveExclusionWindowsOutput = Schema.Struct({ExclusionWindows: ExclusionWindows, NextToken: Schema.optional(Schema.String)});
export const ListServiceStatesInput = Schema.Struct({StartTime: Schema.Date, EndTime: Schema.Date, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String), IncludeLinkedAccounts: Schema.optional(Schema.Boolean), AwsAccountId: Schema.optional(Schema.String), AttributeFilters: Schema.optional(AttributeFilters)});
export const ListTagsForResourceResponse = Schema.Struct({Tags: Schema.optional(TagList)});
export const PutGroupingConfigurationInput = Schema.Struct({GroupingAttributeDefinitions: GroupingAttributeDefinitions});
export const TagResourceRequest = Schema.Struct({ResourceArn: Schema.String, Tags: TagList});
export const TagResourceResponse = Schema.Struct({});
export const ResourceNotFoundException = Schema.Struct({ResourceType: Schema.String, ResourceId: Schema.String, Message: Schema.String});
export const ServiceLevelObjectiveBudgetReportError = Schema.Struct({Name: Schema.String, Arn: Schema.String, ErrorCode: Schema.String, ErrorMessage: Schema.String});
export const ServiceLevelObjectiveBudgetReportErrors = Schema.Array(ServiceLevelObjectiveBudgetReportError);
export const LogGroupReferences = Schema.Array(Attributes);
export const Dimension = Schema.Struct({Name: Schema.String, Value: Schema.String});
export const Dimensions = Schema.Array(Dimension);
export const MetricReference = Schema.Struct({Namespace: Schema.String, MetricType: Schema.String, Dimensions: Schema.optional(Dimensions), MetricName: Schema.String, AccountId: Schema.optional(Schema.String)});
export const MetricReferences = Schema.Array(MetricReference);
export const ServiceDependent = Schema.Struct({OperationName: Schema.optional(Schema.String), DependentKeyAttributes: Attributes, DependentOperationName: Schema.optional(Schema.String), MetricReferences: MetricReferences});
export const ServiceDependents = Schema.Array(ServiceDependent);
export const ServiceOperation = Schema.Struct({Name: Schema.String, MetricReferences: MetricReferences});
export const ServiceOperations = Schema.Array(ServiceOperation);
export const ServiceEntity = Schema.Struct({Type: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), Environment: Schema.optional(Schema.String), AwsAccountId: Schema.optional(Schema.String)});
export const ServiceLevelObjectiveEntity = Schema.Struct({SloName: Schema.optional(Schema.String), SloArn: Schema.optional(Schema.String)});
export const ServiceOperationEntity = Schema.Struct({Service: Schema.optional(ServiceEntity), Operation: Schema.optional(Schema.String), MetricType: Schema.optional(Schema.String)});
export const CanaryEntity = Schema.Struct({CanaryName: Schema.String});
export const BatchUpdateExclusionWindowsInput = Schema.Struct({SloIds: ServiceLevelObjectiveIds, AddExclusionWindows: Schema.optional(ExclusionWindows), RemoveExclusionWindows: Schema.optional(ExclusionWindows)});
export const ListServiceDependentsOutput = Schema.Struct({StartTime: Schema.Date, EndTime: Schema.Date, ServiceDependents: ServiceDependents, NextToken: Schema.optional(Schema.String)});
export const ListServiceOperationsOutput = Schema.Struct({StartTime: Schema.Date, EndTime: Schema.Date, ServiceOperations: ServiceOperations, NextToken: Schema.optional(Schema.String)});
export const ServiceQuotaExceededException = Schema.Struct({Message: Schema.String});
export const AuditTargetEntity = Schema.Union(ServiceEntity, ServiceLevelObjectiveEntity, ServiceOperationEntity, CanaryEntity);
export const AttributeMap = Schema.Record({key: Schema.String, value: Schema.String});
export const AttributeMaps = Schema.Array(AttributeMap);
export const ServiceGroup = Schema.Struct({GroupName: Schema.String, GroupValue: Schema.String, GroupSource: Schema.String, GroupIdentifier: Schema.String});
export const ServiceGroups = Schema.Array(ServiceGroup);
export const Service = Schema.Struct({KeyAttributes: Attributes, AttributeMaps: Schema.optional(AttributeMaps), ServiceGroups: Schema.optional(ServiceGroups), MetricReferences: MetricReferences, LogGroupReferences: Schema.optional(LogGroupReferences)});
export const AuditTarget = Schema.Struct({Type: Schema.String, Data: AuditTargetEntity});
export const AuditTargets = Schema.Array(AuditTarget);
export const ServiceSummary = Schema.Struct({KeyAttributes: Attributes, AttributeMaps: Schema.optional(AttributeMaps), MetricReferences: MetricReferences, ServiceGroups: Schema.optional(ServiceGroups)});
export const ServiceSummaries = Schema.Array(ServiceSummary);
export const GroupingConfiguration = Schema.Struct({GroupingAttributeDefinitions: GroupingAttributeDefinitions, UpdatedAt: Schema.Date});
export const GetServiceOutput = Schema.Struct({Service: Service, StartTime: Schema.Date, EndTime: Schema.Date, LogGroupReferences: Schema.optional(LogGroupReferences)});
export const ListAuditFindingsInput = Schema.Struct({StartTime: Schema.Date, EndTime: Schema.Date, Auditors: Schema.optional(Auditors), AuditTargets: AuditTargets, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const ListServicesOutput = Schema.Struct({StartTime: Schema.Date, EndTime: Schema.Date, ServiceSummaries: ServiceSummaries, NextToken: Schema.optional(Schema.String)});
export const PutGroupingConfigurationOutput = Schema.Struct({GroupingConfiguration: GroupingConfiguration});
export const ChangeEvent = Schema.Struct({Timestamp: Schema.Date, AccountId: Schema.String, Region: Schema.String, Entity: Attributes, ChangeEventType: Schema.String, EventId: Schema.String, UserName: Schema.optional(Schema.String), EventName: Schema.optional(Schema.String)});
export const LatestChangeEvents = Schema.Array(ChangeEvent);
export const DependencyConfig = Schema.Struct({DependencyKeyAttributes: Attributes, DependencyOperationName: Schema.String});
export const Metric = Schema.Struct({Namespace: Schema.optional(Schema.String), MetricName: Schema.optional(Schema.String), Dimensions: Schema.optional(Dimensions)});
export const MetricStat = Schema.Struct({Metric: Metric, Period: Schema.Number, Stat: Schema.String, Unit: Schema.optional(Schema.String)});
export const MetricDataQuery = Schema.Struct({Id: Schema.String, MetricStat: Schema.optional(MetricStat), Expression: Schema.optional(Schema.String), Label: Schema.optional(Schema.String), ReturnData: Schema.optional(Schema.Boolean), Period: Schema.optional(Schema.Number), AccountId: Schema.optional(Schema.String)});
export const MetricDataQueries = Schema.Array(MetricDataQuery);
export const MonitoredRequestCountMetricDataQueries = Schema.Union(MetricDataQueries, MetricDataQueries);
export const RollingInterval = Schema.Struct({DurationUnit: Schema.String, Duration: Schema.Number});
export const CalendarInterval = Schema.Struct({StartTime: Schema.Date, DurationUnit: Schema.String, Duration: Schema.Number});
export const BatchUpdateExclusionWindowsError = Schema.Struct({SloId: Schema.String, ErrorCode: Schema.String, ErrorMessage: Schema.String});
export const BatchUpdateExclusionWindowsErrors = Schema.Array(BatchUpdateExclusionWindowsError);
export const ServiceDependency = Schema.Struct({OperationName: Schema.String, DependencyKeyAttributes: Attributes, DependencyOperationName: Schema.String, MetricReferences: MetricReferences});
export const ServiceDependencies = Schema.Array(ServiceDependency);
export const ServiceState = Schema.Struct({AttributeFilters: Schema.optional(AttributeFilters), Service: Attributes, LatestChangeEvents: LatestChangeEvents});
export const ServiceStates = Schema.Array(ServiceState);
export const RequestBasedServiceLevelIndicatorMetric = Schema.Struct({KeyAttributes: Schema.optional(Attributes), OperationName: Schema.optional(Schema.String), MetricType: Schema.optional(Schema.String), TotalRequestCountMetric: MetricDataQueries, MonitoredRequestCountMetric: MonitoredRequestCountMetricDataQueries, DependencyConfig: Schema.optional(DependencyConfig)});
export const Interval = Schema.Union(RollingInterval, CalendarInterval);
export const BatchUpdateExclusionWindowsOutput = Schema.Struct({SloIds: ServiceLevelObjectiveIds, Errors: BatchUpdateExclusionWindowsErrors});
export const ListServiceDependenciesOutput = Schema.Struct({StartTime: Schema.Date, EndTime: Schema.Date, ServiceDependencies: ServiceDependencies, NextToken: Schema.optional(Schema.String)});
export const ListServiceStatesOutput = Schema.Struct({StartTime: Schema.Date, EndTime: Schema.Date, ServiceStates: ServiceStates, NextToken: Schema.optional(Schema.String)});
export const RequestBasedServiceLevelIndicator = Schema.Struct({RequestBasedSliMetric: RequestBasedServiceLevelIndicatorMetric, MetricThreshold: Schema.optional(Schema.Number), ComparisonOperator: Schema.optional(Schema.String)});
export const Goal = Schema.Struct({Interval: Schema.optional(Interval), AttainmentGoal: Schema.optional(Schema.Number), WarningThreshold: Schema.optional(Schema.Number)});
export const AuditorResult = Schema.Struct({Auditor: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Severity: Schema.optional(Schema.String)});
export const AuditorResults = Schema.Array(AuditorResult);
export const MetricGraph = Schema.Struct({MetricDataQueries: Schema.optional(MetricDataQueries), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date)});
export const ServiceLevelIndicatorMetric = Schema.Struct({KeyAttributes: Schema.optional(Attributes), OperationName: Schema.optional(Schema.String), MetricType: Schema.optional(Schema.String), MetricDataQueries: MetricDataQueries, DependencyConfig: Schema.optional(DependencyConfig)});
export const Node = Schema.Struct({KeyAttributes: Attributes, Name: Schema.String, NodeId: Schema.String, Operation: Schema.optional(Schema.String), Type: Schema.optional(Schema.String), Duration: Schema.optional(Schema.Number), Status: Schema.optional(Schema.String)});
export const Nodes = Schema.Array(Node);
export const Edge = Schema.Struct({SourceNodeId: Schema.optional(Schema.String), DestinationNodeId: Schema.optional(Schema.String), Duration: Schema.optional(Schema.Number), ConnectionType: Schema.optional(Schema.String)});
export const Edges = Schema.Array(Edge);
export const ServiceLevelIndicator = Schema.Struct({SliMetric: ServiceLevelIndicatorMetric, MetricThreshold: Schema.Number, ComparisonOperator: Schema.String});
export const DependencyGraph = Schema.Struct({Nodes: Schema.optional(Nodes), Edges: Schema.optional(Edges)});
export const ServiceLevelObjectiveBudgetReport = Schema.Struct({Arn: Schema.String, Name: Schema.String, EvaluationType: Schema.optional(Schema.String), BudgetStatus: Schema.String, Attainment: Schema.optional(Schema.Number), TotalBudgetSeconds: Schema.optional(Schema.Number), BudgetSecondsRemaining: Schema.optional(Schema.Number), TotalBudgetRequests: Schema.optional(Schema.Number), BudgetRequestsRemaining: Schema.optional(Schema.Number), Sli: Schema.optional(ServiceLevelIndicator), RequestBasedSli: Schema.optional(RequestBasedServiceLevelIndicator), Goal: Schema.optional(Goal)});
export const ServiceLevelObjectiveBudgetReports = Schema.Array(ServiceLevelObjectiveBudgetReport);
export const AuditFinding = Schema.Struct({KeyAttributes: Attributes, AuditorResults: Schema.optional(AuditorResults), Operation: Schema.optional(Schema.String), MetricGraph: Schema.optional(MetricGraph), DependencyGraph: Schema.optional(DependencyGraph), Type: Schema.optional(Schema.String)});
export const AuditFindings = Schema.Array(AuditFinding);
export const BatchGetServiceLevelObjectiveBudgetReportOutput = Schema.Struct({Timestamp: Schema.Date, Reports: ServiceLevelObjectiveBudgetReports, Errors: ServiceLevelObjectiveBudgetReportErrors});
export const ListAuditFindingsOutput = Schema.Struct({AuditFindings: AuditFindings, NextToken: Schema.optional(Schema.String)});

//# Errors
export class AccessDeniedExceptionError extends Schema.TaggedError<AccessDeniedExceptionError>()("AccessDeniedException", AccessDeniedException) {};
export class ThrottlingExceptionError extends Schema.TaggedError<ThrottlingExceptionError>()("ThrottlingException", ThrottlingException) {};
export class ValidationExceptionError extends Schema.TaggedError<ValidationExceptionError>()("ValidationException", ValidationException) {};
export class ResourceNotFoundExceptionError extends Schema.TaggedError<ResourceNotFoundExceptionError>()("ResourceNotFoundException", ResourceNotFoundException) {};
export class ServiceQuotaExceededExceptionError extends Schema.TaggedError<ServiceQuotaExceededExceptionError>()("ServiceQuotaExceededException", ServiceQuotaExceededException) {};

//# Operations
export const startDiscovery = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/start-discovery", method: "POST", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.StartDiscovery" }, StartDiscoveryInput, StartDiscoveryOutput, [AccessDeniedExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteGroupingConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/grouping-configuration", method: "DELETE", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.DeleteGroupingConfiguration" }, Schema.Struct({}), DeleteGroupingConfigurationOutput, [AccessDeniedExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listGroupingAttributeDefinitions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/grouping-attribute-definitions", method: "POST", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.ListGroupingAttributeDefinitions" }, ListGroupingAttributeDefinitionsInput, ListGroupingAttributeDefinitionsOutput, [AccessDeniedExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listServiceLevelObjectiveExclusionWindows = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/slo/{Id}/exclusion-windows", method: "GET", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.ListServiceLevelObjectiveExclusionWindows" }, ListServiceLevelObjectiveExclusionWindowsInput, ListServiceLevelObjectiveExclusionWindowsOutput, [ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/tags", method: "GET", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, [ResourceNotFoundExceptionError, ThrottlingExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const untagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/untag-resource", method: "POST", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.UntagResource" }, UntagResourceRequest, UntagResourceResponse, [ResourceNotFoundExceptionError, ThrottlingExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listServiceDependents = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/service-dependents", method: "POST", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.ListServiceDependents" }, ListServiceDependentsInput, ListServiceDependentsOutput, [ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listServiceOperations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/service-operations", method: "POST", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.ListServiceOperations" }, ListServiceOperationsInput, ListServiceOperationsOutput, [ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const tagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/tag-resource", method: "POST", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.TagResource" }, TagResourceRequest, TagResourceResponse, [ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getService = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/service", method: "POST", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.GetService" }, GetServiceInput, GetServiceOutput, [ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listServices = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/services", method: "GET", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.ListServices" }, ListServicesInput, ListServicesOutput, [ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const putGroupingConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/grouping-configuration", method: "PUT", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.PutGroupingConfiguration" }, PutGroupingConfigurationInput, PutGroupingConfigurationOutput, [AccessDeniedExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const batchUpdateExclusionWindows = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/exclusion-windows", method: "PATCH", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.BatchUpdateExclusionWindows" }, BatchUpdateExclusionWindowsInput, BatchUpdateExclusionWindowsOutput, [ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listServiceDependencies = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/service-dependencies", method: "POST", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.ListServiceDependencies" }, ListServiceDependenciesInput, ListServiceDependenciesOutput, [ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listServiceStates = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/service/states", method: "POST", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.ListServiceStates" }, ListServiceStatesInput, ListServiceStatesOutput, [ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const batchGetServiceLevelObjectiveBudgetReport = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/budget-report", method: "POST", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.BatchGetServiceLevelObjectiveBudgetReport" }, BatchGetServiceLevelObjectiveBudgetReportInput, BatchGetServiceLevelObjectiveBudgetReportOutput, [ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listAuditFindings = /*#__PURE__*/ makeOperation(() => Operation({ version: "2024-04-15", uri: "/auditFindings", method: "POST", sdkId: "Application Signals", sigV4ServiceName: "application-signals", name: "ApplicationSignals.ListAuditFindings" }, ListAuditFindingsInput, ListAuditFindingsOutput, [ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
