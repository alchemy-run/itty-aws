import { Schema} from "effect"
import { FormatXMLRequest, FormatXMLResponse, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
const GetDataLakePrincipalRequest = Schema.Struct({})
const TagValueList = Schema.Array(Schema.String)
const PermissionList = Schema.Array(Schema.String)
const PermissionTypeList = Schema.Array(Schema.String)
const AssumeDecoratedRoleWithSAMLRequest = Schema.Struct({SAMLAssertion: Schema.String, RoleArn: Schema.String, PrincipalArn: Schema.String, DurationSeconds: Schema.optional(Schema.Number)})
const BatchRevokePermissionsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Entries: BatchPermissionsRequestEntryList})
const CancelTransactionRequest = Schema.Struct({TransactionId: Schema.String})
const CancelTransactionResponse = Schema.Struct({})
const CommitTransactionRequest = Schema.Struct({TransactionId: Schema.String})
const CreateLFTagRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), TagKey: Schema.String, TagValues: TagValueList})
const CreateLFTagResponse = Schema.Struct({})
const DeleteDataCellsFilterRequest = Schema.Struct({TableCatalogId: Schema.optional(Schema.String), DatabaseName: Schema.optional(Schema.String), TableName: Schema.optional(Schema.String), Name: Schema.optional(Schema.String)})
const DeleteDataCellsFilterResponse = Schema.Struct({})
const DeleteLakeFormationIdentityCenterConfigurationRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String)})
const DeleteLakeFormationIdentityCenterConfigurationResponse = Schema.Struct({})
const DeleteLakeFormationOptInRequest = Schema.Struct({Principal: DataLakePrincipal, Resource: Resource, Condition: Schema.optional(Condition)})
const DeleteLakeFormationOptInResponse = Schema.Struct({})
const DeleteLFTagRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), TagKey: Schema.String})
const DeleteLFTagResponse = Schema.Struct({})
const DeleteLFTagExpressionRequest = Schema.Struct({Name: Schema.String, CatalogId: Schema.optional(Schema.String)})
const DeleteLFTagExpressionResponse = Schema.Struct({})
export const DeleteLFTagExpression = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/DeleteLFTagExpression", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "DeleteLFTagExpression" }, DeleteLFTagExpressionRequest, DeleteLFTagExpressionResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeregisterResourceRequest = Schema.Struct({ResourceArn: Schema.String})
const DeregisterResourceResponse = Schema.Struct({})
export const DeregisterResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/DeregisterResource", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "DeregisterResource" }, DeregisterResourceRequest, DeregisterResourceResponse, Schema.Union(ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeLakeFormationIdentityCenterConfigurationRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String)})
const DescribeResourceRequest = Schema.Struct({ResourceArn: Schema.String})
const DescribeTransactionRequest = Schema.Struct({TransactionId: Schema.String})
const ExtendTransactionRequest = Schema.Struct({TransactionId: Schema.optional(Schema.String)})
const ExtendTransactionResponse = Schema.Struct({})
const GetDataCellsFilterRequest = Schema.Struct({TableCatalogId: Schema.String, DatabaseName: Schema.String, TableName: Schema.String, Name: Schema.String})
const GetDataLakePrincipalResponse = Schema.Struct({Identity: Schema.optional(Schema.String)})
export const GetDataLakePrincipal = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetDataLakePrincipal", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetDataLakePrincipal" }, GetDataLakePrincipalRequest, GetDataLakePrincipalResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetDataLakeSettingsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String)})
const GetEffectivePermissionsForPathRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), ResourceArn: Schema.String, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const GetLFTagRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), TagKey: Schema.String})
const GetLFTagExpressionRequest = Schema.Struct({Name: Schema.String, CatalogId: Schema.optional(Schema.String)})
const GetQueryStateRequest = Schema.Struct({QueryId: Schema.String})
const GetQueryStatisticsRequest = Schema.Struct({QueryId: Schema.String})
const GetResourceLFTagsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Resource: Resource, ShowAssignedLFTags: Schema.optional(Schema.Boolean)})
const GetTableObjectsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, TransactionId: Schema.optional(Schema.String), QueryAsOfTime: Schema.optional(Schema.Date), PartitionPredicate: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const GetWorkUnitResultsRequest = Schema.Struct({QueryId: Schema.String, WorkUnitId: Schema.Number, WorkUnitToken: Schema.String})
const GetWorkUnitsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), PageSize: Schema.optional(Schema.Number), QueryId: Schema.String})
const GrantPermissionsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Principal: DataLakePrincipal, Resource: Resource, Permissions: PermissionList, Condition: Schema.optional(Condition), PermissionsWithGrantOption: Schema.optional(PermissionList)})
const GrantPermissionsResponse = Schema.Struct({})
export const GrantPermissions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GrantPermissions", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GrantPermissions" }, GrantPermissionsRequest, GrantPermissionsResponse, Schema.Union(ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InvalidInputException", InvalidInputException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListLakeFormationOptInsRequest = Schema.Struct({Principal: Schema.optional(DataLakePrincipal), Resource: Schema.optional(Resource), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListLFTagExpressionsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListLFTagsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), ResourceShareType: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListPermissionsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Principal: Schema.optional(DataLakePrincipal), ResourceType: Schema.optional(Schema.String), Resource: Schema.optional(Resource), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), IncludeRelated: Schema.optional(Schema.String)})
const ListTableStorageOptimizersRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, StorageOptimizerType: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListTransactionsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), StatusFilter: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const RegisterResourceRequest = Schema.Struct({ResourceArn: Schema.String, UseServiceLinkedRole: Schema.optional(Schema.Boolean), RoleArn: Schema.optional(Schema.String), WithFederation: Schema.optional(Schema.Boolean), HybridAccessEnabled: Schema.optional(Schema.Boolean), WithPrivilegedAccess: Schema.optional(Schema.Boolean)})
const RegisterResourceResponse = Schema.Struct({})
const RemoveLFTagsFromResourceRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Resource: Resource, LFTags: LFTagsList})
const RevokePermissionsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Principal: DataLakePrincipal, Resource: Resource, Permissions: PermissionList, Condition: Schema.optional(Condition), PermissionsWithGrantOption: Schema.optional(PermissionList)})
const RevokePermissionsResponse = Schema.Struct({})
export const RevokePermissions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/RevokePermissions", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "RevokePermissions" }, RevokePermissionsRequest, RevokePermissionsResponse, Schema.Union(ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InvalidInputException", InvalidInputException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const SearchDatabasesByLFTagsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), CatalogId: Schema.optional(Schema.String), Expression: Expression})
const SearchTablesByLFTagsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), CatalogId: Schema.optional(Schema.String), Expression: Expression})
const StartTransactionRequest = Schema.Struct({TransactionType: Schema.optional(Schema.String)})
const UpdateDataCellsFilterRequest = Schema.Struct({TableData: DataCellsFilter})
const UpdateDataCellsFilterResponse = Schema.Struct({})
export const UpdateDataCellsFilter = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/UpdateDataCellsFilter", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "UpdateDataCellsFilter" }, UpdateDataCellsFilterRequest, UpdateDataCellsFilterResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateLakeFormationIdentityCenterConfigurationRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), ShareRecipients: Schema.optional(DataLakePrincipalList), ApplicationStatus: Schema.optional(Schema.String), ExternalFiltering: Schema.optional(ExternalFilteringConfiguration)})
const UpdateLakeFormationIdentityCenterConfigurationResponse = Schema.Struct({})
export const UpdateLakeFormationIdentityCenterConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/UpdateLakeFormationIdentityCenterConfiguration", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "UpdateLakeFormationIdentityCenterConfiguration" }, UpdateLakeFormationIdentityCenterConfigurationRequest, UpdateLakeFormationIdentityCenterConfigurationResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateLFTagRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), TagKey: Schema.String, TagValuesToDelete: Schema.optional(TagValueList), TagValuesToAdd: Schema.optional(TagValueList)})
const UpdateLFTagResponse = Schema.Struct({})
export const UpdateLFTag = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/UpdateLFTag", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "UpdateLFTag" }, UpdateLFTagRequest, UpdateLFTagResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateLFTagExpressionRequest = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), CatalogId: Schema.optional(Schema.String), Expression: Expression})
const UpdateLFTagExpressionResponse = Schema.Struct({})
const UpdateResourceRequest = Schema.Struct({RoleArn: Schema.String, ResourceArn: Schema.String, WithFederation: Schema.optional(Schema.Boolean), HybridAccessEnabled: Schema.optional(Schema.Boolean)})
const UpdateResourceResponse = Schema.Struct({})
export const UpdateResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/UpdateResource", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "UpdateResource" }, UpdateResourceRequest, UpdateResourceResponse, Schema.Union(ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ColumnNames = Schema.Array(Schema.String)
const ScopeTargets = Schema.Array(Schema.String)
const ValueStringList = Schema.Array(Schema.String)
const TableWildcard = Schema.Struct({})
const StringValueList = Schema.Array(Schema.String)
const TrustedResourceOwners = Schema.Array(Schema.String)
const AuthorizedSessionTagValueList = Schema.Array(Schema.String)
const LFTagPair = Schema.Struct({CatalogId: Schema.optional(Schema.String), TagKey: Schema.String, TagValues: TagValueList})
const LFTagsList = Schema.Array(LFTagPair)
const BatchPermissionsRequestEntry = Schema.Struct({Id: Schema.String, Principal: Schema.optional(DataLakePrincipal), Resource: Schema.optional(Resource), Permissions: Schema.optional(PermissionList), Condition: Schema.optional(Condition), PermissionsWithGrantOption: Schema.optional(PermissionList)})
const BatchPermissionsRequestEntryList = Schema.Array(BatchPermissionsRequestEntry)
const ExternalFilteringConfiguration = Schema.Struct({Status: Schema.String, AuthorizedTargets: ScopeTargets})
const DataLakePrincipal = Schema.Struct({DataLakePrincipalIdentifier: Schema.optional(Schema.String)})
const DataLakePrincipalList = Schema.Array(DataLakePrincipal)
const Condition = Schema.Struct({Expression: Schema.optional(Schema.String)})
const LFTag = Schema.Struct({TagKey: Schema.String, TagValues: TagValueList})
const Expression = Schema.Array(LFTag)
const VirtualObject = Schema.Struct({Uri: Schema.String, ETag: Schema.optional(Schema.String)})
const VirtualObjectList = Schema.Array(VirtualObject)
const PartitionValueList = Schema.Struct({Values: ValueStringList})
const AuditContext = Schema.Struct({AdditionalAuditContext: Schema.optional(Schema.String)})
const TableResource = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, Name: Schema.optional(Schema.String), TableWildcard: Schema.optional(TableWildcard)})
const FilterCondition = Schema.Struct({Field: Schema.optional(Schema.String), ComparisonOperator: Schema.optional(Schema.String), StringValueList: Schema.optional(StringValueList)})
const FilterConditionList = Schema.Array(FilterCondition)
const TransactionDescriptionList = Schema.Array(TransactionDescription)
const AllRowsWildcard = Schema.Struct({})
const PartitionValuesList = Schema.Array(Schema.String)
const AssumeDecoratedRoleWithSAMLResponse = Schema.Struct({AccessKeyId: Schema.optional(Schema.String), SecretAccessKey: Schema.optional(Schema.String), SessionToken: Schema.optional(Schema.String), Expiration: Schema.optional(Schema.Date)})
export const AssumeDecoratedRoleWithSAML = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/AssumeDecoratedRoleWithSAML", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "AssumeDecoratedRoleWithSAML" }, AssumeDecoratedRoleWithSAMLRequest, AssumeDecoratedRoleWithSAMLResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const BatchGrantPermissionsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Entries: BatchPermissionsRequestEntryList})
const ConcurrentModificationException = Schema.Struct({Message: Schema.optional(Schema.String)})
const CommitTransactionResponse = Schema.Struct({TransactionStatus: Schema.optional(Schema.String)})
export const CommitTransaction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/CommitTransaction", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "CommitTransaction" }, CommitTransactionRequest, CommitTransactionResponse, Schema.Union(ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("TransactionCanceledException", TransactionCanceledException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateLakeFormationIdentityCenterConfigurationRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), InstanceArn: Schema.optional(Schema.String), ExternalFiltering: Schema.optional(ExternalFilteringConfiguration), ShareRecipients: Schema.optional(DataLakePrincipalList)})
const CreateLakeFormationOptInRequest = Schema.Struct({Principal: DataLakePrincipal, Resource: Resource, Condition: Schema.optional(Condition)})
const CreateLakeFormationOptInResponse = Schema.Struct({})
export const CreateLakeFormationOptIn = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/CreateLakeFormationOptIn", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "CreateLakeFormationOptIn" }, CreateLakeFormationOptInRequest, CreateLakeFormationOptInResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("ResourceNumberLimitExceededException", ResourceNumberLimitExceededException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const AccessDeniedException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateLFTag = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/CreateLFTag", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "CreateLFTag" }, CreateLFTagRequest, CreateLFTagResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("ResourceNumberLimitExceededException", ResourceNumberLimitExceededException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateLFTagExpressionRequest = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), CatalogId: Schema.optional(Schema.String), Expression: Expression})
const CreateLFTagExpressionResponse = Schema.Struct({})
export const CreateLFTagExpression = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/CreateLFTagExpression", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "CreateLFTagExpression" }, CreateLFTagExpressionRequest, CreateLFTagExpressionResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("ResourceNumberLimitExceededException", ResourceNumberLimitExceededException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const EntityNotFoundException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteDataCellsFilter = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/DeleteDataCellsFilter", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "DeleteDataCellsFilter" }, DeleteDataCellsFilterRequest, DeleteDataCellsFilterResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InternalServiceException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteLakeFormationIdentityCenterConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/DeleteLakeFormationIdentityCenterConfiguration", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "DeleteLakeFormationIdentityCenterConfiguration" }, DeleteLakeFormationIdentityCenterConfigurationRequest, DeleteLakeFormationIdentityCenterConfigurationResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidInputException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteLakeFormationOptIn = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/DeleteLakeFormationOptIn", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "DeleteLakeFormationOptIn" }, DeleteLakeFormationOptInRequest, DeleteLakeFormationOptInResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const OperationTimeoutException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteLFTag = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/DeleteLFTag", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "DeleteLFTag" }, DeleteLFTagRequest, DeleteLFTagResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteObjectsOnCancelRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, TransactionId: Schema.String, Objects: VirtualObjectList})
const DeleteObjectsOnCancelResponse = Schema.Struct({})
const DescribeLakeFormationIdentityCenterConfigurationResponse = Schema.Struct({CatalogId: Schema.optional(Schema.String), InstanceArn: Schema.optional(Schema.String), ApplicationArn: Schema.optional(Schema.String), ExternalFiltering: Schema.optional(ExternalFilteringConfiguration), ShareRecipients: Schema.optional(DataLakePrincipalList), ResourceShare: Schema.optional(Schema.String)})
export const DescribeLakeFormationIdentityCenterConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/DescribeLakeFormationIdentityCenterConfiguration", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "DescribeLakeFormationIdentityCenterConfiguration" }, DescribeLakeFormationIdentityCenterConfigurationRequest, DescribeLakeFormationIdentityCenterConfigurationResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TransactionCanceledException = Schema.Struct({Message: Schema.optional(Schema.String)})
const GetDataCellsFilterResponse = Schema.Struct({DataCellsFilter: Schema.optional(DataCellsFilter)})
export const GetDataCellsFilter = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetDataCellsFilter", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetDataCellsFilter" }, GetDataCellsFilterRequest, GetDataCellsFilterResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetDataLakeSettingsResponse = Schema.Struct({DataLakeSettings: Schema.optional(DataLakeSettings)})
export const GetDataLakeSettings = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetDataLakeSettings", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetDataLakeSettings" }, GetDataLakeSettingsRequest, GetDataLakeSettingsResponse, Schema.Union(ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetLFTagResponse = Schema.Struct({CatalogId: Schema.optional(Schema.String), TagKey: Schema.optional(Schema.String), TagValues: Schema.optional(TagValueList)})
export const GetLFTag = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetLFTag", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetLFTag" }, GetLFTagRequest, GetLFTagResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetLFTagExpressionResponse = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), CatalogId: Schema.optional(Schema.String), Expression: Schema.optional(Expression)})
export const GetLFTagExpression = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetLFTagExpression", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetLFTagExpression" }, GetLFTagExpressionRequest, GetLFTagExpressionResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetQueryStateResponse = Schema.Struct({Error: Schema.optional(Schema.String), State: Schema.String})
export const GetQueryState = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetQueryState", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetQueryState" }, GetQueryStateRequest, GetQueryStateResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetTemporaryGluePartitionCredentialsRequest = Schema.Struct({TableArn: Schema.String, Partition: PartitionValueList, Permissions: Schema.optional(PermissionList), DurationSeconds: Schema.optional(Schema.Number), AuditContext: Schema.optional(AuditContext), SupportedPermissionTypes: Schema.optional(PermissionTypeList)})
const GetWorkUnitResultsResponse = Schema.Struct({ResultStream: Schema.optional(Body("undefined", StreamBody()))})
const ListDataCellsFilterRequest = Schema.Struct({Table: Schema.optional(TableResource), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)})
const ListLFTagsResponse = Schema.Struct({LFTags: Schema.optional(LFTagsList), NextToken: Schema.optional(Schema.String)})
export const ListLFTags = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/ListLFTags", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "ListLFTags" }, ListLFTagsRequest, ListLFTagsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListPermissionsResponse = Schema.Struct({PrincipalResourcePermissions: Schema.optional(PrincipalResourcePermissionsList), NextToken: Schema.optional(Schema.String)})
export const ListPermissions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/ListPermissions", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "ListPermissions" }, ListPermissionsRequest, ListPermissionsResponse, Schema.Union(ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListResourcesRequest = Schema.Struct({FilterConditionList: Schema.optional(FilterConditionList), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListTransactionsResponse = Schema.Struct({Transactions: Schema.optional(TransactionDescriptionList), NextToken: Schema.optional(Schema.String)})
export const ListTransactions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/ListTransactions", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "ListTransactions" }, ListTransactionsRequest, ListTransactionsResponse, Schema.Union(ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const AlreadyExistsException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const RegisterResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/RegisterResource", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "RegisterResource" }, RegisterResourceRequest, RegisterResourceResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("AlreadyExistsException", AlreadyExistsException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("ResourceNumberLimitExceededException", ResourceNumberLimitExceededException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const StartTransactionResponse = Schema.Struct({TransactionId: Schema.optional(Schema.String)})
export const StartTransaction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/StartTransaction", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "StartTransaction" }, StartTransactionRequest, StartTransactionResponse, Schema.Union(ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ResourceNumberLimitExceededException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateLFTagExpression = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/UpdateLFTagExpression", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "UpdateLFTagExpression" }, UpdateLFTagExpressionRequest, UpdateLFTagExpressionResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("ResourceNumberLimitExceededException", ResourceNumberLimitExceededException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CatalogResource = Schema.Struct({Id: Schema.optional(Schema.String)})
const DatabaseResource = Schema.Struct({CatalogId: Schema.optional(Schema.String), Name: Schema.String})
const TableWithColumnsResource = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, Name: Schema.String, ColumnNames: Schema.optional(ColumnNames), ColumnWildcard: Schema.optional(ColumnWildcard)})
const DataLocationResource = Schema.Struct({CatalogId: Schema.optional(Schema.String), ResourceArn: Schema.String})
const DataCellsFilterResource = Schema.Struct({TableCatalogId: Schema.optional(Schema.String), DatabaseName: Schema.optional(Schema.String), TableName: Schema.optional(Schema.String), Name: Schema.optional(Schema.String)})
const LFTagKeyResource = Schema.Struct({CatalogId: Schema.optional(Schema.String), TagKey: Schema.String, TagValues: TagValueList})
const LFTagPolicyResource = Schema.Struct({CatalogId: Schema.optional(Schema.String), ResourceType: Schema.String, Expression: Schema.optional(Expression), ExpressionName: Schema.optional(Schema.String)})
const LFTagExpressionResource = Schema.Struct({CatalogId: Schema.optional(Schema.String), Name: Schema.String})
const RowFilter = Schema.Struct({FilterExpression: Schema.optional(Schema.String), AllRowsWildcard: Schema.optional(AllRowsWildcard)})
const ColumnWildcard = Schema.Struct({ExcludedColumnNames: Schema.optional(ColumnNames)})
const AdditionalContextMap = Schema.Record({key: Schema.String, value: Schema.String})
const PrincipalPermissions = Schema.Struct({Principal: Schema.optional(DataLakePrincipal), Permissions: Schema.optional(PermissionList)})
const PrincipalPermissionsList = Schema.Array(PrincipalPermissions)
const ParametersMap = Schema.Record({key: Schema.String, value: Schema.String})
const QueryParameterMap = Schema.Record({key: Schema.String, value: Schema.String})
const AddObjectInput = Schema.Struct({Uri: Schema.String, ETag: Schema.String, Size: Schema.Number, PartitionValues: Schema.optional(PartitionValuesList)})
const DeleteObjectInput = Schema.Struct({Uri: Schema.String, ETag: Schema.optional(Schema.String), PartitionValues: Schema.optional(PartitionValuesList)})
const StorageOptimizerConfig = Schema.Record({key: Schema.String, value: Schema.String})
const Resource = Schema.Struct({Catalog: Schema.optional(CatalogResource), Database: Schema.optional(DatabaseResource), Table: Schema.optional(TableResource), TableWithColumns: Schema.optional(TableWithColumnsResource), DataLocation: Schema.optional(DataLocationResource), DataCellsFilter: Schema.optional(DataCellsFilterResource), LFTag: Schema.optional(LFTagKeyResource), LFTagPolicy: Schema.optional(LFTagPolicyResource), LFTagExpression: Schema.optional(LFTagExpressionResource)})
const DataCellsFilter = Schema.Struct({TableCatalogId: Schema.String, DatabaseName: Schema.String, TableName: Schema.String, Name: Schema.String, RowFilter: Schema.optional(RowFilter), ColumnNames: Schema.optional(ColumnNames), ColumnWildcard: Schema.optional(ColumnWildcard), VersionId: Schema.optional(Schema.String)})
const ResourceInfo = Schema.Struct({ResourceArn: Schema.optional(Schema.String), RoleArn: Schema.optional(Schema.String), LastModified: Schema.optional(Schema.Date), WithFederation: Schema.optional(Schema.Boolean), HybridAccessEnabled: Schema.optional(Schema.Boolean), WithPrivilegedAccess: Schema.optional(Schema.Boolean)})
const TransactionDescription = Schema.Struct({TransactionId: Schema.optional(Schema.String), TransactionStatus: Schema.optional(Schema.String), TransactionStartTime: Schema.optional(Schema.Date), TransactionEndTime: Schema.optional(Schema.Date)})
const ExecutionStatistics = Schema.Struct({AverageExecutionTimeMillis: Schema.optional(Schema.Number), DataScannedBytes: Schema.optional(Schema.Number), WorkUnitsExecutedCount: Schema.optional(Schema.Number)})
const PlanningStatistics = Schema.Struct({EstimatedDataToScanBytes: Schema.optional(Schema.Number), PlanningTimeMillis: Schema.optional(Schema.Number), QueueTimeMillis: Schema.optional(Schema.Number), WorkUnitsGeneratedCount: Schema.optional(Schema.Number)})
const ColumnLFTag = Schema.Struct({Name: Schema.optional(Schema.String), LFTags: Schema.optional(LFTagsList)})
const ColumnLFTagsList = Schema.Array(ColumnLFTag)
const QuerySessionContext = Schema.Struct({QueryId: Schema.optional(Schema.String), QueryStartTime: Schema.optional(Schema.Date), ClusterId: Schema.optional(Schema.String), QueryAuthorizationId: Schema.optional(Schema.String), AdditionalContext: Schema.optional(AdditionalContextMap)})
const WorkUnitRange = Schema.Struct({WorkUnitIdMax: Schema.Number, WorkUnitIdMin: Schema.Number, WorkUnitToken: Schema.String})
const WorkUnitRangeList = Schema.Array(WorkUnitRange)
const DataCellsFilterList = Schema.Array(DataCellsFilter)
const LakeFormationOptInsInfo = Schema.Struct({Resource: Schema.optional(Resource), Principal: Schema.optional(DataLakePrincipal), Condition: Schema.optional(Condition), LastModified: Schema.optional(Schema.Date), LastUpdatedBy: Schema.optional(Schema.String)})
const LakeFormationOptInsInfoList = Schema.Array(LakeFormationOptInsInfo)
const LFTagExpression = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), CatalogId: Schema.optional(Schema.String), Expression: Schema.optional(Expression)})
const LFTagExpressionsList = Schema.Array(LFTagExpression)
const ResourceInfoList = Schema.Array(ResourceInfo)
const StorageOptimizer = Schema.Struct({StorageOptimizerType: Schema.optional(Schema.String), Config: Schema.optional(StorageOptimizerConfig), ErrorMessage: Schema.optional(Schema.String), Warnings: Schema.optional(Schema.String), LastRunDetails: Schema.optional(Schema.String)})
const StorageOptimizerList = Schema.Array(StorageOptimizer)
const DataLakeSettings = Schema.Struct({DataLakeAdmins: Schema.optional(DataLakePrincipalList), ReadOnlyAdmins: Schema.optional(DataLakePrincipalList), CreateDatabaseDefaultPermissions: Schema.optional(PrincipalPermissionsList), CreateTableDefaultPermissions: Schema.optional(PrincipalPermissionsList), Parameters: Schema.optional(ParametersMap), TrustedResourceOwners: Schema.optional(TrustedResourceOwners), AllowExternalDataFiltering: Schema.optional(Schema.Boolean), AllowFullTableExternalDataAccess: Schema.optional(Schema.Boolean), ExternalDataFilteringAllowList: Schema.optional(DataLakePrincipalList), AuthorizedSessionTagValueList: Schema.optional(AuthorizedSessionTagValueList)})
const LFTagError = Schema.Struct({LFTag: Schema.optional(LFTagPair), Error: Schema.optional(ErrorDetail)})
const LFTagErrors = Schema.Array(LFTagError)
const TaggedDatabase = Schema.Struct({Database: Schema.optional(DatabaseResource), LFTags: Schema.optional(LFTagsList)})
const DatabaseLFTagsList = Schema.Array(TaggedDatabase)
const TaggedTable = Schema.Struct({Table: Schema.optional(TableResource), LFTagOnDatabase: Schema.optional(LFTagsList), LFTagsOnTable: Schema.optional(LFTagsList), LFTagsOnColumns: Schema.optional(ColumnLFTagsList)})
const TableLFTagsList = Schema.Array(TaggedTable)
const QueryPlanningContext = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, QueryAsOfTime: Schema.optional(Schema.Date), QueryParameters: Schema.optional(QueryParameterMap), TransactionId: Schema.optional(Schema.String)})
const WriteOperation = Schema.Struct({AddObject: Schema.optional(AddObjectInput), DeleteObject: Schema.optional(DeleteObjectInput)})
const WriteOperationList = Schema.Array(WriteOperation)
const StorageOptimizerConfigMap = Schema.Record({key: Schema.String, value: StorageOptimizerConfig})
const ResourceShareList = Schema.Array(Schema.String)
const AddLFTagsToResourceRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Resource: Resource, LFTags: LFTagsList})
const BatchGrantPermissionsResponse = Schema.Struct({Failures: Schema.optional(BatchPermissionsFailureList)})
export const BatchGrantPermissions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/BatchGrantPermissions", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "BatchGrantPermissions" }, BatchGrantPermissionsRequest, BatchGrantPermissionsResponse, Schema.Union(ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TransactionCommitInProgressException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CancelTransaction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/CancelTransaction", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "CancelTransaction" }, CancelTransactionRequest, CancelTransactionResponse, Schema.Union(ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("TransactionCommitInProgressException", TransactionCommitInProgressException), ErrorAnnotation("TransactionCommittedException", TransactionCommittedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateDataCellsFilterRequest = Schema.Struct({TableData: DataCellsFilter})
const CreateDataCellsFilterResponse = Schema.Struct({})
export const CreateDataCellsFilter = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/CreateDataCellsFilter", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "CreateDataCellsFilter" }, CreateDataCellsFilterRequest, CreateDataCellsFilterResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("AlreadyExistsException", AlreadyExistsException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("ResourceNumberLimitExceededException", ResourceNumberLimitExceededException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateLakeFormationIdentityCenterConfigurationResponse = Schema.Struct({ApplicationArn: Schema.optional(Schema.String)})
export const CreateLakeFormationIdentityCenterConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/CreateLakeFormationIdentityCenterConfiguration", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "CreateLakeFormationIdentityCenterConfiguration" }, CreateLakeFormationIdentityCenterConfigurationRequest, CreateLakeFormationIdentityCenterConfigurationResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("AlreadyExistsException", AlreadyExistsException), ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ResourceNotReadyException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteObjectsOnCancel = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/DeleteObjectsOnCancel", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "DeleteObjectsOnCancel" }, DeleteObjectsOnCancelRequest, DeleteObjectsOnCancelResponse, Schema.Union(ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("ResourceNotReadyException", ResourceNotReadyException), ErrorAnnotation("TransactionCanceledException", TransactionCanceledException), ErrorAnnotation("TransactionCommittedException", TransactionCommittedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeResourceResponse = Schema.Struct({ResourceInfo: Schema.optional(ResourceInfo)})
export const DescribeResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/DescribeResource", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "DescribeResource" }, DescribeResourceRequest, DescribeResourceResponse, Schema.Union(ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeTransactionResponse = Schema.Struct({TransactionDescription: Schema.optional(TransactionDescription)})
export const DescribeTransaction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/DescribeTransaction", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "DescribeTransaction" }, DescribeTransactionRequest, DescribeTransactionResponse, Schema.Union(ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TransactionCommittedException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const ExtendTransaction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/ExtendTransaction", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "ExtendTransaction" }, ExtendTransactionRequest, ExtendTransactionResponse, Schema.Union(ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("TransactionCanceledException", TransactionCanceledException), ErrorAnnotation("TransactionCommitInProgressException", TransactionCommitInProgressException), ErrorAnnotation("TransactionCommittedException", TransactionCommittedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetQueryStatisticsResponse = Schema.Struct({ExecutionStatistics: Schema.optional(ExecutionStatistics), PlanningStatistics: Schema.optional(PlanningStatistics), QuerySubmissionTime: Schema.optional(Schema.Date)})
const GetResourceLFTagsResponse = Schema.Struct({LFTagOnDatabase: Schema.optional(LFTagsList), LFTagsOnTable: Schema.optional(LFTagsList), LFTagsOnColumns: Schema.optional(ColumnLFTagsList)})
const GetTemporaryGluePartitionCredentialsResponse = Schema.Struct({AccessKeyId: Schema.optional(Schema.String), SecretAccessKey: Schema.optional(Schema.String), SessionToken: Schema.optional(Schema.String), Expiration: Schema.optional(Schema.Date)})
const GetTemporaryGlueTableCredentialsRequest = Schema.Struct({TableArn: Schema.String, Permissions: Schema.optional(PermissionList), DurationSeconds: Schema.optional(Schema.Number), AuditContext: Schema.optional(AuditContext), SupportedPermissionTypes: Schema.optional(PermissionTypeList), S3Path: Schema.optional(Schema.String), QuerySessionContext: Schema.optional(QuerySessionContext)})
const ExpiredException = Schema.Struct({Message: Schema.optional(Schema.String)})
const GetWorkUnitsResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), QueryId: Schema.String, WorkUnitRanges: WorkUnitRangeList})
const ListDataCellsFilterResponse = Schema.Struct({DataCellsFilters: Schema.optional(DataCellsFilterList), NextToken: Schema.optional(Schema.String)})
export const ListDataCellsFilter = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/ListDataCellsFilter", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "ListDataCellsFilter" }, ListDataCellsFilterRequest, ListDataCellsFilterResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListLakeFormationOptInsResponse = Schema.Struct({LakeFormationOptInsInfoList: Schema.optional(LakeFormationOptInsInfoList), NextToken: Schema.optional(Schema.String)})
export const ListLakeFormationOptIns = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/ListLakeFormationOptIns", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "ListLakeFormationOptIns" }, ListLakeFormationOptInsRequest, ListLakeFormationOptInsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListLFTagExpressionsResponse = Schema.Struct({LFTagExpressions: Schema.optional(LFTagExpressionsList), NextToken: Schema.optional(Schema.String)})
export const ListLFTagExpressions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/ListLFTagExpressions", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "ListLFTagExpressions" }, ListLFTagExpressionsRequest, ListLFTagExpressionsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListResourcesResponse = Schema.Struct({ResourceInfoList: Schema.optional(ResourceInfoList), NextToken: Schema.optional(Schema.String)})
export const ListResources = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/ListResources", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "ListResources" }, ListResourcesRequest, ListResourcesResponse, Schema.Union(ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListTableStorageOptimizersResponse = Schema.Struct({StorageOptimizerList: Schema.optional(StorageOptimizerList), NextToken: Schema.optional(Schema.String)})
export const ListTableStorageOptimizers = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/ListTableStorageOptimizers", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "ListTableStorageOptimizers" }, ListTableStorageOptimizersRequest, ListTableStorageOptimizersResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutDataLakeSettingsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DataLakeSettings: DataLakeSettings})
const PutDataLakeSettingsResponse = Schema.Struct({})
export const PutDataLakeSettings = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/PutDataLakeSettings", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "PutDataLakeSettings" }, PutDataLakeSettingsRequest, PutDataLakeSettingsResponse, Schema.Union(ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const RemoveLFTagsFromResourceResponse = Schema.Struct({Failures: Schema.optional(LFTagErrors)})
export const RemoveLFTagsFromResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/RemoveLFTagsFromResource", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "RemoveLFTagsFromResource" }, RemoveLFTagsFromResourceRequest, RemoveLFTagsFromResourceResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("GlueEncryptionException", GlueEncryptionException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const SearchDatabasesByLFTagsResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), DatabaseList: Schema.optional(DatabaseLFTagsList)})
export const SearchDatabasesByLFTags = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/SearchDatabasesByLFTags", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "SearchDatabasesByLFTags" }, SearchDatabasesByLFTagsRequest, SearchDatabasesByLFTagsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("GlueEncryptionException", GlueEncryptionException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const SearchTablesByLFTagsResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), TableList: Schema.optional(TableLFTagsList)})
export const SearchTablesByLFTags = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/SearchTablesByLFTags", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "SearchTablesByLFTags" }, SearchTablesByLFTagsRequest, SearchTablesByLFTagsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("GlueEncryptionException", GlueEncryptionException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const StartQueryPlanningRequest = Schema.Struct({QueryPlanningContext: QueryPlanningContext, QueryString: Schema.String})
const UpdateTableObjectsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, TransactionId: Schema.optional(Schema.String), WriteOperations: WriteOperationList})
const UpdateTableObjectsResponse = Schema.Struct({})
export const UpdateTableObjects = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/UpdateTableObjects", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "UpdateTableObjects" }, UpdateTableObjectsRequest, UpdateTableObjectsResponse, Schema.Union(ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("ResourceNotReadyException", ResourceNotReadyException), ErrorAnnotation("TransactionCanceledException", TransactionCanceledException), ErrorAnnotation("TransactionCommitInProgressException", TransactionCommitInProgressException), ErrorAnnotation("TransactionCommittedException", TransactionCommittedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateTableStorageOptimizerRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, StorageOptimizerConfig: StorageOptimizerConfigMap})
const ErrorDetail = Schema.Struct({ErrorCode: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String)})
const DetailsMap = Schema.Struct({ResourceShare: Schema.optional(ResourceShareList)})
const TableObject = Schema.Struct({Uri: Schema.optional(Schema.String), ETag: Schema.optional(Schema.String), Size: Schema.optional(Schema.Number)})
const TableObjectList = Schema.Array(TableObject)
const BatchPermissionsFailureEntry = Schema.Struct({RequestEntry: Schema.optional(BatchPermissionsRequestEntry), Error: Schema.optional(ErrorDetail)})
const BatchPermissionsFailureList = Schema.Array(BatchPermissionsFailureEntry)
const PrincipalResourcePermissions = Schema.Struct({Principal: Schema.optional(DataLakePrincipal), Resource: Schema.optional(Resource), Condition: Schema.optional(Condition), Permissions: Schema.optional(PermissionList), PermissionsWithGrantOption: Schema.optional(PermissionList), AdditionalDetails: Schema.optional(DetailsMap), LastUpdated: Schema.optional(Schema.Date), LastUpdatedBy: Schema.optional(Schema.String)})
const PrincipalResourcePermissionsList = Schema.Array(PrincipalResourcePermissions)
const PartitionObjects = Schema.Struct({PartitionValues: Schema.optional(PartitionValuesList), Objects: Schema.optional(TableObjectList)})
const PartitionedTableObjectsList = Schema.Array(PartitionObjects)
const PathStringList = Schema.Array(Schema.String)
const AddLFTagsToResourceResponse = Schema.Struct({Failures: Schema.optional(LFTagErrors)})
export const AddLFTagsToResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/AddLFTagsToResource", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "AddLFTagsToResource" }, AddLFTagsToResourceRequest, AddLFTagsToResourceResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const BatchRevokePermissionsResponse = Schema.Struct({Failures: Schema.optional(BatchPermissionsFailureList)})
export const BatchRevokePermissions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/BatchRevokePermissions", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "BatchRevokePermissions" }, BatchRevokePermissionsRequest, BatchRevokePermissionsResponse, Schema.Union(ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetEffectivePermissionsForPathResponse = Schema.Struct({Permissions: Schema.optional(PrincipalResourcePermissionsList), NextToken: Schema.optional(Schema.String)})
export const GetEffectivePermissionsForPath = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetEffectivePermissionsForPath", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetEffectivePermissionsForPath" }, GetEffectivePermissionsForPathRequest, GetEffectivePermissionsForPathResponse, Schema.Union(ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const StatisticsNotReadyYetException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const GetQueryStatistics = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetQueryStatistics", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetQueryStatistics" }, GetQueryStatisticsRequest, GetQueryStatisticsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ExpiredException", ExpiredException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("StatisticsNotReadyYetException", StatisticsNotReadyYetException), ErrorAnnotation("ThrottledException", ThrottledException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GlueEncryptionException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const GetResourceLFTags = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetResourceLFTags", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetResourceLFTags" }, GetResourceLFTagsRequest, GetResourceLFTagsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("GlueEncryptionException", GlueEncryptionException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetTableObjectsResponse = Schema.Struct({Objects: Schema.optional(PartitionedTableObjectsList), NextToken: Schema.optional(Schema.String)})
export const GetTableObjects = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetTableObjects", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetTableObjects" }, GetTableObjectsRequest, GetTableObjectsResponse, Schema.Union(ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("ResourceNotReadyException", ResourceNotReadyException), ErrorAnnotation("TransactionCanceledException", TransactionCanceledException), ErrorAnnotation("TransactionCommittedException", TransactionCommittedException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PermissionTypeMismatchException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const GetTemporaryGluePartitionCredentials = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetTemporaryGluePartitionCredentials", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetTemporaryGluePartitionCredentials" }, GetTemporaryGluePartitionCredentialsRequest, GetTemporaryGluePartitionCredentialsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("PermissionTypeMismatchException", PermissionTypeMismatchException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetTemporaryGlueTableCredentialsResponse = Schema.Struct({AccessKeyId: Schema.optional(Schema.String), SecretAccessKey: Schema.optional(Schema.String), SessionToken: Schema.optional(Schema.String), Expiration: Schema.optional(Schema.Date), VendedS3Path: Schema.optional(PathStringList)})
export const GetTemporaryGlueTableCredentials = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetTemporaryGlueTableCredentials", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetTemporaryGlueTableCredentials" }, GetTemporaryGlueTableCredentialsRequest, GetTemporaryGlueTableCredentialsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("OperationTimeoutException", OperationTimeoutException), ErrorAnnotation("PermissionTypeMismatchException", PermissionTypeMismatchException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ThrottledException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const GetWorkUnitResults = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetWorkUnitResults", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetWorkUnitResults" }, GetWorkUnitResultsRequest, GetWorkUnitResultsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ExpiredException", ExpiredException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("ThrottledException", ThrottledException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const WorkUnitsNotReadyYetException = Schema.Struct({Message: Schema.optional(Schema.String)})
export const GetWorkUnits = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/GetWorkUnits", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "GetWorkUnits" }, GetWorkUnitsRequest, GetWorkUnitsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ExpiredException", ExpiredException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("WorkUnitsNotReadyYetException", WorkUnitsNotReadyYetException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const StartQueryPlanningResponse = Schema.Struct({QueryId: Schema.String})
export const StartQueryPlanning = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/StartQueryPlanning", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "StartQueryPlanning" }, StartQueryPlanningRequest, StartQueryPlanningResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException), ErrorAnnotation("ThrottledException", ThrottledException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateTableStorageOptimizerResponse = Schema.Struct({Result: Schema.optional(Schema.String)})
export const UpdateTableStorageOptimizer = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/UpdateTableStorageOptimizer", method: "POST", sdkId: "LakeFormation", sigV4ServiceName: "lakeformation", name: "UpdateTableStorageOptimizer" }, UpdateTableStorageOptimizerRequest, UpdateTableStorageOptimizerResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("EntityNotFoundException", EntityNotFoundException), ErrorAnnotation("InternalServiceException", InternalServiceException), ErrorAnnotation("InvalidInputException", InvalidInputException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
