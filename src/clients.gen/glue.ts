import { Schema} from "effect"
import { FormatAwsJSON11Request,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const DeleteGlueIdentityCenterConfigurationRequest = Schema.Struct({});
export const DeleteGlueIdentityCenterConfigurationResponse = Schema.Struct({});
export const GetGlueIdentityCenterConfigurationRequest = Schema.Struct({});
export const DeleteConnectionNameList = Schema.Array(Schema.String);
export const BatchDeleteTableNameList = Schema.Array(Schema.String);
export const BatchDeleteTableVersionList = Schema.Array(Schema.String);
export const BatchGetBlueprintNames = Schema.Array(Schema.String);
export const CrawlerNameList = Schema.Array(Schema.String);
export const CustomEntityTypeNames = Schema.Array(Schema.String);
export const DataQualityResultIds = Schema.Array(Schema.String);
export const DevEndpointNames = Schema.Array(Schema.String);
export const JobNameList = Schema.Array(Schema.String);
export const ValueStringList = Schema.Array(Schema.String);
export const PartitionValueList = Schema.Struct({Values: ValueStringList});
export const BatchGetPartitionValueList = Schema.Array(PartitionValueList);
export const TriggerNameList = Schema.Array(Schema.String);
export const WorkflowNames = Schema.Array(Schema.String);
export const BatchStopJobRunJobRunIdList = Schema.Array(Schema.String);
export const ColumnNameList = Schema.Array(Schema.String);
export const ClassifierNameList = Schema.Array(Schema.String);
export const ContextWords = Schema.Array(Schema.String);
export const StringList = Schema.Array(Schema.String);
export const PublicKeysList = Schema.Array(Schema.String);
export const IdentityCenterScopesList = Schema.Array(Schema.String);
export const KeyList = Schema.Array(Schema.String);
export const PartitionIndex = Schema.Struct({Keys: KeyList, IndexName: Schema.String});
export const PartitionIndexList = Schema.Array(PartitionIndex);
export const GetColumnNamesList = Schema.Array(Schema.String);
export const DatabaseAttributesList = Schema.Array(Schema.String);
export const SelectedFields = Schema.Array(Schema.String);
export const OrchestrationStringList = Schema.Array(Schema.String);
export const CatalogEntry = Schema.Struct({DatabaseName: Schema.String, TableName: Schema.String});
export const CatalogEntries = Schema.Array(CatalogEntry);
export const TableAttributesList = Schema.Array(Schema.String);
export const PermissionTypeList = Schema.Array(Schema.String);
export const PermissionList = Schema.Array(Schema.String);
export const MetadataKeyValuePair = Schema.Struct({MetadataKey: Schema.optional(Schema.String), MetadataValue: Schema.optional(Schema.String)});
export const MetadataList = Schema.Array(MetadataKeyValuePair);
export const NodeIdList = Schema.Array(Schema.String);
export const RulesetNames = Schema.Array(Schema.String);
export const TagKeysList = Schema.Array(Schema.String);
export const BoundedPartitionValueList = Schema.Array(Schema.String);
export const BatchDeleteConnectionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), ConnectionNameList: DeleteConnectionNameList});
export const BatchDeleteTableRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TablesToDelete: BatchDeleteTableNameList, TransactionId: Schema.optional(Schema.String)});
export const BatchDeleteTableVersionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, VersionIds: BatchDeleteTableVersionList});
export const BatchGetBlueprintsRequest = Schema.Struct({Names: BatchGetBlueprintNames, IncludeBlueprint: Schema.optional(Schema.Boolean), IncludeParameterSpec: Schema.optional(Schema.Boolean)});
export const BatchGetCrawlersRequest = Schema.Struct({CrawlerNames: CrawlerNameList});
export const BatchGetCustomEntityTypesRequest = Schema.Struct({Names: CustomEntityTypeNames});
export const BatchGetDataQualityResultRequest = Schema.Struct({ResultIds: DataQualityResultIds});
export const BatchGetDevEndpointsRequest = Schema.Struct({DevEndpointNames: DevEndpointNames});
export const BatchGetJobsRequest = Schema.Struct({JobNames: JobNameList});
export const BatchGetPartitionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, PartitionsToGet: BatchGetPartitionValueList});
export const BatchGetTriggersRequest = Schema.Struct({TriggerNames: TriggerNameList});
export const BatchGetWorkflowsRequest = Schema.Struct({Names: WorkflowNames, IncludeGraph: Schema.optional(Schema.Boolean)});
export const BatchStopJobRunRequest = Schema.Struct({JobName: Schema.String, JobRunIds: BatchStopJobRunJobRunIdList});
export const CancelDataQualityRuleRecommendationRunRequest = Schema.Struct({RunId: Schema.String});
export const CancelDataQualityRuleRecommendationRunResponse = Schema.Struct({});
export const CancelDataQualityRulesetEvaluationRunRequest = Schema.Struct({RunId: Schema.String});
export const CancelDataQualityRulesetEvaluationRunResponse = Schema.Struct({});
export const CancelMLTaskRunRequest = Schema.Struct({TransformId: Schema.String, TaskRunId: Schema.String});
export const CancelStatementRequest = Schema.Struct({SessionId: Schema.String, Id: Schema.Number, RequestOrigin: Schema.optional(Schema.String)});
export const CancelStatementResponse = Schema.Struct({});
export const CheckSchemaVersionValidityInput = Schema.Struct({DataFormat: Schema.String, SchemaDefinition: Schema.String});
export const TagsMap = Schema.Record({key: Schema.String, value: Schema.String});
export const CreateColumnStatisticsTaskSettingsRequest = Schema.Struct({DatabaseName: Schema.String, TableName: Schema.String, Role: Schema.String, Schedule: Schema.optional(Schema.String), ColumnNameList: Schema.optional(ColumnNameList), SampleSize: Schema.optional(Schema.Number), CatalogID: Schema.optional(Schema.String), SecurityConfiguration: Schema.optional(Schema.String), Tags: Schema.optional(TagsMap)});
export const CreateColumnStatisticsTaskSettingsResponse = Schema.Struct({});
export const CreateCustomEntityTypeRequest = Schema.Struct({Name: Schema.String, RegexString: Schema.String, ContextWords: Schema.optional(ContextWords), Tags: Schema.optional(TagsMap)});
export const CreateGlueIdentityCenterConfigurationRequest = Schema.Struct({InstanceArn: Schema.String, Scopes: Schema.optional(IdentityCenterScopesList), UserBackgroundSessionsEnabled: Schema.optional(Schema.Boolean)});
export const ParametersMap = Schema.Record({key: Schema.String, value: Schema.String});
export const Column = Schema.Struct({Name: Schema.String, Type: Schema.optional(Schema.String), Comment: Schema.optional(Schema.String), Parameters: Schema.optional(ParametersMap)});
export const ColumnList = Schema.Array(Column);
export const LocationStringList = Schema.Array(Schema.String);
export const SerDeInfo = Schema.Struct({Name: Schema.optional(Schema.String), SerializationLibrary: Schema.optional(Schema.String), Parameters: Schema.optional(ParametersMap)});
export const NameStringList = Schema.Array(Schema.String);
export const Order = Schema.Struct({Column: Schema.String, SortOrder: Schema.Number});
export const OrderList = Schema.Array(Order);
export const ColumnValueStringList = Schema.Array(Schema.String);
export const LocationMap = Schema.Record({key: Schema.String, value: Schema.String});
export const SkewedInfo = Schema.Struct({SkewedColumnNames: Schema.optional(NameStringList), SkewedColumnValues: Schema.optional(ColumnValueStringList), SkewedColumnValueLocationMaps: Schema.optional(LocationMap)});
export const SchemaId = Schema.Struct({SchemaArn: Schema.optional(Schema.String), SchemaName: Schema.optional(Schema.String), RegistryName: Schema.optional(Schema.String)});
export const SchemaReference = Schema.Struct({SchemaId: Schema.optional(SchemaId), SchemaVersionId: Schema.optional(Schema.String), SchemaVersionNumber: Schema.optional(Schema.Number)});
export const StorageDescriptor = Schema.Struct({Columns: Schema.optional(ColumnList), Location: Schema.optional(Schema.String), AdditionalLocations: Schema.optional(LocationStringList), InputFormat: Schema.optional(Schema.String), OutputFormat: Schema.optional(Schema.String), Compressed: Schema.optional(Schema.Boolean), NumberOfBuckets: Schema.optional(Schema.Number), SerdeInfo: Schema.optional(SerDeInfo), BucketColumns: Schema.optional(NameStringList), SortColumns: Schema.optional(OrderList), Parameters: Schema.optional(ParametersMap), SkewedInfo: Schema.optional(SkewedInfo), StoredAsSubDirectories: Schema.optional(Schema.Boolean), SchemaReference: Schema.optional(SchemaReference)});
export const PartitionInput = Schema.Struct({Values: Schema.optional(ValueStringList), LastAccessTime: Schema.optional(Schema.Date), StorageDescriptor: Schema.optional(StorageDescriptor), Parameters: Schema.optional(ParametersMap), LastAnalyzedTime: Schema.optional(Schema.Date)});
export const CreatePartitionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, PartitionInput: PartitionInput});
export const CreatePartitionResponse = Schema.Struct({});
export const CreateRegistryInput = Schema.Struct({RegistryName: Schema.String, Description: Schema.optional(Schema.String), Tags: Schema.optional(TagsMap)});
export const DeleteBlueprintRequest = Schema.Struct({Name: Schema.String});
export const DeleteCatalogRequest = Schema.Struct({CatalogId: Schema.String});
export const DeleteCatalogResponse = Schema.Struct({});
export const DeleteClassifierRequest = Schema.Struct({Name: Schema.String});
export const DeleteClassifierResponse = Schema.Struct({});
export const DeleteColumnStatisticsForPartitionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, PartitionValues: ValueStringList, ColumnName: Schema.String});
export const DeleteColumnStatisticsForPartitionResponse = Schema.Struct({});
export const DeleteColumnStatisticsForTableRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, ColumnName: Schema.String});
export const DeleteColumnStatisticsForTableResponse = Schema.Struct({});
export const DeleteColumnStatisticsTaskSettingsRequest = Schema.Struct({DatabaseName: Schema.String, TableName: Schema.String});
export const DeleteColumnStatisticsTaskSettingsResponse = Schema.Struct({});
export const DeleteConnectionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), ConnectionName: Schema.String});
export const DeleteConnectionResponse = Schema.Struct({});
export const DeleteCrawlerRequest = Schema.Struct({Name: Schema.String});
export const DeleteCrawlerResponse = Schema.Struct({});
export const DeleteCustomEntityTypeRequest = Schema.Struct({Name: Schema.String});
export const DeleteDatabaseRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Name: Schema.String});
export const DeleteDatabaseResponse = Schema.Struct({});
export const DeleteDataQualityRulesetRequest = Schema.Struct({Name: Schema.String});
export const DeleteDataQualityRulesetResponse = Schema.Struct({});
export const DeleteDevEndpointRequest = Schema.Struct({EndpointName: Schema.String});
export const DeleteDevEndpointResponse = Schema.Struct({});
export const AccessDeniedException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DeleteIntegrationRequest = Schema.Struct({IntegrationIdentifier: Schema.String});
export const DeleteIntegrationTablePropertiesRequest = Schema.Struct({ResourceArn: Schema.String, TableName: Schema.String});
export const DeleteIntegrationTablePropertiesResponse = Schema.Struct({});
export const DeleteJobRequest = Schema.Struct({JobName: Schema.String});
export const DeleteMLTransformRequest = Schema.Struct({TransformId: Schema.String});
export const DeletePartitionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, PartitionValues: ValueStringList});
export const DeletePartitionResponse = Schema.Struct({});
export const DeletePartitionIndexRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, IndexName: Schema.String});
export const DeletePartitionIndexResponse = Schema.Struct({});
export const RegistryId = Schema.Struct({RegistryName: Schema.optional(Schema.String), RegistryArn: Schema.optional(Schema.String)});
export const DeleteRegistryInput = Schema.Struct({RegistryId: RegistryId});
export const DeleteResourcePolicyRequest = Schema.Struct({PolicyHashCondition: Schema.optional(Schema.String), ResourceArn: Schema.optional(Schema.String)});
export const DeleteResourcePolicyResponse = Schema.Struct({});
export const DeleteSchemaVersionsInput = Schema.Struct({SchemaId: SchemaId, Versions: Schema.String});
export const DeleteSecurityConfigurationRequest = Schema.Struct({Name: Schema.String});
export const DeleteSecurityConfigurationResponse = Schema.Struct({});
export const DeleteSessionRequest = Schema.Struct({Id: Schema.String, RequestOrigin: Schema.optional(Schema.String)});
export const DeleteTableRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, Name: Schema.String, TransactionId: Schema.optional(Schema.String)});
export const DeleteTableResponse = Schema.Struct({});
export const DeleteTableOptimizerRequest = Schema.Struct({CatalogId: Schema.String, DatabaseName: Schema.String, TableName: Schema.String, Type: Schema.String});
export const DeleteTableOptimizerResponse = Schema.Struct({});
export const DeleteTableVersionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, VersionId: Schema.String});
export const DeleteTableVersionResponse = Schema.Struct({});
export const DeleteTriggerRequest = Schema.Struct({Name: Schema.String});
export const DeleteUsageProfileRequest = Schema.Struct({Name: Schema.String});
export const DeleteUsageProfileResponse = Schema.Struct({});
export const DeleteUserDefinedFunctionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, FunctionName: Schema.String});
export const DeleteUserDefinedFunctionResponse = Schema.Struct({});
export const DeleteWorkflowRequest = Schema.Struct({Name: Schema.String});
export const DescribeConnectionTypeRequest = Schema.Struct({ConnectionType: Schema.String});
export const DescribeEntityRequest = Schema.Struct({ConnectionName: Schema.String, CatalogId: Schema.optional(Schema.String), EntityName: Schema.String, NextToken: Schema.optional(Schema.String), DataStoreApiVersion: Schema.optional(Schema.String)});
export const DescribeInboundIntegrationsRequest = Schema.Struct({IntegrationArn: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxRecords: Schema.optional(Schema.Number), TargetArn: Schema.optional(Schema.String)});
export const GetBlueprintRequest = Schema.Struct({Name: Schema.String, IncludeBlueprint: Schema.optional(Schema.Boolean), IncludeParameterSpec: Schema.optional(Schema.Boolean)});
export const GetBlueprintRunRequest = Schema.Struct({BlueprintName: Schema.String, RunId: Schema.String});
export const GetBlueprintRunsRequest = Schema.Struct({BlueprintName: Schema.String, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const GetCatalogRequest = Schema.Struct({CatalogId: Schema.String});
export const GetCatalogImportStatusRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String)});
export const GetCatalogsRequest = Schema.Struct({ParentCatalogId: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), Recursive: Schema.optional(Schema.Boolean), IncludeRoot: Schema.optional(Schema.Boolean)});
export const GetClassifierRequest = Schema.Struct({Name: Schema.String});
export const GetClassifiersRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const GetColumnStatisticsForPartitionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, PartitionValues: ValueStringList, ColumnNames: GetColumnNamesList});
export const GetColumnStatisticsForTableRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, ColumnNames: GetColumnNamesList});
export const GetColumnStatisticsTaskRunRequest = Schema.Struct({ColumnStatisticsTaskRunId: Schema.String});
export const GetColumnStatisticsTaskRunsRequest = Schema.Struct({DatabaseName: Schema.String, TableName: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const GetColumnStatisticsTaskSettingsRequest = Schema.Struct({DatabaseName: Schema.String, TableName: Schema.String});
export const GetConnectionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Name: Schema.String, HidePassword: Schema.optional(Schema.Boolean), ApplyOverrideForComputeEnvironment: Schema.optional(Schema.String)});
export const GetCrawlerRequest = Schema.Struct({Name: Schema.String});
export const GetCrawlerMetricsRequest = Schema.Struct({CrawlerNameList: Schema.optional(CrawlerNameList), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const GetCrawlersRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const GetCustomEntityTypeRequest = Schema.Struct({Name: Schema.String});
export const GetDatabaseRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Name: Schema.String});
export const GetDatabasesRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), ResourceShareType: Schema.optional(Schema.String), AttributesToGet: Schema.optional(DatabaseAttributesList)});
export const GetDataCatalogEncryptionSettingsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String)});
export const GetDataflowGraphRequest = Schema.Struct({PythonScript: Schema.optional(Schema.String)});
export const GetDataQualityModelRequest = Schema.Struct({StatisticId: Schema.optional(Schema.String), ProfileId: Schema.String});
export const GetDataQualityModelResultRequest = Schema.Struct({StatisticId: Schema.String, ProfileId: Schema.String});
export const GetDataQualityResultRequest = Schema.Struct({ResultId: Schema.String});
export const GetDataQualityRuleRecommendationRunRequest = Schema.Struct({RunId: Schema.String});
export const GetDataQualityRulesetRequest = Schema.Struct({Name: Schema.String});
export const GetDataQualityRulesetEvaluationRunRequest = Schema.Struct({RunId: Schema.String});
export const GetDevEndpointRequest = Schema.Struct({EndpointName: Schema.String});
export const GetDevEndpointsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const GetGlueIdentityCenterConfigurationResponse = Schema.Struct({ApplicationArn: Schema.optional(Schema.String), InstanceArn: Schema.optional(Schema.String), Scopes: Schema.optional(OrchestrationStringList), UserBackgroundSessionsEnabled: Schema.optional(Schema.Boolean)});
export const GetIntegrationResourcePropertyRequest = Schema.Struct({ResourceArn: Schema.String});
export const GetIntegrationTablePropertiesRequest = Schema.Struct({ResourceArn: Schema.String, TableName: Schema.String});
export const GetJobRequest = Schema.Struct({JobName: Schema.String});
export const GetJobBookmarkRequest = Schema.Struct({JobName: Schema.String, RunId: Schema.optional(Schema.String)});
export const GetJobRunRequest = Schema.Struct({JobName: Schema.String, RunId: Schema.String, PredecessorsIncluded: Schema.optional(Schema.Boolean)});
export const GetJobRunsRequest = Schema.Struct({JobName: Schema.String, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const GetJobsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const GetMLTaskRunRequest = Schema.Struct({TransformId: Schema.String, TaskRunId: Schema.String});
export const GetMLTransformRequest = Schema.Struct({TransformId: Schema.String});
export const GetPartitionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, PartitionValues: ValueStringList});
export const GetPartitionIndexesRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, NextToken: Schema.optional(Schema.String)});
export const GetRegistryInput = Schema.Struct({RegistryId: RegistryId});
export const GetResourcePoliciesRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const GetResourcePolicyRequest = Schema.Struct({ResourceArn: Schema.optional(Schema.String)});
export const GetSchemaInput = Schema.Struct({SchemaId: SchemaId});
export const GetSchemaByDefinitionInput = Schema.Struct({SchemaId: SchemaId, SchemaDefinition: Schema.String});
export const SchemaVersionNumber = Schema.Struct({LatestVersion: Schema.optional(Schema.Boolean), VersionNumber: Schema.optional(Schema.Number)});
export const GetSchemaVersionsDiffInput = Schema.Struct({SchemaId: SchemaId, FirstSchemaVersionNumber: SchemaVersionNumber, SecondSchemaVersionNumber: SchemaVersionNumber, SchemaDiffType: Schema.String});
export const GetSecurityConfigurationRequest = Schema.Struct({Name: Schema.String});
export const GetSecurityConfigurationsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const GetSessionRequest = Schema.Struct({Id: Schema.String, RequestOrigin: Schema.optional(Schema.String)});
export const GetStatementRequest = Schema.Struct({SessionId: Schema.String, Id: Schema.Number, RequestOrigin: Schema.optional(Schema.String)});
export const GetTableOptimizerRequest = Schema.Struct({CatalogId: Schema.String, DatabaseName: Schema.String, TableName: Schema.String, Type: Schema.String});
export const AuditColumnNamesList = Schema.Array(Schema.String);
export const AuditContext = Schema.Struct({AdditionalAuditContext: Schema.optional(Schema.String), RequestedColumns: Schema.optional(AuditColumnNamesList), AllColumnsRequested: Schema.optional(Schema.Boolean)});
export const GetTablesRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, Expression: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), TransactionId: Schema.optional(Schema.String), QueryAsOfTime: Schema.optional(Schema.Date), AuditContext: Schema.optional(AuditContext), IncludeStatusDetails: Schema.optional(Schema.Boolean), AttributesToGet: Schema.optional(TableAttributesList)});
export const GetTableVersionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, VersionId: Schema.optional(Schema.String)});
export const GetTableVersionsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const GetTagsRequest = Schema.Struct({ResourceArn: Schema.String});
export const GetTriggerRequest = Schema.Struct({Name: Schema.String});
export const GetTriggersRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), DependentJobName: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const Segment = Schema.Struct({SegmentNumber: Schema.Number, TotalSegments: Schema.Number});
export const AdditionalContextMap = Schema.Record({key: Schema.String, value: Schema.String});
export const QuerySessionContext = Schema.Struct({QueryId: Schema.optional(Schema.String), QueryStartTime: Schema.optional(Schema.Date), ClusterId: Schema.optional(Schema.String), QueryAuthorizationId: Schema.optional(Schema.String), AdditionalContext: Schema.optional(AdditionalContextMap)});
export const GetUnfilteredPartitionsMetadataRequest = Schema.Struct({Region: Schema.optional(Schema.String), CatalogId: Schema.String, DatabaseName: Schema.String, TableName: Schema.String, Expression: Schema.optional(Schema.String), AuditContext: Schema.optional(AuditContext), SupportedPermissionTypes: PermissionTypeList, NextToken: Schema.optional(Schema.String), Segment: Schema.optional(Segment), MaxResults: Schema.optional(Schema.Number), QuerySessionContext: Schema.optional(QuerySessionContext)});
export const GetUsageProfileRequest = Schema.Struct({Name: Schema.String});
export const GetUserDefinedFunctionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, FunctionName: Schema.String});
export const GetUserDefinedFunctionsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.optional(Schema.String), Pattern: Schema.String, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const GetWorkflowRequest = Schema.Struct({Name: Schema.String, IncludeGraph: Schema.optional(Schema.Boolean)});
export const GetWorkflowRunRequest = Schema.Struct({Name: Schema.String, RunId: Schema.String, IncludeGraph: Schema.optional(Schema.Boolean)});
export const GetWorkflowRunPropertiesRequest = Schema.Struct({Name: Schema.String, RunId: Schema.String});
export const GetWorkflowRunsRequest = Schema.Struct({Name: Schema.String, IncludeGraph: Schema.optional(Schema.Boolean), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const ImportCatalogToGlueRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String)});
export const ImportCatalogToGlueResponse = Schema.Struct({});
export const ListBlueprintsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), Tags: Schema.optional(TagsMap)});
export const ListColumnStatisticsTaskRunsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListConnectionTypesRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListCrawlersRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String), Tags: Schema.optional(TagsMap)});
export const ListCustomEntityTypesRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), Tags: Schema.optional(TagsMap)});
export const TimestampFilter = Schema.Struct({RecordedBefore: Schema.optional(Schema.Date), RecordedAfter: Schema.optional(Schema.Date)});
export const ListDataQualityStatisticsRequest = Schema.Struct({StatisticId: Schema.optional(Schema.String), ProfileId: Schema.optional(Schema.String), TimestampFilter: Schema.optional(TimestampFilter), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListDevEndpointsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), Tags: Schema.optional(TagsMap)});
export const ListEntitiesRequest = Schema.Struct({ConnectionName: Schema.optional(Schema.String), CatalogId: Schema.optional(Schema.String), ParentEntityName: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String), DataStoreApiVersion: Schema.optional(Schema.String)});
export const ListJobsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), Tags: Schema.optional(TagsMap)});
export const SchemaColumn = Schema.Struct({Name: Schema.optional(Schema.String), DataType: Schema.optional(Schema.String)});
export const TransformSchema = Schema.Array(SchemaColumn);
export const TransformFilterCriteria = Schema.Struct({Name: Schema.optional(Schema.String), TransformType: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), GlueVersion: Schema.optional(Schema.String), CreatedBefore: Schema.optional(Schema.Date), CreatedAfter: Schema.optional(Schema.Date), LastModifiedBefore: Schema.optional(Schema.Date), LastModifiedAfter: Schema.optional(Schema.Date), Schema: Schema.optional(TransformSchema)});
export const TransformSortCriteria = Schema.Struct({Column: Schema.String, SortDirection: Schema.String});
export const ListMLTransformsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), Filter: Schema.optional(TransformFilterCriteria), Sort: Schema.optional(TransformSortCriteria), Tags: Schema.optional(TagsMap)});
export const ListRegistriesInput = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListSchemasInput = Schema.Struct({RegistryId: Schema.optional(RegistryId), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListSchemaVersionsInput = Schema.Struct({SchemaId: SchemaId, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListSessionsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), Tags: Schema.optional(TagsMap), RequestOrigin: Schema.optional(Schema.String)});
export const ListStatementsRequest = Schema.Struct({SessionId: Schema.String, RequestOrigin: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String)});
export const ListTableOptimizerRunsRequest = Schema.Struct({CatalogId: Schema.String, DatabaseName: Schema.String, TableName: Schema.String, Type: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListTriggersRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), DependentJobName: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), Tags: Schema.optional(TagsMap)});
export const ListUsageProfilesRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const ListWorkflowsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const IntegrationSourcePropertiesMap = Schema.Record({key: Schema.String, value: Schema.String});
export const IntegrationConfig = Schema.Struct({RefreshInterval: Schema.optional(Schema.String), SourceProperties: Schema.optional(IntegrationSourcePropertiesMap), ContinuousSync: Schema.optional(Schema.Boolean)});
export const ModifyIntegrationRequest = Schema.Struct({IntegrationIdentifier: Schema.String, Description: Schema.optional(Schema.String), DataFilter: Schema.optional(Schema.String), IntegrationConfig: Schema.optional(IntegrationConfig), IntegrationName: Schema.optional(Schema.String)});
export const PutDataQualityProfileAnnotationRequest = Schema.Struct({ProfileId: Schema.String, InclusionAnnotation: Schema.String});
export const PutDataQualityProfileAnnotationResponse = Schema.Struct({});
export const PutResourcePolicyRequest = Schema.Struct({PolicyInJson: Schema.String, ResourceArn: Schema.optional(Schema.String), PolicyHashCondition: Schema.optional(Schema.String), PolicyExistsCondition: Schema.optional(Schema.String), EnableHybrid: Schema.optional(Schema.String)});
export const WorkflowRunProperties = Schema.Record({key: Schema.String, value: Schema.String});
export const PutWorkflowRunPropertiesRequest = Schema.Struct({Name: Schema.String, RunId: Schema.String, RunProperties: WorkflowRunProperties});
export const PutWorkflowRunPropertiesResponse = Schema.Struct({});
export const QuerySchemaVersionMetadataInput = Schema.Struct({SchemaId: Schema.optional(SchemaId), SchemaVersionNumber: Schema.optional(SchemaVersionNumber), SchemaVersionId: Schema.optional(Schema.String), MetadataList: Schema.optional(MetadataList), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const RegisterSchemaVersionInput = Schema.Struct({SchemaId: SchemaId, SchemaDefinition: Schema.String});
export const RemoveSchemaVersionMetadataInput = Schema.Struct({SchemaId: Schema.optional(SchemaId), SchemaVersionNumber: Schema.optional(SchemaVersionNumber), SchemaVersionId: Schema.optional(Schema.String), MetadataKeyValue: MetadataKeyValuePair});
export const ResetJobBookmarkRequest = Schema.Struct({JobName: Schema.String, RunId: Schema.optional(Schema.String)});
export const ResumeWorkflowRunRequest = Schema.Struct({Name: Schema.String, RunId: Schema.String, NodeIds: NodeIdList});
export const RunStatementRequest = Schema.Struct({SessionId: Schema.String, Code: Schema.String, RequestOrigin: Schema.optional(Schema.String)});
export const StartBlueprintRunRequest = Schema.Struct({BlueprintName: Schema.String, Parameters: Schema.optional(Schema.String), RoleArn: Schema.String});
export const StartColumnStatisticsTaskRunRequest = Schema.Struct({DatabaseName: Schema.String, TableName: Schema.String, ColumnNameList: Schema.optional(ColumnNameList), Role: Schema.String, SampleSize: Schema.optional(Schema.Number), CatalogID: Schema.optional(Schema.String), SecurityConfiguration: Schema.optional(Schema.String)});
export const StartColumnStatisticsTaskRunScheduleRequest = Schema.Struct({DatabaseName: Schema.String, TableName: Schema.String});
export const StartColumnStatisticsTaskRunScheduleResponse = Schema.Struct({});
export const StartCrawlerRequest = Schema.Struct({Name: Schema.String});
export const StartCrawlerResponse = Schema.Struct({});
export const StartCrawlerScheduleRequest = Schema.Struct({CrawlerName: Schema.String});
export const StartCrawlerScheduleResponse = Schema.Struct({});
export const StartExportLabelsTaskRunRequest = Schema.Struct({TransformId: Schema.String, OutputS3Path: Schema.String});
export const StartImportLabelsTaskRunRequest = Schema.Struct({TransformId: Schema.String, InputS3Path: Schema.String, ReplaceAllLabels: Schema.optional(Schema.Boolean)});
export const GenericMap = Schema.Record({key: Schema.String, value: Schema.String});
export const NotificationProperty = Schema.Struct({NotifyDelayAfter: Schema.optional(Schema.Number)});
export const StartJobRunRequest = Schema.Struct({JobName: Schema.String, JobRunQueuingEnabled: Schema.optional(Schema.Boolean), JobRunId: Schema.optional(Schema.String), Arguments: Schema.optional(GenericMap), AllocatedCapacity: Schema.optional(Schema.Number), Timeout: Schema.optional(Schema.Number), MaxCapacity: Schema.optional(Schema.Number), SecurityConfiguration: Schema.optional(Schema.String), NotificationProperty: Schema.optional(NotificationProperty), WorkerType: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), ExecutionClass: Schema.optional(Schema.String), ExecutionRoleSessionPolicy: Schema.optional(Schema.String)});
export const StartMLEvaluationTaskRunRequest = Schema.Struct({TransformId: Schema.String});
export const StartMLLabelingSetGenerationTaskRunRequest = Schema.Struct({TransformId: Schema.String, OutputS3Path: Schema.String});
export const StartTriggerRequest = Schema.Struct({Name: Schema.String});
export const StartWorkflowRunRequest = Schema.Struct({Name: Schema.String, RunProperties: Schema.optional(WorkflowRunProperties)});
export const StopColumnStatisticsTaskRunRequest = Schema.Struct({DatabaseName: Schema.String, TableName: Schema.String});
export const StopColumnStatisticsTaskRunResponse = Schema.Struct({});
export const StopColumnStatisticsTaskRunScheduleRequest = Schema.Struct({DatabaseName: Schema.String, TableName: Schema.String});
export const StopColumnStatisticsTaskRunScheduleResponse = Schema.Struct({});
export const StopCrawlerRequest = Schema.Struct({Name: Schema.String});
export const StopCrawlerResponse = Schema.Struct({});
export const StopCrawlerScheduleRequest = Schema.Struct({CrawlerName: Schema.String});
export const StopCrawlerScheduleResponse = Schema.Struct({});
export const StopSessionRequest = Schema.Struct({Id: Schema.String, RequestOrigin: Schema.optional(Schema.String)});
export const StopTriggerRequest = Schema.Struct({Name: Schema.String});
export const StopWorkflowRunRequest = Schema.Struct({Name: Schema.String, RunId: Schema.String});
export const StopWorkflowRunResponse = Schema.Struct({});
export const TagResourceRequest = Schema.Struct({ResourceArn: Schema.String, TagsToAdd: TagsMap});
export const TagResourceResponse = Schema.Struct({});
export const UntagResourceRequest = Schema.Struct({ResourceArn: Schema.String, TagsToRemove: TagKeysList});
export const UntagResourceResponse = Schema.Struct({});
export const UpdateBlueprintRequest = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), BlueprintLocation: Schema.String});
export const FederatedCatalog = Schema.Struct({Identifier: Schema.optional(Schema.String), ConnectionName: Schema.optional(Schema.String), ConnectionType: Schema.optional(Schema.String)});
export const TargetRedshiftCatalog = Schema.Struct({CatalogArn: Schema.String});
export const DataLakeAccessProperties = Schema.Struct({DataLakeAccess: Schema.optional(Schema.Boolean), DataTransferRole: Schema.optional(Schema.String), KmsKey: Schema.optional(Schema.String), CatalogType: Schema.optional(Schema.String)});
export const IcebergOptimizationProperties = Schema.Struct({RoleArn: Schema.optional(Schema.String), Compaction: Schema.optional(ParametersMap), Retention: Schema.optional(ParametersMap), OrphanFileDeletion: Schema.optional(ParametersMap)});
export const CatalogProperties = Schema.Struct({DataLakeAccessProperties: Schema.optional(DataLakeAccessProperties), IcebergOptimizationProperties: Schema.optional(IcebergOptimizationProperties), CustomProperties: Schema.optional(ParametersMap)});
export const DataLakePrincipal = Schema.Struct({DataLakePrincipalIdentifier: Schema.optional(Schema.String)});
export const PrincipalPermissions = Schema.Struct({Principal: Schema.optional(DataLakePrincipal), Permissions: Schema.optional(PermissionList)});
export const PrincipalPermissionsList = Schema.Array(PrincipalPermissions);
export const CatalogInput = Schema.Struct({Description: Schema.optional(Schema.String), FederatedCatalog: Schema.optional(FederatedCatalog), Parameters: Schema.optional(ParametersMap), TargetRedshiftCatalog: Schema.optional(TargetRedshiftCatalog), CatalogProperties: Schema.optional(CatalogProperties), CreateTableDefaultPermissions: Schema.optional(PrincipalPermissionsList), CreateDatabaseDefaultPermissions: Schema.optional(PrincipalPermissionsList), AllowFullTableExternalDataAccess: Schema.optional(Schema.String)});
export const UpdateCatalogRequest = Schema.Struct({CatalogId: Schema.String, CatalogInput: CatalogInput});
export const UpdateCatalogResponse = Schema.Struct({});
export const BooleanColumnStatisticsData = Schema.Struct({NumberOfTrues: Schema.Number, NumberOfFalses: Schema.Number, NumberOfNulls: Schema.Number});
export const DateColumnStatisticsData = Schema.Struct({MinimumValue: Schema.optional(Schema.Date), MaximumValue: Schema.optional(Schema.Date), NumberOfNulls: Schema.Number, NumberOfDistinctValues: Schema.Number});
export const DecimalNumber = Schema.Struct({UnscaledValue: StreamBody(), Scale: Schema.Number});
export const DecimalColumnStatisticsData = Schema.Struct({MinimumValue: Schema.optional(DecimalNumber), MaximumValue: Schema.optional(DecimalNumber), NumberOfNulls: Schema.Number, NumberOfDistinctValues: Schema.Number});
export const DoubleColumnStatisticsData = Schema.Struct({MinimumValue: Schema.optional(Schema.Number), MaximumValue: Schema.optional(Schema.Number), NumberOfNulls: Schema.Number, NumberOfDistinctValues: Schema.Number});
export const LongColumnStatisticsData = Schema.Struct({MinimumValue: Schema.optional(Schema.Number), MaximumValue: Schema.optional(Schema.Number), NumberOfNulls: Schema.Number, NumberOfDistinctValues: Schema.Number});
export const StringColumnStatisticsData = Schema.Struct({MaximumLength: Schema.Number, AverageLength: Schema.Number, NumberOfNulls: Schema.Number, NumberOfDistinctValues: Schema.Number});
export const BinaryColumnStatisticsData = Schema.Struct({MaximumLength: Schema.Number, AverageLength: Schema.Number, NumberOfNulls: Schema.Number});
export const ColumnStatisticsData = Schema.Struct({Type: Schema.String, BooleanColumnStatisticsData: Schema.optional(BooleanColumnStatisticsData), DateColumnStatisticsData: Schema.optional(DateColumnStatisticsData), DecimalColumnStatisticsData: Schema.optional(DecimalColumnStatisticsData), DoubleColumnStatisticsData: Schema.optional(DoubleColumnStatisticsData), LongColumnStatisticsData: Schema.optional(LongColumnStatisticsData), StringColumnStatisticsData: Schema.optional(StringColumnStatisticsData), BinaryColumnStatisticsData: Schema.optional(BinaryColumnStatisticsData)});
export const ColumnStatistics = Schema.Struct({ColumnName: Schema.String, ColumnType: Schema.String, AnalyzedTime: Schema.Date, StatisticsData: ColumnStatisticsData});
export const UpdateColumnStatisticsList = Schema.Array(ColumnStatistics);
export const UpdateColumnStatisticsForTableRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, ColumnStatisticsList: UpdateColumnStatisticsList});
export const UpdateColumnStatisticsTaskSettingsRequest = Schema.Struct({DatabaseName: Schema.String, TableName: Schema.String, Role: Schema.optional(Schema.String), Schedule: Schema.optional(Schema.String), ColumnNameList: Schema.optional(ColumnNameList), SampleSize: Schema.optional(Schema.Number), CatalogID: Schema.optional(Schema.String), SecurityConfiguration: Schema.optional(Schema.String)});
export const UpdateColumnStatisticsTaskSettingsResponse = Schema.Struct({});
export const MatchCriteria = Schema.Array(Schema.String);
export const ConnectionProperties = Schema.Record({key: Schema.String, value: Schema.String});
export const PropertyMap = Schema.Record({key: Schema.String, value: Schema.String});
export const SecurityGroupIdList = Schema.Array(Schema.String);
export const PhysicalConnectionRequirements = Schema.Struct({SubnetId: Schema.optional(Schema.String), SecurityGroupIdList: Schema.optional(SecurityGroupIdList), AvailabilityZone: Schema.optional(Schema.String)});
export const OAuth2ClientApplication = Schema.Struct({UserManagedClientApplicationClientId: Schema.optional(Schema.String), AWSManagedClientApplicationReference: Schema.optional(Schema.String)});
export const TokenUrlParametersMap = Schema.Record({key: Schema.String, value: Schema.String});
export const AuthorizationCodeProperties = Schema.Struct({AuthorizationCode: Schema.optional(Schema.String), RedirectUri: Schema.optional(Schema.String)});
export const OAuth2Credentials = Schema.Struct({UserManagedClientApplicationClientSecret: Schema.optional(Schema.String), AccessToken: Schema.optional(Schema.String), RefreshToken: Schema.optional(Schema.String), JwtToken: Schema.optional(Schema.String)});
export const OAuth2PropertiesInput = Schema.Struct({OAuth2GrantType: Schema.optional(Schema.String), OAuth2ClientApplication: Schema.optional(OAuth2ClientApplication), TokenUrl: Schema.optional(Schema.String), TokenUrlParametersMap: Schema.optional(TokenUrlParametersMap), AuthorizationCodeProperties: Schema.optional(AuthorizationCodeProperties), OAuth2Credentials: Schema.optional(OAuth2Credentials)});
export const BasicAuthenticationCredentials = Schema.Struct({Username: Schema.optional(Schema.String), Password: Schema.optional(Schema.String)});
export const CredentialMap = Schema.Record({key: Schema.String, value: Schema.String});
export const AuthenticationConfigurationInput = Schema.Struct({AuthenticationType: Schema.optional(Schema.String), OAuth2Properties: Schema.optional(OAuth2PropertiesInput), SecretArn: Schema.optional(Schema.String), KmsKeyArn: Schema.optional(Schema.String), BasicAuthenticationCredentials: Schema.optional(BasicAuthenticationCredentials), CustomAuthenticationCredentials: Schema.optional(CredentialMap)});
export const ComputeEnvironmentList = Schema.Array(Schema.String);
export const ConnectionInput = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), ConnectionType: Schema.String, MatchCriteria: Schema.optional(MatchCriteria), ConnectionProperties: ConnectionProperties, SparkProperties: Schema.optional(PropertyMap), AthenaProperties: Schema.optional(PropertyMap), PythonProperties: Schema.optional(PropertyMap), PhysicalConnectionRequirements: Schema.optional(PhysicalConnectionRequirements), AuthenticationConfiguration: Schema.optional(AuthenticationConfigurationInput), ValidateCredentials: Schema.optional(Schema.Boolean), ValidateForComputeEnvironments: Schema.optional(ComputeEnvironmentList)});
export const UpdateConnectionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Name: Schema.String, ConnectionInput: ConnectionInput});
export const UpdateConnectionResponse = Schema.Struct({});
export const PathList = Schema.Array(Schema.String);
export const S3Target = Schema.Struct({Path: Schema.optional(Schema.String), Exclusions: Schema.optional(PathList), ConnectionName: Schema.optional(Schema.String), SampleSize: Schema.optional(Schema.Number), EventQueueArn: Schema.optional(Schema.String), DlqEventQueueArn: Schema.optional(Schema.String)});
export const S3TargetList = Schema.Array(S3Target);
export const EnableAdditionalMetadata = Schema.Array(Schema.String);
export const JdbcTarget = Schema.Struct({ConnectionName: Schema.optional(Schema.String), Path: Schema.optional(Schema.String), Exclusions: Schema.optional(PathList), EnableAdditionalMetadata: Schema.optional(EnableAdditionalMetadata)});
export const JdbcTargetList = Schema.Array(JdbcTarget);
export const MongoDBTarget = Schema.Struct({ConnectionName: Schema.optional(Schema.String), Path: Schema.optional(Schema.String), ScanAll: Schema.optional(Schema.Boolean)});
export const MongoDBTargetList = Schema.Array(MongoDBTarget);
export const DynamoDBTarget = Schema.Struct({Path: Schema.optional(Schema.String), scanAll: Schema.optional(Schema.Boolean), scanRate: Schema.optional(Schema.Number)});
export const DynamoDBTargetList = Schema.Array(DynamoDBTarget);
export const CatalogTablesList = Schema.Array(Schema.String);
export const CatalogTarget = Schema.Struct({DatabaseName: Schema.String, Tables: CatalogTablesList, ConnectionName: Schema.optional(Schema.String), EventQueueArn: Schema.optional(Schema.String), DlqEventQueueArn: Schema.optional(Schema.String)});
export const CatalogTargetList = Schema.Array(CatalogTarget);
export const DeltaTarget = Schema.Struct({DeltaTables: Schema.optional(PathList), ConnectionName: Schema.optional(Schema.String), WriteManifest: Schema.optional(Schema.Boolean), CreateNativeDeltaTable: Schema.optional(Schema.Boolean)});
export const DeltaTargetList = Schema.Array(DeltaTarget);
export const IcebergTarget = Schema.Struct({Paths: Schema.optional(PathList), ConnectionName: Schema.optional(Schema.String), Exclusions: Schema.optional(PathList), MaximumTraversalDepth: Schema.optional(Schema.Number)});
export const IcebergTargetList = Schema.Array(IcebergTarget);
export const HudiTarget = Schema.Struct({Paths: Schema.optional(PathList), ConnectionName: Schema.optional(Schema.String), Exclusions: Schema.optional(PathList), MaximumTraversalDepth: Schema.optional(Schema.Number)});
export const HudiTargetList = Schema.Array(HudiTarget);
export const CrawlerTargets = Schema.Struct({S3Targets: Schema.optional(S3TargetList), JdbcTargets: Schema.optional(JdbcTargetList), MongoDBTargets: Schema.optional(MongoDBTargetList), DynamoDBTargets: Schema.optional(DynamoDBTargetList), CatalogTargets: Schema.optional(CatalogTargetList), DeltaTargets: Schema.optional(DeltaTargetList), IcebergTargets: Schema.optional(IcebergTargetList), HudiTargets: Schema.optional(HudiTargetList)});
export const SchemaChangePolicy = Schema.Struct({UpdateBehavior: Schema.optional(Schema.String), DeleteBehavior: Schema.optional(Schema.String)});
export const RecrawlPolicy = Schema.Struct({RecrawlBehavior: Schema.optional(Schema.String)});
export const LineageConfiguration = Schema.Struct({CrawlerLineageSettings: Schema.optional(Schema.String)});
export const LakeFormationConfiguration = Schema.Struct({UseLakeFormationCredentials: Schema.optional(Schema.Boolean), AccountId: Schema.optional(Schema.String)});
export const UpdateCrawlerRequest = Schema.Struct({Name: Schema.String, Role: Schema.optional(Schema.String), DatabaseName: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Targets: Schema.optional(CrawlerTargets), Schedule: Schema.optional(Schema.String), Classifiers: Schema.optional(ClassifierNameList), TablePrefix: Schema.optional(Schema.String), SchemaChangePolicy: Schema.optional(SchemaChangePolicy), RecrawlPolicy: Schema.optional(RecrawlPolicy), LineageConfiguration: Schema.optional(LineageConfiguration), LakeFormationConfiguration: Schema.optional(LakeFormationConfiguration), Configuration: Schema.optional(Schema.String), CrawlerSecurityConfiguration: Schema.optional(Schema.String)});
export const UpdateCrawlerResponse = Schema.Struct({});
export const UpdateCrawlerScheduleRequest = Schema.Struct({CrawlerName: Schema.String, Schedule: Schema.optional(Schema.String)});
export const UpdateCrawlerScheduleResponse = Schema.Struct({});
export const DatabaseIdentifier = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.optional(Schema.String), Region: Schema.optional(Schema.String)});
export const FederatedDatabase = Schema.Struct({Identifier: Schema.optional(Schema.String), ConnectionName: Schema.optional(Schema.String), ConnectionType: Schema.optional(Schema.String)});
export const DatabaseInput = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), LocationUri: Schema.optional(Schema.String), Parameters: Schema.optional(ParametersMap), CreateTableDefaultPermissions: Schema.optional(PrincipalPermissionsList), TargetDatabase: Schema.optional(DatabaseIdentifier), FederatedDatabase: Schema.optional(FederatedDatabase)});
export const UpdateDatabaseRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Name: Schema.String, DatabaseInput: DatabaseInput});
export const UpdateDatabaseResponse = Schema.Struct({});
export const UpdateDataQualityRulesetRequest = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), Ruleset: Schema.optional(Schema.String)});
export const UpdateGlueIdentityCenterConfigurationRequest = Schema.Struct({Scopes: Schema.optional(IdentityCenterScopesList), UserBackgroundSessionsEnabled: Schema.optional(Schema.Boolean)});
export const UpdateGlueIdentityCenterConfigurationResponse = Schema.Struct({});
export const SourceProcessingProperties = Schema.Struct({RoleArn: Schema.optional(Schema.String)});
export const TargetProcessingProperties = Schema.Struct({RoleArn: Schema.optional(Schema.String), KmsArn: Schema.optional(Schema.String), ConnectionName: Schema.optional(Schema.String), EventBusArn: Schema.optional(Schema.String)});
export const UpdateIntegrationResourcePropertyRequest = Schema.Struct({ResourceArn: Schema.String, SourceProcessingProperties: Schema.optional(SourceProcessingProperties), TargetProcessingProperties: Schema.optional(TargetProcessingProperties)});
export const SourceTableFieldsList = Schema.Array(Schema.String);
export const PrimaryKeyList = Schema.Array(Schema.String);
export const SourceTableConfig = Schema.Struct({Fields: Schema.optional(SourceTableFieldsList), FilterPredicate: Schema.optional(Schema.String), PrimaryKey: Schema.optional(PrimaryKeyList), RecordUpdateField: Schema.optional(Schema.String)});
export const IntegrationPartition = Schema.Struct({FieldName: Schema.optional(Schema.String), FunctionSpec: Schema.optional(Schema.String), ConversionSpec: Schema.optional(Schema.String)});
export const IntegrationPartitionSpecList = Schema.Array(IntegrationPartition);
export const TargetTableConfig = Schema.Struct({UnnestSpec: Schema.optional(Schema.String), PartitionSpec: Schema.optional(IntegrationPartitionSpecList), TargetTableName: Schema.optional(Schema.String)});
export const UpdateIntegrationTablePropertiesRequest = Schema.Struct({ResourceArn: Schema.String, TableName: Schema.String, SourceTableConfig: Schema.optional(SourceTableConfig), TargetTableConfig: Schema.optional(TargetTableConfig)});
export const UpdateIntegrationTablePropertiesResponse = Schema.Struct({});
export const UpdateJobFromSourceControlRequest = Schema.Struct({JobName: Schema.optional(Schema.String), Provider: Schema.optional(Schema.String), RepositoryName: Schema.optional(Schema.String), RepositoryOwner: Schema.optional(Schema.String), BranchName: Schema.optional(Schema.String), Folder: Schema.optional(Schema.String), CommitId: Schema.optional(Schema.String), AuthStrategy: Schema.optional(Schema.String), AuthToken: Schema.optional(Schema.String)});
export const FindMatchesParameters = Schema.Struct({PrimaryKeyColumnName: Schema.optional(Schema.String), PrecisionRecallTradeoff: Schema.optional(Schema.Number), AccuracyCostTradeoff: Schema.optional(Schema.Number), EnforceProvidedLabels: Schema.optional(Schema.Boolean)});
export const TransformParameters = Schema.Struct({TransformType: Schema.String, FindMatchesParameters: Schema.optional(FindMatchesParameters)});
export const UpdateMLTransformRequest = Schema.Struct({TransformId: Schema.String, Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Parameters: Schema.optional(TransformParameters), Role: Schema.optional(Schema.String), GlueVersion: Schema.optional(Schema.String), MaxCapacity: Schema.optional(Schema.Number), WorkerType: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), Timeout: Schema.optional(Schema.Number), MaxRetries: Schema.optional(Schema.Number)});
export const UpdatePartitionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, PartitionValueList: BoundedPartitionValueList, PartitionInput: PartitionInput});
export const UpdatePartitionResponse = Schema.Struct({});
export const UpdateRegistryInput = Schema.Struct({RegistryId: RegistryId, Description: Schema.String});
export const UpdateSchemaInput = Schema.Struct({SchemaId: SchemaId, SchemaVersionNumber: Schema.optional(SchemaVersionNumber), Compatibility: Schema.optional(Schema.String), Description: Schema.optional(Schema.String)});
export const UpdateSourceControlFromJobRequest = Schema.Struct({JobName: Schema.optional(Schema.String), Provider: Schema.optional(Schema.String), RepositoryName: Schema.optional(Schema.String), RepositoryOwner: Schema.optional(Schema.String), BranchName: Schema.optional(Schema.String), Folder: Schema.optional(Schema.String), CommitId: Schema.optional(Schema.String), AuthStrategy: Schema.optional(Schema.String), AuthToken: Schema.optional(Schema.String)});
export const TableOptimizerVpcConfiguration = Schema.Union(Schema.String);
export const IcebergCompactionConfiguration = Schema.Struct({strategy: Schema.optional(Schema.String), minInputFiles: Schema.optional(Schema.Number), deleteFileThreshold: Schema.optional(Schema.Number)});
export const CompactionConfiguration = Schema.Struct({icebergConfiguration: Schema.optional(IcebergCompactionConfiguration)});
export const IcebergRetentionConfiguration = Schema.Struct({snapshotRetentionPeriodInDays: Schema.optional(Schema.Number), numberOfSnapshotsToRetain: Schema.optional(Schema.Number), cleanExpiredFiles: Schema.optional(Schema.Boolean), runRateInHours: Schema.optional(Schema.Number)});
export const RetentionConfiguration = Schema.Struct({icebergConfiguration: Schema.optional(IcebergRetentionConfiguration)});
export const IcebergOrphanFileDeletionConfiguration = Schema.Struct({orphanFileRetentionPeriodInDays: Schema.optional(Schema.Number), location: Schema.optional(Schema.String), runRateInHours: Schema.optional(Schema.Number)});
export const OrphanFileDeletionConfiguration = Schema.Struct({icebergConfiguration: Schema.optional(IcebergOrphanFileDeletionConfiguration)});
export const TableOptimizerConfiguration = Schema.Struct({roleArn: Schema.optional(Schema.String), enabled: Schema.optional(Schema.Boolean), vpcConfiguration: Schema.optional(TableOptimizerVpcConfiguration), compactionConfiguration: Schema.optional(CompactionConfiguration), retentionConfiguration: Schema.optional(RetentionConfiguration), orphanFileDeletionConfiguration: Schema.optional(OrphanFileDeletionConfiguration)});
export const UpdateTableOptimizerRequest = Schema.Struct({CatalogId: Schema.String, DatabaseName: Schema.String, TableName: Schema.String, Type: Schema.String, TableOptimizerConfiguration: TableOptimizerConfiguration});
export const UpdateTableOptimizerResponse = Schema.Struct({});
export const AllowedValuesStringList = Schema.Array(Schema.String);
export const ConfigurationObject = Schema.Struct({DefaultValue: Schema.optional(Schema.String), AllowedValues: Schema.optional(AllowedValuesStringList), MinValue: Schema.optional(Schema.String), MaxValue: Schema.optional(Schema.String)});
export const ConfigurationMap = Schema.Record({key: Schema.String, value: ConfigurationObject});
export const ProfileConfiguration = Schema.Struct({SessionConfiguration: Schema.optional(ConfigurationMap), JobConfiguration: Schema.optional(ConfigurationMap)});
export const UpdateUsageProfileRequest = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), Configuration: ProfileConfiguration});
export const ResourceUri = Schema.Struct({ResourceType: Schema.optional(Schema.String), Uri: Schema.optional(Schema.String)});
export const ResourceUriList = Schema.Array(ResourceUri);
export const UserDefinedFunctionInput = Schema.Struct({FunctionName: Schema.optional(Schema.String), ClassName: Schema.optional(Schema.String), OwnerName: Schema.optional(Schema.String), OwnerType: Schema.optional(Schema.String), ResourceUris: Schema.optional(ResourceUriList)});
export const UpdateUserDefinedFunctionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, FunctionName: Schema.String, FunctionInput: UserDefinedFunctionInput});
export const UpdateUserDefinedFunctionResponse = Schema.Struct({});
export const UpdateWorkflowRequest = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), DefaultRunProperties: Schema.optional(WorkflowRunProperties), MaxConcurrentRuns: Schema.optional(Schema.Number)});
export const CsvHeader = Schema.Array(Schema.String);
export const CustomDatatypes = Schema.Array(Schema.String);
export const ConnectionStringList = Schema.Array(Schema.String);
export const IntegrationFilterValues = Schema.Array(Schema.String);
export const BatchDeletePartitionValueList = Schema.Array(PartitionValueList);
export const BlueprintNames = Schema.Array(Schema.String);
export const BatchGetTableOptimizerEntry = Schema.Struct({catalogId: Schema.optional(Schema.String), databaseName: Schema.optional(Schema.String), tableName: Schema.optional(Schema.String), type: Schema.optional(Schema.String)});
export const BatchGetTableOptimizerEntries = Schema.Array(BatchGetTableOptimizerEntry);
export const DatapointInclusionAnnotation = Schema.Struct({ProfileId: Schema.optional(Schema.String), StatisticId: Schema.optional(Schema.String), InclusionAnnotation: Schema.optional(Schema.String)});
export const InclusionAnnotationList = Schema.Array(DatapointInclusionAnnotation);
export const BatchUpdatePartitionRequestEntry = Schema.Struct({PartitionValueList: BoundedPartitionValueList, PartitionInput: PartitionInput});
export const BatchUpdatePartitionRequestEntryList = Schema.Array(BatchUpdatePartitionRequestEntry);
export const CreateGrokClassifierRequest = Schema.Struct({Classification: Schema.String, Name: Schema.String, GrokPattern: Schema.String, CustomPatterns: Schema.optional(Schema.String)});
export const CreateXMLClassifierRequest = Schema.Struct({Classification: Schema.String, Name: Schema.String, RowTag: Schema.optional(Schema.String)});
export const CreateJsonClassifierRequest = Schema.Struct({Name: Schema.String, JsonPath: Schema.String});
export const CreateCsvClassifierRequest = Schema.Struct({Name: Schema.String, Delimiter: Schema.optional(Schema.String), QuoteSymbol: Schema.optional(Schema.String), ContainsHeader: Schema.optional(Schema.String), Header: Schema.optional(CsvHeader), DisableValueTrimming: Schema.optional(Schema.Boolean), AllowSingleColumn: Schema.optional(Schema.Boolean), CustomDatatypeConfigured: Schema.optional(Schema.Boolean), CustomDatatypes: Schema.optional(CustomDatatypes), Serde: Schema.optional(Schema.String)});
export const DataQualityTargetTable = Schema.Struct({TableName: Schema.String, DatabaseName: Schema.String, CatalogId: Schema.optional(Schema.String)});
export const MapValue = Schema.Record({key: Schema.String, value: Schema.String});
export const IntegrationAdditionalEncryptionContextMap = Schema.Record({key: Schema.String, value: Schema.String});
export const Tag = Schema.Struct({key: Schema.optional(Schema.String), value: Schema.optional(Schema.String)});
export const IntegrationTagsList = Schema.Array(Tag);
export const ExecutionProperty = Schema.Struct({MaxConcurrentRuns: Schema.optional(Schema.Number)});
export const JobCommand = Schema.Struct({Name: Schema.optional(Schema.String), ScriptLocation: Schema.optional(Schema.String), PythonVersion: Schema.optional(Schema.String), Runtime: Schema.optional(Schema.String)});
export const ConnectionsList = Schema.Struct({Connections: Schema.optional(ConnectionStringList)});
export const SourceControlDetails = Schema.Struct({Provider: Schema.optional(Schema.String), Repository: Schema.optional(Schema.String), Owner: Schema.optional(Schema.String), Branch: Schema.optional(Schema.String), Folder: Schema.optional(Schema.String), LastCommitId: Schema.optional(Schema.String), AuthStrategy: Schema.optional(Schema.String), AuthToken: Schema.optional(Schema.String)});
export const CodeGenEdge = Schema.Struct({Source: Schema.String, Target: Schema.String, TargetParameter: Schema.optional(Schema.String)});
export const DagEdges = Schema.Array(CodeGenEdge);
export const SessionCommand = Schema.Struct({Name: Schema.optional(Schema.String), PythonVersion: Schema.optional(Schema.String)});
export const OrchestrationArgumentsMap = Schema.Record({key: Schema.String, value: Schema.String});
export const Action = Schema.Struct({JobName: Schema.optional(Schema.String), Arguments: Schema.optional(GenericMap), Timeout: Schema.optional(Schema.Number), SecurityConfiguration: Schema.optional(Schema.String), NotificationProperty: Schema.optional(NotificationProperty), CrawlerName: Schema.optional(Schema.String)});
export const ActionList = Schema.Array(Action);
export const EventBatchingCondition = Schema.Struct({BatchSize: Schema.Number, BatchWindow: Schema.optional(Schema.Number)});
export const IntegrationFilter = Schema.Struct({Name: Schema.optional(Schema.String), Values: Schema.optional(IntegrationFilterValues)});
export const IntegrationFilterList = Schema.Array(IntegrationFilter);
export const BlueprintRun = Schema.Struct({BlueprintName: Schema.optional(Schema.String), RunId: Schema.optional(Schema.String), WorkflowName: Schema.optional(Schema.String), State: Schema.optional(Schema.String), StartedOn: Schema.optional(Schema.Date), CompletedOn: Schema.optional(Schema.Date), ErrorMessage: Schema.optional(Schema.String), RollbackErrorMessage: Schema.optional(Schema.String), Parameters: Schema.optional(Schema.String), RoleArn: Schema.optional(Schema.String)});
export const BlueprintRuns = Schema.Array(BlueprintRun);
export const DataLakeAccessPropertiesOutput = Schema.Struct({DataLakeAccess: Schema.optional(Schema.Boolean), DataTransferRole: Schema.optional(Schema.String), KmsKey: Schema.optional(Schema.String), ManagedWorkgroupName: Schema.optional(Schema.String), ManagedWorkgroupStatus: Schema.optional(Schema.String), RedshiftDatabaseName: Schema.optional(Schema.String), StatusMessage: Schema.optional(Schema.String), CatalogType: Schema.optional(Schema.String)});
export const IcebergOptimizationPropertiesOutput = Schema.Struct({RoleArn: Schema.optional(Schema.String), Compaction: Schema.optional(ParametersMap), Retention: Schema.optional(ParametersMap), OrphanFileDeletion: Schema.optional(ParametersMap), LastUpdatedTime: Schema.optional(Schema.Date)});
export const CatalogPropertiesOutput = Schema.Struct({DataLakeAccessProperties: Schema.optional(DataLakeAccessPropertiesOutput), IcebergOptimizationProperties: Schema.optional(IcebergOptimizationPropertiesOutput), CustomProperties: Schema.optional(ParametersMap)});
export const Catalog = Schema.Struct({CatalogId: Schema.optional(Schema.String), Name: Schema.String, ResourceArn: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Parameters: Schema.optional(ParametersMap), CreateTime: Schema.optional(Schema.Date), UpdateTime: Schema.optional(Schema.Date), TargetRedshiftCatalog: Schema.optional(TargetRedshiftCatalog), FederatedCatalog: Schema.optional(FederatedCatalog), CatalogProperties: Schema.optional(CatalogPropertiesOutput), CreateTableDefaultPermissions: Schema.optional(PrincipalPermissionsList), CreateDatabaseDefaultPermissions: Schema.optional(PrincipalPermissionsList), AllowFullTableExternalDataAccess: Schema.optional(Schema.String)});
export const CatalogList = Schema.Array(Catalog);
export const GrokClassifier = Schema.Struct({Name: Schema.String, Classification: Schema.String, CreationTime: Schema.optional(Schema.Date), LastUpdated: Schema.optional(Schema.Date), Version: Schema.optional(Schema.Number), GrokPattern: Schema.String, CustomPatterns: Schema.optional(Schema.String)});
export const XMLClassifier = Schema.Struct({Name: Schema.String, Classification: Schema.String, CreationTime: Schema.optional(Schema.Date), LastUpdated: Schema.optional(Schema.Date), Version: Schema.optional(Schema.Number), RowTag: Schema.optional(Schema.String)});
export const JsonClassifier = Schema.Struct({Name: Schema.String, CreationTime: Schema.optional(Schema.Date), LastUpdated: Schema.optional(Schema.Date), Version: Schema.optional(Schema.Number), JsonPath: Schema.String});
export const CsvClassifier = Schema.Struct({Name: Schema.String, CreationTime: Schema.optional(Schema.Date), LastUpdated: Schema.optional(Schema.Date), Version: Schema.optional(Schema.Number), Delimiter: Schema.optional(Schema.String), QuoteSymbol: Schema.optional(Schema.String), ContainsHeader: Schema.optional(Schema.String), Header: Schema.optional(CsvHeader), DisableValueTrimming: Schema.optional(Schema.Boolean), AllowSingleColumn: Schema.optional(Schema.Boolean), CustomDatatypeConfigured: Schema.optional(Schema.Boolean), CustomDatatypes: Schema.optional(CustomDatatypes), Serde: Schema.optional(Schema.String)});
export const Classifier = Schema.Struct({GrokClassifier: Schema.optional(GrokClassifier), XMLClassifier: Schema.optional(XMLClassifier), JsonClassifier: Schema.optional(JsonClassifier), CsvClassifier: Schema.optional(CsvClassifier)});
export const ClassifierList = Schema.Array(Classifier);
export const ColumnStatisticsList = Schema.Array(ColumnStatistics);
export const ColumnStatisticsTaskRun = Schema.Struct({CustomerId: Schema.optional(Schema.String), ColumnStatisticsTaskRunId: Schema.optional(Schema.String), DatabaseName: Schema.optional(Schema.String), TableName: Schema.optional(Schema.String), ColumnNameList: Schema.optional(ColumnNameList), CatalogID: Schema.optional(Schema.String), Role: Schema.optional(Schema.String), SampleSize: Schema.optional(Schema.Number), SecurityConfiguration: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), WorkerType: Schema.optional(Schema.String), ComputationType: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), LastUpdated: Schema.optional(Schema.Date), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), ErrorMessage: Schema.optional(Schema.String), DPUSeconds: Schema.optional(Schema.Number)});
export const ColumnStatisticsTaskRunsList = Schema.Array(ColumnStatisticsTaskRun);
export const GetConnectionsFilter = Schema.Struct({MatchCriteria: Schema.optional(MatchCriteria), ConnectionType: Schema.optional(Schema.String), ConnectionSchemaVersion: Schema.optional(Schema.Number)});
export const Database = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), LocationUri: Schema.optional(Schema.String), Parameters: Schema.optional(ParametersMap), CreateTime: Schema.optional(Schema.Date), CreateTableDefaultPermissions: Schema.optional(PrincipalPermissionsList), TargetDatabase: Schema.optional(DatabaseIdentifier), CatalogId: Schema.optional(Schema.String), FederatedDatabase: Schema.optional(FederatedDatabase)});
export const DatabaseList = Schema.Array(Database);
export const DataQualityResultIdList = Schema.Array(Schema.String);
export const ConnectionOptions = Schema.Record({key: Schema.String, value: Schema.String});
export const Predecessor = Schema.Struct({JobName: Schema.optional(Schema.String), RunId: Schema.optional(Schema.String)});
export const PredecessorList = Schema.Array(Predecessor);
export const JobRun = Schema.Struct({Id: Schema.optional(Schema.String), Attempt: Schema.optional(Schema.Number), PreviousRunId: Schema.optional(Schema.String), TriggerName: Schema.optional(Schema.String), JobName: Schema.optional(Schema.String), JobMode: Schema.optional(Schema.String), JobRunQueuingEnabled: Schema.optional(Schema.Boolean), StartedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date), CompletedOn: Schema.optional(Schema.Date), JobRunState: Schema.optional(Schema.String), Arguments: Schema.optional(GenericMap), ErrorMessage: Schema.optional(Schema.String), PredecessorRuns: Schema.optional(PredecessorList), AllocatedCapacity: Schema.optional(Schema.Number), ExecutionTime: Schema.optional(Schema.Number), Timeout: Schema.optional(Schema.Number), MaxCapacity: Schema.optional(Schema.Number), WorkerType: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), SecurityConfiguration: Schema.optional(Schema.String), LogGroupName: Schema.optional(Schema.String), NotificationProperty: Schema.optional(NotificationProperty), GlueVersion: Schema.optional(Schema.String), DPUSeconds: Schema.optional(Schema.Number), ExecutionClass: Schema.optional(Schema.String), MaintenanceWindow: Schema.optional(Schema.String), ProfileName: Schema.optional(Schema.String), StateDetail: Schema.optional(Schema.String), ExecutionRoleSessionPolicy: Schema.optional(Schema.String)});
export const JobRunList = Schema.Array(JobRun);
export const CodeGenNodeArg = Schema.Struct({Name: Schema.String, Value: Schema.String, Param: Schema.optional(Schema.Boolean)});
export const CodeGenNodeArgs = Schema.Array(CodeGenNodeArg);
export const Location = Schema.Struct({Jdbc: Schema.optional(CodeGenNodeArgs), S3: Schema.optional(CodeGenNodeArgs), DynamoDB: Schema.optional(CodeGenNodeArgs)});
export const TaskRunFilterCriteria = Schema.Struct({TaskRunType: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), StartedBefore: Schema.optional(Schema.Date), StartedAfter: Schema.optional(Schema.Date)});
export const TaskRunSortCriteria = Schema.Struct({Column: Schema.String, SortDirection: Schema.String});
export const MappingEntry = Schema.Struct({SourceTable: Schema.optional(Schema.String), SourcePath: Schema.optional(Schema.String), SourceType: Schema.optional(Schema.String), TargetTable: Schema.optional(Schema.String), TargetPath: Schema.optional(Schema.String), TargetType: Schema.optional(Schema.String)});
export const MappingList = Schema.Array(MappingEntry);
export const AdditionalPlanOptionsMap = Schema.Record({key: Schema.String, value: Schema.String});
export const S3Encryption = Schema.Struct({S3EncryptionMode: Schema.optional(Schema.String), KmsKeyArn: Schema.optional(Schema.String)});
export const S3EncryptionList = Schema.Array(S3Encryption);
export const CloudWatchEncryption = Schema.Struct({CloudWatchEncryptionMode: Schema.optional(Schema.String), KmsKeyArn: Schema.optional(Schema.String)});
export const JobBookmarksEncryption = Schema.Struct({JobBookmarksEncryptionMode: Schema.optional(Schema.String), KmsKeyArn: Schema.optional(Schema.String)});
export const DataQualityEncryption = Schema.Struct({DataQualityEncryptionMode: Schema.optional(Schema.String), KmsKeyArn: Schema.optional(Schema.String)});
export const EncryptionConfiguration = Schema.Struct({S3Encryption: Schema.optional(S3EncryptionList), CloudWatchEncryption: Schema.optional(CloudWatchEncryption), JobBookmarksEncryption: Schema.optional(JobBookmarksEncryption), DataQualityEncryption: Schema.optional(DataQualityEncryption)});
export const SecurityConfiguration = Schema.Struct({Name: Schema.optional(Schema.String), CreatedTimeStamp: Schema.optional(Schema.Date), EncryptionConfiguration: Schema.optional(EncryptionConfiguration)});
export const SecurityConfigurationList = Schema.Array(SecurityConfiguration);
export const TableIdentifier = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), Region: Schema.optional(Schema.String)});
export const FederatedTable = Schema.Struct({Identifier: Schema.optional(Schema.String), DatabaseIdentifier: Schema.optional(Schema.String), ConnectionName: Schema.optional(Schema.String), ConnectionType: Schema.optional(Schema.String)});
export const ViewSubObjectsList = Schema.Array(Schema.String);
export const ViewRepresentation = Schema.Struct({Dialect: Schema.optional(Schema.String), DialectVersion: Schema.optional(Schema.String), ViewOriginalText: Schema.optional(Schema.String), ViewExpandedText: Schema.optional(Schema.String), ValidationConnection: Schema.optional(Schema.String), IsStale: Schema.optional(Schema.Boolean)});
export const ViewRepresentationList = Schema.Array(ViewRepresentation);
export const ViewDefinition = Schema.Struct({IsProtected: Schema.optional(Schema.Boolean), Definer: Schema.optional(Schema.String), SubObjects: Schema.optional(ViewSubObjectsList), Representations: Schema.optional(ViewRepresentationList)});
export const ErrorDetail = Schema.Struct({ErrorCode: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String)});
export const ViewValidation = Schema.Struct({Dialect: Schema.optional(Schema.String), DialectVersion: Schema.optional(Schema.String), ViewValidationText: Schema.optional(Schema.String), UpdateTime: Schema.optional(Schema.Date), State: Schema.optional(Schema.String), Error: Schema.optional(ErrorDetail)});
export const ViewValidationList = Schema.Array(ViewValidation);
export const StatusDetails = Schema.Struct({RequestedChange: Schema.optional(Table), ViewValidations: Schema.optional(ViewValidationList)});
export const TableStatus = Schema.Struct({RequestedBy: Schema.optional(Schema.String), UpdatedBy: Schema.optional(Schema.String), RequestTime: Schema.optional(Schema.Date), UpdateTime: Schema.optional(Schema.Date), Action: Schema.optional(Schema.String), State: Schema.optional(Schema.String), Error: Schema.optional(ErrorDetail), Details: Schema.optional(StatusDetails)});
export const Table = Schema.Struct({Name: Schema.String, DatabaseName: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Owner: Schema.optional(Schema.String), CreateTime: Schema.optional(Schema.Date), UpdateTime: Schema.optional(Schema.Date), LastAccessTime: Schema.optional(Schema.Date), LastAnalyzedTime: Schema.optional(Schema.Date), Retention: Schema.optional(Schema.Number), StorageDescriptor: Schema.optional(StorageDescriptor), PartitionKeys: Schema.optional(ColumnList), ViewOriginalText: Schema.optional(Schema.String), ViewExpandedText: Schema.optional(Schema.String), TableType: Schema.optional(Schema.String), Parameters: Schema.optional(ParametersMap), CreatedBy: Schema.optional(Schema.String), IsRegisteredWithLakeFormation: Schema.optional(Schema.Boolean), TargetTable: Schema.optional(TableIdentifier), CatalogId: Schema.optional(Schema.String), VersionId: Schema.optional(Schema.String), FederatedTable: Schema.optional(FederatedTable), ViewDefinition: Schema.optional(ViewDefinition), IsMultiDialectView: Schema.optional(Schema.Boolean), Status: Schema.optional(TableStatus)});
export const TableVersion = Schema.Struct({Table: Schema.optional(Table), VersionId: Schema.optional(Schema.String)});
export const GetTableVersionsList = Schema.Array(TableVersion);
export const SupportedDialect = Schema.Struct({Dialect: Schema.optional(Schema.String), DialectVersion: Schema.optional(Schema.String)});
export const UserDefinedFunction = Schema.Struct({FunctionName: Schema.optional(Schema.String), DatabaseName: Schema.optional(Schema.String), ClassName: Schema.optional(Schema.String), OwnerName: Schema.optional(Schema.String), OwnerType: Schema.optional(Schema.String), CreateTime: Schema.optional(Schema.Date), ResourceUris: Schema.optional(ResourceUriList), CatalogId: Schema.optional(Schema.String)});
export const UserDefinedFunctionList = Schema.Array(UserDefinedFunction);
export const WorkflowRunStatistics = Schema.Struct({TotalActions: Schema.optional(Schema.Number), TimeoutActions: Schema.optional(Schema.Number), FailedActions: Schema.optional(Schema.Number), StoppedActions: Schema.optional(Schema.Number), SucceededActions: Schema.optional(Schema.Number), RunningActions: Schema.optional(Schema.Number), ErroredActions: Schema.optional(Schema.Number), WaitingActions: Schema.optional(Schema.Number)});
export const Condition = Schema.Struct({LogicalOperator: Schema.optional(Schema.String), JobName: Schema.optional(Schema.String), State: Schema.optional(Schema.String), CrawlerName: Schema.optional(Schema.String), CrawlState: Schema.optional(Schema.String)});
export const ConditionList = Schema.Array(Condition);
export const Predicate = Schema.Struct({Logical: Schema.optional(Schema.String), Conditions: Schema.optional(ConditionList)});
export const Trigger = Schema.Struct({Name: Schema.optional(Schema.String), WorkflowName: Schema.optional(Schema.String), Id: Schema.optional(Schema.String), Type: Schema.optional(Schema.String), State: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Schedule: Schema.optional(Schema.String), Actions: Schema.optional(ActionList), Predicate: Schema.optional(Predicate), EventBatchingCondition: Schema.optional(EventBatchingCondition)});
export const TriggerNodeDetails = Schema.Struct({Trigger: Schema.optional(Trigger)});
export const JobNodeDetails = Schema.Struct({JobRuns: Schema.optional(JobRunList)});
export const Crawl = Schema.Struct({State: Schema.optional(Schema.String), StartedOn: Schema.optional(Schema.Date), CompletedOn: Schema.optional(Schema.Date), ErrorMessage: Schema.optional(Schema.String), LogGroup: Schema.optional(Schema.String), LogStream: Schema.optional(Schema.String)});
export const CrawlList = Schema.Array(Crawl);
export const CrawlerNodeDetails = Schema.Struct({Crawls: Schema.optional(CrawlList)});
export const Node = Schema.Struct({Type: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), UniqueId: Schema.optional(Schema.String), TriggerDetails: Schema.optional(TriggerNodeDetails), JobDetails: Schema.optional(JobNodeDetails), CrawlerDetails: Schema.optional(CrawlerNodeDetails)});
export const NodeList = Schema.Array(Node);
export const Edge = Schema.Struct({SourceId: Schema.optional(Schema.String), DestinationId: Schema.optional(Schema.String)});
export const EdgeList = Schema.Array(Edge);
export const WorkflowGraph = Schema.Struct({Nodes: Schema.optional(NodeList), Edges: Schema.optional(EdgeList)});
export const StartingEventBatchCondition = Schema.Struct({BatchSize: Schema.optional(Schema.Number), BatchWindow: Schema.optional(Schema.Number)});
export const WorkflowRun = Schema.Struct({Name: Schema.optional(Schema.String), WorkflowRunId: Schema.optional(Schema.String), PreviousRunId: Schema.optional(Schema.String), WorkflowRunProperties: Schema.optional(WorkflowRunProperties), StartedOn: Schema.optional(Schema.Date), CompletedOn: Schema.optional(Schema.Date), Status: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String), Statistics: Schema.optional(WorkflowRunStatistics), Graph: Schema.optional(WorkflowGraph), StartingEventBatchCondition: Schema.optional(StartingEventBatchCondition)});
export const WorkflowRuns = Schema.Array(WorkflowRun);
export const ColumnStatisticsTaskRunIdList = Schema.Array(Schema.String);
export const CrawlsFilter = Schema.Struct({FieldName: Schema.optional(Schema.String), FilterOperator: Schema.optional(Schema.String), FieldValue: Schema.optional(Schema.String)});
export const CrawlsFilterList = Schema.Array(CrawlsFilter);
export const GlueTableAdditionalOptions = Schema.Record({key: Schema.String, value: Schema.String});
export const GlueTable = Schema.Struct({DatabaseName: Schema.String, TableName: Schema.String, CatalogId: Schema.optional(Schema.String), ConnectionName: Schema.optional(Schema.String), AdditionalOptions: Schema.optional(GlueTableAdditionalOptions)});
export const DataQualityGlueTable = Schema.Struct({DatabaseName: Schema.String, TableName: Schema.String, CatalogId: Schema.optional(Schema.String), ConnectionName: Schema.optional(Schema.String), AdditionalOptions: Schema.optional(GlueTableAdditionalOptions), PreProcessingQuery: Schema.optional(Schema.String)});
export const DataSource = Schema.Struct({GlueTable: Schema.optional(GlueTable), DataQualityGlueTable: Schema.optional(DataQualityGlueTable)});
export const DataQualityResultFilterCriteria = Schema.Struct({DataSource: Schema.optional(DataSource), JobName: Schema.optional(Schema.String), JobRunId: Schema.optional(Schema.String), StartedAfter: Schema.optional(Schema.Date), StartedBefore: Schema.optional(Schema.Date)});
export const DataQualityRuleRecommendationRunFilter = Schema.Struct({DataSource: DataSource, StartedBefore: Schema.optional(Schema.Date), StartedAfter: Schema.optional(Schema.Date)});
export const DataQualityRulesetEvaluationRunFilter = Schema.Struct({DataSource: DataSource, StartedBefore: Schema.optional(Schema.Date), StartedAfter: Schema.optional(Schema.Date)});
export const DataQualityRulesetFilterCriteria = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), CreatedBefore: Schema.optional(Schema.Date), CreatedAfter: Schema.optional(Schema.Date), LastModifiedBefore: Schema.optional(Schema.Date), LastModifiedAfter: Schema.optional(Schema.Date), TargetTable: Schema.optional(DataQualityTargetTable)});
export const DevEndpointNameList = Schema.Array(Schema.String);
export const TransformIdList = Schema.Array(Schema.String);
export const SessionIdList = Schema.Array(Schema.String);
export const Session = Schema.Struct({Id: Schema.optional(Schema.String), CreatedOn: Schema.optional(Schema.Date), Status: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Role: Schema.optional(Schema.String), Command: Schema.optional(SessionCommand), DefaultArguments: Schema.optional(OrchestrationArgumentsMap), Connections: Schema.optional(ConnectionsList), Progress: Schema.optional(Schema.Number), MaxCapacity: Schema.optional(Schema.Number), SecurityConfiguration: Schema.optional(Schema.String), GlueVersion: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), WorkerType: Schema.optional(Schema.String), CompletedOn: Schema.optional(Schema.Date), ExecutionTime: Schema.optional(Schema.Number), DPUSeconds: Schema.optional(Schema.Number), IdleTimeout: Schema.optional(Schema.Number), ProfileName: Schema.optional(Schema.String)});
export const SessionList = Schema.Array(Session);
export const StatementOutputData = Schema.Struct({TextPlain: Schema.optional(Schema.String)});
export const StatementOutput = Schema.Struct({Data: Schema.optional(StatementOutputData), ExecutionCount: Schema.optional(Schema.Number), Status: Schema.optional(Schema.String), ErrorName: Schema.optional(Schema.String), ErrorValue: Schema.optional(Schema.String), Traceback: Schema.optional(OrchestrationStringList)});
export const Statement = Schema.Struct({Id: Schema.optional(Schema.Number), Code: Schema.optional(Schema.String), State: Schema.optional(Schema.String), Output: Schema.optional(StatementOutput), Progress: Schema.optional(Schema.Number), StartedOn: Schema.optional(Schema.Number), CompletedOn: Schema.optional(Schema.Number)});
export const StatementList = Schema.Array(Statement);
export const PropertyPredicate = Schema.Struct({Key: Schema.optional(Schema.String), Value: Schema.optional(Schema.String), Comparator: Schema.optional(Schema.String)});
export const SearchPropertyPredicates = Schema.Array(PropertyPredicate);
export const SortCriterion = Schema.Struct({FieldName: Schema.optional(Schema.String), Sort: Schema.optional(Schema.String)});
export const SortCriteria = Schema.Array(SortCriterion);
export const DataQualityEvaluationRunAdditionalRunOptions = Schema.Struct({CloudWatchMetricsEnabled: Schema.optional(Schema.Boolean), ResultsS3Prefix: Schema.optional(Schema.String), CompositeRuleEvaluationMethod: Schema.optional(Schema.String)});
export const DataSourceMap = Schema.Record({key: Schema.String, value: DataSource});
export const TestConnectionInput = Schema.Struct({ConnectionType: Schema.String, ConnectionProperties: ConnectionProperties, AuthenticationConfiguration: Schema.optional(AuthenticationConfigurationInput)});
export const UpdateGrokClassifierRequest = Schema.Struct({Name: Schema.String, Classification: Schema.optional(Schema.String), GrokPattern: Schema.optional(Schema.String), CustomPatterns: Schema.optional(Schema.String)});
export const UpdateXMLClassifierRequest = Schema.Struct({Name: Schema.String, Classification: Schema.optional(Schema.String), RowTag: Schema.optional(Schema.String)});
export const UpdateJsonClassifierRequest = Schema.Struct({Name: Schema.String, JsonPath: Schema.optional(Schema.String)});
export const UpdateCsvClassifierRequest = Schema.Struct({Name: Schema.String, Delimiter: Schema.optional(Schema.String), QuoteSymbol: Schema.optional(Schema.String), ContainsHeader: Schema.optional(Schema.String), Header: Schema.optional(CsvHeader), DisableValueTrimming: Schema.optional(Schema.Boolean), AllowSingleColumn: Schema.optional(Schema.Boolean), CustomDatatypeConfigured: Schema.optional(Schema.Boolean), CustomDatatypes: Schema.optional(CustomDatatypes), Serde: Schema.optional(Schema.String)});
export const DevEndpointCustomLibraries = Schema.Struct({ExtraPythonLibsS3Path: Schema.optional(Schema.String), ExtraJarsS3Path: Schema.optional(Schema.String)});
export const GlueStudioSchemaColumn = Schema.Struct({Name: Schema.String, Type: Schema.optional(Schema.String), GlueStudioType: Schema.optional(Schema.String)});
export const GlueStudioSchemaColumnList = Schema.Array(GlueStudioSchemaColumn);
export const GlueSchema = Schema.Struct({Columns: Schema.optional(GlueStudioSchemaColumnList)});
export const GlueSchemas = Schema.Array(GlueSchema);
export const AthenaConnectorSource = Schema.Struct({Name: Schema.String, ConnectionName: Schema.String, ConnectorName: Schema.String, ConnectionType: Schema.String, ConnectionTable: Schema.optional(Schema.String), SchemaName: Schema.String, OutputSchemas: Schema.optional(GlueSchemas)});
export const EnclosedInStringProperties = Schema.Array(Schema.String);
export const JDBCDataTypeMapping = Schema.Record({key: Schema.String, value: Schema.String});
export const JDBCConnectorOptions = Schema.Struct({FilterPredicate: Schema.optional(Schema.String), PartitionColumn: Schema.optional(Schema.String), LowerBound: Schema.optional(Schema.Number), UpperBound: Schema.optional(Schema.Number), NumPartitions: Schema.optional(Schema.Number), JobBookmarkKeys: Schema.optional(EnclosedInStringProperties), JobBookmarkKeysSortOrder: Schema.optional(Schema.String), DataTypeMapping: Schema.optional(JDBCDataTypeMapping)});
export const JDBCConnectorSource = Schema.Struct({Name: Schema.String, ConnectionName: Schema.String, ConnectorName: Schema.String, ConnectionType: Schema.String, AdditionalOptions: Schema.optional(JDBCConnectorOptions), ConnectionTable: Schema.optional(Schema.String), Query: Schema.optional(Schema.String), OutputSchemas: Schema.optional(GlueSchemas)});
export const AdditionalOptions = Schema.Record({key: Schema.String, value: Schema.String});
export const SparkConnectorSource = Schema.Struct({Name: Schema.String, ConnectionName: Schema.String, ConnectorName: Schema.String, ConnectionType: Schema.String, AdditionalOptions: Schema.optional(AdditionalOptions), OutputSchemas: Schema.optional(GlueSchemas)});
export const CatalogSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String, PartitionPredicate: Schema.optional(Schema.String), OutputSchemas: Schema.optional(GlueSchemas)});
export const RedshiftSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String, RedshiftTmpDir: Schema.optional(Schema.String), TmpDirIAMRole: Schema.optional(Schema.String)});
export const S3SourceAdditionalOptions = Schema.Struct({BoundedSize: Schema.optional(Schema.Number), BoundedFiles: Schema.optional(Schema.Number)});
export const S3CatalogSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String, PartitionPredicate: Schema.optional(Schema.String), AdditionalOptions: Schema.optional(S3SourceAdditionalOptions)});
export const S3DirectSourceAdditionalOptions = Schema.Struct({BoundedSize: Schema.optional(Schema.Number), BoundedFiles: Schema.optional(Schema.Number), EnableSamplePath: Schema.optional(Schema.Boolean), SamplePath: Schema.optional(Schema.String)});
export const S3CsvSource = Schema.Struct({Name: Schema.String, Paths: EnclosedInStringProperties, CompressionType: Schema.optional(Schema.String), Exclusions: Schema.optional(EnclosedInStringProperties), GroupSize: Schema.optional(Schema.String), GroupFiles: Schema.optional(Schema.String), Recurse: Schema.optional(Schema.Boolean), MaxBand: Schema.optional(Schema.Number), MaxFilesInBand: Schema.optional(Schema.Number), AdditionalOptions: Schema.optional(S3DirectSourceAdditionalOptions), Separator: Schema.String, Escaper: Schema.optional(Schema.String), QuoteChar: Schema.String, Multiline: Schema.optional(Schema.Boolean), WithHeader: Schema.optional(Schema.Boolean), WriteHeader: Schema.optional(Schema.Boolean), SkipFirst: Schema.optional(Schema.Boolean), OptimizePerformance: Schema.optional(Schema.Boolean), OutputSchemas: Schema.optional(GlueSchemas)});
export const S3JsonSource = Schema.Struct({Name: Schema.String, Paths: EnclosedInStringProperties, CompressionType: Schema.optional(Schema.String), Exclusions: Schema.optional(EnclosedInStringProperties), GroupSize: Schema.optional(Schema.String), GroupFiles: Schema.optional(Schema.String), Recurse: Schema.optional(Schema.Boolean), MaxBand: Schema.optional(Schema.Number), MaxFilesInBand: Schema.optional(Schema.Number), AdditionalOptions: Schema.optional(S3DirectSourceAdditionalOptions), JsonPath: Schema.optional(Schema.String), Multiline: Schema.optional(Schema.Boolean), OutputSchemas: Schema.optional(GlueSchemas)});
export const S3ParquetSource = Schema.Struct({Name: Schema.String, Paths: EnclosedInStringProperties, CompressionType: Schema.optional(Schema.String), Exclusions: Schema.optional(EnclosedInStringProperties), GroupSize: Schema.optional(Schema.String), GroupFiles: Schema.optional(Schema.String), Recurse: Schema.optional(Schema.Boolean), MaxBand: Schema.optional(Schema.Number), MaxFilesInBand: Schema.optional(Schema.Number), AdditionalOptions: Schema.optional(S3DirectSourceAdditionalOptions), OutputSchemas: Schema.optional(GlueSchemas)});
export const RelationalCatalogSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String});
export const DDBELTCatalogAdditionalOptions = Schema.Struct({DynamodbExport: Schema.optional(Schema.String), DynamodbUnnestDDBJson: Schema.optional(Schema.Boolean)});
export const DynamoDBCatalogSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String, PitrEnabled: Schema.optional(Schema.Boolean), AdditionalOptions: Schema.optional(DDBELTCatalogAdditionalOptions)});
export const OneInput = Schema.Array(Schema.String);
export const JDBCConnectorTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, ConnectionName: Schema.String, ConnectionTable: Schema.String, ConnectorName: Schema.String, ConnectionType: Schema.String, AdditionalOptions: Schema.optional(AdditionalOptions), OutputSchemas: Schema.optional(GlueSchemas)});
export const SparkConnectorTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, ConnectionName: Schema.String, ConnectorName: Schema.String, ConnectionType: Schema.String, AdditionalOptions: Schema.optional(AdditionalOptions), OutputSchemas: Schema.optional(GlueSchemas)});
export const GlueStudioPathList = Schema.Array(EnclosedInStringProperties);
export const BasicCatalogTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, PartitionKeys: Schema.optional(GlueStudioPathList), Database: Schema.String, Table: Schema.String});
export const EnclosedInStringPropertiesMinOne = Schema.Array(Schema.String);
export const UpsertRedshiftTargetOptions = Schema.Struct({TableLocation: Schema.optional(Schema.String), ConnectionName: Schema.optional(Schema.String), UpsertKeys: Schema.optional(EnclosedInStringPropertiesMinOne)});
export const RedshiftTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, Database: Schema.String, Table: Schema.String, RedshiftTmpDir: Schema.optional(Schema.String), TmpDirIAMRole: Schema.optional(Schema.String), UpsertRedshiftOptions: Schema.optional(UpsertRedshiftTargetOptions)});
export const CatalogSchemaChangePolicy = Schema.Struct({EnableUpdateCatalog: Schema.optional(Schema.Boolean), UpdateBehavior: Schema.optional(Schema.String)});
export const AutoDataQuality = Schema.Struct({IsEnabled: Schema.optional(Schema.Boolean), EvaluationContext: Schema.optional(Schema.String)});
export const S3CatalogTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, PartitionKeys: Schema.optional(GlueStudioPathList), Table: Schema.String, Database: Schema.String, SchemaChangePolicy: Schema.optional(CatalogSchemaChangePolicy), AutoDataQuality: Schema.optional(AutoDataQuality)});
export const DirectSchemaChangePolicy = Schema.Struct({EnableUpdateCatalog: Schema.optional(Schema.Boolean), UpdateBehavior: Schema.optional(Schema.String), Table: Schema.optional(Schema.String), Database: Schema.optional(Schema.String)});
export const S3GlueParquetTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, PartitionKeys: Schema.optional(GlueStudioPathList), Path: Schema.String, Compression: Schema.optional(Schema.String), NumberTargetPartitions: Schema.optional(Schema.String), SchemaChangePolicy: Schema.optional(DirectSchemaChangePolicy), AutoDataQuality: Schema.optional(AutoDataQuality)});
export const S3DirectTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, PartitionKeys: Schema.optional(GlueStudioPathList), Path: Schema.String, Compression: Schema.optional(Schema.String), NumberTargetPartitions: Schema.optional(Schema.String), Format: Schema.String, SchemaChangePolicy: Schema.optional(DirectSchemaChangePolicy), AutoDataQuality: Schema.optional(AutoDataQuality), OutputSchemas: Schema.optional(GlueSchemas)});
export const Mapping = Schema.Struct({ToKey: Schema.optional(Schema.String), FromPath: Schema.optional(EnclosedInStringProperties), FromType: Schema.optional(Schema.String), ToType: Schema.optional(Schema.String), Dropped: Schema.optional(Schema.Boolean), Children: Schema.optional(Mappings)});
export const Mappings = Schema.Array(Mapping);
export const ApplyMapping = Schema.Struct({Name: Schema.String, Inputs: OneInput, Mapping: Mappings});
export const SelectFields = Schema.Struct({Name: Schema.String, Inputs: OneInput, Paths: GlueStudioPathList});
export const DropFields = Schema.Struct({Name: Schema.String, Inputs: OneInput, Paths: GlueStudioPathList});
export const RenameField = Schema.Struct({Name: Schema.String, Inputs: OneInput, SourcePath: EnclosedInStringProperties, TargetPath: EnclosedInStringProperties});
export const Spigot = Schema.Struct({Name: Schema.String, Inputs: OneInput, Path: Schema.String, Topk: Schema.optional(Schema.Number), Prob: Schema.optional(Schema.Number)});
export const TwoInputs = Schema.Array(Schema.String);
export const JoinColumn = Schema.Struct({From: Schema.String, Keys: GlueStudioPathList});
export const JoinColumns = Schema.Array(JoinColumn);
export const Join = Schema.Struct({Name: Schema.String, Inputs: TwoInputs, JoinType: Schema.String, Columns: JoinColumns});
export const SplitFields = Schema.Struct({Name: Schema.String, Inputs: OneInput, Paths: GlueStudioPathList});
export const SelectFromCollection = Schema.Struct({Name: Schema.String, Inputs: OneInput, Index: Schema.Number});
export const FillMissingValues = Schema.Struct({Name: Schema.String, Inputs: OneInput, ImputedPath: Schema.String, FilledPath: Schema.optional(Schema.String)});
export const FilterValue = Schema.Struct({Type: Schema.String, Value: EnclosedInStringProperties});
export const FilterValues = Schema.Array(FilterValue);
export const FilterExpression = Schema.Struct({Operation: Schema.String, Negated: Schema.optional(Schema.Boolean), Values: FilterValues});
export const FilterExpressions = Schema.Array(FilterExpression);
export const Filter = Schema.Struct({Name: Schema.String, Inputs: OneInput, LogicalOperator: Schema.String, Filters: FilterExpressions});
export const ManyInputs = Schema.Array(Schema.String);
export const CustomCode = Schema.Struct({Name: Schema.String, Inputs: ManyInputs, Code: Schema.String, ClassName: Schema.String, OutputSchemas: Schema.optional(GlueSchemas)});
export const SqlAlias = Schema.Struct({From: Schema.String, Alias: Schema.String});
export const SqlAliases = Schema.Array(SqlAlias);
export const SparkSQL = Schema.Struct({Name: Schema.String, Inputs: ManyInputs, SqlQuery: Schema.String, SqlAliases: SqlAliases, OutputSchemas: Schema.optional(GlueSchemas)});
export const KinesisStreamingSourceOptions = Schema.Struct({EndpointUrl: Schema.optional(Schema.String), StreamName: Schema.optional(Schema.String), Classification: Schema.optional(Schema.String), Delimiter: Schema.optional(Schema.String), StartingPosition: Schema.optional(Schema.String), MaxFetchTimeInMs: Schema.optional(Schema.Number), MaxFetchRecordsPerShard: Schema.optional(Schema.Number), MaxRecordPerRead: Schema.optional(Schema.Number), AddIdleTimeBetweenReads: Schema.optional(Schema.Boolean), IdleTimeBetweenReadsInMs: Schema.optional(Schema.Number), DescribeShardInterval: Schema.optional(Schema.Number), NumRetries: Schema.optional(Schema.Number), RetryIntervalMs: Schema.optional(Schema.Number), MaxRetryIntervalMs: Schema.optional(Schema.Number), AvoidEmptyBatches: Schema.optional(Schema.Boolean), StreamArn: Schema.optional(Schema.String), RoleArn: Schema.optional(Schema.String), RoleSessionName: Schema.optional(Schema.String), AddRecordTimestamp: Schema.optional(Schema.String), EmitConsumerLagMetrics: Schema.optional(Schema.String), StartingTimestamp: Schema.optional(Schema.Date), FanoutConsumerARN: Schema.optional(Schema.String)});
export const StreamingDataPreviewOptions = Schema.Struct({PollingTime: Schema.optional(Schema.Number), RecordPollingLimit: Schema.optional(Schema.Number)});
export const DirectKinesisSource = Schema.Struct({Name: Schema.String, WindowSize: Schema.optional(Schema.Number), DetectSchema: Schema.optional(Schema.Boolean), StreamingOptions: Schema.optional(KinesisStreamingSourceOptions), DataPreviewOptions: Schema.optional(StreamingDataPreviewOptions)});
export const KafkaStreamingSourceOptions = Schema.Struct({BootstrapServers: Schema.optional(Schema.String), SecurityProtocol: Schema.optional(Schema.String), ConnectionName: Schema.optional(Schema.String), TopicName: Schema.optional(Schema.String), Assign: Schema.optional(Schema.String), SubscribePattern: Schema.optional(Schema.String), Classification: Schema.optional(Schema.String), Delimiter: Schema.optional(Schema.String), StartingOffsets: Schema.optional(Schema.String), EndingOffsets: Schema.optional(Schema.String), PollTimeoutMs: Schema.optional(Schema.Number), NumRetries: Schema.optional(Schema.Number), RetryIntervalMs: Schema.optional(Schema.Number), MaxOffsetsPerTrigger: Schema.optional(Schema.Number), MinPartitions: Schema.optional(Schema.Number), IncludeHeaders: Schema.optional(Schema.Boolean), AddRecordTimestamp: Schema.optional(Schema.String), EmitConsumerLagMetrics: Schema.optional(Schema.String), StartingTimestamp: Schema.optional(Schema.Date)});
export const DirectKafkaSource = Schema.Struct({Name: Schema.String, StreamingOptions: Schema.optional(KafkaStreamingSourceOptions), WindowSize: Schema.optional(Schema.Number), DetectSchema: Schema.optional(Schema.Boolean), DataPreviewOptions: Schema.optional(StreamingDataPreviewOptions)});
export const CatalogKinesisSource = Schema.Struct({Name: Schema.String, WindowSize: Schema.optional(Schema.Number), DetectSchema: Schema.optional(Schema.Boolean), Table: Schema.String, Database: Schema.String, StreamingOptions: Schema.optional(KinesisStreamingSourceOptions), DataPreviewOptions: Schema.optional(StreamingDataPreviewOptions)});
export const CatalogKafkaSource = Schema.Struct({Name: Schema.String, WindowSize: Schema.optional(Schema.Number), DetectSchema: Schema.optional(Schema.Boolean), Table: Schema.String, Database: Schema.String, StreamingOptions: Schema.optional(KafkaStreamingSourceOptions), DataPreviewOptions: Schema.optional(StreamingDataPreviewOptions)});
export const NullCheckBoxList = Schema.Struct({IsEmpty: Schema.optional(Schema.Boolean), IsNullString: Schema.optional(Schema.Boolean), IsNegOne: Schema.optional(Schema.Boolean)});
export const Datatype = Schema.Struct({Id: Schema.String, Label: Schema.String});
export const NullValueField = Schema.Struct({Value: Schema.String, Datatype: Datatype});
export const NullValueFields = Schema.Array(NullValueField);
export const DropNullFields = Schema.Struct({Name: Schema.String, Inputs: OneInput, NullCheckBoxList: Schema.optional(NullCheckBoxList), NullTextList: Schema.optional(NullValueFields)});
export const Merge = Schema.Struct({Name: Schema.String, Inputs: TwoInputs, Source: Schema.String, PrimaryKeys: GlueStudioPathList});
export const Union = Schema.Struct({Name: Schema.String, Inputs: TwoInputs, UnionType: Schema.String});
export const PIIDetection = Schema.Struct({Name: Schema.String, Inputs: OneInput, PiiType: Schema.String, EntityTypesToDetect: EnclosedInStringProperties, OutputColumnName: Schema.optional(Schema.String), SampleFraction: Schema.optional(Schema.Number), ThresholdFraction: Schema.optional(Schema.Number), MaskValue: Schema.optional(Schema.String), RedactText: Schema.optional(Schema.String), RedactChar: Schema.optional(Schema.String), MatchPattern: Schema.optional(Schema.String), NumLeftCharsToExclude: Schema.optional(Schema.Number), NumRightCharsToExclude: Schema.optional(Schema.Number), DetectionParameters: Schema.optional(Schema.String), DetectionSensitivity: Schema.optional(Schema.String)});
export const AggregateOperation = Schema.Struct({Column: EnclosedInStringProperties, AggFunc: Schema.String});
export const AggregateOperations = Schema.Array(AggregateOperation);
export const Aggregate = Schema.Struct({Name: Schema.String, Inputs: OneInput, Groups: GlueStudioPathList, Aggs: AggregateOperations});
export const LimitedStringList = Schema.Array(Schema.String);
export const LimitedPathList = Schema.Array(LimitedStringList);
export const DropDuplicates = Schema.Struct({Name: Schema.String, Inputs: OneInput, Columns: Schema.optional(LimitedPathList)});
export const GovernedCatalogTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, PartitionKeys: Schema.optional(GlueStudioPathList), Table: Schema.String, Database: Schema.String, SchemaChangePolicy: Schema.optional(CatalogSchemaChangePolicy)});
export const GovernedCatalogSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String, PartitionPredicate: Schema.optional(Schema.String), AdditionalOptions: Schema.optional(S3SourceAdditionalOptions)});
export const MicrosoftSQLServerCatalogSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String});
export const MySQLCatalogSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String});
export const OracleSQLCatalogSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String});
export const PostgreSQLCatalogSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String});
export const MicrosoftSQLServerCatalogTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, Database: Schema.String, Table: Schema.String});
export const MySQLCatalogTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, Database: Schema.String, Table: Schema.String});
export const OracleSQLCatalogTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, Database: Schema.String, Table: Schema.String});
export const PostgreSQLCatalogTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, Database: Schema.String, Table: Schema.String});
export const GroupFilters = Schema.Struct({GroupName: Schema.String, Filters: FilterExpressions, LogicalOperator: Schema.String});
export const GroupFiltersList = Schema.Array(GroupFilters);
export const Route = Schema.Struct({Name: Schema.String, Inputs: OneInput, GroupFiltersList: GroupFiltersList});
export const TransformConfigParameter = Schema.Struct({Name: Schema.String, Type: Schema.String, ValidationRule: Schema.optional(Schema.String), ValidationMessage: Schema.optional(Schema.String), Value: Schema.optional(EnclosedInStringProperties), ListType: Schema.optional(Schema.String), IsOptional: Schema.optional(Schema.Boolean)});
export const TransformConfigParameterList = Schema.Array(TransformConfigParameter);
export const DynamicTransform = Schema.Struct({Name: Schema.String, TransformName: Schema.String, Inputs: OneInput, Parameters: Schema.optional(TransformConfigParameterList), FunctionName: Schema.String, Path: Schema.String, Version: Schema.optional(Schema.String), OutputSchemas: Schema.optional(GlueSchemas)});
export const DQResultsPublishingOptions = Schema.Struct({EvaluationContext: Schema.optional(Schema.String), ResultsS3Prefix: Schema.optional(Schema.String), CloudWatchMetricsEnabled: Schema.optional(Schema.Boolean), ResultsPublishingEnabled: Schema.optional(Schema.Boolean)});
export const DQStopJobOnFailureOptions = Schema.Struct({StopJobOnFailureTiming: Schema.optional(Schema.String)});
export const EvaluateDataQuality = Schema.Struct({Name: Schema.String, Inputs: OneInput, Ruleset: Schema.String, Output: Schema.optional(Schema.String), PublishingOptions: Schema.optional(DQResultsPublishingOptions), StopJobOnFailureOptions: Schema.optional(DQStopJobOnFailureOptions)});
export const S3CatalogHudiSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String, AdditionalHudiOptions: Schema.optional(AdditionalOptions), OutputSchemas: Schema.optional(GlueSchemas)});
export const CatalogHudiSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String, AdditionalHudiOptions: Schema.optional(AdditionalOptions), OutputSchemas: Schema.optional(GlueSchemas)});
export const S3HudiSource = Schema.Struct({Name: Schema.String, Paths: EnclosedInStringProperties, AdditionalHudiOptions: Schema.optional(AdditionalOptions), AdditionalOptions: Schema.optional(S3DirectSourceAdditionalOptions), OutputSchemas: Schema.optional(GlueSchemas)});
export const S3HudiCatalogTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, PartitionKeys: Schema.optional(GlueStudioPathList), Table: Schema.String, Database: Schema.String, AdditionalOptions: AdditionalOptions, SchemaChangePolicy: Schema.optional(CatalogSchemaChangePolicy), AutoDataQuality: Schema.optional(AutoDataQuality), OutputSchemas: Schema.optional(GlueSchemas)});
export const S3HudiDirectTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, Path: Schema.String, Compression: Schema.String, NumberTargetPartitions: Schema.optional(Schema.String), PartitionKeys: Schema.optional(GlueStudioPathList), Format: Schema.String, AdditionalOptions: AdditionalOptions, SchemaChangePolicy: Schema.optional(DirectSchemaChangePolicy), AutoDataQuality: Schema.optional(AutoDataQuality)});
export const DirectJDBCSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String, ConnectionName: Schema.String, ConnectionType: Schema.String, RedshiftTmpDir: Schema.optional(Schema.String), OutputSchemas: Schema.optional(GlueSchemas)});
export const S3CatalogDeltaSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String, AdditionalDeltaOptions: Schema.optional(AdditionalOptions), OutputSchemas: Schema.optional(GlueSchemas)});
export const CatalogDeltaSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String, AdditionalDeltaOptions: Schema.optional(AdditionalOptions), OutputSchemas: Schema.optional(GlueSchemas)});
export const S3DeltaSource = Schema.Struct({Name: Schema.String, Paths: EnclosedInStringProperties, AdditionalDeltaOptions: Schema.optional(AdditionalOptions), AdditionalOptions: Schema.optional(S3DirectSourceAdditionalOptions), OutputSchemas: Schema.optional(GlueSchemas)});
export const S3DeltaCatalogTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, PartitionKeys: Schema.optional(GlueStudioPathList), Table: Schema.String, Database: Schema.String, AdditionalOptions: Schema.optional(AdditionalOptions), SchemaChangePolicy: Schema.optional(CatalogSchemaChangePolicy), AutoDataQuality: Schema.optional(AutoDataQuality), OutputSchemas: Schema.optional(GlueSchemas)});
export const S3DeltaDirectTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, PartitionKeys: Schema.optional(GlueStudioPathList), Path: Schema.String, Compression: Schema.String, NumberTargetPartitions: Schema.optional(Schema.String), Format: Schema.String, AdditionalOptions: Schema.optional(AdditionalOptions), SchemaChangePolicy: Schema.optional(DirectSchemaChangePolicy), AutoDataQuality: Schema.optional(AutoDataQuality)});
export const Option = Schema.Struct({Value: Schema.optional(Schema.String), Label: Schema.optional(Schema.String), Description: Schema.optional(Schema.String)});
export const AmazonRedshiftAdvancedOption = Schema.Struct({Key: Schema.optional(Schema.String), Value: Schema.optional(Schema.String)});
export const AmazonRedshiftAdvancedOptions = Schema.Array(AmazonRedshiftAdvancedOption);
export const OptionList = Schema.Array(Option);
export const AmazonRedshiftNodeData = Schema.Struct({AccessType: Schema.optional(Schema.String), SourceType: Schema.optional(Schema.String), Connection: Schema.optional(Option), Schema: Schema.optional(Option), Table: Schema.optional(Option), CatalogDatabase: Schema.optional(Option), CatalogTable: Schema.optional(Option), CatalogRedshiftSchema: Schema.optional(Schema.String), CatalogRedshiftTable: Schema.optional(Schema.String), TempDir: Schema.optional(Schema.String), IamRole: Schema.optional(Option), AdvancedOptions: Schema.optional(AmazonRedshiftAdvancedOptions), SampleQuery: Schema.optional(Schema.String), PreAction: Schema.optional(Schema.String), PostAction: Schema.optional(Schema.String), Action: Schema.optional(Schema.String), TablePrefix: Schema.optional(Schema.String), Upsert: Schema.optional(Schema.Boolean), MergeAction: Schema.optional(Schema.String), MergeWhenMatched: Schema.optional(Schema.String), MergeWhenNotMatched: Schema.optional(Schema.String), MergeClause: Schema.optional(Schema.String), CrawlerConnection: Schema.optional(Schema.String), TableSchema: Schema.optional(OptionList), StagingTable: Schema.optional(Schema.String), SelectedColumns: Schema.optional(OptionList)});
export const AmazonRedshiftSource = Schema.Struct({Name: Schema.optional(Schema.String), Data: Schema.optional(AmazonRedshiftNodeData)});
export const AmazonRedshiftTarget = Schema.Struct({Name: Schema.optional(Schema.String), Data: Schema.optional(AmazonRedshiftNodeData), Inputs: Schema.optional(OneInput)});
export const DQDLAliases = Schema.Record({key: Schema.String, value: Schema.String});
export const DQAdditionalOptions = Schema.Record({key: Schema.String, value: Schema.String});
export const EvaluateDataQualityMultiFrame = Schema.Struct({Name: Schema.String, Inputs: ManyInputs, AdditionalDataSources: Schema.optional(DQDLAliases), Ruleset: Schema.String, PublishingOptions: Schema.optional(DQResultsPublishingOptions), AdditionalOptions: Schema.optional(DQAdditionalOptions), StopJobOnFailureOptions: Schema.optional(DQStopJobOnFailureOptions)});
export const RecipeReference = Schema.Struct({RecipeArn: Schema.String, RecipeVersion: Schema.String});
export const ParameterMap = Schema.Record({key: Schema.String, value: Schema.String});
export const RecipeAction = Schema.Struct({Operation: Schema.String, Parameters: Schema.optional(ParameterMap)});
export const ConditionExpression = Schema.Struct({Condition: Schema.String, Value: Schema.optional(Schema.String), TargetColumn: Schema.String});
export const ConditionExpressionList = Schema.Array(ConditionExpression);
export const RecipeStep = Schema.Struct({Action: RecipeAction, ConditionExpressions: Schema.optional(ConditionExpressionList)});
export const RecipeSteps = Schema.Array(RecipeStep);
export const Recipe = Schema.Struct({Name: Schema.String, Inputs: OneInput, RecipeReference: Schema.optional(RecipeReference), RecipeSteps: Schema.optional(RecipeSteps)});
export const SnowflakeNodeData = Schema.Struct({SourceType: Schema.optional(Schema.String), Connection: Schema.optional(Option), Schema: Schema.optional(Schema.String), Table: Schema.optional(Schema.String), Database: Schema.optional(Schema.String), TempDir: Schema.optional(Schema.String), IamRole: Schema.optional(Option), AdditionalOptions: Schema.optional(AdditionalOptions), SampleQuery: Schema.optional(Schema.String), PreAction: Schema.optional(Schema.String), PostAction: Schema.optional(Schema.String), Action: Schema.optional(Schema.String), Upsert: Schema.optional(Schema.Boolean), MergeAction: Schema.optional(Schema.String), MergeWhenMatched: Schema.optional(Schema.String), MergeWhenNotMatched: Schema.optional(Schema.String), MergeClause: Schema.optional(Schema.String), StagingTable: Schema.optional(Schema.String), SelectedColumns: Schema.optional(OptionList), AutoPushdown: Schema.optional(Schema.Boolean), TableSchema: Schema.optional(OptionList)});
export const SnowflakeSource = Schema.Struct({Name: Schema.String, Data: SnowflakeNodeData, OutputSchemas: Schema.optional(GlueSchemas)});
export const SnowflakeTarget = Schema.Struct({Name: Schema.String, Data: SnowflakeNodeData, Inputs: Schema.optional(OneInput)});
export const ConnectorOptions = Schema.Record({key: Schema.String, value: Schema.String});
export const ConnectorDataSource = Schema.Struct({Name: Schema.String, ConnectionType: Schema.String, Data: ConnectorOptions, OutputSchemas: Schema.optional(GlueSchemas)});
export const ConnectorDataTarget = Schema.Struct({Name: Schema.String, ConnectionType: Schema.String, Data: ConnectorOptions, Inputs: Schema.optional(OneInput)});
export const S3CatalogIcebergSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String, AdditionalIcebergOptions: Schema.optional(AdditionalOptions), OutputSchemas: Schema.optional(GlueSchemas)});
export const CatalogIcebergSource = Schema.Struct({Name: Schema.String, Database: Schema.String, Table: Schema.String, AdditionalIcebergOptions: Schema.optional(AdditionalOptions), OutputSchemas: Schema.optional(GlueSchemas)});
export const S3IcebergCatalogTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, PartitionKeys: Schema.optional(GlueStudioPathList), Table: Schema.String, Database: Schema.String, AdditionalOptions: Schema.optional(AdditionalOptions), SchemaChangePolicy: Schema.optional(CatalogSchemaChangePolicy), AutoDataQuality: Schema.optional(AutoDataQuality)});
export const S3IcebergDirectTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, PartitionKeys: Schema.optional(GlueStudioPathList), Path: Schema.String, Format: Schema.String, AdditionalOptions: Schema.optional(AdditionalOptions), SchemaChangePolicy: Schema.optional(DirectSchemaChangePolicy), AutoDataQuality: Schema.optional(AutoDataQuality), Compression: Schema.String, NumberTargetPartitions: Schema.optional(Schema.String), OutputSchemas: Schema.optional(GlueSchemas)});
export const S3ExcelSource = Schema.Struct({Name: Schema.String, Paths: EnclosedInStringProperties, CompressionType: Schema.optional(Schema.String), Exclusions: Schema.optional(EnclosedInStringProperties), GroupSize: Schema.optional(Schema.String), GroupFiles: Schema.optional(Schema.String), Recurse: Schema.optional(Schema.Boolean), MaxBand: Schema.optional(Schema.Number), MaxFilesInBand: Schema.optional(Schema.Number), AdditionalOptions: Schema.optional(S3DirectSourceAdditionalOptions), NumberRows: Schema.optional(Schema.Number), SkipFooter: Schema.optional(Schema.Number), OutputSchemas: Schema.optional(GlueSchemas)});
export const S3HyperDirectTarget = Schema.Struct({Name: Schema.String, Inputs: OneInput, Format: Schema.optional(Schema.String), PartitionKeys: Schema.optional(GlueStudioPathList), Path: Schema.String, Compression: Schema.optional(Schema.String), SchemaChangePolicy: Schema.optional(DirectSchemaChangePolicy), AutoDataQuality: Schema.optional(AutoDataQuality), OutputSchemas: Schema.optional(GlueSchemas)});
export const DDBELTConnectionOptions = Schema.Struct({DynamodbExport: Schema.optional(Schema.String), DynamodbUnnestDDBJson: Schema.optional(Schema.Boolean), DynamodbTableArn: Schema.String, DynamodbS3Bucket: Schema.optional(Schema.String), DynamodbS3Prefix: Schema.optional(Schema.String), DynamodbS3BucketOwner: Schema.optional(Schema.String), DynamodbStsRoleArn: Schema.optional(Schema.String)});
export const DynamoDBELTConnectorSource = Schema.Struct({Name: Schema.String, ConnectionOptions: Schema.optional(DDBELTConnectionOptions), OutputSchemas: Schema.optional(GlueSchemas)});
export const CodeGenConfigurationNode = Schema.Struct({AthenaConnectorSource: Schema.optional(AthenaConnectorSource), JDBCConnectorSource: Schema.optional(JDBCConnectorSource), SparkConnectorSource: Schema.optional(SparkConnectorSource), CatalogSource: Schema.optional(CatalogSource), RedshiftSource: Schema.optional(RedshiftSource), S3CatalogSource: Schema.optional(S3CatalogSource), S3CsvSource: Schema.optional(S3CsvSource), S3JsonSource: Schema.optional(S3JsonSource), S3ParquetSource: Schema.optional(S3ParquetSource), RelationalCatalogSource: Schema.optional(RelationalCatalogSource), DynamoDBCatalogSource: Schema.optional(DynamoDBCatalogSource), JDBCConnectorTarget: Schema.optional(JDBCConnectorTarget), SparkConnectorTarget: Schema.optional(SparkConnectorTarget), CatalogTarget: Schema.optional(BasicCatalogTarget), RedshiftTarget: Schema.optional(RedshiftTarget), S3CatalogTarget: Schema.optional(S3CatalogTarget), S3GlueParquetTarget: Schema.optional(S3GlueParquetTarget), S3DirectTarget: Schema.optional(S3DirectTarget), ApplyMapping: Schema.optional(ApplyMapping), SelectFields: Schema.optional(SelectFields), DropFields: Schema.optional(DropFields), RenameField: Schema.optional(RenameField), Spigot: Schema.optional(Spigot), Join: Schema.optional(Join), SplitFields: Schema.optional(SplitFields), SelectFromCollection: Schema.optional(SelectFromCollection), FillMissingValues: Schema.optional(FillMissingValues), Filter: Schema.optional(Filter), CustomCode: Schema.optional(CustomCode), SparkSQL: Schema.optional(SparkSQL), DirectKinesisSource: Schema.optional(DirectKinesisSource), DirectKafkaSource: Schema.optional(DirectKafkaSource), CatalogKinesisSource: Schema.optional(CatalogKinesisSource), CatalogKafkaSource: Schema.optional(CatalogKafkaSource), DropNullFields: Schema.optional(DropNullFields), Merge: Schema.optional(Merge), Union: Schema.optional(Union), PIIDetection: Schema.optional(PIIDetection), Aggregate: Schema.optional(Aggregate), DropDuplicates: Schema.optional(DropDuplicates), GovernedCatalogTarget: Schema.optional(GovernedCatalogTarget), GovernedCatalogSource: Schema.optional(GovernedCatalogSource), MicrosoftSQLServerCatalogSource: Schema.optional(MicrosoftSQLServerCatalogSource), MySQLCatalogSource: Schema.optional(MySQLCatalogSource), OracleSQLCatalogSource: Schema.optional(OracleSQLCatalogSource), PostgreSQLCatalogSource: Schema.optional(PostgreSQLCatalogSource), MicrosoftSQLServerCatalogTarget: Schema.optional(MicrosoftSQLServerCatalogTarget), MySQLCatalogTarget: Schema.optional(MySQLCatalogTarget), OracleSQLCatalogTarget: Schema.optional(OracleSQLCatalogTarget), PostgreSQLCatalogTarget: Schema.optional(PostgreSQLCatalogTarget), Route: Schema.optional(Route), DynamicTransform: Schema.optional(DynamicTransform), EvaluateDataQuality: Schema.optional(EvaluateDataQuality), S3CatalogHudiSource: Schema.optional(S3CatalogHudiSource), CatalogHudiSource: Schema.optional(CatalogHudiSource), S3HudiSource: Schema.optional(S3HudiSource), S3HudiCatalogTarget: Schema.optional(S3HudiCatalogTarget), S3HudiDirectTarget: Schema.optional(S3HudiDirectTarget), DirectJDBCSource: Schema.optional(DirectJDBCSource), S3CatalogDeltaSource: Schema.optional(S3CatalogDeltaSource), CatalogDeltaSource: Schema.optional(CatalogDeltaSource), S3DeltaSource: Schema.optional(S3DeltaSource), S3DeltaCatalogTarget: Schema.optional(S3DeltaCatalogTarget), S3DeltaDirectTarget: Schema.optional(S3DeltaDirectTarget), AmazonRedshiftSource: Schema.optional(AmazonRedshiftSource), AmazonRedshiftTarget: Schema.optional(AmazonRedshiftTarget), EvaluateDataQualityMultiFrame: Schema.optional(EvaluateDataQualityMultiFrame), Recipe: Schema.optional(Recipe), SnowflakeSource: Schema.optional(SnowflakeSource), SnowflakeTarget: Schema.optional(SnowflakeTarget), ConnectorDataSource: Schema.optional(ConnectorDataSource), ConnectorDataTarget: Schema.optional(ConnectorDataTarget), S3CatalogIcebergSource: Schema.optional(S3CatalogIcebergSource), CatalogIcebergSource: Schema.optional(CatalogIcebergSource), S3IcebergCatalogTarget: Schema.optional(S3IcebergCatalogTarget), S3IcebergDirectTarget: Schema.optional(S3IcebergDirectTarget), S3ExcelSource: Schema.optional(S3ExcelSource), S3HyperDirectTarget: Schema.optional(S3HyperDirectTarget), DynamoDBELTConnectorSource: Schema.optional(DynamoDBELTConnectorSource)});
export const CodeGenConfigurationNodes = Schema.Record({key: Schema.String, value: CodeGenConfigurationNode});
export const JobUpdate = Schema.Struct({JobMode: Schema.optional(Schema.String), JobRunQueuingEnabled: Schema.optional(Schema.Boolean), Description: Schema.optional(Schema.String), LogUri: Schema.optional(Schema.String), Role: Schema.optional(Schema.String), ExecutionProperty: Schema.optional(ExecutionProperty), Command: Schema.optional(JobCommand), DefaultArguments: Schema.optional(GenericMap), NonOverridableArguments: Schema.optional(GenericMap), Connections: Schema.optional(ConnectionsList), MaxRetries: Schema.optional(Schema.Number), AllocatedCapacity: Schema.optional(Schema.Number), Timeout: Schema.optional(Schema.Number), MaxCapacity: Schema.optional(Schema.Number), WorkerType: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), SecurityConfiguration: Schema.optional(Schema.String), NotificationProperty: Schema.optional(NotificationProperty), GlueVersion: Schema.optional(Schema.String), CodeGenConfigurationNodes: Schema.optional(CodeGenConfigurationNodes), ExecutionClass: Schema.optional(Schema.String), SourceControlDetails: Schema.optional(SourceControlDetails), MaintenanceWindow: Schema.optional(Schema.String)});
export const TriggerUpdate = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Schedule: Schema.optional(Schema.String), Actions: Schema.optional(ActionList), Predicate: Schema.optional(Predicate), EventBatchingCondition: Schema.optional(EventBatchingCondition)});
export const BatchDeletePartitionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, PartitionsToDelete: BatchDeletePartitionValueList});
export const BatchGetTableOptimizerRequest = Schema.Struct({Entries: BatchGetTableOptimizerEntries});
export const BatchPutDataQualityStatisticAnnotationRequest = Schema.Struct({InclusionAnnotations: InclusionAnnotationList, ClientToken: Schema.optional(Schema.String)});
export const BatchUpdatePartitionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, Entries: BatchUpdatePartitionRequestEntryList});
export const EntityNotFoundException = Schema.Struct({Message: Schema.optional(Schema.String), FromFederationSource: Schema.optional(Schema.Boolean)});
export const InternalServiceException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CancelMLTaskRunResponse = Schema.Struct({TransformId: Schema.optional(Schema.String), TaskRunId: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)});
export const IllegalSessionStateException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CheckSchemaVersionValidityResponse = Schema.Struct({Valid: Schema.optional(Schema.Boolean), Error: Schema.optional(Schema.String)});
export const CreateBlueprintRequest = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), BlueprintLocation: Schema.String, Tags: Schema.optional(TagsMap)});
export const CreateClassifierRequest = Schema.Struct({GrokClassifier: Schema.optional(CreateGrokClassifierRequest), XMLClassifier: Schema.optional(CreateXMLClassifierRequest), JsonClassifier: Schema.optional(CreateJsonClassifierRequest), CsvClassifier: Schema.optional(CreateCsvClassifierRequest)});
export const CreateClassifierResponse = Schema.Struct({});
export const AlreadyExistsException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateCustomEntityTypeResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const CreateDataQualityRulesetRequest = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), Ruleset: Schema.String, Tags: Schema.optional(TagsMap), TargetTable: Schema.optional(DataQualityTargetTable), DataQualitySecurityConfiguration: Schema.optional(Schema.String), ClientToken: Schema.optional(Schema.String)});
export const CreateDevEndpointRequest = Schema.Struct({EndpointName: Schema.String, RoleArn: Schema.String, SecurityGroupIds: Schema.optional(StringList), SubnetId: Schema.optional(Schema.String), PublicKey: Schema.optional(Schema.String), PublicKeys: Schema.optional(PublicKeysList), NumberOfNodes: Schema.optional(Schema.Number), WorkerType: Schema.optional(Schema.String), GlueVersion: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), ExtraPythonLibsS3Path: Schema.optional(Schema.String), ExtraJarsS3Path: Schema.optional(Schema.String), SecurityConfiguration: Schema.optional(Schema.String), Tags: Schema.optional(TagsMap), Arguments: Schema.optional(MapValue)});
export const CreateGlueIdentityCenterConfigurationResponse = Schema.Struct({ApplicationArn: Schema.optional(Schema.String)});
export const CreateIntegrationResourcePropertyRequest = Schema.Struct({ResourceArn: Schema.String, SourceProcessingProperties: Schema.optional(SourceProcessingProperties), TargetProcessingProperties: Schema.optional(TargetProcessingProperties)});
export const GlueEncryptionException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreatePartitionIndexRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, PartitionIndex: PartitionIndex});
export const CreatePartitionIndexResponse = Schema.Struct({});
export const CreateRegistryResponse = Schema.Struct({RegistryArn: Schema.optional(Schema.String), RegistryName: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Tags: Schema.optional(TagsMap)});
export const CreateSchemaInput = Schema.Struct({RegistryId: Schema.optional(RegistryId), SchemaName: Schema.String, DataFormat: Schema.String, Compatibility: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Tags: Schema.optional(TagsMap), SchemaDefinition: Schema.optional(Schema.String)});
export const CreateSessionRequest = Schema.Struct({Id: Schema.String, Description: Schema.optional(Schema.String), Role: Schema.String, Command: SessionCommand, Timeout: Schema.optional(Schema.Number), IdleTimeout: Schema.optional(Schema.Number), DefaultArguments: Schema.optional(OrchestrationArgumentsMap), Connections: Schema.optional(ConnectionsList), MaxCapacity: Schema.optional(Schema.Number), NumberOfWorkers: Schema.optional(Schema.Number), WorkerType: Schema.optional(Schema.String), SecurityConfiguration: Schema.optional(Schema.String), GlueVersion: Schema.optional(Schema.String), Tags: Schema.optional(TagsMap), RequestOrigin: Schema.optional(Schema.String)});
export const CreateWorkflowRequest = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), DefaultRunProperties: Schema.optional(WorkflowRunProperties), Tags: Schema.optional(TagsMap), MaxConcurrentRuns: Schema.optional(Schema.Number)});
export const DeleteBlueprintResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const ConcurrentModificationException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const OperationTimeoutException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidInputException = Schema.Struct({Message: Schema.optional(Schema.String), FromFederationSource: Schema.optional(Schema.Boolean)});
export const CrawlerRunningException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DeleteCustomEntityTypeResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const FederationSourceException = Schema.Struct({FederationSourceErrorCode: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)});
export const InternalServerException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DeleteJobResponse = Schema.Struct({JobName: Schema.optional(Schema.String)});
export const DeleteMLTransformResponse = Schema.Struct({TransformId: Schema.optional(Schema.String)});
export const ConflictException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DeleteRegistryResponse = Schema.Struct({RegistryName: Schema.optional(Schema.String), RegistryArn: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)});
export const ConditionCheckFailureException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DeleteSchemaInput = Schema.Struct({SchemaId: SchemaId});
export const DeleteSessionResponse = Schema.Struct({Id: Schema.optional(Schema.String)});
export const FederationSourceRetryableException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ThrottlingException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DeleteTriggerResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const OperationNotSupportedException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DeleteWorkflowResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const DescribeIntegrationsRequest = Schema.Struct({IntegrationIdentifier: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxRecords: Schema.optional(Schema.Number), Filters: Schema.optional(IntegrationFilterList)});
export const LastActiveDefinition = Schema.Struct({Description: Schema.optional(Schema.String), LastModifiedOn: Schema.optional(Schema.Date), ParameterSpec: Schema.optional(Schema.String), BlueprintLocation: Schema.optional(Schema.String), BlueprintServiceLocation: Schema.optional(Schema.String)});
export const Blueprint = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), CreatedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date), ParameterSpec: Schema.optional(Schema.String), BlueprintLocation: Schema.optional(Schema.String), BlueprintServiceLocation: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String), LastActiveDefinition: Schema.optional(LastActiveDefinition)});
export const GetBlueprintResponse = Schema.Struct({Blueprint: Schema.optional(Blueprint)});
export const GetBlueprintRunsResponse = Schema.Struct({BlueprintRuns: Schema.optional(BlueprintRuns), NextToken: Schema.optional(Schema.String)});
export const GetCatalogsResponse = Schema.Struct({CatalogList: CatalogList, NextToken: Schema.optional(Schema.String)});
export const GetClassifiersResponse = Schema.Struct({Classifiers: Schema.optional(ClassifierList), NextToken: Schema.optional(Schema.String)});
export const ColumnError = Schema.Struct({ColumnName: Schema.optional(Schema.String), Error: Schema.optional(ErrorDetail)});
export const ColumnErrors = Schema.Array(ColumnError);
export const GetColumnStatisticsForTableResponse = Schema.Struct({ColumnStatisticsList: Schema.optional(ColumnStatisticsList), Errors: Schema.optional(ColumnErrors)});
export const GetColumnStatisticsTaskRunsResponse = Schema.Struct({ColumnStatisticsTaskRuns: Schema.optional(ColumnStatisticsTaskRunsList), NextToken: Schema.optional(Schema.String)});
export const GetConnectionsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), Filter: Schema.optional(GetConnectionsFilter), HidePassword: Schema.optional(Schema.Boolean), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const Schedule = Schema.Struct({ScheduleExpression: Schema.optional(Schema.String), State: Schema.optional(Schema.String)});
export const LastCrawlInfo = Schema.Struct({Status: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String), LogGroup: Schema.optional(Schema.String), LogStream: Schema.optional(Schema.String), MessagePrefix: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date)});
export const Crawler = Schema.Struct({Name: Schema.optional(Schema.String), Role: Schema.optional(Schema.String), Targets: Schema.optional(CrawlerTargets), DatabaseName: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Classifiers: Schema.optional(ClassifierNameList), RecrawlPolicy: Schema.optional(RecrawlPolicy), SchemaChangePolicy: Schema.optional(SchemaChangePolicy), LineageConfiguration: Schema.optional(LineageConfiguration), State: Schema.optional(Schema.String), TablePrefix: Schema.optional(Schema.String), Schedule: Schema.optional(Schedule), CrawlElapsedTime: Schema.optional(Schema.Number), CreationTime: Schema.optional(Schema.Date), LastUpdated: Schema.optional(Schema.Date), LastCrawl: Schema.optional(LastCrawlInfo), Version: Schema.optional(Schema.Number), Configuration: Schema.optional(Schema.String), CrawlerSecurityConfiguration: Schema.optional(Schema.String), LakeFormationConfiguration: Schema.optional(LakeFormationConfiguration)});
export const GetCrawlerResponse = Schema.Struct({Crawler: Schema.optional(Crawler)});
export const CrawlerList = Schema.Array(Crawler);
export const GetCrawlersResponse = Schema.Struct({Crawlers: Schema.optional(CrawlerList), NextToken: Schema.optional(Schema.String)});
export const GetCustomEntityTypeResponse = Schema.Struct({Name: Schema.optional(Schema.String), RegexString: Schema.optional(Schema.String), ContextWords: Schema.optional(ContextWords)});
export const GetDatabasesResponse = Schema.Struct({DatabaseList: DatabaseList, NextToken: Schema.optional(Schema.String)});
export const EncryptionAtRest = Schema.Struct({CatalogEncryptionMode: Schema.String, SseAwsKmsKeyId: Schema.optional(Schema.String), CatalogEncryptionServiceRole: Schema.optional(Schema.String)});
export const ConnectionPasswordEncryption = Schema.Struct({ReturnConnectionPasswordEncrypted: Schema.Boolean, AwsKmsKeyId: Schema.optional(Schema.String)});
export const DataCatalogEncryptionSettings = Schema.Struct({EncryptionAtRest: Schema.optional(EncryptionAtRest), ConnectionPasswordEncryption: Schema.optional(ConnectionPasswordEncryption)});
export const GetDataCatalogEncryptionSettingsResponse = Schema.Struct({DataCatalogEncryptionSettings: Schema.optional(DataCatalogEncryptionSettings)});
export const CodeGenNode = Schema.Struct({Id: Schema.String, NodeType: Schema.String, Args: CodeGenNodeArgs, LineNumber: Schema.optional(Schema.Number)});
export const DagNodes = Schema.Array(CodeGenNode);
export const GetDataflowGraphResponse = Schema.Struct({DagNodes: Schema.optional(DagNodes), DagEdges: Schema.optional(DagEdges)});
export const GetDataQualityModelResponse = Schema.Struct({Status: Schema.optional(Schema.String), StartedOn: Schema.optional(Schema.Date), CompletedOn: Schema.optional(Schema.Date), FailureReason: Schema.optional(Schema.String)});
export const GetDataQualityRuleRecommendationRunResponse = Schema.Struct({RunId: Schema.optional(Schema.String), DataSource: Schema.optional(DataSource), Role: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), Timeout: Schema.optional(Schema.Number), Status: Schema.optional(Schema.String), ErrorString: Schema.optional(Schema.String), StartedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date), CompletedOn: Schema.optional(Schema.Date), ExecutionTime: Schema.optional(Schema.Number), RecommendedRuleset: Schema.optional(Schema.String), CreatedRulesetName: Schema.optional(Schema.String), DataQualitySecurityConfiguration: Schema.optional(Schema.String)});
export const GetDataQualityRulesetResponse = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Ruleset: Schema.optional(Schema.String), TargetTable: Schema.optional(DataQualityTargetTable), CreatedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date), RecommendationRunId: Schema.optional(Schema.String), DataQualitySecurityConfiguration: Schema.optional(Schema.String)});
export const GetDataQualityRulesetEvaluationRunResponse = Schema.Struct({RunId: Schema.optional(Schema.String), DataSource: Schema.optional(DataSource), Role: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), Timeout: Schema.optional(Schema.Number), AdditionalRunOptions: Schema.optional(DataQualityEvaluationRunAdditionalRunOptions), Status: Schema.optional(Schema.String), ErrorString: Schema.optional(Schema.String), StartedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date), CompletedOn: Schema.optional(Schema.Date), ExecutionTime: Schema.optional(Schema.Number), RulesetNames: Schema.optional(RulesetNames), ResultIds: Schema.optional(DataQualityResultIdList), AdditionalDataSources: Schema.optional(DataSourceMap)});
export const DevEndpoint = Schema.Struct({EndpointName: Schema.optional(Schema.String), RoleArn: Schema.optional(Schema.String), SecurityGroupIds: Schema.optional(StringList), SubnetId: Schema.optional(Schema.String), YarnEndpointAddress: Schema.optional(Schema.String), PrivateAddress: Schema.optional(Schema.String), ZeppelinRemoteSparkInterpreterPort: Schema.optional(Schema.Number), PublicAddress: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), WorkerType: Schema.optional(Schema.String), GlueVersion: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), NumberOfNodes: Schema.optional(Schema.Number), AvailabilityZone: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), ExtraPythonLibsS3Path: Schema.optional(Schema.String), ExtraJarsS3Path: Schema.optional(Schema.String), FailureReason: Schema.optional(Schema.String), LastUpdateStatus: Schema.optional(Schema.String), CreatedTimestamp: Schema.optional(Schema.Date), LastModifiedTimestamp: Schema.optional(Schema.Date), PublicKey: Schema.optional(Schema.String), PublicKeys: Schema.optional(PublicKeysList), SecurityConfiguration: Schema.optional(Schema.String), Arguments: Schema.optional(MapValue)});
export const GetDevEndpointResponse = Schema.Struct({DevEndpoint: Schema.optional(DevEndpoint)});
export const DevEndpointList = Schema.Array(DevEndpoint);
export const GetDevEndpointsResponse = Schema.Struct({DevEndpoints: Schema.optional(DevEndpointList), NextToken: Schema.optional(Schema.String)});
export const GetEntityRecordsRequest = Schema.Struct({ConnectionName: Schema.optional(Schema.String), CatalogId: Schema.optional(Schema.String), EntityName: Schema.String, NextToken: Schema.optional(Schema.String), DataStoreApiVersion: Schema.optional(Schema.String), ConnectionOptions: Schema.optional(ConnectionOptions), FilterPredicate: Schema.optional(Schema.String), Limit: Schema.Number, OrderBy: Schema.optional(Schema.String), SelectedFields: Schema.optional(SelectedFields)});
export const GetIntegrationResourcePropertyResponse = Schema.Struct({ResourceArn: Schema.optional(Schema.String), SourceProcessingProperties: Schema.optional(SourceProcessingProperties), TargetProcessingProperties: Schema.optional(TargetProcessingProperties)});
export const GetIntegrationTablePropertiesResponse = Schema.Struct({ResourceArn: Schema.optional(Schema.String), TableName: Schema.optional(Schema.String), SourceTableConfig: Schema.optional(SourceTableConfig), TargetTableConfig: Schema.optional(TargetTableConfig)});
export const Job = Schema.Struct({Name: Schema.optional(Schema.String), JobMode: Schema.optional(Schema.String), JobRunQueuingEnabled: Schema.optional(Schema.Boolean), Description: Schema.optional(Schema.String), LogUri: Schema.optional(Schema.String), Role: Schema.optional(Schema.String), CreatedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date), ExecutionProperty: Schema.optional(ExecutionProperty), Command: Schema.optional(JobCommand), DefaultArguments: Schema.optional(GenericMap), NonOverridableArguments: Schema.optional(GenericMap), Connections: Schema.optional(ConnectionsList), MaxRetries: Schema.optional(Schema.Number), AllocatedCapacity: Schema.optional(Schema.Number), Timeout: Schema.optional(Schema.Number), MaxCapacity: Schema.optional(Schema.Number), WorkerType: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), SecurityConfiguration: Schema.optional(Schema.String), NotificationProperty: Schema.optional(NotificationProperty), GlueVersion: Schema.optional(Schema.String), CodeGenConfigurationNodes: Schema.optional(CodeGenConfigurationNodes), ExecutionClass: Schema.optional(Schema.String), SourceControlDetails: Schema.optional(SourceControlDetails), MaintenanceWindow: Schema.optional(Schema.String), ProfileName: Schema.optional(Schema.String)});
export const GetJobResponse = Schema.Struct({Job: Schema.optional(Job)});
export const GetJobRunsResponse = Schema.Struct({JobRuns: Schema.optional(JobRunList), NextToken: Schema.optional(Schema.String)});
export const JobList = Schema.Array(Job);
export const GetJobsResponse = Schema.Struct({Jobs: Schema.optional(JobList), NextToken: Schema.optional(Schema.String)});
export const GetMappingRequest = Schema.Struct({Source: CatalogEntry, Sinks: Schema.optional(CatalogEntries), Location: Schema.optional(Location)});
export const GetMLTaskRunsRequest = Schema.Struct({TransformId: Schema.String, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), Filter: Schema.optional(TaskRunFilterCriteria), Sort: Schema.optional(TaskRunSortCriteria)});
export const Partition = Schema.Struct({Values: Schema.optional(ValueStringList), DatabaseName: Schema.optional(Schema.String), TableName: Schema.optional(Schema.String), CreationTime: Schema.optional(Schema.Date), LastAccessTime: Schema.optional(Schema.Date), StorageDescriptor: Schema.optional(StorageDescriptor), Parameters: Schema.optional(ParametersMap), LastAnalyzedTime: Schema.optional(Schema.Date), CatalogId: Schema.optional(Schema.String)});
export const GetPartitionResponse = Schema.Struct({Partition: Schema.optional(Partition)});
export const GetPartitionsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, Expression: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String), Segment: Schema.optional(Segment), MaxResults: Schema.optional(Schema.Number), ExcludeColumnSchema: Schema.optional(Schema.Boolean), TransactionId: Schema.optional(Schema.String), QueryAsOfTime: Schema.optional(Schema.Date)});
export const GetPlanRequest = Schema.Struct({Mapping: MappingList, Source: CatalogEntry, Sinks: Schema.optional(CatalogEntries), Location: Schema.optional(Location), Language: Schema.optional(Schema.String), AdditionalPlanOptionsMap: Schema.optional(AdditionalPlanOptionsMap)});
export const GetRegistryResponse = Schema.Struct({RegistryName: Schema.optional(Schema.String), RegistryArn: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.String), UpdatedTime: Schema.optional(Schema.String)});
export const GetResourcePolicyResponse = Schema.Struct({PolicyInJson: Schema.optional(Schema.String), PolicyHash: Schema.optional(Schema.String), CreateTime: Schema.optional(Schema.Date), UpdateTime: Schema.optional(Schema.Date)});
export const GetSchemaResponse = Schema.Struct({RegistryName: Schema.optional(Schema.String), RegistryArn: Schema.optional(Schema.String), SchemaName: Schema.optional(Schema.String), SchemaArn: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), DataFormat: Schema.optional(Schema.String), Compatibility: Schema.optional(Schema.String), SchemaCheckpoint: Schema.optional(Schema.Number), LatestSchemaVersion: Schema.optional(Schema.Number), NextSchemaVersion: Schema.optional(Schema.Number), SchemaStatus: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.String), UpdatedTime: Schema.optional(Schema.String)});
export const GetSchemaByDefinitionResponse = Schema.Struct({SchemaVersionId: Schema.optional(Schema.String), SchemaArn: Schema.optional(Schema.String), DataFormat: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.String)});
export const GetSchemaVersionInput = Schema.Struct({SchemaId: Schema.optional(SchemaId), SchemaVersionId: Schema.optional(Schema.String), SchemaVersionNumber: Schema.optional(SchemaVersionNumber)});
export const GetSchemaVersionsDiffResponse = Schema.Struct({Diff: Schema.optional(Schema.String)});
export const GetSecurityConfigurationsResponse = Schema.Struct({SecurityConfigurations: Schema.optional(SecurityConfigurationList), NextToken: Schema.optional(Schema.String)});
export const GetTableRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, Name: Schema.String, TransactionId: Schema.optional(Schema.String), QueryAsOfTime: Schema.optional(Schema.Date), AuditContext: Schema.optional(AuditContext), IncludeStatusDetails: Schema.optional(Schema.Boolean)});
export const GetTableVersionsResponse = Schema.Struct({TableVersions: Schema.optional(GetTableVersionsList), NextToken: Schema.optional(Schema.String)});
export const GetTagsResponse = Schema.Struct({Tags: Schema.optional(TagsMap)});
export const GetTriggerResponse = Schema.Struct({Trigger: Schema.optional(Trigger)});
export const TriggerList = Schema.Array(Trigger);
export const GetTriggersResponse = Schema.Struct({Triggers: Schema.optional(TriggerList), NextToken: Schema.optional(Schema.String)});
export const GetUnfilteredTableMetadataRequest = Schema.Struct({Region: Schema.optional(Schema.String), CatalogId: Schema.String, DatabaseName: Schema.String, Name: Schema.String, AuditContext: Schema.optional(AuditContext), SupportedPermissionTypes: PermissionTypeList, ParentResourceArn: Schema.optional(Schema.String), RootResourceArn: Schema.optional(Schema.String), SupportedDialect: Schema.optional(SupportedDialect), Permissions: Schema.optional(PermissionList), QuerySessionContext: Schema.optional(QuerySessionContext)});
export const GetUsageProfileResponse = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Configuration: Schema.optional(ProfileConfiguration), CreatedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date)});
export const GetUserDefinedFunctionsResponse = Schema.Struct({UserDefinedFunctions: Schema.optional(UserDefinedFunctionList), NextToken: Schema.optional(Schema.String)});
export const BlueprintDetails = Schema.Struct({BlueprintName: Schema.optional(Schema.String), RunId: Schema.optional(Schema.String)});
export const Workflow = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), DefaultRunProperties: Schema.optional(WorkflowRunProperties), CreatedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date), LastRun: Schema.optional(WorkflowRun), Graph: Schema.optional(WorkflowGraph), MaxConcurrentRuns: Schema.optional(Schema.Number), BlueprintDetails: Schema.optional(BlueprintDetails)});
export const GetWorkflowResponse = Schema.Struct({Workflow: Schema.optional(Workflow)});
export const GetWorkflowRunPropertiesResponse = Schema.Struct({RunProperties: Schema.optional(WorkflowRunProperties)});
export const GetWorkflowRunsResponse = Schema.Struct({Runs: Schema.optional(WorkflowRuns), NextToken: Schema.optional(Schema.String)});
export const ListBlueprintsResponse = Schema.Struct({Blueprints: Schema.optional(BlueprintNames), NextToken: Schema.optional(Schema.String)});
export const ListColumnStatisticsTaskRunsResponse = Schema.Struct({ColumnStatisticsTaskRunIds: Schema.optional(ColumnStatisticsTaskRunIdList), NextToken: Schema.optional(Schema.String)});
export const ListCrawlersResponse = Schema.Struct({CrawlerNames: Schema.optional(CrawlerNameList), NextToken: Schema.optional(Schema.String)});
export const ListCrawlsRequest = Schema.Struct({CrawlerName: Schema.String, MaxResults: Schema.optional(Schema.Number), Filters: Schema.optional(CrawlsFilterList), NextToken: Schema.optional(Schema.String)});
export const CustomEntityType = Schema.Struct({Name: Schema.String, RegexString: Schema.String, ContextWords: Schema.optional(ContextWords)});
export const CustomEntityTypes = Schema.Array(CustomEntityType);
export const ListCustomEntityTypesResponse = Schema.Struct({CustomEntityTypes: Schema.optional(CustomEntityTypes), NextToken: Schema.optional(Schema.String)});
export const ListDataQualityResultsRequest = Schema.Struct({Filter: Schema.optional(DataQualityResultFilterCriteria), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const ListDataQualityRuleRecommendationRunsRequest = Schema.Struct({Filter: Schema.optional(DataQualityRuleRecommendationRunFilter), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const ListDataQualityRulesetEvaluationRunsRequest = Schema.Struct({Filter: Schema.optional(DataQualityRulesetEvaluationRunFilter), NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const ListDataQualityRulesetsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), Filter: Schema.optional(DataQualityRulesetFilterCriteria), Tags: Schema.optional(TagsMap)});
export const ListDataQualityStatisticAnnotationsRequest = Schema.Struct({StatisticId: Schema.optional(Schema.String), ProfileId: Schema.optional(Schema.String), TimestampFilter: Schema.optional(TimestampFilter), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const ListDevEndpointsResponse = Schema.Struct({DevEndpointNames: Schema.optional(DevEndpointNameList), NextToken: Schema.optional(Schema.String)});
export const ListJobsResponse = Schema.Struct({JobNames: Schema.optional(JobNameList), NextToken: Schema.optional(Schema.String)});
export const ListMLTransformsResponse = Schema.Struct({TransformIds: TransformIdList, NextToken: Schema.optional(Schema.String)});
export const ListSessionsResponse = Schema.Struct({Ids: Schema.optional(SessionIdList), Sessions: Schema.optional(SessionList), NextToken: Schema.optional(Schema.String)});
export const ListStatementsResponse = Schema.Struct({Statements: Schema.optional(StatementList), NextToken: Schema.optional(Schema.String)});
export const ListTriggersResponse = Schema.Struct({TriggerNames: Schema.optional(TriggerNameList), NextToken: Schema.optional(Schema.String)});
export const ListWorkflowsResponse = Schema.Struct({Workflows: Schema.optional(WorkflowNames), NextToken: Schema.optional(Schema.String)});
export const IntegrationError = Schema.Struct({ErrorCode: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String)});
export const IntegrationErrorList = Schema.Array(IntegrationError);
export const ModifyIntegrationResponse = Schema.Struct({SourceArn: Schema.String, TargetArn: Schema.String, IntegrationName: Schema.String, Description: Schema.optional(Schema.String), IntegrationArn: Schema.String, KmsKeyId: Schema.optional(Schema.String), AdditionalEncryptionContext: Schema.optional(IntegrationAdditionalEncryptionContextMap), Tags: Schema.optional(IntegrationTagsList), Status: Schema.String, CreateTime: Schema.Date, Errors: Schema.optional(IntegrationErrorList), DataFilter: Schema.optional(Schema.String), IntegrationConfig: Schema.optional(IntegrationConfig)});
export const PutResourcePolicyResponse = Schema.Struct({PolicyHash: Schema.optional(Schema.String)});
export const PutSchemaVersionMetadataInput = Schema.Struct({SchemaId: Schema.optional(SchemaId), SchemaVersionNumber: Schema.optional(SchemaVersionNumber), SchemaVersionId: Schema.optional(Schema.String), MetadataKeyValue: MetadataKeyValuePair});
export const ResourceNumberLimitExceededException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const RegisterSchemaVersionResponse = Schema.Struct({SchemaVersionId: Schema.optional(Schema.String), VersionNumber: Schema.optional(Schema.Number), Status: Schema.optional(Schema.String)});
export const RemoveSchemaVersionMetadataResponse = Schema.Struct({SchemaArn: Schema.optional(Schema.String), SchemaName: Schema.optional(Schema.String), RegistryName: Schema.optional(Schema.String), LatestVersion: Schema.optional(Schema.Boolean), VersionNumber: Schema.optional(Schema.Number), SchemaVersionId: Schema.optional(Schema.String), MetadataKey: Schema.optional(Schema.String), MetadataValue: Schema.optional(Schema.String)});
export const JobBookmarkEntry = Schema.Struct({JobName: Schema.optional(Schema.String), Version: Schema.optional(Schema.Number), Run: Schema.optional(Schema.Number), Attempt: Schema.optional(Schema.Number), PreviousRunId: Schema.optional(Schema.String), RunId: Schema.optional(Schema.String), JobBookmark: Schema.optional(Schema.String)});
export const ResetJobBookmarkResponse = Schema.Struct({JobBookmarkEntry: Schema.optional(JobBookmarkEntry)});
export const ResumeWorkflowRunResponse = Schema.Struct({RunId: Schema.optional(Schema.String), NodeIds: Schema.optional(NodeIdList)});
export const RunStatementResponse = Schema.Struct({Id: Schema.optional(Schema.Number)});
export const SearchTablesRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String), Filters: Schema.optional(SearchPropertyPredicates), SearchText: Schema.optional(Schema.String), SortCriteria: Schema.optional(SortCriteria), MaxResults: Schema.optional(Schema.Number), ResourceShareType: Schema.optional(Schema.String), IncludeStatusDetails: Schema.optional(Schema.Boolean)});
export const StartBlueprintRunResponse = Schema.Struct({RunId: Schema.optional(Schema.String)});
export const StartColumnStatisticsTaskRunResponse = Schema.Struct({ColumnStatisticsTaskRunId: Schema.optional(Schema.String)});
export const NoScheduleException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const StartDataQualityRulesetEvaluationRunRequest = Schema.Struct({DataSource: DataSource, Role: Schema.String, NumberOfWorkers: Schema.optional(Schema.Number), Timeout: Schema.optional(Schema.Number), ClientToken: Schema.optional(Schema.String), AdditionalRunOptions: Schema.optional(DataQualityEvaluationRunAdditionalRunOptions), RulesetNames: RulesetNames, AdditionalDataSources: Schema.optional(DataSourceMap)});
export const StartExportLabelsTaskRunResponse = Schema.Struct({TaskRunId: Schema.optional(Schema.String)});
export const StartImportLabelsTaskRunResponse = Schema.Struct({TaskRunId: Schema.optional(Schema.String)});
export const StartJobRunResponse = Schema.Struct({JobRunId: Schema.optional(Schema.String)});
export const StartMLEvaluationTaskRunResponse = Schema.Struct({TaskRunId: Schema.optional(Schema.String)});
export const StartMLLabelingSetGenerationTaskRunResponse = Schema.Struct({TaskRunId: Schema.optional(Schema.String)});
export const StartTriggerResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const StartWorkflowRunResponse = Schema.Struct({RunId: Schema.optional(Schema.String)});
export const ColumnStatisticsTaskNotRunningException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CrawlerNotRunningException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const SchedulerNotRunningException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const StopSessionResponse = Schema.Struct({Id: Schema.optional(Schema.String)});
export const StopTriggerResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const IllegalWorkflowStateException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TestConnectionRequest = Schema.Struct({ConnectionName: Schema.optional(Schema.String), CatalogId: Schema.optional(Schema.String), TestConnectionInput: Schema.optional(TestConnectionInput)});
export const TestConnectionResponse = Schema.Struct({});
export const UpdateBlueprintResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const UpdateClassifierRequest = Schema.Struct({GrokClassifier: Schema.optional(UpdateGrokClassifierRequest), XMLClassifier: Schema.optional(UpdateXMLClassifierRequest), JsonClassifier: Schema.optional(UpdateJsonClassifierRequest), CsvClassifier: Schema.optional(UpdateCsvClassifierRequest)});
export const UpdateClassifierResponse = Schema.Struct({});
export const VersionMismatchException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const SchedulerTransitioningException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const UpdateDataQualityRulesetResponse = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Ruleset: Schema.optional(Schema.String)});
export const UpdateDevEndpointRequest = Schema.Struct({EndpointName: Schema.String, PublicKey: Schema.optional(Schema.String), AddPublicKeys: Schema.optional(PublicKeysList), DeletePublicKeys: Schema.optional(PublicKeysList), CustomLibraries: Schema.optional(DevEndpointCustomLibraries), UpdateEtlLibraries: Schema.optional(Schema.Boolean), DeleteArguments: Schema.optional(StringList), AddArguments: Schema.optional(MapValue)});
export const UpdateDevEndpointResponse = Schema.Struct({});
export const UpdateIntegrationResourcePropertyResponse = Schema.Struct({ResourceArn: Schema.optional(Schema.String), SourceProcessingProperties: Schema.optional(SourceProcessingProperties), TargetProcessingProperties: Schema.optional(TargetProcessingProperties)});
export const ResourceNotFoundException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const UpdateJobRequest = Schema.Struct({JobName: Schema.String, JobUpdate: JobUpdate});
export const UpdateJobFromSourceControlResponse = Schema.Struct({JobName: Schema.optional(Schema.String)});
export const UpdateMLTransformResponse = Schema.Struct({TransformId: Schema.optional(Schema.String)});
export const UpdateRegistryResponse = Schema.Struct({RegistryName: Schema.optional(Schema.String), RegistryArn: Schema.optional(Schema.String)});
export const UpdateSchemaResponse = Schema.Struct({SchemaArn: Schema.optional(Schema.String), SchemaName: Schema.optional(Schema.String), RegistryName: Schema.optional(Schema.String)});
export const UpdateSourceControlFromJobResponse = Schema.Struct({JobName: Schema.optional(Schema.String)});
export const ValidationException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const UpdateTriggerRequest = Schema.Struct({Name: Schema.String, TriggerUpdate: TriggerUpdate});
export const UpdateUsageProfileResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const UpdateWorkflowResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const MLUserDataEncryption = Schema.Struct({MlUserDataEncryptionMode: Schema.String, KmsKeyId: Schema.optional(Schema.String)});
export const AuthenticationTypes = Schema.Array(Schema.String);
export const DataOperations = Schema.Array(Schema.String);
export const ComputeEnvironments = Schema.Array(Schema.String);
export const ListOfString = Schema.Array(Schema.String);
export const FieldFilterOperatorsList = Schema.Array(Schema.String);
export const ReferenceDatasetsList = Schema.Array(Schema.String);
export const TableError = Schema.Struct({TableName: Schema.optional(Schema.String), ErrorDetail: Schema.optional(ErrorDetail)});
export const TableErrors = Schema.Array(TableError);
export const TableVersionError = Schema.Struct({TableName: Schema.optional(Schema.String), VersionId: Schema.optional(Schema.String), ErrorDetail: Schema.optional(ErrorDetail)});
export const TableVersionErrors = Schema.Array(TableVersionError);
export const EvaluatedMetricsMap = Schema.Record({key: Schema.String, value: Schema.Number});
export const RuleMetricsMap = Schema.Record({key: Schema.String, value: Schema.Number});
export const Labels = Schema.Record({key: Schema.String, value: Schema.String});
export const DataQualityRuleResult = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), EvaluationMessage: Schema.optional(Schema.String), Result: Schema.optional(Schema.String), EvaluatedMetrics: Schema.optional(EvaluatedMetricsMap), EvaluatedRule: Schema.optional(Schema.String), RuleMetrics: Schema.optional(RuleMetricsMap), Labels: Schema.optional(Labels)});
export const DataQualityRuleResults = Schema.Array(DataQualityRuleResult);
export const DataQualityAnalyzerResult = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), EvaluationMessage: Schema.optional(Schema.String), EvaluatedMetrics: Schema.optional(EvaluatedMetricsMap)});
export const DataQualityAnalyzerResults = Schema.Array(DataQualityAnalyzerResult);
export const DataQualityMetricValues = Schema.Struct({ActualValue: Schema.optional(Schema.Number), ExpectedValue: Schema.optional(Schema.Number), LowerLimit: Schema.optional(Schema.Number), UpperLimit: Schema.optional(Schema.Number)});
export const NewRules = Schema.Array(Schema.String);
export const MetricBasedObservation = Schema.Struct({MetricName: Schema.optional(Schema.String), StatisticId: Schema.optional(Schema.String), MetricValues: Schema.optional(DataQualityMetricValues), NewRules: Schema.optional(NewRules)});
export const DataQualityObservation = Schema.Struct({Description: Schema.optional(Schema.String), MetricBasedObservation: Schema.optional(MetricBasedObservation)});
export const DataQualityObservations = Schema.Array(DataQualityObservation);
export const DataQualityAggregatedMetrics = Schema.Struct({TotalRowsProcessed: Schema.optional(Schema.Number), TotalRowsPassed: Schema.optional(Schema.Number), TotalRowsFailed: Schema.optional(Schema.Number), TotalRulesProcessed: Schema.optional(Schema.Number), TotalRulesPassed: Schema.optional(Schema.Number), TotalRulesFailed: Schema.optional(Schema.Number)});
export const DataQualityResult = Schema.Struct({ResultId: Schema.optional(Schema.String), ProfileId: Schema.optional(Schema.String), Score: Schema.optional(Schema.Number), DataSource: Schema.optional(DataSource), RulesetName: Schema.optional(Schema.String), EvaluationContext: Schema.optional(Schema.String), StartedOn: Schema.optional(Schema.Date), CompletedOn: Schema.optional(Schema.Date), JobName: Schema.optional(Schema.String), JobRunId: Schema.optional(Schema.String), RulesetEvaluationRunId: Schema.optional(Schema.String), RuleResults: Schema.optional(DataQualityRuleResults), AnalyzerResults: Schema.optional(DataQualityAnalyzerResults), Observations: Schema.optional(DataQualityObservations), AggregatedMetrics: Schema.optional(DataQualityAggregatedMetrics)});
export const DataQualityResultsList = Schema.Array(DataQualityResult);
export const PartitionList = Schema.Array(Partition);
export const BatchStopJobRunSuccessfulSubmission = Schema.Struct({JobName: Schema.optional(Schema.String), JobRunId: Schema.optional(Schema.String)});
export const BatchStopJobRunSuccessfulSubmissionList = Schema.Array(BatchStopJobRunSuccessfulSubmission);
export const BatchStopJobRunError = Schema.Struct({JobName: Schema.optional(Schema.String), JobRunId: Schema.optional(Schema.String), ErrorDetail: Schema.optional(ErrorDetail)});
export const BatchStopJobRunErrorList = Schema.Array(BatchStopJobRunError);
export const GlueTables = Schema.Array(GlueTable);
export const TransformEncryption = Schema.Struct({MlUserDataEncryption: Schema.optional(MLUserDataEncryption), TaskRunSecurityConfigurationName: Schema.optional(Schema.String)});
export const Capabilities = Schema.Struct({SupportedAuthenticationTypes: AuthenticationTypes, SupportedDataOperations: DataOperations, SupportedComputeEnvironments: ComputeEnvironments});
export const PropertyTypes = Schema.Array(Schema.String);
export const AllowedValue = Schema.Struct({Description: Schema.optional(Schema.String), Value: Schema.String});
export const AllowedValues = Schema.Array(AllowedValue);
export const Property = Schema.Struct({Name: Schema.String, Description: Schema.String, Required: Schema.Boolean, DefaultValue: Schema.optional(Schema.String), PropertyTypes: PropertyTypes, AllowedValues: Schema.optional(AllowedValues), DataOperationScopes: Schema.optional(DataOperations)});
export const PropertiesMap = Schema.Record({key: Schema.String, value: Property});
export const AuthConfiguration = Schema.Struct({AuthenticationType: Property, SecretArn: Schema.optional(Property), OAuth2Properties: Schema.optional(PropertiesMap), BasicAuthenticationProperties: Schema.optional(PropertiesMap), CustomAuthenticationProperties: Schema.optional(PropertiesMap)});
export const InboundIntegration = Schema.Struct({SourceArn: Schema.String, TargetArn: Schema.String, IntegrationArn: Schema.String, Status: Schema.String, CreateTime: Schema.Date, IntegrationConfig: Schema.optional(IntegrationConfig), Errors: Schema.optional(IntegrationErrorList)});
export const InboundIntegrationsList = Schema.Array(InboundIntegration);
export const CatalogImportStatus = Schema.Struct({ImportCompleted: Schema.optional(Schema.Boolean), ImportTime: Schema.optional(Schema.Date), ImportedBy: Schema.optional(Schema.String)});
export const OAuth2Properties = Schema.Struct({OAuth2GrantType: Schema.optional(Schema.String), OAuth2ClientApplication: Schema.optional(OAuth2ClientApplication), TokenUrl: Schema.optional(Schema.String), TokenUrlParametersMap: Schema.optional(TokenUrlParametersMap)});
export const AuthenticationConfiguration = Schema.Struct({AuthenticationType: Schema.optional(Schema.String), SecretArn: Schema.optional(Schema.String), KmsKeyArn: Schema.optional(Schema.String), OAuth2Properties: Schema.optional(OAuth2Properties)});
export const Connection = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), ConnectionType: Schema.optional(Schema.String), MatchCriteria: Schema.optional(MatchCriteria), ConnectionProperties: Schema.optional(ConnectionProperties), SparkProperties: Schema.optional(PropertyMap), AthenaProperties: Schema.optional(PropertyMap), PythonProperties: Schema.optional(PropertyMap), PhysicalConnectionRequirements: Schema.optional(PhysicalConnectionRequirements), CreationTime: Schema.optional(Schema.Date), LastUpdatedTime: Schema.optional(Schema.Date), LastUpdatedBy: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), StatusReason: Schema.optional(Schema.String), LastConnectionValidationTime: Schema.optional(Schema.Date), AuthenticationConfiguration: Schema.optional(AuthenticationConfiguration), ConnectionSchemaVersion: Schema.optional(Schema.Number), CompatibleComputeEnvironments: Schema.optional(ComputeEnvironmentList)});
export const ConnectionList = Schema.Array(Connection);
export const CrawlerMetrics = Schema.Struct({CrawlerName: Schema.optional(Schema.String), TimeLeftSeconds: Schema.optional(Schema.Number), StillEstimating: Schema.optional(Schema.Boolean), LastRuntimeSeconds: Schema.optional(Schema.Number), MedianRuntimeSeconds: Schema.optional(Schema.Number), TablesCreated: Schema.optional(Schema.Number), TablesUpdated: Schema.optional(Schema.Number), TablesDeleted: Schema.optional(Schema.Number)});
export const CrawlerMetricsList = Schema.Array(CrawlerMetrics);
export const StatisticModelResult = Schema.Struct({LowerBound: Schema.optional(Schema.Number), UpperBound: Schema.optional(Schema.Number), PredictedValue: Schema.optional(Schema.Number), ActualValue: Schema.optional(Schema.Number), Date: Schema.optional(Schema.Date), InclusionAnnotation: Schema.optional(Schema.String)});
export const StatisticModelResults = Schema.Array(StatisticModelResult);
export const Records = Schema.Array(Schema.JsonValue);
export const GluePolicy = Schema.Struct({PolicyInJson: Schema.optional(Schema.String), PolicyHash: Schema.optional(Schema.String), CreateTime: Schema.optional(Schema.Date), UpdateTime: Schema.optional(Schema.Date)});
export const GetResourcePoliciesResponseList = Schema.Array(GluePolicy);
export const RunMetrics = Schema.Struct({NumberOfBytesCompacted: Schema.optional(Schema.String), NumberOfFilesCompacted: Schema.optional(Schema.String), NumberOfDpus: Schema.optional(Schema.String), JobDurationInHour: Schema.optional(Schema.String)});
export const IcebergCompactionMetrics = Schema.Struct({NumberOfBytesCompacted: Schema.optional(Schema.Number), NumberOfFilesCompacted: Schema.optional(Schema.Number), DpuHours: Schema.optional(Schema.Number), NumberOfDpus: Schema.optional(Schema.Number), JobDurationInHour: Schema.optional(Schema.Number)});
export const CompactionMetrics = Schema.Struct({IcebergMetrics: Schema.optional(IcebergCompactionMetrics)});
export const IcebergRetentionMetrics = Schema.Struct({NumberOfDataFilesDeleted: Schema.optional(Schema.Number), NumberOfManifestFilesDeleted: Schema.optional(Schema.Number), NumberOfManifestListsDeleted: Schema.optional(Schema.Number), DpuHours: Schema.optional(Schema.Number), NumberOfDpus: Schema.optional(Schema.Number), JobDurationInHour: Schema.optional(Schema.Number)});
export const RetentionMetrics = Schema.Struct({IcebergMetrics: Schema.optional(IcebergRetentionMetrics)});
export const IcebergOrphanFileDeletionMetrics = Schema.Struct({NumberOfOrphanFilesDeleted: Schema.optional(Schema.Number), DpuHours: Schema.optional(Schema.Number), NumberOfDpus: Schema.optional(Schema.Number), JobDurationInHour: Schema.optional(Schema.Number)});
export const OrphanFileDeletionMetrics = Schema.Struct({IcebergMetrics: Schema.optional(IcebergOrphanFileDeletionMetrics)});
export const TableOptimizerRun = Schema.Struct({eventType: Schema.optional(Schema.String), startTimestamp: Schema.optional(Schema.Date), endTimestamp: Schema.optional(Schema.Date), metrics: Schema.optional(RunMetrics), error: Schema.optional(Schema.String), compactionMetrics: Schema.optional(CompactionMetrics), compactionStrategy: Schema.optional(Schema.String), retentionMetrics: Schema.optional(RetentionMetrics), orphanFileDeletionMetrics: Schema.optional(OrphanFileDeletionMetrics)});
export const TableOptimizer = Schema.Struct({type: Schema.optional(Schema.String), configuration: Schema.optional(TableOptimizerConfiguration), lastRun: Schema.optional(TableOptimizerRun), configurationSource: Schema.optional(Schema.String)});
export const UnfilteredPartition = Schema.Struct({Partition: Schema.optional(Partition), AuthorizedColumns: Schema.optional(NameStringList), IsRegisteredWithLakeFormation: Schema.optional(Schema.Boolean)});
export const UnfilteredPartitionList = Schema.Array(UnfilteredPartition);
export const CustomProperties = Schema.Record({key: Schema.String, value: Schema.String});
export const Entity = Schema.Struct({EntityName: Schema.optional(Schema.String), Label: Schema.optional(Schema.String), IsParentEntity: Schema.optional(Schema.Boolean), Description: Schema.optional(Schema.String), Category: Schema.optional(Schema.String), CustomProperties: Schema.optional(CustomProperties)});
export const EntityList = Schema.Array(Entity);
export const RegistryListItem = Schema.Struct({RegistryName: Schema.optional(Schema.String), RegistryArn: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.String), UpdatedTime: Schema.optional(Schema.String)});
export const RegistryListDefinition = Schema.Array(RegistryListItem);
export const SchemaListItem = Schema.Struct({RegistryName: Schema.optional(Schema.String), SchemaName: Schema.optional(Schema.String), SchemaArn: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), SchemaStatus: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.String), UpdatedTime: Schema.optional(Schema.String)});
export const SchemaListDefinition = Schema.Array(SchemaListItem);
export const SchemaVersionListItem = Schema.Struct({SchemaArn: Schema.optional(Schema.String), SchemaVersionId: Schema.optional(Schema.String), VersionNumber: Schema.optional(Schema.Number), Status: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.String)});
export const SchemaVersionList = Schema.Array(SchemaVersionListItem);
export const UsageProfileDefinition = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), CreatedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date)});
export const UsageProfileDefinitionList = Schema.Array(UsageProfileDefinition);
export const ColumnStatisticsError = Schema.Struct({ColumnStatistics: Schema.optional(ColumnStatistics), Error: Schema.optional(ErrorDetail)});
export const ColumnStatisticsErrors = Schema.Array(ColumnStatisticsError);
export const ViewRepresentationInput = Schema.Struct({Dialect: Schema.optional(Schema.String), DialectVersion: Schema.optional(Schema.String), ViewOriginalText: Schema.optional(Schema.String), ValidationConnection: Schema.optional(Schema.String), ViewExpandedText: Schema.optional(Schema.String)});
export const ViewRepresentationInputList = Schema.Array(ViewRepresentationInput);
export const BackfillErroredPartitionsList = Schema.Array(PartitionValueList);
export const BatchDeleteTableResponse = Schema.Struct({Errors: Schema.optional(TableErrors)});
export const BatchDeleteTableVersionResponse = Schema.Struct({Errors: Schema.optional(TableVersionErrors)});
export const BatchGetCustomEntityTypesResponse = Schema.Struct({CustomEntityTypes: Schema.optional(CustomEntityTypes), CustomEntityTypesNotFound: Schema.optional(CustomEntityTypeNames)});
export const BatchGetDataQualityResultResponse = Schema.Struct({Results: DataQualityResultsList, ResultsNotFound: Schema.optional(DataQualityResultIds)});
export const BatchGetDevEndpointsResponse = Schema.Struct({DevEndpoints: Schema.optional(DevEndpointList), DevEndpointsNotFound: Schema.optional(DevEndpointNames)});
export const BatchGetJobsResponse = Schema.Struct({Jobs: Schema.optional(JobList), JobsNotFound: Schema.optional(JobNameList)});
export const BatchGetPartitionResponse = Schema.Struct({Partitions: Schema.optional(PartitionList), UnprocessedKeys: Schema.optional(BatchGetPartitionValueList)});
export const BatchGetTriggersResponse = Schema.Struct({Triggers: Schema.optional(TriggerList), TriggersNotFound: Schema.optional(TriggerNameList)});
export const BatchStopJobRunResponse = Schema.Struct({SuccessfulSubmissions: Schema.optional(BatchStopJobRunSuccessfulSubmissionList), Errors: Schema.optional(BatchStopJobRunErrorList)});
export const CreateBlueprintResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const ColumnStatisticsTaskRunningException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateCrawlerRequest = Schema.Struct({Name: Schema.String, Role: Schema.String, DatabaseName: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Targets: CrawlerTargets, Schedule: Schema.optional(Schema.String), Classifiers: Schema.optional(ClassifierNameList), TablePrefix: Schema.optional(Schema.String), SchemaChangePolicy: Schema.optional(SchemaChangePolicy), RecrawlPolicy: Schema.optional(RecrawlPolicy), LineageConfiguration: Schema.optional(LineageConfiguration), LakeFormationConfiguration: Schema.optional(LakeFormationConfiguration), Configuration: Schema.optional(Schema.String), CrawlerSecurityConfiguration: Schema.optional(Schema.String), Tags: Schema.optional(TagsMap)});
export const CreateCrawlerResponse = Schema.Struct({});
export const IdempotentParameterMismatchException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateDatabaseRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseInput: DatabaseInput, Tags: Schema.optional(TagsMap)});
export const CreateDatabaseResponse = Schema.Struct({});
export const CreateDataQualityRulesetResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const CreateDevEndpointResponse = Schema.Struct({EndpointName: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), SecurityGroupIds: Schema.optional(StringList), SubnetId: Schema.optional(Schema.String), RoleArn: Schema.optional(Schema.String), YarnEndpointAddress: Schema.optional(Schema.String), ZeppelinRemoteSparkInterpreterPort: Schema.optional(Schema.Number), NumberOfNodes: Schema.optional(Schema.Number), WorkerType: Schema.optional(Schema.String), GlueVersion: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), AvailabilityZone: Schema.optional(Schema.String), VpcId: Schema.optional(Schema.String), ExtraPythonLibsS3Path: Schema.optional(Schema.String), ExtraJarsS3Path: Schema.optional(Schema.String), FailureReason: Schema.optional(Schema.String), SecurityConfiguration: Schema.optional(Schema.String), CreatedTimestamp: Schema.optional(Schema.Date), Arguments: Schema.optional(MapValue)});
export const CreateIntegrationRequest = Schema.Struct({IntegrationName: Schema.String, SourceArn: Schema.String, TargetArn: Schema.String, Description: Schema.optional(Schema.String), DataFilter: Schema.optional(Schema.String), KmsKeyId: Schema.optional(Schema.String), AdditionalEncryptionContext: Schema.optional(IntegrationAdditionalEncryptionContextMap), Tags: Schema.optional(IntegrationTagsList), IntegrationConfig: Schema.optional(IntegrationConfig)});
export const CreateIntegrationResourcePropertyResponse = Schema.Struct({ResourceArn: Schema.String, SourceProcessingProperties: Schema.optional(SourceProcessingProperties), TargetProcessingProperties: Schema.optional(TargetProcessingProperties)});
export const CreateIntegrationTablePropertiesRequest = Schema.Struct({ResourceArn: Schema.String, TableName: Schema.String, SourceTableConfig: Schema.optional(SourceTableConfig), TargetTableConfig: Schema.optional(TargetTableConfig)});
export const CreateIntegrationTablePropertiesResponse = Schema.Struct({});
export const CreateMLTransformRequest = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), InputRecordTables: GlueTables, Parameters: TransformParameters, Role: Schema.String, GlueVersion: Schema.optional(Schema.String), MaxCapacity: Schema.optional(Schema.Number), WorkerType: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), Timeout: Schema.optional(Schema.Number), MaxRetries: Schema.optional(Schema.Number), Tags: Schema.optional(TagsMap), TransformEncryption: Schema.optional(TransformEncryption)});
export const CreateSchemaResponse = Schema.Struct({RegistryName: Schema.optional(Schema.String), RegistryArn: Schema.optional(Schema.String), SchemaName: Schema.optional(Schema.String), SchemaArn: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), DataFormat: Schema.optional(Schema.String), Compatibility: Schema.optional(Schema.String), SchemaCheckpoint: Schema.optional(Schema.Number), LatestSchemaVersion: Schema.optional(Schema.Number), NextSchemaVersion: Schema.optional(Schema.Number), SchemaStatus: Schema.optional(Schema.String), Tags: Schema.optional(TagsMap), SchemaVersionId: Schema.optional(Schema.String), SchemaVersionStatus: Schema.optional(Schema.String)});
export const CreateScriptRequest = Schema.Struct({DagNodes: Schema.optional(DagNodes), DagEdges: Schema.optional(DagEdges), Language: Schema.optional(Schema.String)});
export const CreateSecurityConfigurationRequest = Schema.Struct({Name: Schema.String, EncryptionConfiguration: EncryptionConfiguration});
export const CreateSessionResponse = Schema.Struct({Session: Schema.optional(Session)});
export const IntegerList = Schema.Array(Schema.Number);
export const CreateTriggerRequest = Schema.Struct({Name: Schema.String, WorkflowName: Schema.optional(Schema.String), Type: Schema.String, Schedule: Schema.optional(Schema.String), Predicate: Schema.optional(Predicate), Actions: ActionList, Description: Schema.optional(Schema.String), StartOnCreation: Schema.optional(Schema.Boolean), Tags: Schema.optional(TagsMap), EventBatchingCondition: Schema.optional(EventBatchingCondition)});
export const CreateUserDefinedFunctionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, FunctionInput: UserDefinedFunctionInput});
export const CreateUserDefinedFunctionResponse = Schema.Struct({});
export const CreateWorkflowResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const DeleteIntegrationResponse = Schema.Struct({SourceArn: Schema.String, TargetArn: Schema.String, IntegrationName: Schema.String, Description: Schema.optional(Schema.String), IntegrationArn: Schema.String, KmsKeyId: Schema.optional(Schema.String), AdditionalEncryptionContext: Schema.optional(IntegrationAdditionalEncryptionContextMap), Tags: Schema.optional(IntegrationTagsList), Status: Schema.String, CreateTime: Schema.Date, Errors: Schema.optional(IntegrationErrorList), DataFilter: Schema.optional(Schema.String)});
export const DeleteSchemaResponse = Schema.Struct({SchemaArn: Schema.optional(Schema.String), SchemaName: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)});
export const ResourceNotReadyException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DescribeInboundIntegrationsResponse = Schema.Struct({InboundIntegrations: Schema.optional(InboundIntegrationsList), Marker: Schema.optional(Schema.String)});
export const GetBlueprintRunResponse = Schema.Struct({BlueprintRun: Schema.optional(BlueprintRun)});
export const GetCatalogImportStatusResponse = Schema.Struct({ImportStatus: Schema.optional(CatalogImportStatus)});
export const GetColumnStatisticsForPartitionResponse = Schema.Struct({ColumnStatisticsList: Schema.optional(ColumnStatisticsList), Errors: Schema.optional(ColumnErrors)});
export const GetColumnStatisticsTaskRunResponse = Schema.Struct({ColumnStatisticsTaskRun: Schema.optional(ColumnStatisticsTaskRun)});
export const GetConnectionsResponse = Schema.Struct({ConnectionList: Schema.optional(ConnectionList), NextToken: Schema.optional(Schema.String)});
export const GetCrawlerMetricsResponse = Schema.Struct({CrawlerMetricsList: Schema.optional(CrawlerMetricsList), NextToken: Schema.optional(Schema.String)});
export const GetDatabaseResponse = Schema.Struct({Database: Schema.optional(Database)});
export const GetDataQualityModelResultResponse = Schema.Struct({CompletedOn: Schema.optional(Schema.Date), Model: Schema.optional(StatisticModelResults)});
export const GetEntityRecordsResponse = Schema.Struct({Records: Schema.optional(Records), NextToken: Schema.optional(Schema.String)});
export const GetJobBookmarkResponse = Schema.Struct({JobBookmarkEntry: Schema.optional(JobBookmarkEntry)});
export const GetMappingResponse = Schema.Struct({Mapping: MappingList});
export const GetMLTransformsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), Filter: Schema.optional(TransformFilterCriteria), Sort: Schema.optional(TransformSortCriteria)});
export const GetPartitionsResponse = Schema.Struct({Partitions: Schema.optional(PartitionList), NextToken: Schema.optional(Schema.String)});
export const GetPlanResponse = Schema.Struct({PythonScript: Schema.optional(Schema.String), ScalaCode: Schema.optional(Schema.String)});
export const GetResourcePoliciesResponse = Schema.Struct({GetResourcePoliciesResponseList: Schema.optional(GetResourcePoliciesResponseList), NextToken: Schema.optional(Schema.String)});
export const GetSchemaVersionResponse = Schema.Struct({SchemaVersionId: Schema.optional(Schema.String), SchemaDefinition: Schema.optional(Schema.String), DataFormat: Schema.optional(Schema.String), SchemaArn: Schema.optional(Schema.String), VersionNumber: Schema.optional(Schema.Number), Status: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.String)});
export const GetSecurityConfigurationResponse = Schema.Struct({SecurityConfiguration: Schema.optional(SecurityConfiguration)});
export const GetSessionResponse = Schema.Struct({Session: Schema.optional(Session)});
export const GetTableResponse = Schema.Struct({Table: Schema.optional(Table)});
export const GetTableOptimizerResponse = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.optional(Schema.String), TableName: Schema.optional(Schema.String), TableOptimizer: Schema.optional(TableOptimizer)});
export const GetTableVersionResponse = Schema.Struct({TableVersion: Schema.optional(TableVersion)});
export const GetUnfilteredPartitionMetadataRequest = Schema.Struct({Region: Schema.optional(Schema.String), CatalogId: Schema.String, DatabaseName: Schema.String, TableName: Schema.String, PartitionValues: ValueStringList, AuditContext: Schema.optional(AuditContext), SupportedPermissionTypes: PermissionTypeList, QuerySessionContext: Schema.optional(QuerySessionContext)});
export const GetUnfilteredPartitionsMetadataResponse = Schema.Struct({UnfilteredPartitions: Schema.optional(UnfilteredPartitionList), NextToken: Schema.optional(Schema.String)});
export const GetUserDefinedFunctionResponse = Schema.Struct({UserDefinedFunction: Schema.optional(UserDefinedFunction)});
export const ListEntitiesResponse = Schema.Struct({Entities: Schema.optional(EntityList), NextToken: Schema.optional(Schema.String)});
export const ListRegistriesResponse = Schema.Struct({Registries: Schema.optional(RegistryListDefinition), NextToken: Schema.optional(Schema.String)});
export const ListSchemasResponse = Schema.Struct({Schemas: Schema.optional(SchemaListDefinition), NextToken: Schema.optional(Schema.String)});
export const ListSchemaVersionsResponse = Schema.Struct({Schemas: Schema.optional(SchemaVersionList), NextToken: Schema.optional(Schema.String)});
export const ListUsageProfilesResponse = Schema.Struct({Profiles: Schema.optional(UsageProfileDefinitionList), NextToken: Schema.optional(Schema.String)});
export const IntegrationConflictOperationFault = Schema.Struct({Message: Schema.optional(Schema.String)});
export const PutDataCatalogEncryptionSettingsRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DataCatalogEncryptionSettings: DataCatalogEncryptionSettings});
export const PutDataCatalogEncryptionSettingsResponse = Schema.Struct({});
export const PutSchemaVersionMetadataResponse = Schema.Struct({SchemaArn: Schema.optional(Schema.String), SchemaName: Schema.optional(Schema.String), RegistryName: Schema.optional(Schema.String), LatestVersion: Schema.optional(Schema.Boolean), VersionNumber: Schema.optional(Schema.Number), SchemaVersionId: Schema.optional(Schema.String), MetadataKey: Schema.optional(Schema.String), MetadataValue: Schema.optional(Schema.String)});
export const ConcurrentRunsExceededException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TableList = Schema.Array(Table);
export const SearchTablesResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), TableList: Schema.optional(TableList)});
export const IllegalBlueprintStateException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const SchedulerRunningException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const StartDataQualityRuleRecommendationRunRequest = Schema.Struct({DataSource: DataSource, Role: Schema.String, NumberOfWorkers: Schema.optional(Schema.Number), Timeout: Schema.optional(Schema.Number), CreatedRulesetName: Schema.optional(Schema.String), DataQualitySecurityConfiguration: Schema.optional(Schema.String), ClientToken: Schema.optional(Schema.String)});
export const StartDataQualityRulesetEvaluationRunResponse = Schema.Struct({RunId: Schema.optional(Schema.String)});
export const MLTransformNotReadyException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ColumnStatisticsTaskStoppingException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CrawlerStoppingException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const UpdateColumnStatisticsForTableResponse = Schema.Struct({Errors: Schema.optional(ColumnStatisticsErrors)});
export const UpdateJobResponse = Schema.Struct({JobName: Schema.optional(Schema.String)});
export const UpdateTriggerResponse = Schema.Struct({Trigger: Schema.optional(Trigger)});
export const ViewDefinitionInput = Schema.Struct({IsProtected: Schema.optional(Schema.Boolean), Definer: Schema.optional(Schema.String), Representations: Schema.optional(ViewRepresentationInputList), SubObjects: Schema.optional(ViewSubObjectsList)});
export const ErrorDetails = Schema.Struct({ErrorCode: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String)});
export const ExecutionAttempt = Schema.Struct({Status: Schema.optional(Schema.String), ColumnStatisticsTaskRunId: Schema.optional(Schema.String), ExecutionTimestamp: Schema.optional(Schema.Date), ErrorMessage: Schema.optional(Schema.String)});
export const ImportLabelsTaskRunProperties = Schema.Struct({InputS3Path: Schema.optional(Schema.String), Replace: Schema.optional(Schema.Boolean)});
export const ExportLabelsTaskRunProperties = Schema.Struct({OutputS3Path: Schema.optional(Schema.String)});
export const LabelingSetGenerationTaskRunProperties = Schema.Struct({OutputS3Path: Schema.optional(Schema.String)});
export const FindMatchesTaskRunProperties = Schema.Struct({JobId: Schema.optional(Schema.String), JobName: Schema.optional(Schema.String), JobRunId: Schema.optional(Schema.String)});
export const KeySchemaElement = Schema.Struct({Name: Schema.String, Type: Schema.String});
export const KeySchemaElementList = Schema.Array(KeySchemaElement);
export const BackfillError = Schema.Struct({Code: Schema.optional(Schema.String), Partitions: Schema.optional(BackfillErroredPartitionsList)});
export const BackfillErrors = Schema.Array(BackfillError);
export const ConnectionTypeVariant = Schema.Struct({ConnectionTypeVariantName: Schema.optional(Schema.String), DisplayName: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), LogoUrl: Schema.optional(Schema.String)});
export const ConnectionTypeVariantList = Schema.Array(ConnectionTypeVariant);
export const RunIdentifier = Schema.Struct({RunId: Schema.optional(Schema.String), JobRunId: Schema.optional(Schema.String)});
export const StatisticPropertiesMap = Schema.Record({key: Schema.String, value: Schema.String});
export const TimestampedInclusionAnnotation = Schema.Struct({Value: Schema.optional(Schema.String), LastModifiedOn: Schema.optional(Schema.Date)});
export const StringToStringMap = Schema.Record({key: Schema.String, value: Schema.String});
export const IcebergStructField = Schema.Struct({Id: Schema.Number, Name: Schema.String, Type: Schema.JsonValue, Required: Schema.Boolean, Doc: Schema.optional(Schema.String)});
export const IcebergStructFieldList = Schema.Array(IcebergStructField);
export const IcebergSchema = Schema.Struct({SchemaId: Schema.optional(Schema.Number), IdentifierFieldIds: Schema.optional(IntegerList), Type: Schema.optional(Schema.String), Fields: IcebergStructFieldList});
export const IcebergPartitionField = Schema.Struct({SourceId: Schema.Number, Transform: Schema.String, Name: Schema.String, FieldId: Schema.optional(Schema.Number)});
export const IcebergPartitionSpecFieldList = Schema.Array(IcebergPartitionField);
export const IcebergPartitionSpec = Schema.Struct({Fields: IcebergPartitionSpecFieldList, SpecId: Schema.optional(Schema.Number)});
export const IcebergSortField = Schema.Struct({SourceId: Schema.Number, Transform: Schema.String, Direction: Schema.String, NullOrder: Schema.String});
export const IcebergSortOrderFieldList = Schema.Array(IcebergSortField);
export const IcebergSortOrder = Schema.Struct({OrderId: Schema.Number, Fields: IcebergSortOrderFieldList});
export const IcebergTableUpdate = Schema.Struct({Schema: IcebergSchema, PartitionSpec: Schema.optional(IcebergPartitionSpec), SortOrder: Schema.optional(IcebergSortOrder), Location: Schema.String, Properties: Schema.optional(StringToStringMap)});
export const IcebergTableUpdateList = Schema.Array(IcebergTableUpdate);
export const ErrorByName = Schema.Record({key: Schema.String, value: ErrorDetail});
export const PartitionError = Schema.Struct({PartitionValues: Schema.optional(ValueStringList), ErrorDetail: Schema.optional(ErrorDetail)});
export const PartitionErrors = Schema.Array(PartitionError);
export const Blueprints = Schema.Array(Blueprint);
export const BatchTableOptimizer = Schema.Struct({catalogId: Schema.optional(Schema.String), databaseName: Schema.optional(Schema.String), tableName: Schema.optional(Schema.String), tableOptimizer: Schema.optional(TableOptimizer)});
export const BatchTableOptimizers = Schema.Array(BatchTableOptimizer);
export const BatchGetTableOptimizerError = Schema.Struct({error: Schema.optional(ErrorDetail), catalogId: Schema.optional(Schema.String), databaseName: Schema.optional(Schema.String), tableName: Schema.optional(Schema.String), type: Schema.optional(Schema.String)});
export const BatchGetTableOptimizerErrors = Schema.Array(BatchGetTableOptimizerError);
export const AnnotationError = Schema.Struct({ProfileId: Schema.optional(Schema.String), StatisticId: Schema.optional(Schema.String), FailureReason: Schema.optional(Schema.String)});
export const AnnotationErrorList = Schema.Array(AnnotationError);
export const BatchUpdatePartitionFailureEntry = Schema.Struct({PartitionValueList: Schema.optional(BoundedPartitionValueList), ErrorDetail: Schema.optional(ErrorDetail)});
export const BatchUpdatePartitionFailureList = Schema.Array(BatchUpdatePartitionFailureEntry);
export const TableInput = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), Owner: Schema.optional(Schema.String), LastAccessTime: Schema.optional(Schema.Date), LastAnalyzedTime: Schema.optional(Schema.Date), Retention: Schema.optional(Schema.Number), StorageDescriptor: Schema.optional(StorageDescriptor), PartitionKeys: Schema.optional(ColumnList), ViewOriginalText: Schema.optional(Schema.String), ViewExpandedText: Schema.optional(Schema.String), TableType: Schema.optional(Schema.String), Parameters: Schema.optional(ParametersMap), TargetTable: Schema.optional(TableIdentifier), ViewDefinition: Schema.optional(ViewDefinitionInput)});
export const SchemaVersionErrorItem = Schema.Struct({VersionNumber: Schema.optional(Schema.Number), ErrorDetails: Schema.optional(ErrorDetails)});
export const SchemaVersionErrorList = Schema.Array(SchemaVersionErrorItem);
export const Field = Schema.Struct({FieldName: Schema.optional(Schema.String), Label: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), FieldType: Schema.optional(Schema.String), IsPrimaryKey: Schema.optional(Schema.Boolean), IsNullable: Schema.optional(Schema.Boolean), IsRetrievable: Schema.optional(Schema.Boolean), IsFilterable: Schema.optional(Schema.Boolean), IsPartitionable: Schema.optional(Schema.Boolean), IsCreateable: Schema.optional(Schema.Boolean), IsUpdateable: Schema.optional(Schema.Boolean), IsUpsertable: Schema.optional(Schema.Boolean), IsDefaultOnCreate: Schema.optional(Schema.Boolean), SupportedValues: Schema.optional(ListOfString), SupportedFilterOperators: Schema.optional(FieldFilterOperatorsList), ParentField: Schema.optional(Schema.String), NativeDataType: Schema.optional(Schema.String), CustomProperties: Schema.optional(CustomProperties)});
export const FieldsList = Schema.Array(Field);
export const Integration = Schema.Struct({SourceArn: Schema.String, TargetArn: Schema.String, Description: Schema.optional(Schema.String), IntegrationName: Schema.String, IntegrationArn: Schema.String, KmsKeyId: Schema.optional(Schema.String), AdditionalEncryptionContext: Schema.optional(IntegrationAdditionalEncryptionContextMap), Tags: Schema.optional(IntegrationTagsList), Status: Schema.String, CreateTime: Schema.Date, IntegrationConfig: Schema.optional(IntegrationConfig), Errors: Schema.optional(IntegrationErrorList), DataFilter: Schema.optional(Schema.String)});
export const IntegrationsList = Schema.Array(Integration);
export const ColumnStatisticsTaskSettings = Schema.Struct({DatabaseName: Schema.optional(Schema.String), TableName: Schema.optional(Schema.String), Schedule: Schema.optional(Schedule), ColumnNameList: Schema.optional(ColumnNameList), CatalogID: Schema.optional(Schema.String), Role: Schema.optional(Schema.String), SampleSize: Schema.optional(Schema.Number), SecurityConfiguration: Schema.optional(Schema.String), ScheduleType: Schema.optional(Schema.String), SettingSource: Schema.optional(Schema.String), LastExecutionAttempt: Schema.optional(ExecutionAttempt)});
export const TaskRunProperties = Schema.Struct({TaskType: Schema.optional(Schema.String), ImportLabelsTaskRunProperties: Schema.optional(ImportLabelsTaskRunProperties), ExportLabelsTaskRunProperties: Schema.optional(ExportLabelsTaskRunProperties), LabelingSetGenerationTaskRunProperties: Schema.optional(LabelingSetGenerationTaskRunProperties), FindMatchesTaskRunProperties: Schema.optional(FindMatchesTaskRunProperties)});
export const TaskRun = Schema.Struct({TransformId: Schema.optional(Schema.String), TaskRunId: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), LogGroupName: Schema.optional(Schema.String), Properties: Schema.optional(TaskRunProperties), ErrorString: Schema.optional(Schema.String), StartedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date), CompletedOn: Schema.optional(Schema.Date), ExecutionTime: Schema.optional(Schema.Number)});
export const TaskRunList = Schema.Array(TaskRun);
export const PartitionIndexDescriptor = Schema.Struct({IndexName: Schema.String, Keys: KeySchemaElementList, IndexStatus: Schema.String, BackfillErrors: Schema.optional(BackfillErrors)});
export const PartitionIndexDescriptorList = Schema.Array(PartitionIndexDescriptor);
export const ColumnRowFilter = Schema.Struct({ColumnName: Schema.optional(Schema.String), RowFilterExpression: Schema.optional(Schema.String)});
export const ColumnRowFilterList = Schema.Array(ColumnRowFilter);
export const ConnectionTypeBrief = Schema.Struct({ConnectionType: Schema.optional(Schema.String), DisplayName: Schema.optional(Schema.String), Vendor: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Categories: Schema.optional(ListOfString), Capabilities: Schema.optional(Capabilities), LogoUrl: Schema.optional(Schema.String), ConnectionTypeVariants: Schema.optional(ConnectionTypeVariantList)});
export const ConnectionTypeList = Schema.Array(ConnectionTypeBrief);
export const CrawlerHistory = Schema.Struct({CrawlId: Schema.optional(Schema.String), State: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), EndTime: Schema.optional(Schema.Date), Summary: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String), LogGroup: Schema.optional(Schema.String), LogStream: Schema.optional(Schema.String), MessagePrefix: Schema.optional(Schema.String), DPUHour: Schema.optional(Schema.Number)});
export const CrawlerHistoryList = Schema.Array(CrawlerHistory);
export const DataQualityResultDescription = Schema.Struct({ResultId: Schema.optional(Schema.String), DataSource: Schema.optional(DataSource), JobName: Schema.optional(Schema.String), JobRunId: Schema.optional(Schema.String), StartedOn: Schema.optional(Schema.Date)});
export const DataQualityResultDescriptionList = Schema.Array(DataQualityResultDescription);
export const DataQualityRuleRecommendationRunDescription = Schema.Struct({RunId: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), StartedOn: Schema.optional(Schema.Date), DataSource: Schema.optional(DataSource)});
export const DataQualityRuleRecommendationRunList = Schema.Array(DataQualityRuleRecommendationRunDescription);
export const DataQualityRulesetEvaluationRunDescription = Schema.Struct({RunId: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), StartedOn: Schema.optional(Schema.Date), DataSource: Schema.optional(DataSource)});
export const DataQualityRulesetEvaluationRunList = Schema.Array(DataQualityRulesetEvaluationRunDescription);
export const DataQualityRulesetListDetails = Schema.Struct({Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), CreatedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date), TargetTable: Schema.optional(DataQualityTargetTable), RecommendationRunId: Schema.optional(Schema.String), RuleCount: Schema.optional(Schema.Number)});
export const DataQualityRulesetList = Schema.Array(DataQualityRulesetListDetails);
export const StatisticAnnotation = Schema.Struct({ProfileId: Schema.optional(Schema.String), StatisticId: Schema.optional(Schema.String), StatisticRecordedOn: Schema.optional(Schema.Date), InclusionAnnotation: Schema.optional(TimestampedInclusionAnnotation)});
export const AnnotationList = Schema.Array(StatisticAnnotation);
export const StatisticSummary = Schema.Struct({StatisticId: Schema.optional(Schema.String), ProfileId: Schema.optional(Schema.String), RunIdentifier: Schema.optional(RunIdentifier), StatisticName: Schema.optional(Schema.String), DoubleValue: Schema.optional(Schema.Number), EvaluationLevel: Schema.optional(Schema.String), ColumnsReferenced: Schema.optional(ColumnNameList), ReferencedDatasets: Schema.optional(ReferenceDatasetsList), StatisticProperties: Schema.optional(StatisticPropertiesMap), RecordedOn: Schema.optional(Schema.Date), InclusionAnnotation: Schema.optional(TimestampedInclusionAnnotation)});
export const StatisticSummaryList = Schema.Array(StatisticSummary);
export const PropertyNameOverrides = Schema.Record({key: Schema.String, value: Schema.String});
export const ConfusionMatrix = Schema.Struct({NumTruePositives: Schema.optional(Schema.Number), NumFalsePositives: Schema.optional(Schema.Number), NumTrueNegatives: Schema.optional(Schema.Number), NumFalseNegatives: Schema.optional(Schema.Number)});
export const ColumnImportance = Schema.Struct({ColumnName: Schema.optional(Schema.String), Importance: Schema.optional(Schema.Number)});
export const ColumnImportanceList = Schema.Array(ColumnImportance);
export const OtherMetadataValueListItem = Schema.Struct({MetadataValue: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.String)});
export const OtherMetadataValueList = Schema.Array(OtherMetadataValueListItem);
export const UpdateIcebergTableInput = Schema.Struct({Updates: IcebergTableUpdateList});
export const BatchDeleteConnectionResponse = Schema.Struct({Succeeded: Schema.optional(NameStringList), Errors: Schema.optional(ErrorByName)});
export const BatchDeletePartitionResponse = Schema.Struct({Errors: Schema.optional(PartitionErrors)});
export const BatchGetBlueprintsResponse = Schema.Struct({Blueprints: Schema.optional(Blueprints), MissingBlueprints: Schema.optional(BlueprintNames)});
export const BatchGetCrawlersResponse = Schema.Struct({Crawlers: Schema.optional(CrawlerList), CrawlersNotFound: Schema.optional(CrawlerNameList)});
export const InvalidStateException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const BatchGetTableOptimizerResponse = Schema.Struct({TableOptimizers: Schema.optional(BatchTableOptimizers), Failures: Schema.optional(BatchGetTableOptimizerErrors)});
export const BatchPutDataQualityStatisticAnnotationResponse = Schema.Struct({FailedInclusionAnnotations: Schema.optional(AnnotationErrorList)});
export const BatchUpdatePartitionResponse = Schema.Struct({Errors: Schema.optional(BatchUpdatePartitionFailureList)});
export const CreateCatalogRequest = Schema.Struct({Name: Schema.String, CatalogInput: CatalogInput, Tags: Schema.optional(TagsMap)});
export const CreateCatalogResponse = Schema.Struct({});
export const FederatedResourceAlreadyExistsException = Schema.Struct({Message: Schema.optional(Schema.String), AssociatedGlueResource: Schema.optional(Schema.String)});
export const CreateIntegrationResponse = Schema.Struct({SourceArn: Schema.String, TargetArn: Schema.String, IntegrationName: Schema.String, Description: Schema.optional(Schema.String), IntegrationArn: Schema.String, KmsKeyId: Schema.optional(Schema.String), AdditionalEncryptionContext: Schema.optional(IntegrationAdditionalEncryptionContextMap), Tags: Schema.optional(IntegrationTagsList), Status: Schema.String, CreateTime: Schema.Date, Errors: Schema.optional(IntegrationErrorList), DataFilter: Schema.optional(Schema.String), IntegrationConfig: Schema.optional(IntegrationConfig)});
export const CreateMLTransformResponse = Schema.Struct({TransformId: Schema.optional(Schema.String)});
export const CreateScriptResponse = Schema.Struct({PythonScript: Schema.optional(Schema.String), ScalaCode: Schema.optional(Schema.String)});
export const CreateSecurityConfigurationResponse = Schema.Struct({Name: Schema.optional(Schema.String), CreatedTimestamp: Schema.optional(Schema.Date)});
export const CreateTableOptimizerRequest = Schema.Struct({CatalogId: Schema.String, DatabaseName: Schema.String, TableName: Schema.String, Type: Schema.String, TableOptimizerConfiguration: TableOptimizerConfiguration});
export const CreateTableOptimizerResponse = Schema.Struct({});
export const CreateTriggerResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const CreateUsageProfileRequest = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), Configuration: ProfileConfiguration, Tags: Schema.optional(TagsMap)});
export const IntegrationNotFoundFault = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DeleteSchemaVersionsResponse = Schema.Struct({SchemaVersionErrors: Schema.optional(SchemaVersionErrorList)});
export const DescribeEntityResponse = Schema.Struct({Fields: Schema.optional(FieldsList), NextToken: Schema.optional(Schema.String)});
export const TargetResourceNotFound = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DescribeIntegrationsResponse = Schema.Struct({Integrations: Schema.optional(IntegrationsList), Marker: Schema.optional(Schema.String)});
export const GetClassifierResponse = Schema.Struct({Classifier: Schema.optional(Classifier)});
export const GetColumnStatisticsTaskSettingsResponse = Schema.Struct({ColumnStatisticsTaskSettings: Schema.optional(ColumnStatisticsTaskSettings)});
export const GetJobRunResponse = Schema.Struct({JobRun: Schema.optional(JobRun)});
export const GetMLTaskRunResponse = Schema.Struct({TransformId: Schema.optional(Schema.String), TaskRunId: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), LogGroupName: Schema.optional(Schema.String), Properties: Schema.optional(TaskRunProperties), ErrorString: Schema.optional(Schema.String), StartedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date), CompletedOn: Schema.optional(Schema.Date), ExecutionTime: Schema.optional(Schema.Number)});
export const GetMLTaskRunsResponse = Schema.Struct({TaskRuns: Schema.optional(TaskRunList), NextToken: Schema.optional(Schema.String)});
export const GetPartitionIndexesResponse = Schema.Struct({PartitionIndexDescriptorList: Schema.optional(PartitionIndexDescriptorList), NextToken: Schema.optional(Schema.String)});
export const GetUnfilteredPartitionMetadataResponse = Schema.Struct({Partition: Schema.optional(Partition), AuthorizedColumns: Schema.optional(NameStringList), IsRegisteredWithLakeFormation: Schema.optional(Schema.Boolean)});
export const PermissionTypeMismatchException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const GetUnfilteredTableMetadataResponse = Schema.Struct({Table: Schema.optional(Table), AuthorizedColumns: Schema.optional(NameStringList), IsRegisteredWithLakeFormation: Schema.optional(Schema.Boolean), CellFilters: Schema.optional(ColumnRowFilterList), QueryAuthorizationId: Schema.optional(Schema.String), IsMultiDialectView: Schema.optional(Schema.Boolean), ResourceArn: Schema.optional(Schema.String), IsProtected: Schema.optional(Schema.Boolean), Permissions: Schema.optional(PermissionList), RowFilter: Schema.optional(Schema.String)});
export const GetWorkflowRunResponse = Schema.Struct({Run: Schema.optional(WorkflowRun)});
export const ListConnectionTypesResponse = Schema.Struct({ConnectionTypes: Schema.optional(ConnectionTypeList), NextToken: Schema.optional(Schema.String)});
export const ListCrawlsResponse = Schema.Struct({Crawls: Schema.optional(CrawlerHistoryList), NextToken: Schema.optional(Schema.String)});
export const ListDataQualityResultsResponse = Schema.Struct({Results: DataQualityResultDescriptionList, NextToken: Schema.optional(Schema.String)});
export const ListDataQualityRuleRecommendationRunsResponse = Schema.Struct({Runs: Schema.optional(DataQualityRuleRecommendationRunList), NextToken: Schema.optional(Schema.String)});
export const ListDataQualityRulesetEvaluationRunsResponse = Schema.Struct({Runs: Schema.optional(DataQualityRulesetEvaluationRunList), NextToken: Schema.optional(Schema.String)});
export const ListDataQualityRulesetsResponse = Schema.Struct({Rulesets: Schema.optional(DataQualityRulesetList), NextToken: Schema.optional(Schema.String)});
export const ListDataQualityStatisticAnnotationsResponse = Schema.Struct({Annotations: Schema.optional(AnnotationList), NextToken: Schema.optional(Schema.String)});
export const ListDataQualityStatisticsResponse = Schema.Struct({Statistics: Schema.optional(StatisticSummaryList), NextToken: Schema.optional(Schema.String)});
export const InvalidIntegrationStateFault = Schema.Struct({Message: Schema.optional(Schema.String)});
export const StartDataQualityRuleRecommendationRunResponse = Schema.Struct({RunId: Schema.optional(Schema.String)});
export const ComputeEnvironmentConfiguration = Schema.Struct({Name: Schema.String, Description: Schema.String, ComputeEnvironment: Schema.String, SupportedAuthenticationTypes: AuthenticationTypes, ConnectionOptions: PropertiesMap, ConnectionPropertyNameOverrides: PropertyNameOverrides, ConnectionOptionNameOverrides: PropertyNameOverrides, ConnectionPropertiesRequiredOverrides: ListOfString, PhysicalConnectionPropertiesRequired: Schema.optional(Schema.Boolean)});
export const FindMatchesMetrics = Schema.Struct({AreaUnderPRCurve: Schema.optional(Schema.Number), Precision: Schema.optional(Schema.Number), Recall: Schema.optional(Schema.Number), F1: Schema.optional(Schema.Number), ConfusionMatrix: Schema.optional(ConfusionMatrix), ColumnImportances: Schema.optional(ColumnImportanceList)});
export const MetadataInfo = Schema.Struct({MetadataValue: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.String), OtherMetadataValueList: Schema.optional(OtherMetadataValueList)});
export const UpdateIcebergInput = Schema.Struct({UpdateIcebergTableInput: UpdateIcebergTableInput});
export const PartitionInputList = Schema.Array(PartitionInput);
export const ComputeEnvironmentConfigurationMap = Schema.Record({key: Schema.String, value: ComputeEnvironmentConfiguration});
export const EvaluationMetrics = Schema.Struct({TransformType: Schema.String, FindMatchesMetrics: Schema.optional(FindMatchesMetrics)});
export const MLTransform = Schema.Struct({TransformId: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), CreatedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date), InputRecordTables: Schema.optional(GlueTables), Parameters: Schema.optional(TransformParameters), EvaluationMetrics: Schema.optional(EvaluationMetrics), LabelCount: Schema.optional(Schema.Number), Schema: Schema.optional(TransformSchema), Role: Schema.optional(Schema.String), GlueVersion: Schema.optional(Schema.String), MaxCapacity: Schema.optional(Schema.Number), WorkerType: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), Timeout: Schema.optional(Schema.Number), MaxRetries: Schema.optional(Schema.Number), TransformEncryption: Schema.optional(TransformEncryption)});
export const TransformList = Schema.Array(MLTransform);
export const TableOptimizerRuns = Schema.Array(TableOptimizerRun);
export const MetadataInfoMap = Schema.Record({key: Schema.String, value: MetadataInfo});
export const UpdateOpenTableFormatInput = Schema.Struct({UpdateIcebergInput: Schema.optional(UpdateIcebergInput)});
export const CreateIcebergTableInput = Schema.Struct({Location: Schema.String, Schema: IcebergSchema, PartitionSpec: Schema.optional(IcebergPartitionSpec), WriteOrder: Schema.optional(IcebergSortOrder), Properties: Schema.optional(StringToStringMap)});
export const BatchCreatePartitionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, PartitionInputList: PartitionInputList});
export const CreateConnectionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), ConnectionInput: ConnectionInput, Tags: Schema.optional(TagsMap)});
export const IntegrationQuotaExceededFault = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateUsageProfileResponse = Schema.Struct({Name: Schema.optional(Schema.String)});
export const DescribeConnectionTypeResponse = Schema.Struct({ConnectionType: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Capabilities: Schema.optional(Capabilities), ConnectionProperties: Schema.optional(PropertiesMap), ConnectionOptions: Schema.optional(PropertiesMap), AuthenticationConfiguration: Schema.optional(AuthConfiguration), ComputeEnvironmentConfigurations: Schema.optional(ComputeEnvironmentConfigurationMap), PhysicalConnectionRequirements: Schema.optional(PropertiesMap), AthenaConnectionProperties: Schema.optional(PropertiesMap), PythonConnectionProperties: Schema.optional(PropertiesMap), SparkConnectionProperties: Schema.optional(PropertiesMap)});
export const GetCatalogResponse = Schema.Struct({Catalog: Schema.optional(Catalog)});
export const GetConnectionResponse = Schema.Struct({Connection: Schema.optional(Connection)});
export const GetDataQualityResultResponse = Schema.Struct({ResultId: Schema.optional(Schema.String), ProfileId: Schema.optional(Schema.String), Score: Schema.optional(Schema.Number), DataSource: Schema.optional(DataSource), RulesetName: Schema.optional(Schema.String), EvaluationContext: Schema.optional(Schema.String), StartedOn: Schema.optional(Schema.Date), CompletedOn: Schema.optional(Schema.Date), JobName: Schema.optional(Schema.String), JobRunId: Schema.optional(Schema.String), RulesetEvaluationRunId: Schema.optional(Schema.String), RuleResults: Schema.optional(DataQualityRuleResults), AnalyzerResults: Schema.optional(DataQualityAnalyzerResults), Observations: Schema.optional(DataQualityObservations), AggregatedMetrics: Schema.optional(DataQualityAggregatedMetrics)});
export const GetMLTransformResponse = Schema.Struct({TransformId: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), CreatedOn: Schema.optional(Schema.Date), LastModifiedOn: Schema.optional(Schema.Date), InputRecordTables: Schema.optional(GlueTables), Parameters: Schema.optional(TransformParameters), EvaluationMetrics: Schema.optional(EvaluationMetrics), LabelCount: Schema.optional(Schema.Number), Schema: Schema.optional(TransformSchema), Role: Schema.optional(Schema.String), GlueVersion: Schema.optional(Schema.String), MaxCapacity: Schema.optional(Schema.Number), WorkerType: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), Timeout: Schema.optional(Schema.Number), MaxRetries: Schema.optional(Schema.Number), TransformEncryption: Schema.optional(TransformEncryption)});
export const GetMLTransformsResponse = Schema.Struct({Transforms: TransformList, NextToken: Schema.optional(Schema.String)});
export const GetStatementResponse = Schema.Struct({Statement: Schema.optional(Statement)});
export const ListTableOptimizerRunsResponse = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.optional(Schema.String), TableName: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String), TableOptimizerRuns: Schema.optional(TableOptimizerRuns)});
export const QuerySchemaVersionMetadataResponse = Schema.Struct({MetadataInfoMap: Schema.optional(MetadataInfoMap), SchemaVersionId: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String)});
export const UpdateColumnStatisticsForPartitionRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, TableName: Schema.String, PartitionValues: ValueStringList, ColumnStatisticsList: UpdateColumnStatisticsList});
export const UpdateTableRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, Name: Schema.optional(Schema.String), TableInput: Schema.optional(TableInput), SkipArchive: Schema.optional(Schema.Boolean), TransactionId: Schema.optional(Schema.String), VersionId: Schema.optional(Schema.String), ViewUpdateAction: Schema.optional(Schema.String), Force: Schema.optional(Schema.Boolean), UpdateOpenTableFormatInput: Schema.optional(UpdateOpenTableFormatInput)});
export const UpdateTableResponse = Schema.Struct({});
export const IcebergInput = Schema.Struct({MetadataOperation: Schema.String, Version: Schema.optional(Schema.String), CreateIcebergTableInput: Schema.optional(CreateIcebergTableInput)});
export const OpenTableFormatInput = Schema.Struct({IcebergInput: Schema.optional(IcebergInput)});
export const BatchCreatePartitionResponse = Schema.Struct({Errors: Schema.optional(PartitionErrors)});
export const CreateConnectionResponse = Schema.Struct({CreateConnectionStatus: Schema.optional(Schema.String)});
export const KMSKeyNotAccessibleFault = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateTableRequest = Schema.Struct({CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.String, Name: Schema.optional(Schema.String), TableInput: Schema.optional(TableInput), PartitionIndexes: Schema.optional(PartitionIndexList), TransactionId: Schema.optional(Schema.String), OpenTableFormatInput: Schema.optional(OpenTableFormatInput)});
export const CreateTableResponse = Schema.Struct({});
export const GetTablesResponse = Schema.Struct({TableList: Schema.optional(TableList), NextToken: Schema.optional(Schema.String)});
export const UpdateColumnStatisticsForPartitionResponse = Schema.Struct({Errors: Schema.optional(ColumnStatisticsErrors)});
export const Workflows = Schema.Array(Workflow);
export const BatchGetWorkflowsResponse = Schema.Struct({Workflows: Schema.optional(Workflows), MissingWorkflows: Schema.optional(WorkflowNames)});
export const CreateJobRequest = Schema.Struct({Name: Schema.String, JobMode: Schema.optional(Schema.String), JobRunQueuingEnabled: Schema.optional(Schema.Boolean), Description: Schema.optional(Schema.String), LogUri: Schema.optional(Schema.String), Role: Schema.String, ExecutionProperty: Schema.optional(ExecutionProperty), Command: JobCommand, DefaultArguments: Schema.optional(GenericMap), NonOverridableArguments: Schema.optional(GenericMap), Connections: Schema.optional(ConnectionsList), MaxRetries: Schema.optional(Schema.Number), AllocatedCapacity: Schema.optional(Schema.Number), Timeout: Schema.optional(Schema.Number), MaxCapacity: Schema.optional(Schema.Number), SecurityConfiguration: Schema.optional(Schema.String), Tags: Schema.optional(TagsMap), NotificationProperty: Schema.optional(NotificationProperty), GlueVersion: Schema.optional(Schema.String), NumberOfWorkers: Schema.optional(Schema.Number), WorkerType: Schema.optional(Schema.String), CodeGenConfigurationNodes: Schema.optional(CodeGenConfigurationNodes), ExecutionClass: Schema.optional(Schema.String), SourceControlDetails: Schema.optional(SourceControlDetails), MaintenanceWindow: Schema.optional(Schema.String)});
export const CreateJobResponse = Schema.Struct({Name: Schema.optional(Schema.String)});

//# Errors
export class EntityNotFoundExceptionError extends Schema.TaggedError<EntityNotFoundExceptionError>()("EntityNotFoundException", EntityNotFoundException) {};
export class AccessDeniedExceptionError extends Schema.TaggedError<AccessDeniedExceptionError>()("AccessDeniedException", AccessDeniedException) {};
export class AlreadyExistsExceptionError extends Schema.TaggedError<AlreadyExistsExceptionError>()("AlreadyExistsException", AlreadyExistsException) {};
export class GlueEncryptionExceptionError extends Schema.TaggedError<GlueEncryptionExceptionError>()("GlueEncryptionException", GlueEncryptionException) {};
export class InternalServiceExceptionError extends Schema.TaggedError<InternalServiceExceptionError>()("InternalServiceException", InternalServiceException) {};
export class InvalidInputExceptionError extends Schema.TaggedError<InvalidInputExceptionError>()("InvalidInputException", InvalidInputException) {};
export class OperationTimeoutExceptionError extends Schema.TaggedError<OperationTimeoutExceptionError>()("OperationTimeoutException", OperationTimeoutException) {};
export class ConcurrentModificationExceptionError extends Schema.TaggedError<ConcurrentModificationExceptionError>()("ConcurrentModificationException", ConcurrentModificationException) {};
export class FederationSourceExceptionError extends Schema.TaggedError<FederationSourceExceptionError>()("FederationSourceException", FederationSourceException) {};
export class CrawlerRunningExceptionError extends Schema.TaggedError<CrawlerRunningExceptionError>()("CrawlerRunningException", CrawlerRunningException) {};
export class VersionMismatchExceptionError extends Schema.TaggedError<VersionMismatchExceptionError>()("VersionMismatchException", VersionMismatchException) {};
export class FederationSourceRetryableExceptionError extends Schema.TaggedError<FederationSourceRetryableExceptionError>()("FederationSourceRetryableException", FederationSourceRetryableException) {};
export class InternalServerExceptionError extends Schema.TaggedError<InternalServerExceptionError>()("InternalServerException", InternalServerException) {};
export class ThrottlingExceptionError extends Schema.TaggedError<ThrottlingExceptionError>()("ThrottlingException", ThrottlingException) {};
export class IllegalSessionStateExceptionError extends Schema.TaggedError<IllegalSessionStateExceptionError>()("IllegalSessionStateException", IllegalSessionStateException) {};
export class ResourceNumberLimitExceededExceptionError extends Schema.TaggedError<ResourceNumberLimitExceededExceptionError>()("ResourceNumberLimitExceededException", ResourceNumberLimitExceededException) {};
export class SchedulerTransitioningExceptionError extends Schema.TaggedError<SchedulerTransitioningExceptionError>()("SchedulerTransitioningException", SchedulerTransitioningException) {};
export class ResourceNotFoundExceptionError extends Schema.TaggedError<ResourceNotFoundExceptionError>()("ResourceNotFoundException", ResourceNotFoundException) {};
export class ValidationExceptionError extends Schema.TaggedError<ValidationExceptionError>()("ValidationException", ValidationException) {};
export class ConflictExceptionError extends Schema.TaggedError<ConflictExceptionError>()("ConflictException", ConflictException) {};
export class ConditionCheckFailureExceptionError extends Schema.TaggedError<ConditionCheckFailureExceptionError>()("ConditionCheckFailureException", ConditionCheckFailureException) {};
export class OperationNotSupportedExceptionError extends Schema.TaggedError<OperationNotSupportedExceptionError>()("OperationNotSupportedException", OperationNotSupportedException) {};
export class ColumnStatisticsTaskRunningExceptionError extends Schema.TaggedError<ColumnStatisticsTaskRunningExceptionError>()("ColumnStatisticsTaskRunningException", ColumnStatisticsTaskRunningException) {};
export class NoScheduleExceptionError extends Schema.TaggedError<NoScheduleExceptionError>()("NoScheduleException", NoScheduleException) {};
export class ConcurrentRunsExceededExceptionError extends Schema.TaggedError<ConcurrentRunsExceededExceptionError>()("ConcurrentRunsExceededException", ConcurrentRunsExceededException) {};
export class ColumnStatisticsTaskNotRunningExceptionError extends Schema.TaggedError<ColumnStatisticsTaskNotRunningExceptionError>()("ColumnStatisticsTaskNotRunningException", ColumnStatisticsTaskNotRunningException) {};
export class CrawlerNotRunningExceptionError extends Schema.TaggedError<CrawlerNotRunningExceptionError>()("CrawlerNotRunningException", CrawlerNotRunningException) {};
export class SchedulerNotRunningExceptionError extends Schema.TaggedError<SchedulerNotRunningExceptionError>()("SchedulerNotRunningException", SchedulerNotRunningException) {};
export class IllegalWorkflowStateExceptionError extends Schema.TaggedError<IllegalWorkflowStateExceptionError>()("IllegalWorkflowStateException", IllegalWorkflowStateException) {};
export class IllegalBlueprintStateExceptionError extends Schema.TaggedError<IllegalBlueprintStateExceptionError>()("IllegalBlueprintStateException", IllegalBlueprintStateException) {};
export class IdempotentParameterMismatchExceptionError extends Schema.TaggedError<IdempotentParameterMismatchExceptionError>()("IdempotentParameterMismatchException", IdempotentParameterMismatchException) {};
export class ResourceNotReadyExceptionError extends Schema.TaggedError<ResourceNotReadyExceptionError>()("ResourceNotReadyException", ResourceNotReadyException) {};
export class IntegrationConflictOperationFaultError extends Schema.TaggedError<IntegrationConflictOperationFaultError>()("IntegrationConflictOperationFault", IntegrationConflictOperationFault) {};
export class IntegrationNotFoundFaultError extends Schema.TaggedError<IntegrationNotFoundFaultError>()("IntegrationNotFoundFault", IntegrationNotFoundFault) {};
export class InvalidStateExceptionError extends Schema.TaggedError<InvalidStateExceptionError>()("InvalidStateException", InvalidStateException) {};
export class SchedulerRunningExceptionError extends Schema.TaggedError<SchedulerRunningExceptionError>()("SchedulerRunningException", SchedulerRunningException) {};
export class MLTransformNotReadyExceptionError extends Schema.TaggedError<MLTransformNotReadyExceptionError>()("MLTransformNotReadyException", MLTransformNotReadyException) {};
export class ColumnStatisticsTaskStoppingExceptionError extends Schema.TaggedError<ColumnStatisticsTaskStoppingExceptionError>()("ColumnStatisticsTaskStoppingException", ColumnStatisticsTaskStoppingException) {};
export class CrawlerStoppingExceptionError extends Schema.TaggedError<CrawlerStoppingExceptionError>()("CrawlerStoppingException", CrawlerStoppingException) {};
export class FederatedResourceAlreadyExistsExceptionError extends Schema.TaggedError<FederatedResourceAlreadyExistsExceptionError>()("FederatedResourceAlreadyExistsException", FederatedResourceAlreadyExistsException) {};
export class InvalidIntegrationStateFaultError extends Schema.TaggedError<InvalidIntegrationStateFaultError>()("InvalidIntegrationStateFault", InvalidIntegrationStateFault) {};
export class TargetResourceNotFoundError extends Schema.TaggedError<TargetResourceNotFoundError>()("TargetResourceNotFound", TargetResourceNotFound) {};
export class PermissionTypeMismatchExceptionError extends Schema.TaggedError<PermissionTypeMismatchExceptionError>()("PermissionTypeMismatchException", PermissionTypeMismatchException) {};
export class IntegrationQuotaExceededFaultError extends Schema.TaggedError<IntegrationQuotaExceededFaultError>()("IntegrationQuotaExceededFault", IntegrationQuotaExceededFault) {};
export class KMSKeyNotAccessibleFaultError extends Schema.TaggedError<KMSKeyNotAccessibleFaultError>()("KMSKeyNotAccessibleFault", KMSKeyNotAccessibleFault) {};

//# Operations
export const deleteColumnStatisticsForTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteColumnStatisticsForTable" }, DeleteColumnStatisticsForTableRequest, DeleteColumnStatisticsForTableResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteColumnStatisticsTaskSettings = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteColumnStatisticsTaskSettings" }, DeleteColumnStatisticsTaskSettingsRequest, DeleteColumnStatisticsTaskSettingsResponse, [EntityNotFoundExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteConnection" }, DeleteConnectionRequest, DeleteConnectionResponse, [EntityNotFoundExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteDataQualityRuleset = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteDataQualityRuleset" }, DeleteDataQualityRulesetRequest, DeleteDataQualityRulesetResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteDevEndpoint = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteDevEndpoint" }, DeleteDevEndpointRequest, DeleteDevEndpointResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteGlueIdentityCenterConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteGlueIdentityCenterConfiguration" }, DeleteGlueIdentityCenterConfigurationRequest, DeleteGlueIdentityCenterConfigurationResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deletePartition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeletePartition" }, DeletePartitionRequest, DeletePartitionResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteSecurityConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteSecurityConfiguration" }, DeleteSecurityConfigurationRequest, DeleteSecurityConfigurationResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteTableVersion = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteTableVersion" }, DeleteTableVersionRequest, DeleteTableVersionResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteUserDefinedFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteUserDefinedFunction" }, DeleteUserDefinedFunctionRequest, DeleteUserDefinedFunctionResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getGlueIdentityCenterConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetGlueIdentityCenterConfiguration" }, GetGlueIdentityCenterConfigurationRequest, GetGlueIdentityCenterConfigurationResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const importCatalogToGlue = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ImportCatalogToGlue" }, ImportCatalogToGlueRequest, ImportCatalogToGlueResponse, [InternalServiceExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putDataQualityProfileAnnotation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.PutDataQualityProfileAnnotation" }, PutDataQualityProfileAnnotationRequest, PutDataQualityProfileAnnotationResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startColumnStatisticsTaskRunSchedule = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartColumnStatisticsTaskRunSchedule" }, StartColumnStatisticsTaskRunScheduleRequest, StartColumnStatisticsTaskRunScheduleResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startCrawler = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartCrawler" }, StartCrawlerRequest, StartCrawlerResponse, [CrawlerRunningExceptionError, EntityNotFoundExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const stopColumnStatisticsTaskRunSchedule = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StopColumnStatisticsTaskRunSchedule" }, StopColumnStatisticsTaskRunScheduleRequest, StopColumnStatisticsTaskRunScheduleResponse, [EntityNotFoundExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const tagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.TagResource" }, TagResourceRequest, TagResourceResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const untagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UntagResource" }, UntagResourceRequest, UntagResourceResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateCatalog = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateCatalog" }, UpdateCatalogRequest, UpdateCatalogResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, FederationSourceExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateConnection" }, UpdateConnectionRequest, UpdateConnectionResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateCrawler = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateCrawler" }, UpdateCrawlerRequest, UpdateCrawlerResponse, [CrawlerRunningExceptionError, EntityNotFoundExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, VersionMismatchExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateDatabase = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateDatabase" }, UpdateDatabaseRequest, UpdateDatabaseResponse, [AlreadyExistsExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateGlueIdentityCenterConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateGlueIdentityCenterConfiguration" }, UpdateGlueIdentityCenterConfigurationRequest, UpdateGlueIdentityCenterConfigurationResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updatePartition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdatePartition" }, UpdatePartitionRequest, UpdatePartitionResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateUserDefinedFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateUserDefinedFunction" }, UpdateUserDefinedFunctionRequest, UpdateUserDefinedFunctionResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const cancelDataQualityRuleRecommendationRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CancelDataQualityRuleRecommendationRun" }, CancelDataQualityRuleRecommendationRunRequest, CancelDataQualityRuleRecommendationRunResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const cancelDataQualityRulesetEvaluationRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CancelDataQualityRulesetEvaluationRun" }, CancelDataQualityRulesetEvaluationRunRequest, CancelDataQualityRulesetEvaluationRunResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const cancelMLTaskRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CancelMLTaskRun" }, CancelMLTaskRunRequest, CancelMLTaskRunResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const cancelStatement = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CancelStatement" }, CancelStatementRequest, CancelStatementResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, IllegalSessionStateExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const checkSchemaVersionValidity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CheckSchemaVersionValidity" }, CheckSchemaVersionValidityInput, CheckSchemaVersionValidityResponse, [AccessDeniedExceptionError, InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createClassifier = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateClassifier" }, CreateClassifierRequest, CreateClassifierResponse, [AlreadyExistsExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createGlueIdentityCenterConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateGlueIdentityCenterConfiguration" }, CreateGlueIdentityCenterConfigurationRequest, CreateGlueIdentityCenterConfigurationResponse, [AccessDeniedExceptionError, AlreadyExistsExceptionError, ConcurrentModificationExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createPartition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreatePartition" }, CreatePartitionRequest, CreatePartitionResponse, [AlreadyExistsExceptionError, EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createPartitionIndex = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreatePartitionIndex" }, CreatePartitionIndexRequest, CreatePartitionIndexResponse, [AlreadyExistsExceptionError, EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createRegistry = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateRegistry" }, CreateRegistryInput, CreateRegistryResponse, [AccessDeniedExceptionError, AlreadyExistsExceptionError, ConcurrentModificationExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteBlueprint = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteBlueprint" }, DeleteBlueprintRequest, DeleteBlueprintResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteCatalog = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteCatalog" }, DeleteCatalogRequest, DeleteCatalogResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, FederationSourceExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteClassifier = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteClassifier" }, DeleteClassifierRequest, DeleteClassifierResponse, [EntityNotFoundExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteColumnStatisticsForPartition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteColumnStatisticsForPartition" }, DeleteColumnStatisticsForPartitionRequest, DeleteColumnStatisticsForPartitionResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteCrawler = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteCrawler" }, DeleteCrawlerRequest, DeleteCrawlerResponse, [CrawlerRunningExceptionError, EntityNotFoundExceptionError, OperationTimeoutExceptionError, SchedulerTransitioningExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteCustomEntityType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteCustomEntityType" }, DeleteCustomEntityTypeRequest, DeleteCustomEntityTypeResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteDatabase = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteDatabase" }, DeleteDatabaseRequest, DeleteDatabaseResponse, [ConcurrentModificationExceptionError, EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteIntegrationTableProperties = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteIntegrationTableProperties" }, DeleteIntegrationTablePropertiesRequest, DeleteIntegrationTablePropertiesResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServerExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteJob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteJob" }, DeleteJobRequest, DeleteJobResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteMLTransform = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteMLTransform" }, DeleteMLTransformRequest, DeleteMLTransformResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deletePartitionIndex = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeletePartitionIndex" }, DeletePartitionIndexRequest, DeletePartitionIndexResponse, [ConflictExceptionError, EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteRegistry = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteRegistry" }, DeleteRegistryInput, DeleteRegistryResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteResourcePolicy" }, DeleteResourcePolicyRequest, DeleteResourcePolicyResponse, [ConditionCheckFailureExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteSession = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteSession" }, DeleteSessionRequest, DeleteSessionResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, IllegalSessionStateExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteTableOptimizer = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteTableOptimizer" }, DeleteTableOptimizerRequest, DeleteTableOptimizerResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ThrottlingExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteTrigger = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteTrigger" }, DeleteTriggerRequest, DeleteTriggerResponse, [ConcurrentModificationExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteUsageProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteUsageProfile" }, DeleteUsageProfileRequest, DeleteUsageProfileResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationNotSupportedExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteWorkflow = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteWorkflow" }, DeleteWorkflowRequest, DeleteWorkflowResponse, [ConcurrentModificationExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getBlueprint = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetBlueprint" }, GetBlueprintRequest, GetBlueprintResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getBlueprintRuns = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetBlueprintRuns" }, GetBlueprintRunsRequest, GetBlueprintRunsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getCatalogs = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetCatalogs" }, GetCatalogsRequest, GetCatalogsResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getClassifiers = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetClassifiers" }, GetClassifiersRequest, GetClassifiersResponse, [OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getColumnStatisticsForTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetColumnStatisticsForTable" }, GetColumnStatisticsForTableRequest, GetColumnStatisticsForTableResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getColumnStatisticsTaskRuns = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetColumnStatisticsTaskRuns" }, GetColumnStatisticsTaskRunsRequest, GetColumnStatisticsTaskRunsResponse, [OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getCrawler = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetCrawler" }, GetCrawlerRequest, GetCrawlerResponse, [EntityNotFoundExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getCrawlers = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetCrawlers" }, GetCrawlersRequest, GetCrawlersResponse, [OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getCustomEntityType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetCustomEntityType" }, GetCustomEntityTypeRequest, GetCustomEntityTypeResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getDatabases = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetDatabases" }, GetDatabasesRequest, GetDatabasesResponse, [EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getDataCatalogEncryptionSettings = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetDataCatalogEncryptionSettings" }, GetDataCatalogEncryptionSettingsRequest, GetDataCatalogEncryptionSettingsResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getDataflowGraph = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetDataflowGraph" }, GetDataflowGraphRequest, GetDataflowGraphResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getDataQualityModel = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetDataQualityModel" }, GetDataQualityModelRequest, GetDataQualityModelResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getDataQualityRuleRecommendationRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetDataQualityRuleRecommendationRun" }, GetDataQualityRuleRecommendationRunRequest, GetDataQualityRuleRecommendationRunResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getDataQualityRuleset = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetDataQualityRuleset" }, GetDataQualityRulesetRequest, GetDataQualityRulesetResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getDataQualityRulesetEvaluationRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetDataQualityRulesetEvaluationRun" }, GetDataQualityRulesetEvaluationRunRequest, GetDataQualityRulesetEvaluationRunResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getDevEndpoint = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetDevEndpoint" }, GetDevEndpointRequest, GetDevEndpointResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getDevEndpoints = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetDevEndpoints" }, GetDevEndpointsRequest, GetDevEndpointsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getIntegrationResourceProperty = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetIntegrationResourceProperty" }, GetIntegrationResourcePropertyRequest, GetIntegrationResourcePropertyResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServerExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getIntegrationTableProperties = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetIntegrationTableProperties" }, GetIntegrationTablePropertiesRequest, GetIntegrationTablePropertiesResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServerExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getJob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetJob" }, GetJobRequest, GetJobResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getJobRuns = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetJobRuns" }, GetJobRunsRequest, GetJobRunsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getJobs = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetJobs" }, GetJobsRequest, GetJobsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getPartition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetPartition" }, GetPartitionRequest, GetPartitionResponse, [EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getRegistry = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetRegistry" }, GetRegistryInput, GetRegistryResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetResourcePolicy" }, GetResourcePolicyRequest, GetResourcePolicyResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getSchema = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetSchema" }, GetSchemaInput, GetSchemaResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getSchemaByDefinition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetSchemaByDefinition" }, GetSchemaByDefinitionInput, GetSchemaByDefinitionResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getSchemaVersionsDiff = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetSchemaVersionsDiff" }, GetSchemaVersionsDiffInput, GetSchemaVersionsDiffResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getSecurityConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetSecurityConfigurations" }, GetSecurityConfigurationsRequest, GetSecurityConfigurationsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getTableVersions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetTableVersions" }, GetTableVersionsRequest, GetTableVersionsResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getTags = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetTags" }, GetTagsRequest, GetTagsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getTrigger = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetTrigger" }, GetTriggerRequest, GetTriggerResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getTriggers = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetTriggers" }, GetTriggersRequest, GetTriggersResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getUsageProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetUsageProfile" }, GetUsageProfileRequest, GetUsageProfileResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationNotSupportedExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getUserDefinedFunctions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetUserDefinedFunctions" }, GetUserDefinedFunctionsRequest, GetUserDefinedFunctionsResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getWorkflow = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetWorkflow" }, GetWorkflowRequest, GetWorkflowResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getWorkflowRunProperties = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetWorkflowRunProperties" }, GetWorkflowRunPropertiesRequest, GetWorkflowRunPropertiesResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getWorkflowRuns = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetWorkflowRuns" }, GetWorkflowRunsRequest, GetWorkflowRunsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listBlueprints = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListBlueprints" }, ListBlueprintsRequest, ListBlueprintsResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listColumnStatisticsTaskRuns = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListColumnStatisticsTaskRuns" }, ListColumnStatisticsTaskRunsRequest, ListColumnStatisticsTaskRunsResponse, [OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listCrawlers = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListCrawlers" }, ListCrawlersRequest, ListCrawlersResponse, [OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listCustomEntityTypes = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListCustomEntityTypes" }, ListCustomEntityTypesRequest, ListCustomEntityTypesResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listDevEndpoints = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListDevEndpoints" }, ListDevEndpointsRequest, ListDevEndpointsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listJobs = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListJobs" }, ListJobsRequest, ListJobsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listMLTransforms = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListMLTransforms" }, ListMLTransformsRequest, ListMLTransformsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listSessions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListSessions" }, ListSessionsRequest, ListSessionsResponse, [AccessDeniedExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listStatements = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListStatements" }, ListStatementsRequest, ListStatementsResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, IllegalSessionStateExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listTriggers = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListTriggers" }, ListTriggersRequest, ListTriggersResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listWorkflows = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListWorkflows" }, ListWorkflowsRequest, ListWorkflowsResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.PutResourcePolicy" }, PutResourcePolicyRequest, PutResourcePolicyResponse, [ConditionCheckFailureExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putWorkflowRunProperties = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.PutWorkflowRunProperties" }, PutWorkflowRunPropertiesRequest, PutWorkflowRunPropertiesResponse, [AlreadyExistsExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const registerSchemaVersion = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.RegisterSchemaVersion" }, RegisterSchemaVersionInput, RegisterSchemaVersionResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const removeSchemaVersionMetadata = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.RemoveSchemaVersionMetadata" }, RemoveSchemaVersionMetadataInput, RemoveSchemaVersionMetadataResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const resetJobBookmark = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ResetJobBookmark" }, ResetJobBookmarkRequest, ResetJobBookmarkResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const runStatement = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.RunStatement" }, RunStatementRequest, RunStatementResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, IllegalSessionStateExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startColumnStatisticsTaskRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartColumnStatisticsTaskRun" }, StartColumnStatisticsTaskRunRequest, StartColumnStatisticsTaskRunResponse, [AccessDeniedExceptionError, ColumnStatisticsTaskRunningExceptionError, EntityNotFoundExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startExportLabelsTaskRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartExportLabelsTaskRun" }, StartExportLabelsTaskRunRequest, StartExportLabelsTaskRunResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startImportLabelsTaskRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartImportLabelsTaskRun" }, StartImportLabelsTaskRunRequest, StartImportLabelsTaskRunResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startJobRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartJobRun" }, StartJobRunRequest, StartJobRunResponse, [ConcurrentRunsExceededExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startMLLabelingSetGenerationTaskRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartMLLabelingSetGenerationTaskRun" }, StartMLLabelingSetGenerationTaskRunRequest, StartMLLabelingSetGenerationTaskRunResponse, [ConcurrentRunsExceededExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startTrigger = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartTrigger" }, StartTriggerRequest, StartTriggerResponse, [ConcurrentRunsExceededExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startWorkflowRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartWorkflowRun" }, StartWorkflowRunRequest, StartWorkflowRunResponse, [ConcurrentRunsExceededExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const stopCrawlerSchedule = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StopCrawlerSchedule" }, StopCrawlerScheduleRequest, StopCrawlerScheduleResponse, [EntityNotFoundExceptionError, OperationTimeoutExceptionError, SchedulerNotRunningExceptionError, SchedulerTransitioningExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const stopSession = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StopSession" }, StopSessionRequest, StopSessionResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, IllegalSessionStateExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const stopTrigger = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StopTrigger" }, StopTriggerRequest, StopTriggerResponse, [ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const stopWorkflowRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StopWorkflowRun" }, StopWorkflowRunRequest, StopWorkflowRunResponse, [EntityNotFoundExceptionError, IllegalWorkflowStateExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const testConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.TestConnection" }, TestConnectionRequest, TestConnectionResponse, [AccessDeniedExceptionError, ConflictExceptionError, EntityNotFoundExceptionError, FederationSourceExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateBlueprint = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateBlueprint" }, UpdateBlueprintRequest, UpdateBlueprintResponse, [ConcurrentModificationExceptionError, EntityNotFoundExceptionError, IllegalBlueprintStateExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateClassifier = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateClassifier" }, UpdateClassifierRequest, UpdateClassifierResponse, [EntityNotFoundExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, VersionMismatchExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateColumnStatisticsTaskSettings = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateColumnStatisticsTaskSettings" }, UpdateColumnStatisticsTaskSettingsRequest, UpdateColumnStatisticsTaskSettingsResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, VersionMismatchExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateCrawlerSchedule = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateCrawlerSchedule" }, UpdateCrawlerScheduleRequest, UpdateCrawlerScheduleResponse, [EntityNotFoundExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, SchedulerTransitioningExceptionError, VersionMismatchExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateDataQualityRuleset = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateDataQualityRuleset" }, UpdateDataQualityRulesetRequest, UpdateDataQualityRulesetResponse, [AlreadyExistsExceptionError, EntityNotFoundExceptionError, IdempotentParameterMismatchExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateDevEndpoint = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateDevEndpoint" }, UpdateDevEndpointRequest, UpdateDevEndpointResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateIntegrationResourceProperty = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateIntegrationResourceProperty" }, UpdateIntegrationResourcePropertyRequest, UpdateIntegrationResourcePropertyResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServerExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateIntegrationTableProperties = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateIntegrationTableProperties" }, UpdateIntegrationTablePropertiesRequest, UpdateIntegrationTablePropertiesResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServerExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateJobFromSourceControl = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateJobFromSourceControl" }, UpdateJobFromSourceControlRequest, UpdateJobFromSourceControlResponse, [AccessDeniedExceptionError, AlreadyExistsExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateMLTransform = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateMLTransform" }, UpdateMLTransformRequest, UpdateMLTransformResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateRegistry = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateRegistry" }, UpdateRegistryInput, UpdateRegistryResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateSchema = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateSchema" }, UpdateSchemaInput, UpdateSchemaResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateSourceControlFromJob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateSourceControlFromJob" }, UpdateSourceControlFromJobRequest, UpdateSourceControlFromJobResponse, [AccessDeniedExceptionError, AlreadyExistsExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateTableOptimizer = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateTableOptimizer" }, UpdateTableOptimizerRequest, UpdateTableOptimizerResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateUsageProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateUsageProfile" }, UpdateUsageProfileRequest, UpdateUsageProfileResponse, [ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationNotSupportedExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateWorkflow = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateWorkflow" }, UpdateWorkflowRequest, UpdateWorkflowResponse, [ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchDeleteTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchDeleteTable" }, BatchDeleteTableRequest, BatchDeleteTableResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNotReadyExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchDeleteTableVersion = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchDeleteTableVersion" }, BatchDeleteTableVersionRequest, BatchDeleteTableVersionResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchGetCustomEntityTypes = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchGetCustomEntityTypes" }, BatchGetCustomEntityTypesRequest, BatchGetCustomEntityTypesResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchGetDataQualityResult = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchGetDataQualityResult" }, BatchGetDataQualityResultRequest, BatchGetDataQualityResultResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchGetDevEndpoints = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchGetDevEndpoints" }, BatchGetDevEndpointsRequest, BatchGetDevEndpointsResponse, [AccessDeniedExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchGetJobs = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchGetJobs" }, BatchGetJobsRequest, BatchGetJobsResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchGetTriggers = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchGetTriggers" }, BatchGetTriggersRequest, BatchGetTriggersResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchStopJobRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchStopJobRun" }, BatchStopJobRunRequest, BatchStopJobRunResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createBlueprint = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateBlueprint" }, CreateBlueprintRequest, CreateBlueprintResponse, [AlreadyExistsExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createColumnStatisticsTaskSettings = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateColumnStatisticsTaskSettings" }, CreateColumnStatisticsTaskSettingsRequest, CreateColumnStatisticsTaskSettingsResponse, [AccessDeniedExceptionError, AlreadyExistsExceptionError, ColumnStatisticsTaskRunningExceptionError, EntityNotFoundExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createCrawler = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateCrawler" }, CreateCrawlerRequest, CreateCrawlerResponse, [AlreadyExistsExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createCustomEntityType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateCustomEntityType" }, CreateCustomEntityTypeRequest, CreateCustomEntityTypeResponse, [AccessDeniedExceptionError, AlreadyExistsExceptionError, IdempotentParameterMismatchExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createDataQualityRuleset = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateDataQualityRuleset" }, CreateDataQualityRulesetRequest, CreateDataQualityRulesetResponse, [AlreadyExistsExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createDevEndpoint = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateDevEndpoint" }, CreateDevEndpointRequest, CreateDevEndpointResponse, [AccessDeniedExceptionError, AlreadyExistsExceptionError, IdempotentParameterMismatchExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createIntegrationResourceProperty = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateIntegrationResourceProperty" }, CreateIntegrationResourcePropertyRequest, CreateIntegrationResourcePropertyResponse, [AccessDeniedExceptionError, ConflictExceptionError, EntityNotFoundExceptionError, InternalServerExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createIntegrationTableProperties = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateIntegrationTableProperties" }, CreateIntegrationTablePropertiesRequest, CreateIntegrationTablePropertiesResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServerExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createSchema = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateSchema" }, CreateSchemaInput, CreateSchemaResponse, [AccessDeniedExceptionError, AlreadyExistsExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createSession = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateSession" }, CreateSessionRequest, CreateSessionResponse, [AccessDeniedExceptionError, AlreadyExistsExceptionError, IdempotentParameterMismatchExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createUserDefinedFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateUserDefinedFunction" }, CreateUserDefinedFunctionRequest, CreateUserDefinedFunctionResponse, [AlreadyExistsExceptionError, EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createWorkflow = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateWorkflow" }, CreateWorkflowRequest, CreateWorkflowResponse, [AlreadyExistsExceptionError, ConcurrentModificationExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteSchema = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteSchema" }, DeleteSchemaInput, DeleteSchemaResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteTable" }, DeleteTableRequest, DeleteTableResponse, [ConcurrentModificationExceptionError, EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNotReadyExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getBlueprintRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetBlueprintRun" }, GetBlueprintRunRequest, GetBlueprintRunResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getCatalogImportStatus = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetCatalogImportStatus" }, GetCatalogImportStatusRequest, GetCatalogImportStatusResponse, [InternalServiceExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getColumnStatisticsForPartition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetColumnStatisticsForPartition" }, GetColumnStatisticsForPartitionRequest, GetColumnStatisticsForPartitionResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getColumnStatisticsTaskRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetColumnStatisticsTaskRun" }, GetColumnStatisticsTaskRunRequest, GetColumnStatisticsTaskRunResponse, [EntityNotFoundExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getConnections = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetConnections" }, GetConnectionsRequest, GetConnectionsResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getCrawlerMetrics = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetCrawlerMetrics" }, GetCrawlerMetricsRequest, GetCrawlerMetricsResponse, [OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getDatabase = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetDatabase" }, GetDatabaseRequest, GetDatabaseResponse, [EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getDataQualityModelResult = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetDataQualityModelResult" }, GetDataQualityModelResultRequest, GetDataQualityModelResultResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getEntityRecords = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetEntityRecords" }, GetEntityRecordsRequest, GetEntityRecordsResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, FederationSourceExceptionError, GlueEncryptionExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getJobBookmark = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetJobBookmark" }, GetJobBookmarkRequest, GetJobBookmarkResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getMapping = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetMapping" }, GetMappingRequest, GetMappingResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getPartitions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetPartitions" }, GetPartitionsRequest, GetPartitionsResponse, [EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, InvalidStateExceptionError, OperationTimeoutExceptionError, ResourceNotReadyExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getPlan = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetPlan" }, GetPlanRequest, GetPlanResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getResourcePolicies = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetResourcePolicies" }, GetResourcePoliciesRequest, GetResourcePoliciesResponse, [GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getSchemaVersion = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetSchemaVersion" }, GetSchemaVersionInput, GetSchemaVersionResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getSecurityConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetSecurityConfiguration" }, GetSecurityConfigurationRequest, GetSecurityConfigurationResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getSession = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetSession" }, GetSessionRequest, GetSessionResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetTable" }, GetTableRequest, GetTableResponse, [EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNotReadyExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getTableOptimizer = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetTableOptimizer" }, GetTableOptimizerRequest, GetTableOptimizerResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ThrottlingExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getTableVersion = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetTableVersion" }, GetTableVersionRequest, GetTableVersionResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getUserDefinedFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetUserDefinedFunction" }, GetUserDefinedFunctionRequest, GetUserDefinedFunctionResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listEntities = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListEntities" }, ListEntitiesRequest, ListEntitiesResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, FederationSourceExceptionError, GlueEncryptionExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listRegistries = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListRegistries" }, ListRegistriesInput, ListRegistriesResponse, [AccessDeniedExceptionError, InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listSchemas = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListSchemas" }, ListSchemasInput, ListSchemasResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listSchemaVersions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListSchemaVersions" }, ListSchemaVersionsInput, ListSchemaVersionsResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listUsageProfiles = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListUsageProfiles" }, ListUsageProfilesRequest, ListUsageProfilesResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationNotSupportedExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putDataCatalogEncryptionSettings = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.PutDataCatalogEncryptionSettings" }, PutDataCatalogEncryptionSettingsRequest, PutDataCatalogEncryptionSettingsResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putSchemaVersionMetadata = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.PutSchemaVersionMetadata" }, PutSchemaVersionMetadataInput, PutSchemaVersionMetadataResponse, [AccessDeniedExceptionError, AlreadyExistsExceptionError, EntityNotFoundExceptionError, InvalidInputExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const resumeWorkflowRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ResumeWorkflowRun" }, ResumeWorkflowRunRequest, ResumeWorkflowRunResponse, [ConcurrentRunsExceededExceptionError, EntityNotFoundExceptionError, IllegalWorkflowStateExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const searchTables = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.SearchTables" }, SearchTablesRequest, SearchTablesResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startBlueprintRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartBlueprintRun" }, StartBlueprintRunRequest, StartBlueprintRunResponse, [EntityNotFoundExceptionError, IllegalBlueprintStateExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startCrawlerSchedule = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartCrawlerSchedule" }, StartCrawlerScheduleRequest, StartCrawlerScheduleResponse, [EntityNotFoundExceptionError, NoScheduleExceptionError, OperationTimeoutExceptionError, SchedulerRunningExceptionError, SchedulerTransitioningExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startDataQualityRulesetEvaluationRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartDataQualityRulesetEvaluationRun" }, StartDataQualityRulesetEvaluationRunRequest, StartDataQualityRulesetEvaluationRunResponse, [ConflictExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startMLEvaluationTaskRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartMLEvaluationTaskRun" }, StartMLEvaluationTaskRunRequest, StartMLEvaluationTaskRunResponse, [ConcurrentRunsExceededExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, MLTransformNotReadyExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const stopColumnStatisticsTaskRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StopColumnStatisticsTaskRun" }, StopColumnStatisticsTaskRunRequest, StopColumnStatisticsTaskRunResponse, [ColumnStatisticsTaskNotRunningExceptionError, ColumnStatisticsTaskStoppingExceptionError, EntityNotFoundExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const stopCrawler = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StopCrawler" }, StopCrawlerRequest, StopCrawlerResponse, [CrawlerNotRunningExceptionError, CrawlerStoppingExceptionError, EntityNotFoundExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateColumnStatisticsForTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateColumnStatisticsForTable" }, UpdateColumnStatisticsForTableRequest, UpdateColumnStatisticsForTableResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateJob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateJob" }, UpdateJobRequest, UpdateJobResponse, [ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateTrigger = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateTrigger" }, UpdateTriggerRequest, UpdateTriggerResponse, [ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchDeleteConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchDeleteConnection" }, BatchDeleteConnectionRequest, BatchDeleteConnectionResponse, [InternalServiceExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchDeletePartition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchDeletePartition" }, BatchDeletePartitionRequest, BatchDeletePartitionResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchGetBlueprints = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchGetBlueprints" }, BatchGetBlueprintsRequest, BatchGetBlueprintsResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchGetCrawlers = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchGetCrawlers" }, BatchGetCrawlersRequest, BatchGetCrawlersResponse, [InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchGetPartition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchGetPartition" }, BatchGetPartitionRequest, BatchGetPartitionResponse, [EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, InvalidStateExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchGetTableOptimizer = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchGetTableOptimizer" }, BatchGetTableOptimizerRequest, BatchGetTableOptimizerResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ThrottlingExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchPutDataQualityStatisticAnnotation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchPutDataQualityStatisticAnnotation" }, BatchPutDataQualityStatisticAnnotationRequest, BatchPutDataQualityStatisticAnnotationResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchUpdatePartition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchUpdatePartition" }, BatchUpdatePartitionRequest, BatchUpdatePartitionResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createCatalog = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateCatalog" }, CreateCatalogRequest, CreateCatalogResponse, [AccessDeniedExceptionError, AlreadyExistsExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, FederatedResourceAlreadyExistsExceptionError, FederationSourceExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createDatabase = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateDatabase" }, CreateDatabaseRequest, CreateDatabaseResponse, [AlreadyExistsExceptionError, ConcurrentModificationExceptionError, FederatedResourceAlreadyExistsExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createMLTransform = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateMLTransform" }, CreateMLTransformRequest, CreateMLTransformResponse, [AccessDeniedExceptionError, AlreadyExistsExceptionError, IdempotentParameterMismatchExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createScript = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateScript" }, CreateScriptRequest, CreateScriptResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createSecurityConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateSecurityConfiguration" }, CreateSecurityConfigurationRequest, CreateSecurityConfigurationResponse, [AlreadyExistsExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createTableOptimizer = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateTableOptimizer" }, CreateTableOptimizerRequest, CreateTableOptimizerResponse, [AccessDeniedExceptionError, AlreadyExistsExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createTrigger = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateTrigger" }, CreateTriggerRequest, CreateTriggerResponse, [AlreadyExistsExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, IdempotentParameterMismatchExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteIntegration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteIntegration" }, DeleteIntegrationRequest, DeleteIntegrationResponse, [AccessDeniedExceptionError, ConflictExceptionError, EntityNotFoundExceptionError, IntegrationConflictOperationFaultError, IntegrationNotFoundFaultError, InternalServerExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, InvalidIntegrationStateFaultError, InvalidStateExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteSchemaVersions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DeleteSchemaVersions" }, DeleteSchemaVersionsInput, DeleteSchemaVersionsResponse, [AccessDeniedExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeEntity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DescribeEntity" }, DescribeEntityRequest, DescribeEntityResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, FederationSourceExceptionError, GlueEncryptionExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeInboundIntegrations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DescribeInboundIntegrations" }, DescribeInboundIntegrationsRequest, DescribeInboundIntegrationsResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, IntegrationNotFoundFaultError, InternalServerExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationNotSupportedExceptionError, TargetResourceNotFoundError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeIntegrations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DescribeIntegrations" }, DescribeIntegrationsRequest, DescribeIntegrationsResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, IntegrationNotFoundFaultError, InternalServerExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getClassifier = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetClassifier" }, GetClassifierRequest, GetClassifierResponse, [EntityNotFoundExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getColumnStatisticsTaskSettings = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetColumnStatisticsTaskSettings" }, GetColumnStatisticsTaskSettingsRequest, GetColumnStatisticsTaskSettingsResponse, [EntityNotFoundExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getJobRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetJobRun" }, GetJobRunRequest, GetJobRunResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getMLTaskRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetMLTaskRun" }, GetMLTaskRunRequest, GetMLTaskRunResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getMLTaskRuns = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetMLTaskRuns" }, GetMLTaskRunsRequest, GetMLTaskRunsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getPartitionIndexes = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetPartitionIndexes" }, GetPartitionIndexesRequest, GetPartitionIndexesResponse, [ConflictExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getUnfilteredPartitionMetadata = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetUnfilteredPartitionMetadata" }, GetUnfilteredPartitionMetadataRequest, GetUnfilteredPartitionMetadataResponse, [EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, PermissionTypeMismatchExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getUnfilteredPartitionsMetadata = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetUnfilteredPartitionsMetadata" }, GetUnfilteredPartitionsMetadataRequest, GetUnfilteredPartitionsMetadataResponse, [EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, PermissionTypeMismatchExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getUnfilteredTableMetadata = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetUnfilteredTableMetadata" }, GetUnfilteredTableMetadataRequest, GetUnfilteredTableMetadataResponse, [EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, PermissionTypeMismatchExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getWorkflowRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetWorkflowRun" }, GetWorkflowRunRequest, GetWorkflowRunResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listConnectionTypes = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListConnectionTypes" }, ListConnectionTypesRequest, ListConnectionTypesResponse, [AccessDeniedExceptionError, InternalServiceExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listCrawls = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListCrawls" }, ListCrawlsRequest, ListCrawlsResponse, [EntityNotFoundExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listDataQualityResults = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListDataQualityResults" }, ListDataQualityResultsRequest, ListDataQualityResultsResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listDataQualityRuleRecommendationRuns = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListDataQualityRuleRecommendationRuns" }, ListDataQualityRuleRecommendationRunsRequest, ListDataQualityRuleRecommendationRunsResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listDataQualityRulesetEvaluationRuns = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListDataQualityRulesetEvaluationRuns" }, ListDataQualityRulesetEvaluationRunsRequest, ListDataQualityRulesetEvaluationRunsResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listDataQualityRulesets = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListDataQualityRulesets" }, ListDataQualityRulesetsRequest, ListDataQualityRulesetsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listDataQualityStatisticAnnotations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListDataQualityStatisticAnnotations" }, ListDataQualityStatisticAnnotationsRequest, ListDataQualityStatisticAnnotationsResponse, [InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listDataQualityStatistics = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListDataQualityStatistics" }, ListDataQualityStatisticsRequest, ListDataQualityStatisticsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const modifyIntegration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ModifyIntegration" }, ModifyIntegrationRequest, ModifyIntegrationResponse, [AccessDeniedExceptionError, ConflictExceptionError, EntityNotFoundExceptionError, IntegrationConflictOperationFaultError, IntegrationNotFoundFaultError, InternalServerExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, InvalidIntegrationStateFaultError, InvalidStateExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startDataQualityRuleRecommendationRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.StartDataQualityRuleRecommendationRun" }, StartDataQualityRuleRecommendationRunRequest, StartDataQualityRuleRecommendationRunResponse, [ConflictExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createUsageProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateUsageProfile" }, CreateUsageProfileRequest, CreateUsageProfileResponse, [AlreadyExistsExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationNotSupportedExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeConnectionType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.DescribeConnectionType" }, DescribeConnectionTypeRequest, DescribeConnectionTypeResponse, [AccessDeniedExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getCatalog = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetCatalog" }, GetCatalogRequest, GetCatalogResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetConnection" }, GetConnectionRequest, GetConnectionResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getDataQualityResult = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetDataQualityResult" }, GetDataQualityResultRequest, GetDataQualityResultResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getMLTransform = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetMLTransform" }, GetMLTransformRequest, GetMLTransformResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getMLTransforms = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetMLTransforms" }, GetMLTransformsRequest, GetMLTransformsResponse, [EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getStatement = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetStatement" }, GetStatementRequest, GetStatementResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, IllegalSessionStateExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listTableOptimizerRuns = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.ListTableOptimizerRuns" }, ListTableOptimizerRunsRequest, ListTableOptimizerRunsResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const querySchemaVersionMetadata = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.QuerySchemaVersionMetadata" }, QuerySchemaVersionMetadataInput, QuerySchemaVersionMetadataResponse, [AccessDeniedExceptionError, EntityNotFoundExceptionError, InvalidInputExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateTable" }, UpdateTableRequest, UpdateTableResponse, [AlreadyExistsExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNotReadyExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchCreatePartition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchCreatePartition" }, BatchCreatePartitionRequest, BatchCreatePartitionResponse, [AlreadyExistsExceptionError, EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createConnection = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateConnection" }, CreateConnectionRequest, CreateConnectionResponse, [AlreadyExistsExceptionError, GlueEncryptionExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createIntegration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateIntegration" }, CreateIntegrationRequest, CreateIntegrationResponse, [AccessDeniedExceptionError, ConflictExceptionError, EntityNotFoundExceptionError, IntegrationConflictOperationFaultError, IntegrationQuotaExceededFaultError, InternalServerExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, KMSKeyNotAccessibleFaultError, ResourceNotFoundExceptionError, ResourceNumberLimitExceededExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createTable = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateTable" }, CreateTableRequest, CreateTableResponse, [AlreadyExistsExceptionError, ConcurrentModificationExceptionError, EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNotReadyExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getTables = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.GetTables" }, GetTablesRequest, GetTablesResponse, [EntityNotFoundExceptionError, FederationSourceExceptionError, FederationSourceRetryableExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateColumnStatisticsForPartition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.UpdateColumnStatisticsForPartition" }, UpdateColumnStatisticsForPartitionRequest, UpdateColumnStatisticsForPartitionResponse, [EntityNotFoundExceptionError, GlueEncryptionExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchGetWorkflows = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.BatchGetWorkflows" }, BatchGetWorkflowsRequest, BatchGetWorkflowsResponse, [InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createJob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-03-31", uri: "/", method: "POST", sdkId: "Glue", sigV4ServiceName: "glue", name: "AWSGlue.CreateJob" }, CreateJobRequest, CreateJobResponse, [AlreadyExistsExceptionError, ConcurrentModificationExceptionError, IdempotentParameterMismatchExceptionError, InternalServiceExceptionError, InvalidInputExceptionError, OperationTimeoutExceptionError, ResourceNumberLimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
