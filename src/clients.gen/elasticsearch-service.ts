import { Schema} from "effect"
import { FormatXMLRequest, FormatXMLResponse, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
const DomainNameList = Schema.Array(Schema.String)
const VpcEndpointIdList = Schema.Array(Schema.String)
const StringList = Schema.Array(Schema.String)
const AcceptInboundCrossClusterSearchConnectionRequest = Schema.Struct({CrossClusterSearchConnectionId: Schema.String})
const AssociatePackageRequest = Schema.Struct({PackageID: Schema.String, DomainName: Schema.String})
const AuthorizeVpcEndpointAccessRequest = Schema.Struct({DomainName: Schema.String, Account: Schema.String})
const CancelDomainConfigChangeRequest = Schema.Struct({DomainName: Schema.String, DryRun: Schema.optional(Schema.Boolean)})
const CancelElasticsearchServiceSoftwareUpdateRequest = Schema.Struct({DomainName: Schema.String})
const CreateVpcEndpointRequest = Schema.Struct({DomainArn: Schema.String, VpcOptions: VPCOptions, ClientToken: Schema.optional(Schema.String)})
const DeleteElasticsearchDomainRequest = Schema.Struct({DomainName: Schema.String})
const BaseException = Schema.Struct({message: Schema.optional(Schema.String)})
const DeleteInboundCrossClusterSearchConnectionRequest = Schema.Struct({CrossClusterSearchConnectionId: Schema.String})
const DeleteOutboundCrossClusterSearchConnectionRequest = Schema.Struct({CrossClusterSearchConnectionId: Schema.String})
const DeletePackageRequest = Schema.Struct({PackageID: Schema.String})
const DeleteVpcEndpointRequest = Schema.Struct({VpcEndpointId: Schema.String})
const DescribeDomainAutoTunesRequest = Schema.Struct({DomainName: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const DescribeDomainChangeProgressRequest = Schema.Struct({DomainName: Schema.String, ChangeId: Schema.optional(Schema.String)})
const DescribeElasticsearchDomainRequest = Schema.Struct({DomainName: Schema.String})
const DescribeElasticsearchDomainConfigRequest = Schema.Struct({DomainName: Schema.String})
const DescribeElasticsearchDomainsRequest = Schema.Struct({DomainNames: DomainNameList})
const DescribeElasticsearchInstanceTypeLimitsRequest = Schema.Struct({DomainName: Schema.optional(Schema.String), InstanceType: Schema.String, ElasticsearchVersion: Schema.String})
const DescribeOutboundCrossClusterSearchConnectionsRequest = Schema.Struct({Filters: Schema.optional(FilterList), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const DescribeReservedElasticsearchInstanceOfferingsRequest = Schema.Struct({ReservedElasticsearchInstanceOfferingId: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const DescribeReservedElasticsearchInstancesRequest = Schema.Struct({ReservedElasticsearchInstanceId: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const DescribeVpcEndpointsRequest = Schema.Struct({VpcEndpointIds: VpcEndpointIdList})
const DissociatePackageRequest = Schema.Struct({PackageID: Schema.String, DomainName: Schema.String})
const GetCompatibleElasticsearchVersionsRequest = Schema.Struct({DomainName: Schema.optional(Schema.String)})
const GetPackageVersionHistoryRequest = Schema.Struct({PackageID: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const GetUpgradeHistoryRequest = Schema.Struct({DomainName: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const GetUpgradeStatusRequest = Schema.Struct({DomainName: Schema.String})
const ListDomainNamesRequest = Schema.Struct({EngineType: Schema.optional(Schema.String)})
const ListDomainsForPackageRequest = Schema.Struct({PackageID: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListElasticsearchInstanceTypesRequest = Schema.Struct({ElasticsearchVersion: Schema.String, DomainName: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListElasticsearchVersionsRequest = Schema.Struct({MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListPackagesForDomainRequest = Schema.Struct({DomainName: Schema.String, MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const ListTagsRequest = Schema.Struct({ARN: Schema.String})
const ListVpcEndpointAccessRequest = Schema.Struct({DomainName: Schema.String, NextToken: Schema.optional(Schema.String)})
const ListVpcEndpointsRequest = Schema.Struct({NextToken: Schema.optional(Schema.String)})
const ListVpcEndpointsForDomainRequest = Schema.Struct({DomainName: Schema.String, NextToken: Schema.optional(Schema.String)})
const PurchaseReservedElasticsearchInstanceOfferingRequest = Schema.Struct({ReservedElasticsearchInstanceOfferingId: Schema.String, ReservationName: Schema.String, InstanceCount: Schema.optional(Schema.Number)})
const RejectInboundCrossClusterSearchConnectionRequest = Schema.Struct({CrossClusterSearchConnectionId: Schema.String})
const RemoveTagsRequest = Schema.Struct({ARN: Schema.String, TagKeys: StringList})
const RevokeVpcEndpointAccessRequest = Schema.Struct({DomainName: Schema.String, Account: Schema.String})
const RevokeVpcEndpointAccessResponse = Schema.Struct({})
const StartElasticsearchServiceSoftwareUpdateRequest = Schema.Struct({DomainName: Schema.String})
const UpdatePackageRequest = Schema.Struct({PackageID: Schema.String, PackageSource: PackageSource, PackageDescription: Schema.optional(Schema.String), CommitMessage: Schema.optional(Schema.String)})
const UpdateVpcEndpointRequest = Schema.Struct({VpcEndpointId: Schema.String, VpcOptions: VPCOptions})
const UpgradeElasticsearchDomainRequest = Schema.Struct({DomainName: Schema.String, TargetVersion: Schema.String, PerformCheckOnly: Schema.optional(Schema.Boolean)})
const ValueStringList = Schema.Array(Schema.String)
const DescribePackagesFilterValues = Schema.Array(Schema.String)
const Tag = Schema.Struct({Key: Schema.String, Value: Schema.String})
const TagList = Schema.Array(Tag)
const GUIDList = Schema.Array(Schema.String)
const EBSOptions = Schema.Struct({EBSEnabled: Schema.optional(Schema.Boolean), VolumeType: Schema.optional(Schema.String), VolumeSize: Schema.optional(Schema.Number), Iops: Schema.optional(Schema.Number), Throughput: Schema.optional(Schema.Number)})
const SnapshotOptions = Schema.Struct({AutomatedSnapshotStartHour: Schema.optional(Schema.Number)})
const VPCOptions = Schema.Struct({SubnetIds: Schema.optional(StringList), SecurityGroupIds: Schema.optional(StringList)})
const CognitoOptions = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), UserPoolId: Schema.optional(Schema.String), IdentityPoolId: Schema.optional(Schema.String), RoleArn: Schema.optional(Schema.String)})
const EncryptionAtRestOptions = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), KmsKeyId: Schema.optional(Schema.String)})
const NodeToNodeEncryptionOptions = Schema.Struct({Enabled: Schema.optional(Schema.Boolean)})
const AdvancedOptions = Schema.Record({key: Schema.String, value: Schema.String})
const DomainEndpointOptions = Schema.Struct({EnforceHTTPS: Schema.optional(Schema.Boolean), TLSSecurityPolicy: Schema.optional(Schema.String), CustomEndpointEnabled: Schema.optional(Schema.Boolean), CustomEndpoint: Schema.optional(Schema.String), CustomEndpointCertificateArn: Schema.optional(Schema.String)})
const DomainInformation = Schema.Struct({OwnerId: Schema.optional(Schema.String), DomainName: Schema.String, Region: Schema.optional(Schema.String)})
const PackageSource = Schema.Struct({S3BucketName: Schema.optional(Schema.String), S3Key: Schema.optional(Schema.String)})
const ElasticsearchDomainStatusList = Schema.Array(ElasticsearchDomainStatus)
const Filter = Schema.Struct({Name: Schema.optional(Schema.String), Values: Schema.optional(ValueStringList)})
const FilterList = Schema.Array(Filter)
const OutboundCrossClusterSearchConnections = Schema.Array(OutboundCrossClusterSearchConnection)
const DescribePackagesFilter = Schema.Struct({Name: Schema.optional(Schema.String), Value: Schema.optional(DescribePackagesFilterValues)})
const DescribePackagesFilterList = Schema.Array(DescribePackagesFilter)
const VpcEndpoints = Schema.Array(VpcEndpoint)
const DomainPackageDetailsList = Schema.Array(DomainPackageDetails)
const ElasticsearchInstanceTypeList = Schema.Array(Schema.String)
const ElasticsearchVersionList = Schema.Array(Schema.String)
const AuthorizedPrincipalList = Schema.Array(AuthorizedPrincipal)
const VpcEndpointSummaryList = Schema.Array(VpcEndpointSummary)
const AutoTuneOptions = Schema.Struct({DesiredState: Schema.optional(Schema.String), RollbackOnDisable: Schema.optional(Schema.String), MaintenanceSchedules: Schema.optional(AutoTuneMaintenanceScheduleList)})
const AddTagsRequest = Schema.Struct({ARN: Schema.String, TagList: TagList})
const CreateOutboundCrossClusterSearchConnectionRequest = Schema.Struct({SourceDomainInfo: DomainInformation, DestinationDomainInfo: DomainInformation, ConnectionAlias: Schema.String})
const CreatePackageRequest = Schema.Struct({PackageName: Schema.String, PackageType: Schema.String, PackageDescription: Schema.optional(Schema.String), PackageSource: PackageSource})
const InternalException = Schema.Struct({message: Schema.optional(Schema.String)})
export const DeleteElasticsearchServiceRole = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/role", method: "DELETE", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DeleteElasticsearchServiceRole" }, Schema.Struct({}), Schema.Struct({}), Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteInboundCrossClusterSearchConnectionResponse = Schema.Struct({CrossClusterSearchConnection: Schema.optional(InboundCrossClusterSearchConnection)})
const DescribeElasticsearchDomainResponse = Schema.Struct({DomainStatus: ElasticsearchDomainStatus})
export const DescribeElasticsearchDomain = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/domain/{DomainName}", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DescribeElasticsearchDomain" }, DescribeElasticsearchDomainRequest, DescribeElasticsearchDomainResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeElasticsearchDomainsResponse = Schema.Struct({DomainStatusList: ElasticsearchDomainStatusList})
export const DescribeElasticsearchDomains = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/domain-info", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DescribeElasticsearchDomains" }, DescribeElasticsearchDomainsRequest, DescribeElasticsearchDomainsResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeInboundCrossClusterSearchConnectionsRequest = Schema.Struct({Filters: Schema.optional(FilterList), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const DescribeOutboundCrossClusterSearchConnectionsResponse = Schema.Struct({CrossClusterSearchConnections: Schema.optional(OutboundCrossClusterSearchConnections), NextToken: Schema.optional(Schema.String)})
const DescribePackagesRequest = Schema.Struct({Filters: Schema.optional(DescribePackagesFilterList), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)})
const DissociatePackageResponse = Schema.Struct({DomainPackageDetails: Schema.optional(DomainPackageDetails)})
const GetUpgradeStatusResponse = Schema.Struct({UpgradeStep: Schema.optional(Schema.String), StepStatus: Schema.optional(Schema.String), UpgradeName: Schema.optional(Schema.String)})
export const GetUpgradeStatus = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/upgradeDomain/{DomainName}/status", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "GetUpgradeStatus" }, GetUpgradeStatusRequest, GetUpgradeStatusResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDomainsForPackageResponse = Schema.Struct({DomainPackageDetailsList: Schema.optional(DomainPackageDetailsList), NextToken: Schema.optional(Schema.String)})
export const ListDomainsForPackage = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/packages/{PackageID}/domains", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "ListDomainsForPackage" }, ListDomainsForPackageRequest, ListDomainsForPackageResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListElasticsearchInstanceTypesResponse = Schema.Struct({ElasticsearchInstanceTypes: Schema.optional(ElasticsearchInstanceTypeList), NextToken: Schema.optional(Schema.String)})
export const ListElasticsearchInstanceTypes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/instanceTypes/{ElasticsearchVersion}", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "ListElasticsearchInstanceTypes" }, ListElasticsearchInstanceTypesRequest, ListElasticsearchInstanceTypesResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListElasticsearchVersionsResponse = Schema.Struct({ElasticsearchVersions: Schema.optional(ElasticsearchVersionList), NextToken: Schema.optional(Schema.String)})
export const ListElasticsearchVersions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/versions", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "ListElasticsearchVersions" }, ListElasticsearchVersionsRequest, ListElasticsearchVersionsResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListPackagesForDomainResponse = Schema.Struct({DomainPackageDetailsList: Schema.optional(DomainPackageDetailsList), NextToken: Schema.optional(Schema.String)})
export const ListPackagesForDomain = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/domain/{DomainName}/packages", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "ListPackagesForDomain" }, ListPackagesForDomainRequest, ListPackagesForDomainResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListTagsResponse = Schema.Struct({TagList: Schema.optional(TagList)})
export const ListTags = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/tags", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "ListTags" }, ListTagsRequest, ListTagsResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListVpcEndpointAccessResponse = Schema.Struct({AuthorizedPrincipalList: AuthorizedPrincipalList, NextToken: Schema.String})
export const ListVpcEndpointAccess = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/domain/{DomainName}/listVpcEndpointAccess", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "ListVpcEndpointAccess" }, ListVpcEndpointAccessRequest, ListVpcEndpointAccessResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListVpcEndpointsResponse = Schema.Struct({VpcEndpointSummaryList: VpcEndpointSummaryList, NextToken: Schema.String})
export const ListVpcEndpoints = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/vpcEndpoints", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "ListVpcEndpoints" }, ListVpcEndpointsRequest, ListVpcEndpointsResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListVpcEndpointsForDomainResponse = Schema.Struct({VpcEndpointSummaryList: VpcEndpointSummaryList, NextToken: Schema.String})
export const ListVpcEndpointsForDomain = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/domain/{DomainName}/vpcEndpoints", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "ListVpcEndpointsForDomain" }, ListVpcEndpointsForDomainRequest, ListVpcEndpointsForDomainResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PurchaseReservedElasticsearchInstanceOfferingResponse = Schema.Struct({ReservedElasticsearchInstanceId: Schema.optional(Schema.String), ReservationName: Schema.optional(Schema.String)})
const RejectInboundCrossClusterSearchConnectionResponse = Schema.Struct({CrossClusterSearchConnection: Schema.optional(InboundCrossClusterSearchConnection)})
export const RejectInboundCrossClusterSearchConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/ccs/inboundConnection/{CrossClusterSearchConnectionId}/reject", method: "PUT", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "RejectInboundCrossClusterSearchConnection" }, RejectInboundCrossClusterSearchConnectionRequest, RejectInboundCrossClusterSearchConnectionResponse, Schema.Union(ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ValidationException = Schema.Struct({message: Schema.optional(Schema.String)})
export const RemoveTags = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/tags-removal", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "RemoveTags" }, RemoveTagsRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DisabledOperationException = Schema.Struct({message: Schema.optional(Schema.String)})
export const RevokeVpcEndpointAccess = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/domain/{DomainName}/revokeVpcEndpointAccess", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "RevokeVpcEndpointAccess" }, RevokeVpcEndpointAccessRequest, RevokeVpcEndpointAccessResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const StartElasticsearchServiceSoftwareUpdateResponse = Schema.Struct({ServiceSoftwareOptions: Schema.optional(ServiceSoftwareOptions)})
export const StartElasticsearchServiceSoftwareUpdate = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/serviceSoftwareUpdate/start", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "StartElasticsearchServiceSoftwareUpdate" }, StartElasticsearchServiceSoftwareUpdateRequest, StartElasticsearchServiceSoftwareUpdateResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateElasticsearchDomainConfigRequest = Schema.Struct({DomainName: Schema.String, ElasticsearchClusterConfig: Schema.optional(ElasticsearchClusterConfig), EBSOptions: Schema.optional(EBSOptions), SnapshotOptions: Schema.optional(SnapshotOptions), VPCOptions: Schema.optional(VPCOptions), CognitoOptions: Schema.optional(CognitoOptions), AdvancedOptions: Schema.optional(AdvancedOptions), AccessPolicies: Schema.optional(Schema.String), LogPublishingOptions: Schema.optional(LogPublishingOptions), DomainEndpointOptions: Schema.optional(DomainEndpointOptions), AdvancedSecurityOptions: Schema.optional(AdvancedSecurityOptionsInput), NodeToNodeEncryptionOptions: Schema.optional(NodeToNodeEncryptionOptions), EncryptionAtRestOptions: Schema.optional(EncryptionAtRestOptions), AutoTuneOptions: Schema.optional(AutoTuneOptions), DryRun: Schema.optional(Schema.Boolean)})
const UpdatePackageResponse = Schema.Struct({PackageDetails: Schema.optional(PackageDetails)})
export const UpdatePackage = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/packages/update", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "UpdatePackage" }, UpdatePackageRequest, UpdatePackageResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateVpcEndpointResponse = Schema.Struct({VpcEndpoint: VpcEndpoint})
const ZoneAwarenessConfig = Schema.Struct({AvailabilityZoneCount: Schema.optional(Schema.Number)})
const ColdStorageOptions = Schema.Struct({Enabled: Schema.Boolean})
const LogPublishingOption = Schema.Struct({CloudWatchLogsLogGroupArn: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean)})
const MasterUserOptions = Schema.Struct({MasterUserARN: Schema.optional(Schema.String), MasterUserName: Schema.optional(Schema.String), MasterUserPassword: Schema.optional(Schema.String)})
const AuthorizedPrincipal = Schema.Struct({PrincipalType: Schema.optional(Schema.String), Principal: Schema.optional(Schema.String)})
const CancelledChangeProperty = Schema.Struct({PropertyName: Schema.optional(Schema.String), CancelledValue: Schema.optional(Schema.String), ActiveValue: Schema.optional(Schema.String)})
const CancelledChangePropertyList = Schema.Array(CancelledChangeProperty)
const ServiceSoftwareOptions = Schema.Struct({CurrentVersion: Schema.optional(Schema.String), NewVersion: Schema.optional(Schema.String), UpdateAvailable: Schema.optional(Schema.Boolean), Cancellable: Schema.optional(Schema.Boolean), UpdateStatus: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), AutomatedUpdateDate: Schema.optional(Schema.Date), OptionalDeployment: Schema.optional(Schema.Boolean)})
const ElasticsearchClusterConfig = Schema.Struct({InstanceType: Schema.optional(Schema.String), InstanceCount: Schema.optional(Schema.Number), DedicatedMasterEnabled: Schema.optional(Schema.Boolean), ZoneAwarenessEnabled: Schema.optional(Schema.Boolean), ZoneAwarenessConfig: Schema.optional(ZoneAwarenessConfig), DedicatedMasterType: Schema.optional(Schema.String), DedicatedMasterCount: Schema.optional(Schema.Number), WarmEnabled: Schema.optional(Schema.Boolean), WarmType: Schema.optional(Schema.String), WarmCount: Schema.optional(Schema.Number), ColdStorageOptions: Schema.optional(ColdStorageOptions)})
const LogPublishingOptions = Schema.Record({key: Schema.String, value: LogPublishingOption})
const PackageDetails = Schema.Struct({PackageID: Schema.optional(Schema.String), PackageName: Schema.optional(Schema.String), PackageType: Schema.optional(Schema.String), PackageDescription: Schema.optional(Schema.String), PackageStatus: Schema.optional(Schema.String), CreatedAt: Schema.optional(Schema.Date), LastUpdatedAt: Schema.optional(Schema.Date), AvailablePackageVersion: Schema.optional(Schema.String), ErrorDetails: Schema.optional(ErrorDetails)})
const VpcEndpointSummary = Schema.Struct({VpcEndpointId: Schema.optional(Schema.String), VpcEndpointOwner: Schema.optional(Schema.String), DomainArn: Schema.optional(Schema.String), Status: Schema.optional(Schema.String)})
const InboundCrossClusterSearchConnections = Schema.Array(InboundCrossClusterSearchConnection)
const PackageDetailsList = Schema.Array(PackageDetails)
const ReservedElasticsearchInstance = Schema.Struct({ReservationName: Schema.optional(Schema.String), ReservedElasticsearchInstanceId: Schema.optional(Schema.String), ReservedElasticsearchInstanceOfferingId: Schema.optional(Schema.String), ElasticsearchInstanceType: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), Duration: Schema.optional(Schema.Number), FixedPrice: Schema.optional(Schema.Number), UsagePrice: Schema.optional(Schema.Number), CurrencyCode: Schema.optional(Schema.String), ElasticsearchInstanceCount: Schema.optional(Schema.Number), State: Schema.optional(Schema.String), PaymentOption: Schema.optional(Schema.String), RecurringCharges: Schema.optional(RecurringChargeList)})
const ReservedElasticsearchInstanceList = Schema.Array(ReservedElasticsearchInstance)
const VpcEndpointError = Schema.Struct({VpcEndpointId: Schema.optional(Schema.String), ErrorCode: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String)})
const VpcEndpointErrorList = Schema.Array(VpcEndpointError)
const CompatibleVersionsMap = Schema.Struct({SourceVersion: Schema.optional(Schema.String), TargetVersions: Schema.optional(ElasticsearchVersionList)})
const CompatibleElasticsearchVersionsList = Schema.Array(CompatibleVersionsMap)
const PackageVersionHistory = Schema.Struct({PackageVersion: Schema.optional(Schema.String), CommitMessage: Schema.optional(Schema.String), CreatedAt: Schema.optional(Schema.Date)})
const PackageVersionHistoryList = Schema.Array(PackageVersionHistory)
const DomainInfo = Schema.Struct({DomainName: Schema.optional(Schema.String), EngineType: Schema.optional(Schema.String)})
const DomainInfoList = Schema.Array(DomainInfo)
const ChangeProgressDetails = Schema.Struct({ChangeId: Schema.optional(Schema.String), Message: Schema.optional(Schema.String), ConfigChangeStatus: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), LastUpdatedTime: Schema.optional(Schema.Date), InitiatedBy: Schema.optional(Schema.String)})
const SAMLIdp = Schema.Struct({MetadataContent: Schema.String, EntityId: Schema.String})
const Duration = Schema.Struct({Value: Schema.optional(Schema.Number), Unit: Schema.optional(Schema.String)})
const Issues = Schema.Array(Schema.String)
const LimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)})
export const AddTags = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/tags", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "AddTags" }, AddTagsRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const AuthorizeVpcEndpointAccessResponse = Schema.Struct({AuthorizedPrincipal: AuthorizedPrincipal})
export const AuthorizeVpcEndpointAccess = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/domain/{DomainName}/authorizeVpcEndpointAccess", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "AuthorizeVpcEndpointAccess" }, AuthorizeVpcEndpointAccessRequest, AuthorizeVpcEndpointAccessResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CancelDomainConfigChangeResponse = Schema.Struct({DryRun: Schema.optional(Schema.Boolean), CancelledChangeIds: Schema.optional(GUIDList), CancelledChangeProperties: Schema.optional(CancelledChangePropertyList)})
export const CancelDomainConfigChange = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/domain/{DomainName}/config/cancel", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "CancelDomainConfigChange" }, CancelDomainConfigChangeRequest, CancelDomainConfigChangeResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CancelElasticsearchServiceSoftwareUpdateResponse = Schema.Struct({ServiceSoftwareOptions: Schema.optional(ServiceSoftwareOptions)})
export const CancelElasticsearchServiceSoftwareUpdate = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/serviceSoftwareUpdate/cancel", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "CancelElasticsearchServiceSoftwareUpdate" }, CancelElasticsearchServiceSoftwareUpdateRequest, CancelElasticsearchServiceSoftwareUpdateResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateOutboundCrossClusterSearchConnectionResponse = Schema.Struct({SourceDomainInfo: Schema.optional(DomainInformation), DestinationDomainInfo: Schema.optional(DomainInformation), ConnectionAlias: Schema.optional(Schema.String), ConnectionStatus: Schema.optional(OutboundCrossClusterSearchConnectionStatus), CrossClusterSearchConnectionId: Schema.optional(Schema.String)})
export const CreateOutboundCrossClusterSearchConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/ccs/outboundConnection", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "CreateOutboundCrossClusterSearchConnection" }, CreateOutboundCrossClusterSearchConnectionRequest, CreateOutboundCrossClusterSearchConnectionResponse, Schema.Union(ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceAlreadyExistsException", ResourceAlreadyExistsException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreatePackageResponse = Schema.Struct({PackageDetails: Schema.optional(PackageDetails)})
const ResourceNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)})
export const DeleteInboundCrossClusterSearchConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/ccs/inboundConnection/{CrossClusterSearchConnectionId}", method: "DELETE", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DeleteInboundCrossClusterSearchConnection" }, DeleteInboundCrossClusterSearchConnectionRequest, DeleteInboundCrossClusterSearchConnectionResponse, Schema.Union(ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeletePackageResponse = Schema.Struct({PackageDetails: Schema.optional(PackageDetails)})
export const DeletePackage = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/packages/{PackageID}", method: "DELETE", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DeletePackage" }, DeletePackageRequest, DeletePackageResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteVpcEndpointResponse = Schema.Struct({VpcEndpointSummary: VpcEndpointSummary})
export const DeleteVpcEndpoint = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/vpcEndpoints/{VpcEndpointId}", method: "DELETE", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DeleteVpcEndpoint" }, DeleteVpcEndpointRequest, DeleteVpcEndpointResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeInboundCrossClusterSearchConnectionsResponse = Schema.Struct({CrossClusterSearchConnections: Schema.optional(InboundCrossClusterSearchConnections), NextToken: Schema.optional(Schema.String)})
export const DescribeInboundCrossClusterSearchConnections = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/ccs/inboundConnection/search", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DescribeInboundCrossClusterSearchConnections" }, DescribeInboundCrossClusterSearchConnectionsRequest, DescribeInboundCrossClusterSearchConnectionsResponse, Schema.Union(ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InvalidPaginationTokenException", InvalidPaginationTokenException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidPaginationTokenException = Schema.Struct({message: Schema.optional(Schema.String)})
export const DescribeOutboundCrossClusterSearchConnections = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/ccs/outboundConnection/search", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DescribeOutboundCrossClusterSearchConnections" }, DescribeOutboundCrossClusterSearchConnectionsRequest, DescribeOutboundCrossClusterSearchConnectionsResponse, Schema.Union(ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InvalidPaginationTokenException", InvalidPaginationTokenException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribePackagesResponse = Schema.Struct({PackageDetailsList: Schema.optional(PackageDetailsList), NextToken: Schema.optional(Schema.String)})
export const DescribePackages = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/packages/describe", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DescribePackages" }, DescribePackagesRequest, DescribePackagesResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeReservedElasticsearchInstancesResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), ReservedElasticsearchInstances: Schema.optional(ReservedElasticsearchInstanceList)})
export const DescribeReservedElasticsearchInstances = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/reservedInstances", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DescribeReservedElasticsearchInstances" }, DescribeReservedElasticsearchInstancesRequest, DescribeReservedElasticsearchInstancesResponse, Schema.Union(ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeVpcEndpointsResponse = Schema.Struct({VpcEndpoints: VpcEndpoints, VpcEndpointErrors: VpcEndpointErrorList})
export const DescribeVpcEndpoints = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/vpcEndpoints/describe", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DescribeVpcEndpoints" }, DescribeVpcEndpointsRequest, DescribeVpcEndpointsResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const AccessDeniedException = Schema.Struct({message: Schema.optional(Schema.String)})
export const DissociatePackage = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/packages/dissociate/{PackageID}/{DomainName}", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DissociatePackage" }, DissociatePackageRequest, DissociatePackageResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetCompatibleElasticsearchVersionsResponse = Schema.Struct({CompatibleElasticsearchVersions: Schema.optional(CompatibleElasticsearchVersionsList)})
export const GetCompatibleElasticsearchVersions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/compatibleVersions", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "GetCompatibleElasticsearchVersions" }, GetCompatibleElasticsearchVersionsRequest, GetCompatibleElasticsearchVersionsResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetPackageVersionHistoryResponse = Schema.Struct({PackageID: Schema.optional(Schema.String), PackageVersionHistoryList: Schema.optional(PackageVersionHistoryList), NextToken: Schema.optional(Schema.String)})
export const GetPackageVersionHistory = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/packages/{PackageID}/history", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "GetPackageVersionHistory" }, GetPackageVersionHistoryRequest, GetPackageVersionHistoryResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDomainNamesResponse = Schema.Struct({DomainNames: Schema.optional(DomainInfoList)})
export const ListDomainNames = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/domain", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "ListDomainNames" }, ListDomainNamesRequest, ListDomainNamesResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ResourceAlreadyExistsException = Schema.Struct({message: Schema.optional(Schema.String)})
export const PurchaseReservedElasticsearchInstanceOffering = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/purchaseReservedInstanceOffering", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "PurchaseReservedElasticsearchInstanceOffering" }, PurchaseReservedElasticsearchInstanceOfferingRequest, PurchaseReservedElasticsearchInstanceOfferingResponse, Schema.Union(ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceAlreadyExistsException", ResourceAlreadyExistsException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ConflictException = Schema.Struct({message: Schema.optional(Schema.String)})
export const UpdateVpcEndpoint = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/vpcEndpoints/update", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "UpdateVpcEndpoint" }, UpdateVpcEndpointRequest, UpdateVpcEndpointResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpgradeElasticsearchDomainResponse = Schema.Struct({DomainName: Schema.optional(Schema.String), TargetVersion: Schema.optional(Schema.String), PerformCheckOnly: Schema.optional(Schema.Boolean), ChangeProgressDetails: Schema.optional(ChangeProgressDetails)})
export const UpgradeElasticsearchDomain = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/upgradeDomain", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "UpgradeElasticsearchDomain" }, UpgradeElasticsearchDomainRequest, UpgradeElasticsearchDomainResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceAlreadyExistsException", ResourceAlreadyExistsException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InboundCrossClusterSearchConnectionStatus = Schema.Struct({StatusCode: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
const ErrorDetails = Schema.Struct({ErrorType: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String)})
const SAMLOptionsInput = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), Idp: Schema.optional(SAMLIdp), MasterUserName: Schema.optional(Schema.String), MasterBackendRole: Schema.optional(Schema.String), SubjectKey: Schema.optional(Schema.String), RolesKey: Schema.optional(Schema.String), SessionTimeoutMinutes: Schema.optional(Schema.Number)})
const AutoTuneMaintenanceSchedule = Schema.Struct({StartAt: Schema.optional(Schema.Date), Duration: Schema.optional(Duration), CronExpressionForRecurrence: Schema.optional(Schema.String)})
const AutoTuneMaintenanceScheduleList = Schema.Array(AutoTuneMaintenanceSchedule)
const VPCDerivedInfo = Schema.Struct({VPCId: Schema.optional(Schema.String), SubnetIds: Schema.optional(StringList), AvailabilityZones: Schema.optional(StringList), SecurityGroupIds: Schema.optional(StringList)})
const EndpointsMap = Schema.Record({key: Schema.String, value: Schema.String})
const AutoTuneOptionsOutput = Schema.Struct({State: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String)})
const ModifyingProperties = Schema.Struct({Name: Schema.optional(Schema.String), ActiveValue: Schema.optional(Schema.String), PendingValue: Schema.optional(Schema.String), ValueType: Schema.optional(Schema.String)})
const ModifyingPropertiesList = Schema.Array(ModifyingProperties)
const OutboundCrossClusterSearchConnectionStatus = Schema.Struct({StatusCode: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
const ChangeProgressStage = Schema.Struct({Name: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), Description: Schema.optional(Schema.String), LastUpdated: Schema.optional(Schema.Date)})
const ChangeProgressStageList = Schema.Array(ChangeProgressStage)
const ElasticsearchClusterConfigStatus = Schema.Struct({Options: ElasticsearchClusterConfig, Status: OptionStatus})
const EBSOptionsStatus = Schema.Struct({Options: EBSOptions, Status: OptionStatus})
const AccessPoliciesStatus = Schema.Struct({Options: Schema.String, Status: OptionStatus})
const SnapshotOptionsStatus = Schema.Struct({Options: SnapshotOptions, Status: OptionStatus})
const VPCDerivedInfoStatus = Schema.Struct({Options: VPCDerivedInfo, Status: OptionStatus})
const CognitoOptionsStatus = Schema.Struct({Options: CognitoOptions, Status: OptionStatus})
const EncryptionAtRestOptionsStatus = Schema.Struct({Options: EncryptionAtRestOptions, Status: OptionStatus})
const NodeToNodeEncryptionOptionsStatus = Schema.Struct({Options: NodeToNodeEncryptionOptions, Status: OptionStatus})
const AdvancedOptionsStatus = Schema.Struct({Options: AdvancedOptions, Status: OptionStatus})
const LogPublishingOptionsStatus = Schema.Struct({Options: Schema.optional(LogPublishingOptions), Status: Schema.optional(OptionStatus)})
const DomainEndpointOptionsStatus = Schema.Struct({Options: DomainEndpointOptions, Status: OptionStatus})
const AdvancedSecurityOptionsStatus = Schema.Struct({Options: AdvancedSecurityOptions, Status: OptionStatus})
const RecurringCharge = Schema.Struct({RecurringChargeAmount: Schema.optional(Schema.Number), RecurringChargeFrequency: Schema.optional(Schema.String)})
const RecurringChargeList = Schema.Array(RecurringCharge)
const UpgradeStepItem = Schema.Struct({UpgradeStep: Schema.optional(Schema.String), UpgradeStepStatus: Schema.optional(Schema.String), Issues: Schema.optional(Issues), ProgressPercent: Schema.optional(Schema.Number)})
const UpgradeStepsList = Schema.Array(UpgradeStepItem)
const LimitValueList = Schema.Array(Schema.String)
const InboundCrossClusterSearchConnection = Schema.Struct({SourceDomainInfo: Schema.optional(DomainInformation), DestinationDomainInfo: Schema.optional(DomainInformation), CrossClusterSearchConnectionId: Schema.optional(Schema.String), ConnectionStatus: Schema.optional(InboundCrossClusterSearchConnectionStatus)})
const DomainPackageDetails = Schema.Struct({PackageID: Schema.optional(Schema.String), PackageName: Schema.optional(Schema.String), PackageType: Schema.optional(Schema.String), LastUpdated: Schema.optional(Schema.Date), DomainName: Schema.optional(Schema.String), DomainPackageStatus: Schema.optional(Schema.String), PackageVersion: Schema.optional(Schema.String), ReferencePath: Schema.optional(Schema.String), ErrorDetails: Schema.optional(ErrorDetails)})
const AdvancedSecurityOptionsInput = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), InternalUserDatabaseEnabled: Schema.optional(Schema.Boolean), MasterUserOptions: Schema.optional(MasterUserOptions), SAMLOptions: Schema.optional(SAMLOptionsInput), AnonymousAuthEnabled: Schema.optional(Schema.Boolean)})
const AutoTuneOptionsInput = Schema.Struct({DesiredState: Schema.optional(Schema.String), MaintenanceSchedules: Schema.optional(AutoTuneMaintenanceScheduleList)})
const VpcEndpoint = Schema.Struct({VpcEndpointId: Schema.optional(Schema.String), VpcEndpointOwner: Schema.optional(Schema.String), DomainArn: Schema.optional(Schema.String), VpcOptions: Schema.optional(VPCDerivedInfo), Status: Schema.optional(Schema.String), Endpoint: Schema.optional(Schema.String)})
const OutboundCrossClusterSearchConnection = Schema.Struct({SourceDomainInfo: Schema.optional(DomainInformation), DestinationDomainInfo: Schema.optional(DomainInformation), CrossClusterSearchConnectionId: Schema.optional(Schema.String), ConnectionAlias: Schema.optional(Schema.String), ConnectionStatus: Schema.optional(OutboundCrossClusterSearchConnectionStatus)})
const ChangeProgressStatusDetails = Schema.Struct({ChangeId: Schema.optional(Schema.String), StartTime: Schema.optional(Schema.Date), Status: Schema.optional(Schema.String), PendingProperties: Schema.optional(StringList), CompletedProperties: Schema.optional(StringList), TotalNumberOfStages: Schema.optional(Schema.Number), ChangeProgressStages: Schema.optional(ChangeProgressStageList), ConfigChangeStatus: Schema.optional(Schema.String), LastUpdatedTime: Schema.optional(Schema.Date), InitiatedBy: Schema.optional(Schema.String)})
const ReservedElasticsearchInstanceOffering = Schema.Struct({ReservedElasticsearchInstanceOfferingId: Schema.optional(Schema.String), ElasticsearchInstanceType: Schema.optional(Schema.String), Duration: Schema.optional(Schema.Number), FixedPrice: Schema.optional(Schema.Number), UsagePrice: Schema.optional(Schema.Number), CurrencyCode: Schema.optional(Schema.String), PaymentOption: Schema.optional(Schema.String), RecurringCharges: Schema.optional(RecurringChargeList)})
const ReservedElasticsearchInstanceOfferingList = Schema.Array(ReservedElasticsearchInstanceOffering)
const UpgradeHistory = Schema.Struct({UpgradeName: Schema.optional(Schema.String), StartTimestamp: Schema.optional(Schema.Date), UpgradeStatus: Schema.optional(Schema.String), StepsList: Schema.optional(UpgradeStepsList)})
const UpgradeHistoryList = Schema.Array(UpgradeHistory)
const DryRunResults = Schema.Struct({DeploymentType: Schema.optional(Schema.String), Message: Schema.optional(Schema.String)})
const SAMLOptionsOutput = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), Idp: Schema.optional(SAMLIdp), SubjectKey: Schema.optional(Schema.String), RolesKey: Schema.optional(Schema.String), SessionTimeoutMinutes: Schema.optional(Schema.Number)})
const ScheduledAutoTuneDetails = Schema.Struct({Date: Schema.optional(Schema.Date), ActionType: Schema.optional(Schema.String), Action: Schema.optional(Schema.String), Severity: Schema.optional(Schema.String)})
const OptionStatus = Schema.Struct({CreationDate: Schema.Date, UpdateDate: Schema.Date, UpdateVersion: Schema.optional(Schema.Number), State: Schema.String, PendingDeletion: Schema.optional(Schema.Boolean)})
const AutoTuneStatus = Schema.Struct({CreationDate: Schema.Date, UpdateDate: Schema.Date, UpdateVersion: Schema.optional(Schema.Number), State: Schema.String, ErrorMessage: Schema.optional(Schema.String), PendingDeletion: Schema.optional(Schema.Boolean)})
const AdditionalLimit = Schema.Struct({LimitName: Schema.optional(Schema.String), LimitValues: Schema.optional(LimitValueList)})
const AdditionalLimitList = Schema.Array(AdditionalLimit)
const AcceptInboundCrossClusterSearchConnectionResponse = Schema.Struct({CrossClusterSearchConnection: Schema.optional(InboundCrossClusterSearchConnection)})
export const AcceptInboundCrossClusterSearchConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/ccs/inboundConnection/{CrossClusterSearchConnectionId}/accept", method: "PUT", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "AcceptInboundCrossClusterSearchConnection" }, AcceptInboundCrossClusterSearchConnectionRequest, AcceptInboundCrossClusterSearchConnectionResponse, Schema.Union(ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const AssociatePackageResponse = Schema.Struct({DomainPackageDetails: Schema.optional(DomainPackageDetails)})
export const AssociatePackage = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/packages/associate/{PackageID}/{DomainName}", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "AssociatePackage" }, AssociatePackageRequest, AssociatePackageResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateElasticsearchDomainRequest = Schema.Struct({DomainName: Schema.String, ElasticsearchVersion: Schema.optional(Schema.String), ElasticsearchClusterConfig: Schema.optional(ElasticsearchClusterConfig), EBSOptions: Schema.optional(EBSOptions), AccessPolicies: Schema.optional(Schema.String), SnapshotOptions: Schema.optional(SnapshotOptions), VPCOptions: Schema.optional(VPCOptions), CognitoOptions: Schema.optional(CognitoOptions), EncryptionAtRestOptions: Schema.optional(EncryptionAtRestOptions), NodeToNodeEncryptionOptions: Schema.optional(NodeToNodeEncryptionOptions), AdvancedOptions: Schema.optional(AdvancedOptions), LogPublishingOptions: Schema.optional(LogPublishingOptions), DomainEndpointOptions: Schema.optional(DomainEndpointOptions), AdvancedSecurityOptions: Schema.optional(AdvancedSecurityOptionsInput), AutoTuneOptions: Schema.optional(AutoTuneOptionsInput), TagList: Schema.optional(TagList)})
const InvalidTypeException = Schema.Struct({message: Schema.optional(Schema.String)})
export const CreatePackage = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/packages", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "CreatePackage" }, CreatePackageRequest, CreatePackageResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("InvalidTypeException", InvalidTypeException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceAlreadyExistsException", ResourceAlreadyExistsException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateVpcEndpointResponse = Schema.Struct({VpcEndpoint: VpcEndpoint})
export const CreateVpcEndpoint = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/vpcEndpoints", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "CreateVpcEndpoint" }, CreateVpcEndpointRequest, CreateVpcEndpointResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteOutboundCrossClusterSearchConnectionResponse = Schema.Struct({CrossClusterSearchConnection: Schema.optional(OutboundCrossClusterSearchConnection)})
export const DeleteOutboundCrossClusterSearchConnection = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/ccs/outboundConnection/{CrossClusterSearchConnectionId}", method: "DELETE", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DeleteOutboundCrossClusterSearchConnection" }, DeleteOutboundCrossClusterSearchConnectionRequest, DeleteOutboundCrossClusterSearchConnectionResponse, Schema.Union(ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeDomainChangeProgressResponse = Schema.Struct({ChangeProgressStatus: Schema.optional(ChangeProgressStatusDetails)})
export const DescribeDomainChangeProgress = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/domain/{DomainName}/progress", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DescribeDomainChangeProgress" }, DescribeDomainChangeProgressRequest, DescribeDomainChangeProgressResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeReservedElasticsearchInstanceOfferingsResponse = Schema.Struct({NextToken: Schema.optional(Schema.String), ReservedElasticsearchInstanceOfferings: Schema.optional(ReservedElasticsearchInstanceOfferingList)})
export const DescribeReservedElasticsearchInstanceOfferings = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/reservedInstanceOfferings", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DescribeReservedElasticsearchInstanceOfferings" }, DescribeReservedElasticsearchInstanceOfferingsRequest, DescribeReservedElasticsearchInstanceOfferingsResponse, Schema.Union(ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetUpgradeHistoryResponse = Schema.Struct({UpgradeHistories: Schema.optional(UpgradeHistoryList), NextToken: Schema.optional(Schema.String)})
export const GetUpgradeHistory = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/upgradeDomain/{DomainName}/history", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "GetUpgradeHistory" }, GetUpgradeHistoryRequest, GetUpgradeHistoryResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateElasticsearchDomainConfigResponse = Schema.Struct({DomainConfig: ElasticsearchDomainConfig, DryRunResults: Schema.optional(DryRunResults)})
export const UpdateElasticsearchDomainConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/domain/{DomainName}/config", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "UpdateElasticsearchDomainConfig" }, UpdateElasticsearchDomainConfigRequest, UpdateElasticsearchDomainConfigResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("InvalidTypeException", InvalidTypeException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const AdvancedSecurityOptions = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), InternalUserDatabaseEnabled: Schema.optional(Schema.Boolean), SAMLOptions: Schema.optional(SAMLOptionsOutput), AnonymousAuthDisableDate: Schema.optional(Schema.Date), AnonymousAuthEnabled: Schema.optional(Schema.Boolean)})
const AutoTuneDetails = Schema.Struct({ScheduledAutoTuneDetails: Schema.optional(ScheduledAutoTuneDetails)})
const ElasticsearchVersionStatus = Schema.Struct({Options: Schema.String, Status: OptionStatus})
const AutoTuneOptionsStatus = Schema.Struct({Options: Schema.optional(AutoTuneOptions), Status: Schema.optional(AutoTuneStatus)})
const StorageTypeLimit = Schema.Struct({LimitName: Schema.optional(Schema.String), LimitValues: Schema.optional(LimitValueList)})
const StorageTypeLimitList = Schema.Array(StorageTypeLimit)
const InstanceCountLimits = Schema.Struct({MinimumInstanceCount: Schema.optional(Schema.Number), MaximumInstanceCount: Schema.optional(Schema.Number)})
const ElasticsearchDomainStatus = Schema.Struct({DomainId: Schema.String, DomainName: Schema.String, ARN: Schema.String, Created: Schema.optional(Schema.Boolean), Deleted: Schema.optional(Schema.Boolean), Endpoint: Schema.optional(Schema.String), Endpoints: Schema.optional(EndpointsMap), Processing: Schema.optional(Schema.Boolean), UpgradeProcessing: Schema.optional(Schema.Boolean), ElasticsearchVersion: Schema.optional(Schema.String), ElasticsearchClusterConfig: ElasticsearchClusterConfig, EBSOptions: Schema.optional(EBSOptions), AccessPolicies: Schema.optional(Schema.String), SnapshotOptions: Schema.optional(SnapshotOptions), VPCOptions: Schema.optional(VPCDerivedInfo), CognitoOptions: Schema.optional(CognitoOptions), EncryptionAtRestOptions: Schema.optional(EncryptionAtRestOptions), NodeToNodeEncryptionOptions: Schema.optional(NodeToNodeEncryptionOptions), AdvancedOptions: Schema.optional(AdvancedOptions), LogPublishingOptions: Schema.optional(LogPublishingOptions), ServiceSoftwareOptions: Schema.optional(ServiceSoftwareOptions), DomainEndpointOptions: Schema.optional(DomainEndpointOptions), AdvancedSecurityOptions: Schema.optional(AdvancedSecurityOptions), AutoTuneOptions: Schema.optional(AutoTuneOptionsOutput), ChangeProgressDetails: Schema.optional(ChangeProgressDetails), DomainProcessingStatus: Schema.optional(Schema.String), ModifyingProperties: Schema.optional(ModifyingPropertiesList)})
const AutoTune = Schema.Struct({AutoTuneType: Schema.optional(Schema.String), AutoTuneDetails: Schema.optional(AutoTuneDetails)})
const AutoTuneList = Schema.Array(AutoTune)
const ElasticsearchDomainConfig = Schema.Struct({ElasticsearchVersion: Schema.optional(ElasticsearchVersionStatus), ElasticsearchClusterConfig: Schema.optional(ElasticsearchClusterConfigStatus), EBSOptions: Schema.optional(EBSOptionsStatus), AccessPolicies: Schema.optional(AccessPoliciesStatus), SnapshotOptions: Schema.optional(SnapshotOptionsStatus), VPCOptions: Schema.optional(VPCDerivedInfoStatus), CognitoOptions: Schema.optional(CognitoOptionsStatus), EncryptionAtRestOptions: Schema.optional(EncryptionAtRestOptionsStatus), NodeToNodeEncryptionOptions: Schema.optional(NodeToNodeEncryptionOptionsStatus), AdvancedOptions: Schema.optional(AdvancedOptionsStatus), LogPublishingOptions: Schema.optional(LogPublishingOptionsStatus), DomainEndpointOptions: Schema.optional(DomainEndpointOptionsStatus), AdvancedSecurityOptions: Schema.optional(AdvancedSecurityOptionsStatus), AutoTuneOptions: Schema.optional(AutoTuneOptionsStatus), ChangeProgressDetails: Schema.optional(ChangeProgressDetails), ModifyingProperties: Schema.optional(ModifyingPropertiesList)})
const StorageType = Schema.Struct({StorageTypeName: Schema.optional(Schema.String), StorageSubTypeName: Schema.optional(Schema.String), StorageTypeLimits: Schema.optional(StorageTypeLimitList)})
const StorageTypeList = Schema.Array(StorageType)
const InstanceLimits = Schema.Struct({InstanceCountLimits: Schema.optional(InstanceCountLimits)})
const CreateElasticsearchDomainResponse = Schema.Struct({DomainStatus: Schema.optional(ElasticsearchDomainStatus)})
export const CreateElasticsearchDomain = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/domain", method: "POST", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "CreateElasticsearchDomain" }, CreateElasticsearchDomainRequest, CreateElasticsearchDomainResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("DisabledOperationException", DisabledOperationException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("InvalidTypeException", InvalidTypeException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceAlreadyExistsException", ResourceAlreadyExistsException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteElasticsearchDomainResponse = Schema.Struct({DomainStatus: Schema.optional(ElasticsearchDomainStatus)})
export const DeleteElasticsearchDomain = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/domain/{DomainName}", method: "DELETE", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DeleteElasticsearchDomain" }, DeleteElasticsearchDomainRequest, DeleteElasticsearchDomainResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeDomainAutoTunesResponse = Schema.Struct({AutoTunes: Schema.optional(AutoTuneList), NextToken: Schema.optional(Schema.String)})
export const DescribeDomainAutoTunes = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/domain/{DomainName}/autoTunes", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DescribeDomainAutoTunes" }, DescribeDomainAutoTunesRequest, DescribeDomainAutoTunesResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeElasticsearchDomainConfigResponse = Schema.Struct({DomainConfig: ElasticsearchDomainConfig})
export const DescribeElasticsearchDomainConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/domain/{DomainName}/config", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DescribeElasticsearchDomainConfig" }, DescribeElasticsearchDomainConfigRequest, DescribeElasticsearchDomainConfigResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const Limits = Schema.Struct({StorageTypes: Schema.optional(StorageTypeList), InstanceLimits: Schema.optional(InstanceLimits), AdditionalLimits: Schema.optional(AdditionalLimitList)})
const LimitsByRole = Schema.Record({key: Schema.String, value: Limits})
const DescribeElasticsearchInstanceTypeLimitsResponse = Schema.Struct({LimitsByRole: Schema.optional(LimitsByRole)})
export const DescribeElasticsearchInstanceTypeLimits = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2015-01-01/es/instanceTypeLimits/{ElasticsearchVersion}/{InstanceType}", method: "GET", sdkId: "Elasticsearch Service", sigV4ServiceName: "es", name: "DescribeElasticsearchInstanceTypeLimits" }, DescribeElasticsearchInstanceTypeLimitsRequest, DescribeElasticsearchInstanceTypeLimitsResponse, Schema.Union(ErrorAnnotation("BaseException", BaseException), ErrorAnnotation("InternalException", InternalException), ErrorAnnotation("InvalidTypeException", InvalidTypeException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
