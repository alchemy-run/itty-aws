import { Schema} from "effect"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
export const TagKeyList = Schema.Array(Schema.String);
export const Tags = Schema.Record({key: Schema.String, value: Schema.String});
export const CreateWorkerConfigurationRequest = Schema.Struct({description: Schema.optional(Schema.String), name: Schema.String, propertiesFileContent: Schema.String, tags: Schema.optional(Tags)});
export const DeleteConnectorRequest = Schema.Struct({connectorArn: Schema.String, currentVersion: Schema.optional(Schema.String)});
export const DeleteCustomPluginRequest = Schema.Struct({customPluginArn: Schema.String});
export const DeleteWorkerConfigurationRequest = Schema.Struct({workerConfigurationArn: Schema.String});
export const DescribeConnectorRequest = Schema.Struct({connectorArn: Schema.String});
export const DescribeConnectorOperationRequest = Schema.Struct({connectorOperationArn: Schema.String});
export const DescribeCustomPluginRequest = Schema.Struct({customPluginArn: Schema.String});
export const DescribeWorkerConfigurationRequest = Schema.Struct({workerConfigurationArn: Schema.String});
export const ListConnectorOperationsRequest = Schema.Struct({connectorArn: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListConnectorsRequest = Schema.Struct({connectorNamePrefix: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListCustomPluginsRequest = Schema.Struct({maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), namePrefix: Schema.optional(Schema.String)});
export const ListTagsForResourceRequest = Schema.Struct({resourceArn: Schema.String});
export const ListWorkerConfigurationsRequest = Schema.Struct({maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), namePrefix: Schema.optional(Schema.String)});
export const TagResourceRequest = Schema.Struct({resourceArn: Schema.String, tags: Tags});
export const TagResourceResponse = Schema.Struct({});
export const UntagResourceRequest = Schema.Struct({resourceArn: Schema.String, tagKeys: TagKeyList});
export const UntagResourceResponse = Schema.Struct({});
export const ConnectorConfiguration = Schema.Record({key: Schema.String, value: Schema.String});
export const KafkaClusterClientAuthentication = Schema.Struct({authenticationType: Schema.String});
export const KafkaClusterEncryptionInTransit = Schema.Struct({encryptionType: Schema.String});
export const WorkerConfiguration = Schema.Struct({revision: Schema.Number, workerConfigurationArn: Schema.String});
export const ConnectorConfigurationUpdate = Schema.Record({key: Schema.String, value: Schema.String});
export const DeleteConnectorResponse = Schema.Struct({connectorArn: Schema.optional(Schema.String), connectorState: Schema.optional(Schema.String)});
export const DeleteCustomPluginResponse = Schema.Struct({customPluginArn: Schema.optional(Schema.String), customPluginState: Schema.optional(Schema.String)});
export const DeleteWorkerConfigurationResponse = Schema.Struct({workerConfigurationArn: Schema.optional(Schema.String), workerConfigurationState: Schema.optional(Schema.String)});
export const ListTagsForResourceResponse = Schema.Struct({tags: Schema.optional(Tags)});
export const BadRequestException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ForbiddenException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ProvisionedCapacity = Schema.Struct({mcuCount: Schema.Number, workerCount: Schema.Number});
export const CustomPlugin = Schema.Struct({customPluginArn: Schema.String, revision: Schema.Number});
export const S3Location = Schema.Struct({bucketArn: Schema.String, fileKey: Schema.String, objectVersion: Schema.optional(Schema.String)});
export const ProvisionedCapacityUpdate = Schema.Struct({mcuCount: Schema.Number, workerCount: Schema.Number});
export const __listOf__string = Schema.Array(Schema.String);
export const Plugin = Schema.Struct({customPlugin: CustomPlugin});
export const __listOfPlugin = Schema.Array(Plugin);
export const CustomPluginLocation = Schema.Struct({s3Location: S3Location});
export const WorkerConfigurationRevisionSummary = Schema.Struct({creationTime: Schema.optional(Schema.Date), description: Schema.optional(Schema.String), revision: Schema.optional(Schema.Number)});
export const KafkaClusterClientAuthenticationDescription = Schema.Struct({authenticationType: Schema.optional(Schema.String)});
export const KafkaClusterEncryptionInTransitDescription = Schema.Struct({encryptionType: Schema.optional(Schema.String)});
export const WorkerConfigurationDescription = Schema.Struct({revision: Schema.optional(Schema.Number), workerConfigurationArn: Schema.optional(Schema.String)});
export const StateDescription = Schema.Struct({code: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const ConnectorOperationStep = Schema.Struct({stepType: Schema.optional(Schema.String), stepState: Schema.optional(Schema.String)});
export const __listOfConnectorOperationStep = Schema.Array(ConnectorOperationStep);
export const ScaleInPolicyDescription = Schema.Struct({cpuUtilizationPercentage: Schema.optional(Schema.Number)});
export const ScaleOutPolicyDescription = Schema.Struct({cpuUtilizationPercentage: Schema.optional(Schema.Number)});
export const AutoScalingDescription = Schema.Struct({maxWorkerCount: Schema.optional(Schema.Number), mcuCount: Schema.optional(Schema.Number), minWorkerCount: Schema.optional(Schema.Number), scaleInPolicy: Schema.optional(ScaleInPolicyDescription), scaleOutPolicy: Schema.optional(ScaleOutPolicyDescription)});
export const ProvisionedCapacityDescription = Schema.Struct({mcuCount: Schema.optional(Schema.Number), workerCount: Schema.optional(Schema.Number)});
export const CapacityDescription = Schema.Struct({autoScaling: Schema.optional(AutoScalingDescription), provisionedCapacity: Schema.optional(ProvisionedCapacityDescription)});
export const WorkerSetting = Schema.Struct({capacity: Schema.optional(CapacityDescription)});
export const WorkerConfigurationRevisionDescription = Schema.Struct({creationTime: Schema.optional(Schema.Date), description: Schema.optional(Schema.String), propertiesFileContent: Schema.optional(Schema.String), revision: Schema.optional(Schema.Number)});
export const ConnectorOperationSummary = Schema.Struct({connectorOperationArn: Schema.optional(Schema.String), connectorOperationType: Schema.optional(Schema.String), connectorOperationState: Schema.optional(Schema.String), creationTime: Schema.optional(Schema.Date), endTime: Schema.optional(Schema.Date)});
export const __listOfConnectorOperationSummary = Schema.Array(ConnectorOperationSummary);
export const VpcDescription = Schema.Struct({securityGroups: Schema.optional(__listOf__string), subnets: Schema.optional(__listOf__string)});
export const ApacheKafkaClusterDescription = Schema.Struct({bootstrapServers: Schema.optional(Schema.String), vpc: Schema.optional(VpcDescription)});
export const KafkaClusterDescription = Schema.Struct({apacheKafkaCluster: Schema.optional(ApacheKafkaClusterDescription)});
export const CloudWatchLogsLogDeliveryDescription = Schema.Struct({enabled: Schema.optional(Schema.Boolean), logGroup: Schema.optional(Schema.String)});
export const FirehoseLogDeliveryDescription = Schema.Struct({deliveryStream: Schema.optional(Schema.String), enabled: Schema.optional(Schema.Boolean)});
export const S3LogDeliveryDescription = Schema.Struct({bucket: Schema.optional(Schema.String), enabled: Schema.optional(Schema.Boolean), prefix: Schema.optional(Schema.String)});
export const WorkerLogDeliveryDescription = Schema.Struct({cloudWatchLogs: Schema.optional(CloudWatchLogsLogDeliveryDescription), firehose: Schema.optional(FirehoseLogDeliveryDescription), s3: Schema.optional(S3LogDeliveryDescription)});
export const LogDeliveryDescription = Schema.Struct({workerLogDelivery: Schema.optional(WorkerLogDeliveryDescription)});
export const CustomPluginDescription = Schema.Struct({customPluginArn: Schema.optional(Schema.String), revision: Schema.optional(Schema.Number)});
export const PluginDescription = Schema.Struct({customPlugin: Schema.optional(CustomPluginDescription)});
export const __listOfPluginDescription = Schema.Array(PluginDescription);
export const ConnectorSummary = Schema.Struct({capacity: Schema.optional(CapacityDescription), connectorArn: Schema.optional(Schema.String), connectorDescription: Schema.optional(Schema.String), connectorName: Schema.optional(Schema.String), connectorState: Schema.optional(Schema.String), creationTime: Schema.optional(Schema.Date), currentVersion: Schema.optional(Schema.String), kafkaCluster: Schema.optional(KafkaClusterDescription), kafkaClusterClientAuthentication: Schema.optional(KafkaClusterClientAuthenticationDescription), kafkaClusterEncryptionInTransit: Schema.optional(KafkaClusterEncryptionInTransitDescription), kafkaConnectVersion: Schema.optional(Schema.String), logDelivery: Schema.optional(LogDeliveryDescription), plugins: Schema.optional(__listOfPluginDescription), serviceExecutionRoleArn: Schema.optional(Schema.String), workerConfiguration: Schema.optional(WorkerConfigurationDescription)});
export const __listOfConnectorSummary = Schema.Array(ConnectorSummary);
export const CustomPluginFileDescription = Schema.Struct({fileMd5: Schema.optional(Schema.String), fileSize: Schema.optional(Schema.Number)});
export const S3LocationDescription = Schema.Struct({bucketArn: Schema.optional(Schema.String), fileKey: Schema.optional(Schema.String), objectVersion: Schema.optional(Schema.String)});
export const CustomPluginLocationDescription = Schema.Struct({s3Location: Schema.optional(S3LocationDescription)});
export const CustomPluginRevisionSummary = Schema.Struct({contentType: Schema.optional(Schema.String), creationTime: Schema.optional(Schema.Date), description: Schema.optional(Schema.String), fileDescription: Schema.optional(CustomPluginFileDescription), location: Schema.optional(CustomPluginLocationDescription), revision: Schema.optional(Schema.Number)});
export const CustomPluginSummary = Schema.Struct({creationTime: Schema.optional(Schema.Date), customPluginArn: Schema.optional(Schema.String), customPluginState: Schema.optional(Schema.String), description: Schema.optional(Schema.String), latestRevision: Schema.optional(CustomPluginRevisionSummary), name: Schema.optional(Schema.String)});
export const __listOfCustomPluginSummary = Schema.Array(CustomPluginSummary);
export const WorkerConfigurationSummary = Schema.Struct({creationTime: Schema.optional(Schema.Date), description: Schema.optional(Schema.String), latestRevision: Schema.optional(WorkerConfigurationRevisionSummary), name: Schema.optional(Schema.String), workerConfigurationArn: Schema.optional(Schema.String), workerConfigurationState: Schema.optional(Schema.String)});
export const __listOfWorkerConfigurationSummary = Schema.Array(WorkerConfigurationSummary);
export const ScaleInPolicy = Schema.Struct({cpuUtilizationPercentage: Schema.Number});
export const ScaleOutPolicy = Schema.Struct({cpuUtilizationPercentage: Schema.Number});
export const Vpc = Schema.Struct({securityGroups: Schema.optional(__listOf__string), subnets: __listOf__string});
export const CloudWatchLogsLogDelivery = Schema.Struct({enabled: Schema.Boolean, logGroup: Schema.optional(Schema.String)});
export const FirehoseLogDelivery = Schema.Struct({deliveryStream: Schema.optional(Schema.String), enabled: Schema.Boolean});
export const S3LogDelivery = Schema.Struct({bucket: Schema.optional(Schema.String), enabled: Schema.Boolean, prefix: Schema.optional(Schema.String)});
export const ScaleInPolicyUpdate = Schema.Struct({cpuUtilizationPercentage: Schema.Number});
export const ScaleOutPolicyUpdate = Schema.Struct({cpuUtilizationPercentage: Schema.Number});
export const CreateCustomPluginRequest = Schema.Struct({contentType: Schema.String, description: Schema.optional(Schema.String), location: CustomPluginLocation, name: Schema.String, tags: Schema.optional(Tags)});
export const CreateWorkerConfigurationResponse = Schema.Struct({creationTime: Schema.optional(Schema.Date), latestRevision: Schema.optional(WorkerConfigurationRevisionSummary), name: Schema.optional(Schema.String), workerConfigurationArn: Schema.optional(Schema.String), workerConfigurationState: Schema.optional(Schema.String)});
export const InternalServerErrorException = Schema.Struct({message: Schema.optional(Schema.String)});
export const NotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ServiceUnavailableException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeConnectorOperationResponse = Schema.Struct({connectorArn: Schema.optional(Schema.String), connectorOperationArn: Schema.optional(Schema.String), connectorOperationState: Schema.optional(Schema.String), connectorOperationType: Schema.optional(Schema.String), operationSteps: Schema.optional(__listOfConnectorOperationStep), originWorkerSetting: Schema.optional(WorkerSetting), originConnectorConfiguration: Schema.optional(ConnectorConfiguration), targetWorkerSetting: Schema.optional(WorkerSetting), targetConnectorConfiguration: Schema.optional(ConnectorConfiguration), errorInfo: Schema.optional(StateDescription), creationTime: Schema.optional(Schema.Date), endTime: Schema.optional(Schema.Date)});
export const DescribeWorkerConfigurationResponse = Schema.Struct({creationTime: Schema.optional(Schema.Date), description: Schema.optional(Schema.String), latestRevision: Schema.optional(WorkerConfigurationRevisionDescription), name: Schema.optional(Schema.String), workerConfigurationArn: Schema.optional(Schema.String), workerConfigurationState: Schema.optional(Schema.String)});
export const ListConnectorOperationsResponse = Schema.Struct({connectorOperations: Schema.optional(__listOfConnectorOperationSummary), nextToken: Schema.optional(Schema.String)});
export const ListConnectorsResponse = Schema.Struct({connectors: Schema.optional(__listOfConnectorSummary), nextToken: Schema.optional(Schema.String)});
export const ListCustomPluginsResponse = Schema.Struct({customPlugins: Schema.optional(__listOfCustomPluginSummary), nextToken: Schema.optional(Schema.String)});
export const TooManyRequestsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ListWorkerConfigurationsResponse = Schema.Struct({nextToken: Schema.optional(Schema.String), workerConfigurations: Schema.optional(__listOfWorkerConfigurationSummary)});
export const ConflictException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UnauthorizedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const AutoScaling = Schema.Struct({maxWorkerCount: Schema.Number, mcuCount: Schema.Number, minWorkerCount: Schema.Number, scaleInPolicy: Schema.optional(ScaleInPolicy), scaleOutPolicy: Schema.optional(ScaleOutPolicy)});
export const ApacheKafkaCluster = Schema.Struct({bootstrapServers: Schema.String, vpc: Vpc});
export const WorkerLogDelivery = Schema.Struct({cloudWatchLogs: Schema.optional(CloudWatchLogsLogDelivery), firehose: Schema.optional(FirehoseLogDelivery), s3: Schema.optional(S3LogDelivery)});
export const AutoScalingUpdate = Schema.Struct({maxWorkerCount: Schema.Number, mcuCount: Schema.Number, minWorkerCount: Schema.Number, scaleInPolicy: ScaleInPolicyUpdate, scaleOutPolicy: ScaleOutPolicyUpdate});
export const Capacity = Schema.Struct({autoScaling: Schema.optional(AutoScaling), provisionedCapacity: Schema.optional(ProvisionedCapacity)});
export const KafkaCluster = Schema.Struct({apacheKafkaCluster: ApacheKafkaCluster});
export const LogDelivery = Schema.Struct({workerLogDelivery: WorkerLogDelivery});
export const CapacityUpdate = Schema.Struct({autoScaling: Schema.optional(AutoScalingUpdate), provisionedCapacity: Schema.optional(ProvisionedCapacityUpdate)});
export const CreateConnectorRequest = Schema.Struct({capacity: Capacity, connectorConfiguration: ConnectorConfiguration, connectorDescription: Schema.optional(Schema.String), connectorName: Schema.String, kafkaCluster: KafkaCluster, kafkaClusterClientAuthentication: KafkaClusterClientAuthentication, kafkaClusterEncryptionInTransit: KafkaClusterEncryptionInTransit, kafkaConnectVersion: Schema.String, logDelivery: Schema.optional(LogDelivery), plugins: __listOfPlugin, serviceExecutionRoleArn: Schema.String, workerConfiguration: Schema.optional(WorkerConfiguration), tags: Schema.optional(Tags)});
export const CreateCustomPluginResponse = Schema.Struct({customPluginArn: Schema.optional(Schema.String), customPluginState: Schema.optional(Schema.String), name: Schema.optional(Schema.String), revision: Schema.optional(Schema.Number)});
export const UpdateConnectorRequest = Schema.Struct({capacity: Schema.optional(CapacityUpdate), connectorConfiguration: Schema.optional(ConnectorConfigurationUpdate), connectorArn: Schema.String, currentVersion: Schema.String});
export const CreateConnectorResponse = Schema.Struct({connectorArn: Schema.optional(Schema.String), connectorName: Schema.optional(Schema.String), connectorState: Schema.optional(Schema.String)});
export const DescribeConnectorResponse = Schema.Struct({capacity: Schema.optional(CapacityDescription), connectorArn: Schema.optional(Schema.String), connectorConfiguration: Schema.optional(ConnectorConfiguration), connectorDescription: Schema.optional(Schema.String), connectorName: Schema.optional(Schema.String), connectorState: Schema.optional(Schema.String), creationTime: Schema.optional(Schema.Date), currentVersion: Schema.optional(Schema.String), kafkaCluster: Schema.optional(KafkaClusterDescription), kafkaClusterClientAuthentication: Schema.optional(KafkaClusterClientAuthenticationDescription), kafkaClusterEncryptionInTransit: Schema.optional(KafkaClusterEncryptionInTransitDescription), kafkaConnectVersion: Schema.optional(Schema.String), logDelivery: Schema.optional(LogDeliveryDescription), plugins: Schema.optional(__listOfPluginDescription), serviceExecutionRoleArn: Schema.optional(Schema.String), workerConfiguration: Schema.optional(WorkerConfigurationDescription), stateDescription: Schema.optional(StateDescription)});
export const DescribeCustomPluginResponse = Schema.Struct({creationTime: Schema.optional(Schema.Date), customPluginArn: Schema.optional(Schema.String), customPluginState: Schema.optional(Schema.String), description: Schema.optional(Schema.String), latestRevision: Schema.optional(CustomPluginRevisionSummary), name: Schema.optional(Schema.String), stateDescription: Schema.optional(StateDescription)});
export const UpdateConnectorResponse = Schema.Struct({connectorArn: Schema.optional(Schema.String), connectorState: Schema.optional(Schema.String), connectorOperationArn: Schema.optional(Schema.String)});
export const CreateWorkerConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/worker-configurations", method: "POST", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.CreateWorkerConfiguration" }, CreateWorkerConfigurationRequest, CreateWorkerConfigurationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteConnector = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/connectors/{connectorArn}", method: "DELETE", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.DeleteConnector" }, DeleteConnectorRequest, DeleteConnectorResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteCustomPlugin = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/custom-plugins/{customPluginArn}", method: "DELETE", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.DeleteCustomPlugin" }, DeleteCustomPluginRequest, DeleteCustomPluginResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteWorkerConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/worker-configurations/{workerConfigurationArn}", method: "DELETE", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.DeleteWorkerConfiguration" }, DeleteWorkerConfigurationRequest, DeleteWorkerConfigurationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeConnectorOperation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/connectorOperations/{connectorOperationArn}", method: "GET", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.DescribeConnectorOperation" }, DescribeConnectorOperationRequest, DescribeConnectorOperationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeWorkerConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/worker-configurations/{workerConfigurationArn}", method: "GET", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.DescribeWorkerConfiguration" }, DescribeWorkerConfigurationRequest, DescribeWorkerConfigurationResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListConnectorOperations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/connectors/{connectorArn}/operations", method: "GET", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.ListConnectorOperations" }, ListConnectorOperationsRequest, ListConnectorOperationsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListConnectors = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/connectors", method: "GET", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.ListConnectors" }, ListConnectorsRequest, ListConnectorsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListCustomPlugins = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/custom-plugins", method: "GET", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.ListCustomPlugins" }, ListCustomPluginsRequest, ListCustomPluginsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/tags/{resourceArn}", method: "GET", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListWorkerConfigurations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/worker-configurations", method: "GET", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.ListWorkerConfigurations" }, ListWorkerConfigurationsRequest, ListWorkerConfigurationsResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const TagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/tags/{resourceArn}", method: "POST", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.TagResource" }, TagResourceRequest, TagResourceResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UntagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/tags/{resourceArn}", method: "DELETE", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.UntagResource" }, UntagResourceRequest, UntagResourceResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateCustomPlugin = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/custom-plugins", method: "POST", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.CreateCustomPlugin" }, CreateCustomPluginRequest, CreateCustomPluginResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateConnector = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/connectors", method: "POST", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.CreateConnector" }, CreateConnectorRequest, CreateConnectorResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeConnector = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/connectors/{connectorArn}", method: "GET", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.DescribeConnector" }, DescribeConnectorRequest, DescribeConnectorResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeCustomPlugin = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/custom-plugins/{customPluginArn}", method: "GET", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.DescribeCustomPlugin" }, DescribeCustomPluginRequest, DescribeCustomPluginResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateConnector = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-09-14", uri: "/v1/connectors/{connectorArn}", method: "PUT", sdkId: "KafkaConnect", sigV4ServiceName: "kafkaconnect", name: "KafkaConnect.UpdateConnector" }, UpdateConnectorRequest, UpdateConnectorResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ForbiddenException", ForbiddenException), ErrorAnnotation("InternalServerErrorException", InternalServerErrorException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("TooManyRequestsException", TooManyRequestsException), ErrorAnnotation("UnauthorizedException", UnauthorizedException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
