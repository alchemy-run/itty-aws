import { Schema} from "effect"
import { FormatXMLRequest, FormatXMLResponse, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
const DeleteSessionRequest = Schema.Struct({botName: Schema.String, botAlias: Schema.String, userId: Schema.String})
const GetSessionRequest = Schema.Struct({botName: Schema.String, botAlias: Schema.String, userId: Schema.String, checkpointLabelFilter: Schema.optional(Schema.String)})
const PostContentRequest = Schema.Struct({botName: Schema.String, botAlias: Schema.String, userId: Schema.String, sessionAttributes: Schema.optional(Header("x-amz-lex-session-attributes")), requestAttributes: Schema.optional(Header("x-amz-lex-request-attributes")), contentType: Header("Content-Type"), accept: Schema.optional(Header("Accept")), inputStream: Body("undefined", StreamBody()), activeContexts: Schema.optional(Header("x-amz-lex-active-contexts"))})
const StringMap = Schema.Record({key: Schema.String, value: Schema.String})
const DialogAction = Schema.Struct({type: Schema.String, intentName: Schema.optional(Schema.String), slots: Schema.optional(StringMap), slotToElicit: Schema.optional(Schema.String), fulfillmentState: Schema.optional(Schema.String), message: Schema.optional(Schema.String), messageFormat: Schema.optional(Schema.String)})
const IntentSummary = Schema.Struct({intentName: Schema.optional(Schema.String), checkpointLabel: Schema.optional(Schema.String), slots: Schema.optional(StringMap), confirmationStatus: Schema.optional(Schema.String), dialogActionType: Schema.String, fulfillmentState: Schema.optional(Schema.String), slotToElicit: Schema.optional(Schema.String)})
const IntentSummaryList = Schema.Array(IntentSummary)
const DeleteSessionResponse = Schema.Struct({botName: Schema.optional(Schema.String), botAlias: Schema.optional(Schema.String), userId: Schema.optional(Schema.String), sessionId: Schema.optional(Schema.String)})
const GetSessionResponse = Schema.Struct({recentIntentSummaryView: Schema.optional(IntentSummaryList), sessionAttributes: Schema.optional(StringMap), sessionId: Schema.optional(Schema.String), dialogAction: Schema.optional(DialogAction), activeContexts: Schema.optional(ActiveContextsList)})
const PostContentResponse = Schema.Struct({contentType: Schema.optional(Header("Content-Type")), intentName: Schema.optional(Header("x-amz-lex-intent-name")), nluIntentConfidence: Schema.optional(Header("x-amz-lex-nlu-intent-confidence")), alternativeIntents: Schema.optional(Header("x-amz-lex-alternative-intents")), slots: Schema.optional(Header("x-amz-lex-slots")), sessionAttributes: Schema.optional(Header("x-amz-lex-session-attributes")), sentimentResponse: Schema.optional(Header("x-amz-lex-sentiment")), message: Schema.optional(Header("x-amz-lex-message")), encodedMessage: Schema.optional(Header("x-amz-lex-encoded-message")), messageFormat: Schema.optional(Header("x-amz-lex-message-format")), dialogState: Schema.optional(Header("x-amz-lex-dialog-state")), slotToElicit: Schema.optional(Header("x-amz-lex-slot-to-elicit")), inputTranscript: Schema.optional(Header("x-amz-lex-input-transcript")), encodedInputTranscript: Schema.optional(Header("x-amz-lex-encoded-input-transcript")), audioStream: Schema.optional(Body("undefined", StreamBody())), botVersion: Schema.optional(Header("x-amz-lex-bot-version")), sessionId: Schema.optional(Header("x-amz-lex-session-id")), activeContexts: Schema.optional(Header("x-amz-lex-active-contexts"))})
const PutSessionRequest = Schema.Struct({botName: Schema.String, botAlias: Schema.String, userId: Schema.String, sessionAttributes: Schema.optional(StringMap), dialogAction: Schema.optional(DialogAction), recentIntentSummaryView: Schema.optional(IntentSummaryList), accept: Schema.optional(Header("Accept")), activeContexts: Schema.optional(ActiveContextsList)})
const ActiveContextTimeToLive = Schema.Struct({timeToLiveInSeconds: Schema.optional(Schema.Number), turnsToLive: Schema.optional(Schema.Number)})
const ActiveContextParametersMap = Schema.Record({key: Schema.String, value: Schema.String})
const ActiveContext = Schema.Struct({name: Schema.String, timeToLive: ActiveContextTimeToLive, parameters: ActiveContextParametersMap})
const ActiveContextsList = Schema.Array(ActiveContext)
const BadRequestException = Schema.Struct({message: Schema.optional(Schema.String)})
const InternalFailureException = Schema.Struct({message: Schema.optional(Schema.String)})
const BadGatewayException = Schema.Struct({Message: Schema.optional(Schema.String)})
const PostTextRequest = Schema.Struct({botName: Schema.String, botAlias: Schema.String, userId: Schema.String, sessionAttributes: Schema.optional(StringMap), requestAttributes: Schema.optional(StringMap), inputText: Schema.String, activeContexts: Schema.optional(ActiveContextsList)})
const PutSessionResponse = Schema.Struct({contentType: Schema.optional(Header("Content-Type")), intentName: Schema.optional(Header("x-amz-lex-intent-name")), slots: Schema.optional(Header("x-amz-lex-slots")), sessionAttributes: Schema.optional(Header("x-amz-lex-session-attributes")), message: Schema.optional(Header("x-amz-lex-message")), encodedMessage: Schema.optional(Header("x-amz-lex-encoded-message")), messageFormat: Schema.optional(Header("x-amz-lex-message-format")), dialogState: Schema.optional(Header("x-amz-lex-dialog-state")), slotToElicit: Schema.optional(Header("x-amz-lex-slot-to-elicit")), audioStream: Schema.optional(Body("undefined", StreamBody())), sessionId: Schema.optional(Header("x-amz-lex-session-id")), activeContexts: Schema.optional(Header("x-amz-lex-active-contexts"))})
const ConflictException = Schema.Struct({message: Schema.optional(Schema.String)})
const LimitExceededException = Schema.Struct({retryAfterSeconds: Schema.optional(Header("Retry-After")), message: Schema.optional(Schema.String)})
export const GetSession = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/session", method: "GET", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "GetSession" }, GetSessionRequest, GetSessionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("InternalFailureException", InternalFailureException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DependencyFailedException = Schema.Struct({Message: Schema.optional(Schema.String)})
const NotAcceptableException = Schema.Struct({message: Schema.optional(Schema.String)})
export const PutSession = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/session", method: "POST", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "PutSession" }, PutSessionRequest, PutSessionResponse, Schema.Union(ErrorAnnotation("BadGatewayException", BadGatewayException), ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("DependencyFailedException", DependencyFailedException), ErrorAnnotation("InternalFailureException", InternalFailureException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("NotAcceptableException", NotAcceptableException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const IntentConfidence = Schema.Struct({score: Schema.optional(Schema.Number)})
const PredictedIntent = Schema.Struct({intentName: Schema.optional(Schema.String), nluIntentConfidence: Schema.optional(IntentConfidence), slots: Schema.optional(StringMap)})
const IntentList = Schema.Array(PredictedIntent)
const SentimentResponse = Schema.Struct({sentimentLabel: Schema.optional(Schema.String), sentimentScore: Schema.optional(Schema.String)})
const NotFoundException = Schema.Struct({message: Schema.optional(Schema.String)})
export const DeleteSession = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/session", method: "DELETE", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "DeleteSession" }, DeleteSessionRequest, DeleteSessionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalFailureException", InternalFailureException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const LoopDetectedException = Schema.Struct({Message: Schema.optional(Schema.String)})
const Button = Schema.Struct({text: Schema.String, value: Schema.String})
const listOfButtons = Schema.Array(Button)
const RequestTimeoutException = Schema.Struct({message: Schema.optional(Schema.String)})
const GenericAttachment = Schema.Struct({title: Schema.optional(Schema.String), subTitle: Schema.optional(Schema.String), attachmentLinkUrl: Schema.optional(Schema.String), imageUrl: Schema.optional(Schema.String), buttons: Schema.optional(listOfButtons)})
const genericAttachmentList = Schema.Array(GenericAttachment)
const ResponseCard = Schema.Struct({version: Schema.optional(Schema.String), contentType: Schema.optional(Schema.String), genericAttachments: Schema.optional(genericAttachmentList)})
const UnsupportedMediaTypeException = Schema.Struct({message: Schema.optional(Schema.String)})
export const PostContent = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/content", method: "POST", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "PostContent" }, PostContentRequest, PostContentResponse, Schema.Union(ErrorAnnotation("BadGatewayException", BadGatewayException), ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("DependencyFailedException", DependencyFailedException), ErrorAnnotation("InternalFailureException", InternalFailureException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("LoopDetectedException", LoopDetectedException), ErrorAnnotation("NotAcceptableException", NotAcceptableException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("RequestTimeoutException", RequestTimeoutException), ErrorAnnotation("UnsupportedMediaTypeException", UnsupportedMediaTypeException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PostTextResponse = Schema.Struct({intentName: Schema.optional(Schema.String), nluIntentConfidence: Schema.optional(IntentConfidence), alternativeIntents: Schema.optional(IntentList), slots: Schema.optional(StringMap), sessionAttributes: Schema.optional(StringMap), message: Schema.optional(Schema.String), sentimentResponse: Schema.optional(SentimentResponse), messageFormat: Schema.optional(Schema.String), dialogState: Schema.optional(Schema.String), slotToElicit: Schema.optional(Schema.String), responseCard: Schema.optional(ResponseCard), sessionId: Schema.optional(Schema.String), botVersion: Schema.optional(Schema.String), activeContexts: Schema.optional(ActiveContextsList)})
export const PostText = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/text", method: "POST", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "PostText" }, PostTextRequest, PostTextResponse, Schema.Union(ErrorAnnotation("BadGatewayException", BadGatewayException), ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("DependencyFailedException", DependencyFailedException), ErrorAnnotation("InternalFailureException", InternalFailureException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("LoopDetectedException", LoopDetectedException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
