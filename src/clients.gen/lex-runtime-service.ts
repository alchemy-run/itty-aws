import * as S from "effect/Schema"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import * as H from "../schema-helpers.ts";

//# Schemas
export class DeleteSessionRequest extends S.Class<DeleteSessionRequest>("DeleteSessionRequest")({botName: S.String, botAlias: S.String, userId: S.String}) {}
export class GetSessionRequest extends S.Class<GetSessionRequest>("GetSessionRequest")({botName: S.String, botAlias: S.String, userId: S.String, checkpointLabelFilter: S.optional(S.String)}) {}
export class PostContentRequest extends S.Class<PostContentRequest>("PostContentRequest")({botName: S.String, botAlias: S.String, userId: S.String, sessionAttributes: S.optional(H.Header("x-amz-lex-session-attributes")), requestAttributes: S.optional(H.Header("x-amz-lex-request-attributes")), contentType: H.Header("Content-Type"), accept: S.optional(H.Header("Accept")), inputStream: H.Body("undefined", H.StreamBody()), activeContexts: S.optional(H.Header("x-amz-lex-active-contexts"))}) {}
export const StringMap = S.Record({key: S.String, value: S.String});
export class DialogAction extends S.Class<DialogAction>("DialogAction")({type: S.String, intentName: S.optional(S.String), slots: S.optional(StringMap), slotToElicit: S.optional(S.String), fulfillmentState: S.optional(S.String), message: S.optional(S.String), messageFormat: S.optional(S.String)}) {}
export class IntentSummary extends S.Class<IntentSummary>("IntentSummary")({intentName: S.optional(S.String), checkpointLabel: S.optional(S.String), slots: S.optional(StringMap), confirmationStatus: S.optional(S.String), dialogActionType: S.String, fulfillmentState: S.optional(S.String), slotToElicit: S.optional(S.String)}) {}
export const IntentSummaryList = S.Array(IntentSummary);
export class DeleteSessionResponse extends S.Class<DeleteSessionResponse>("DeleteSessionResponse")({botName: S.optional(S.String), botAlias: S.optional(S.String), userId: S.optional(S.String), sessionId: S.optional(S.String)}) {}
export class ActiveContextTimeToLive extends S.Class<ActiveContextTimeToLive>("ActiveContextTimeToLive")({timeToLiveInSeconds: S.optional(S.Number), turnsToLive: S.optional(S.Number)}) {}
export const ActiveContextParametersMap = S.Record({key: S.String, value: S.String});
export class ActiveContext extends S.Class<ActiveContext>("ActiveContext")({name: S.String, timeToLive: ActiveContextTimeToLive, parameters: ActiveContextParametersMap}) {}
export const ActiveContextsList = S.Array(ActiveContext);
export class GetSessionResponse extends S.Class<GetSessionResponse>("GetSessionResponse")({recentIntentSummaryView: S.optional(IntentSummaryList), sessionAttributes: S.optional(StringMap), sessionId: S.optional(S.String), dialogAction: S.optional(DialogAction), activeContexts: S.optional(ActiveContextsList)}) {}
export class PostContentResponse extends S.Class<PostContentResponse>("PostContentResponse")({contentType: S.optional(H.Header("Content-Type")), intentName: S.optional(H.Header("x-amz-lex-intent-name")), nluIntentConfidence: S.optional(H.Header("x-amz-lex-nlu-intent-confidence")), alternativeIntents: S.optional(H.Header("x-amz-lex-alternative-intents")), slots: S.optional(H.Header("x-amz-lex-slots")), sessionAttributes: S.optional(H.Header("x-amz-lex-session-attributes")), sentimentResponse: S.optional(H.Header("x-amz-lex-sentiment")), message: S.optional(H.Header("x-amz-lex-message")), encodedMessage: S.optional(H.Header("x-amz-lex-encoded-message")), messageFormat: S.optional(H.Header("x-amz-lex-message-format")), dialogState: S.optional(H.Header("x-amz-lex-dialog-state")), slotToElicit: S.optional(H.Header("x-amz-lex-slot-to-elicit")), inputTranscript: S.optional(H.Header("x-amz-lex-input-transcript")), encodedInputTranscript: S.optional(H.Header("x-amz-lex-encoded-input-transcript")), audioStream: S.optional(H.Body("undefined", H.StreamBody())), botVersion: S.optional(H.Header("x-amz-lex-bot-version")), sessionId: S.optional(H.Header("x-amz-lex-session-id")), activeContexts: S.optional(H.Header("x-amz-lex-active-contexts"))}) {}
export class PutSessionRequest extends S.Class<PutSessionRequest>("PutSessionRequest")({botName: S.String, botAlias: S.String, userId: S.String, sessionAttributes: S.optional(StringMap), dialogAction: S.optional(DialogAction), recentIntentSummaryView: S.optional(IntentSummaryList), accept: S.optional(H.Header("Accept")), activeContexts: S.optional(ActiveContextsList)}) {}
export class BadRequestException extends S.Class<BadRequestException>("BadRequestException")({message: S.optional(S.String)}) {}
export class InternalFailureException extends S.Class<InternalFailureException>("InternalFailureException")({message: S.optional(S.String)}) {}
export class BadGatewayException extends S.Class<BadGatewayException>("BadGatewayException")({Message: S.optional(S.String)}) {}
export class PostTextRequest extends S.Class<PostTextRequest>("PostTextRequest")({botName: S.String, botAlias: S.String, userId: S.String, sessionAttributes: S.optional(StringMap), requestAttributes: S.optional(StringMap), inputText: S.String, activeContexts: S.optional(ActiveContextsList)}) {}
export class PutSessionResponse extends S.Class<PutSessionResponse>("PutSessionResponse")({contentType: S.optional(H.Header("Content-Type")), intentName: S.optional(H.Header("x-amz-lex-intent-name")), slots: S.optional(H.Header("x-amz-lex-slots")), sessionAttributes: S.optional(H.Header("x-amz-lex-session-attributes")), message: S.optional(H.Header("x-amz-lex-message")), encodedMessage: S.optional(H.Header("x-amz-lex-encoded-message")), messageFormat: S.optional(H.Header("x-amz-lex-message-format")), dialogState: S.optional(H.Header("x-amz-lex-dialog-state")), slotToElicit: S.optional(H.Header("x-amz-lex-slot-to-elicit")), audioStream: S.optional(H.Body("undefined", H.StreamBody())), sessionId: S.optional(H.Header("x-amz-lex-session-id")), activeContexts: S.optional(H.Header("x-amz-lex-active-contexts"))}) {}
export class ConflictException extends S.Class<ConflictException>("ConflictException")({message: S.optional(S.String)}) {}
export class LimitExceededException extends S.Class<LimitExceededException>("LimitExceededException")({retryAfterSeconds: S.optional(H.Header("Retry-After")), message: S.optional(S.String)}) {}
export class DependencyFailedException extends S.Class<DependencyFailedException>("DependencyFailedException")({Message: S.optional(S.String)}) {}
export class NotAcceptableException extends S.Class<NotAcceptableException>("NotAcceptableException")({message: S.optional(S.String)}) {}
export class IntentConfidence extends S.Class<IntentConfidence>("IntentConfidence")({score: S.optional(S.Number)}) {}
export class PredictedIntent extends S.Class<PredictedIntent>("PredictedIntent")({intentName: S.optional(S.String), nluIntentConfidence: S.optional(IntentConfidence), slots: S.optional(StringMap)}) {}
export const IntentList = S.Array(PredictedIntent);
export class SentimentResponse extends S.Class<SentimentResponse>("SentimentResponse")({sentimentLabel: S.optional(S.String), sentimentScore: S.optional(S.String)}) {}
export class NotFoundException extends S.Class<NotFoundException>("NotFoundException")({message: S.optional(S.String)}) {}
export class LoopDetectedException extends S.Class<LoopDetectedException>("LoopDetectedException")({Message: S.optional(S.String)}) {}
export class Button extends S.Class<Button>("Button")({text: S.String, value: S.String}) {}
export const listOfButtons = S.Array(Button);
export class RequestTimeoutException extends S.Class<RequestTimeoutException>("RequestTimeoutException")({message: S.optional(S.String)}) {}
export class GenericAttachment extends S.Class<GenericAttachment>("GenericAttachment")({title: S.optional(S.String), subTitle: S.optional(S.String), attachmentLinkUrl: S.optional(S.String), imageUrl: S.optional(S.String), buttons: S.optional(listOfButtons)}) {}
export const genericAttachmentList = S.Array(GenericAttachment);
export class ResponseCard extends S.Class<ResponseCard>("ResponseCard")({version: S.optional(S.String), contentType: S.optional(S.String), genericAttachments: S.optional(genericAttachmentList)}) {}
export class UnsupportedMediaTypeException extends S.Class<UnsupportedMediaTypeException>("UnsupportedMediaTypeException")({message: S.optional(S.String)}) {}
export class PostTextResponse extends S.Class<PostTextResponse>("PostTextResponse")({intentName: S.optional(S.String), nluIntentConfidence: S.optional(IntentConfidence), alternativeIntents: S.optional(IntentList), slots: S.optional(StringMap), sessionAttributes: S.optional(StringMap), message: S.optional(S.String), sentimentResponse: S.optional(SentimentResponse), messageFormat: S.optional(S.String), dialogState: S.optional(S.String), slotToElicit: S.optional(S.String), responseCard: S.optional(ResponseCard), sessionId: S.optional(S.String), botVersion: S.optional(S.String), activeContexts: S.optional(ActiveContextsList)}) {}

//# Errors
export class BadRequestExceptionError extends S.TaggedError<BadRequestExceptionError>()("BadRequestException", BadRequestException.fields) {};
export class InternalFailureExceptionError extends S.TaggedError<InternalFailureExceptionError>()("InternalFailureException", InternalFailureException.fields) {};
export class BadGatewayExceptionError extends S.TaggedError<BadGatewayExceptionError>()("BadGatewayException", BadGatewayException.fields) {};
export class ConflictExceptionError extends S.TaggedError<ConflictExceptionError>()("ConflictException", ConflictException.fields) {};
export class DependencyFailedExceptionError extends S.TaggedError<DependencyFailedExceptionError>()("DependencyFailedException", DependencyFailedException.fields) {};
export class LimitExceededExceptionError extends S.TaggedError<LimitExceededExceptionError>()("LimitExceededException", LimitExceededException.fields) {};
export class NotFoundExceptionError extends S.TaggedError<NotFoundExceptionError>()("NotFoundException", NotFoundException.fields) {};
export class NotAcceptableExceptionError extends S.TaggedError<NotAcceptableExceptionError>()("NotAcceptableException", NotAcceptableException.fields) {};
export class LoopDetectedExceptionError extends S.TaggedError<LoopDetectedExceptionError>()("LoopDetectedException", LoopDetectedException.fields) {};
export class RequestTimeoutExceptionError extends S.TaggedError<RequestTimeoutExceptionError>()("RequestTimeoutException", RequestTimeoutException.fields) {};
export class UnsupportedMediaTypeExceptionError extends S.TaggedError<UnsupportedMediaTypeExceptionError>()("UnsupportedMediaTypeException", UnsupportedMediaTypeException.fields) {};

//# Operations
export const getSession = /*#__PURE__*/ makeOperation(() => H.Operation({ version: "2016-11-28", uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/session", method: "GET", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "AWSDeepSenseRunTimeService.GetSession" }, GetSessionRequest, GetSessionResponse, [BadRequestExceptionError, InternalFailureExceptionError, LimitExceededExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const putSession = /*#__PURE__*/ makeOperation(() => H.Operation({ version: "2016-11-28", uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/session", method: "POST", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "AWSDeepSenseRunTimeService.PutSession" }, PutSessionRequest, PutSessionResponse, [BadGatewayExceptionError, BadRequestExceptionError, ConflictExceptionError, DependencyFailedExceptionError, InternalFailureExceptionError, LimitExceededExceptionError, NotAcceptableExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteSession = /*#__PURE__*/ makeOperation(() => H.Operation({ version: "2016-11-28", uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/session", method: "DELETE", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "AWSDeepSenseRunTimeService.DeleteSession" }, DeleteSessionRequest, DeleteSessionResponse, [BadRequestExceptionError, ConflictExceptionError, InternalFailureExceptionError, LimitExceededExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const postContent = /*#__PURE__*/ makeOperation(() => H.Operation({ version: "2016-11-28", uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/content", method: "POST", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "AWSDeepSenseRunTimeService.PostContent" }, PostContentRequest, PostContentResponse, [BadGatewayExceptionError, BadRequestExceptionError, ConflictExceptionError, DependencyFailedExceptionError, InternalFailureExceptionError, LimitExceededExceptionError, LoopDetectedExceptionError, NotAcceptableExceptionError, NotFoundExceptionError, RequestTimeoutExceptionError, UnsupportedMediaTypeExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const postText = /*#__PURE__*/ makeOperation(() => H.Operation({ version: "2016-11-28", uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/text", method: "POST", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "AWSDeepSenseRunTimeService.PostText" }, PostTextRequest, PostTextResponse, [BadGatewayExceptionError, BadRequestExceptionError, ConflictExceptionError, DependencyFailedExceptionError, InternalFailureExceptionError, LimitExceededExceptionError, LoopDetectedExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
