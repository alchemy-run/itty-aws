import { Schema} from "effect"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
export const DeleteSessionRequest = Schema.Struct({botName: Schema.String, botAlias: Schema.String, userId: Schema.String});
export const GetSessionRequest = Schema.Struct({botName: Schema.String, botAlias: Schema.String, userId: Schema.String, checkpointLabelFilter: Schema.optional(Schema.String)});
export const PostContentRequest = Schema.Struct({botName: Schema.String, botAlias: Schema.String, userId: Schema.String, sessionAttributes: Schema.optional(Header("x-amz-lex-session-attributes")), requestAttributes: Schema.optional(Header("x-amz-lex-request-attributes")), contentType: Header("Content-Type"), accept: Schema.optional(Header("Accept")), inputStream: Body("undefined", StreamBody()), activeContexts: Schema.optional(Header("x-amz-lex-active-contexts"))});
export const StringMap = Schema.Record({key: Schema.String, value: Schema.String});
export const DialogAction = Schema.Struct({type: Schema.String, intentName: Schema.optional(Schema.String), slots: Schema.optional(StringMap), slotToElicit: Schema.optional(Schema.String), fulfillmentState: Schema.optional(Schema.String), message: Schema.optional(Schema.String), messageFormat: Schema.optional(Schema.String)});
export const IntentSummary = Schema.Struct({intentName: Schema.optional(Schema.String), checkpointLabel: Schema.optional(Schema.String), slots: Schema.optional(StringMap), confirmationStatus: Schema.optional(Schema.String), dialogActionType: Schema.String, fulfillmentState: Schema.optional(Schema.String), slotToElicit: Schema.optional(Schema.String)});
export const IntentSummaryList = Schema.Array(IntentSummary);
export const DeleteSessionResponse = Schema.Struct({botName: Schema.optional(Schema.String), botAlias: Schema.optional(Schema.String), userId: Schema.optional(Schema.String), sessionId: Schema.optional(Schema.String)});
export const ActiveContextTimeToLive = Schema.Struct({timeToLiveInSeconds: Schema.optional(Schema.Number), turnsToLive: Schema.optional(Schema.Number)});
export const ActiveContextParametersMap = Schema.Record({key: Schema.String, value: Schema.String});
export const ActiveContext = Schema.Struct({name: Schema.String, timeToLive: ActiveContextTimeToLive, parameters: ActiveContextParametersMap});
export const ActiveContextsList = Schema.Array(ActiveContext);
export const GetSessionResponse = Schema.Struct({recentIntentSummaryView: Schema.optional(IntentSummaryList), sessionAttributes: Schema.optional(StringMap), sessionId: Schema.optional(Schema.String), dialogAction: Schema.optional(DialogAction), activeContexts: Schema.optional(ActiveContextsList)});
export const PostContentResponse = Schema.Struct({contentType: Schema.optional(Header("Content-Type")), intentName: Schema.optional(Header("x-amz-lex-intent-name")), nluIntentConfidence: Schema.optional(Header("x-amz-lex-nlu-intent-confidence")), alternativeIntents: Schema.optional(Header("x-amz-lex-alternative-intents")), slots: Schema.optional(Header("x-amz-lex-slots")), sessionAttributes: Schema.optional(Header("x-amz-lex-session-attributes")), sentimentResponse: Schema.optional(Header("x-amz-lex-sentiment")), message: Schema.optional(Header("x-amz-lex-message")), encodedMessage: Schema.optional(Header("x-amz-lex-encoded-message")), messageFormat: Schema.optional(Header("x-amz-lex-message-format")), dialogState: Schema.optional(Header("x-amz-lex-dialog-state")), slotToElicit: Schema.optional(Header("x-amz-lex-slot-to-elicit")), inputTranscript: Schema.optional(Header("x-amz-lex-input-transcript")), encodedInputTranscript: Schema.optional(Header("x-amz-lex-encoded-input-transcript")), audioStream: Schema.optional(Body("undefined", StreamBody())), botVersion: Schema.optional(Header("x-amz-lex-bot-version")), sessionId: Schema.optional(Header("x-amz-lex-session-id")), activeContexts: Schema.optional(Header("x-amz-lex-active-contexts"))});
export const PutSessionRequest = Schema.Struct({botName: Schema.String, botAlias: Schema.String, userId: Schema.String, sessionAttributes: Schema.optional(StringMap), dialogAction: Schema.optional(DialogAction), recentIntentSummaryView: Schema.optional(IntentSummaryList), accept: Schema.optional(Header("Accept")), activeContexts: Schema.optional(ActiveContextsList)});
export const BadRequestException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InternalFailureException = Schema.Struct({message: Schema.optional(Schema.String)});
export const BadGatewayException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const PostTextRequest = Schema.Struct({botName: Schema.String, botAlias: Schema.String, userId: Schema.String, sessionAttributes: Schema.optional(StringMap), requestAttributes: Schema.optional(StringMap), inputText: Schema.String, activeContexts: Schema.optional(ActiveContextsList)});
export const PutSessionResponse = Schema.Struct({contentType: Schema.optional(Header("Content-Type")), intentName: Schema.optional(Header("x-amz-lex-intent-name")), slots: Schema.optional(Header("x-amz-lex-slots")), sessionAttributes: Schema.optional(Header("x-amz-lex-session-attributes")), message: Schema.optional(Header("x-amz-lex-message")), encodedMessage: Schema.optional(Header("x-amz-lex-encoded-message")), messageFormat: Schema.optional(Header("x-amz-lex-message-format")), dialogState: Schema.optional(Header("x-amz-lex-dialog-state")), slotToElicit: Schema.optional(Header("x-amz-lex-slot-to-elicit")), audioStream: Schema.optional(Body("undefined", StreamBody())), sessionId: Schema.optional(Header("x-amz-lex-session-id")), activeContexts: Schema.optional(Header("x-amz-lex-active-contexts"))});
export const ConflictException = Schema.Struct({message: Schema.optional(Schema.String)});
export const LimitExceededException = Schema.Struct({retryAfterSeconds: Schema.optional(Header("Retry-After")), message: Schema.optional(Schema.String)});
export const DependencyFailedException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NotAcceptableException = Schema.Struct({message: Schema.optional(Schema.String)});
export const IntentConfidence = Schema.Struct({score: Schema.optional(Schema.Number)});
export const PredictedIntent = Schema.Struct({intentName: Schema.optional(Schema.String), nluIntentConfidence: Schema.optional(IntentConfidence), slots: Schema.optional(StringMap)});
export const IntentList = Schema.Array(PredictedIntent);
export const SentimentResponse = Schema.Struct({sentimentLabel: Schema.optional(Schema.String), sentimentScore: Schema.optional(Schema.String)});
export const NotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const LoopDetectedException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const Button = Schema.Struct({text: Schema.String, value: Schema.String});
export const listOfButtons = Schema.Array(Button);
export const RequestTimeoutException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GenericAttachment = Schema.Struct({title: Schema.optional(Schema.String), subTitle: Schema.optional(Schema.String), attachmentLinkUrl: Schema.optional(Schema.String), imageUrl: Schema.optional(Schema.String), buttons: Schema.optional(listOfButtons)});
export const genericAttachmentList = Schema.Array(GenericAttachment);
export const ResponseCard = Schema.Struct({version: Schema.optional(Schema.String), contentType: Schema.optional(Schema.String), genericAttachments: Schema.optional(genericAttachmentList)});
export const UnsupportedMediaTypeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PostTextResponse = Schema.Struct({intentName: Schema.optional(Schema.String), nluIntentConfidence: Schema.optional(IntentConfidence), alternativeIntents: Schema.optional(IntentList), slots: Schema.optional(StringMap), sessionAttributes: Schema.optional(StringMap), message: Schema.optional(Schema.String), sentimentResponse: Schema.optional(SentimentResponse), messageFormat: Schema.optional(Schema.String), dialogState: Schema.optional(Schema.String), slotToElicit: Schema.optional(Schema.String), responseCard: Schema.optional(ResponseCard), sessionId: Schema.optional(Schema.String), botVersion: Schema.optional(Schema.String), activeContexts: Schema.optional(ActiveContextsList)});
export const GetSession = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-28", uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/session", method: "GET", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "AWSDeepSenseRunTimeService.GetSession" }, GetSessionRequest, GetSessionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("InternalFailureException", InternalFailureException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const PutSession = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-28", uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/session", method: "POST", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "AWSDeepSenseRunTimeService.PutSession" }, PutSessionRequest, PutSessionResponse, Schema.Union(ErrorAnnotation("BadGatewayException", BadGatewayException), ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("DependencyFailedException", DependencyFailedException), ErrorAnnotation("InternalFailureException", InternalFailureException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("NotAcceptableException", NotAcceptableException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteSession = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-28", uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/session", method: "DELETE", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "AWSDeepSenseRunTimeService.DeleteSession" }, DeleteSessionRequest, DeleteSessionResponse, Schema.Union(ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalFailureException", InternalFailureException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const PostContent = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-28", uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/content", method: "POST", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "AWSDeepSenseRunTimeService.PostContent" }, PostContentRequest, PostContentResponse, Schema.Union(ErrorAnnotation("BadGatewayException", BadGatewayException), ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("DependencyFailedException", DependencyFailedException), ErrorAnnotation("InternalFailureException", InternalFailureException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("LoopDetectedException", LoopDetectedException), ErrorAnnotation("NotAcceptableException", NotAcceptableException), ErrorAnnotation("NotFoundException", NotFoundException), ErrorAnnotation("RequestTimeoutException", RequestTimeoutException), ErrorAnnotation("UnsupportedMediaTypeException", UnsupportedMediaTypeException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const PostText = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-28", uri: "/bot/{botName}/alias/{botAlias}/user/{userId}/text", method: "POST", sdkId: "Lex Runtime Service", sigV4ServiceName: "lex", name: "AWSDeepSenseRunTimeService.PostText" }, PostTextRequest, PostTextResponse, Schema.Union(ErrorAnnotation("BadGatewayException", BadGatewayException), ErrorAnnotation("BadRequestException", BadRequestException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("DependencyFailedException", DependencyFailedException), ErrorAnnotation("InternalFailureException", InternalFailureException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("LoopDetectedException", LoopDetectedException), ErrorAnnotation("NotFoundException", NotFoundException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
