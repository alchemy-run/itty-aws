import { Schema} from "effect"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const StringList = Schema.Array(Schema.String);
export const IncludeClustersList = Schema.Array(Schema.String);
export const EksAnywhereSubscriptionStatusValues = Schema.Array(Schema.String);
export const TagKeyList = Schema.Array(Schema.String);
export const TagMap = Schema.Record({key: Schema.String, value: Schema.String});
export const CreateAccessEntryRequest = Schema.Struct({clusterName: Schema.String, principalArn: Schema.String, kubernetesGroups: Schema.optional(StringList), tags: Schema.optional(TagMap), clientRequestToken: Schema.optional(Schema.String), username: Schema.optional(Schema.String), type: Schema.optional(Schema.String)});
export const CreatePodIdentityAssociationRequest = Schema.Struct({clusterName: Schema.String, namespace: Schema.String, serviceAccount: Schema.String, roleArn: Schema.String, clientRequestToken: Schema.optional(Schema.String), tags: Schema.optional(TagMap), disableSessionTags: Schema.optional(Schema.Boolean), targetRoleArn: Schema.optional(Schema.String)});
export const DeleteAccessEntryRequest = Schema.Struct({clusterName: Schema.String, principalArn: Schema.String});
export const DeleteAccessEntryResponse = Schema.Struct({});
export const DeleteAddonRequest = Schema.Struct({clusterName: Schema.String, addonName: Schema.String, preserve: Schema.optional(Schema.Boolean)});
export const DeleteClusterRequest = Schema.Struct({name: Schema.String});
export const DeleteEksAnywhereSubscriptionRequest = Schema.Struct({id: Schema.String});
export const DeleteFargateProfileRequest = Schema.Struct({clusterName: Schema.String, fargateProfileName: Schema.String});
export const DeleteNodegroupRequest = Schema.Struct({clusterName: Schema.String, nodegroupName: Schema.String});
export const DeletePodIdentityAssociationRequest = Schema.Struct({clusterName: Schema.String, associationId: Schema.String});
export const DeregisterClusterRequest = Schema.Struct({name: Schema.String});
export const DescribeAccessEntryRequest = Schema.Struct({clusterName: Schema.String, principalArn: Schema.String});
export const DescribeAddonRequest = Schema.Struct({clusterName: Schema.String, addonName: Schema.String});
export const DescribeAddonConfigurationRequest = Schema.Struct({addonName: Schema.String, addonVersion: Schema.String});
export const DescribeAddonVersionsRequest = Schema.Struct({kubernetesVersion: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), addonName: Schema.optional(Schema.String), types: Schema.optional(StringList), publishers: Schema.optional(StringList), owners: Schema.optional(StringList)});
export const DescribeClusterRequest = Schema.Struct({name: Schema.String});
export const DescribeClusterVersionsRequest = Schema.Struct({clusterType: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), defaultOnly: Schema.optional(Schema.Boolean), includeAll: Schema.optional(Schema.Boolean), clusterVersions: Schema.optional(StringList), status: Schema.optional(Schema.String), versionStatus: Schema.optional(Schema.String)});
export const DescribeEksAnywhereSubscriptionRequest = Schema.Struct({id: Schema.String});
export const DescribeFargateProfileRequest = Schema.Struct({clusterName: Schema.String, fargateProfileName: Schema.String});
export const DescribeInsightRequest = Schema.Struct({clusterName: Schema.String, id: Schema.String});
export const DescribeInsightsRefreshRequest = Schema.Struct({clusterName: Schema.String});
export const DescribeNodegroupRequest = Schema.Struct({clusterName: Schema.String, nodegroupName: Schema.String});
export const DescribePodIdentityAssociationRequest = Schema.Struct({clusterName: Schema.String, associationId: Schema.String});
export const DescribeUpdateRequest = Schema.Struct({name: Schema.String, updateId: Schema.String, nodegroupName: Schema.optional(Schema.String), addonName: Schema.optional(Schema.String)});
export const DisassociateAccessPolicyRequest = Schema.Struct({clusterName: Schema.String, principalArn: Schema.String, policyArn: Schema.String});
export const DisassociateAccessPolicyResponse = Schema.Struct({});
export const IdentityProviderConfig = Schema.Struct({type: Schema.String, name: Schema.String});
export const DisassociateIdentityProviderConfigRequest = Schema.Struct({clusterName: Schema.String, identityProviderConfig: IdentityProviderConfig, clientRequestToken: Schema.optional(Schema.String)});
export const ListAccessEntriesRequest = Schema.Struct({clusterName: Schema.String, associatedPolicyArn: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListAccessPoliciesRequest = Schema.Struct({maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListAddonsRequest = Schema.Struct({clusterName: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListAssociatedAccessPoliciesRequest = Schema.Struct({clusterName: Schema.String, principalArn: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListClustersRequest = Schema.Struct({maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), include: Schema.optional(IncludeClustersList)});
export const ListEksAnywhereSubscriptionsRequest = Schema.Struct({maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), includeStatus: Schema.optional(EksAnywhereSubscriptionStatusValues)});
export const ListFargateProfilesRequest = Schema.Struct({clusterName: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListIdentityProviderConfigsRequest = Schema.Struct({clusterName: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListNodegroupsRequest = Schema.Struct({clusterName: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListPodIdentityAssociationsRequest = Schema.Struct({clusterName: Schema.String, namespace: Schema.optional(Schema.String), serviceAccount: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListTagsForResourceRequest = Schema.Struct({resourceArn: Schema.String});
export const ListUpdatesRequest = Schema.Struct({name: Schema.String, nodegroupName: Schema.optional(Schema.String), addonName: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const StartInsightsRefreshRequest = Schema.Struct({clusterName: Schema.String});
export const TagResourceRequest = Schema.Struct({resourceArn: Schema.String, tags: TagMap});
export const TagResourceResponse = Schema.Struct({});
export const UntagResourceRequest = Schema.Struct({resourceArn: Schema.String, tagKeys: TagKeyList});
export const UntagResourceResponse = Schema.Struct({});
export const UpdateAccessEntryRequest = Schema.Struct({clusterName: Schema.String, principalArn: Schema.String, kubernetesGroups: Schema.optional(StringList), clientRequestToken: Schema.optional(Schema.String), username: Schema.optional(Schema.String)});
export const AddonPodIdentityAssociations = Schema.Struct({serviceAccount: Schema.String, roleArn: Schema.String});
export const AddonPodIdentityAssociationsList = Schema.Array(AddonPodIdentityAssociations);
export const UpdateAddonRequest = Schema.Struct({clusterName: Schema.String, addonName: Schema.String, addonVersion: Schema.optional(Schema.String), serviceAccountRoleArn: Schema.optional(Schema.String), resolveConflicts: Schema.optional(Schema.String), clientRequestToken: Schema.optional(Schema.String), configurationValues: Schema.optional(Schema.String), podIdentityAssociations: Schema.optional(AddonPodIdentityAssociationsList)});
export const UpdateClusterVersionRequest = Schema.Struct({name: Schema.String, version: Schema.String, clientRequestToken: Schema.optional(Schema.String), force: Schema.optional(Schema.Boolean)});
export const UpdateEksAnywhereSubscriptionRequest = Schema.Struct({id: Schema.String, autoRenew: Schema.Boolean, clientRequestToken: Schema.optional(Schema.String)});
export const LaunchTemplateSpecification = Schema.Struct({name: Schema.optional(Schema.String), version: Schema.optional(Schema.String), id: Schema.optional(Schema.String)});
export const UpdateNodegroupVersionRequest = Schema.Struct({clusterName: Schema.String, nodegroupName: Schema.String, version: Schema.optional(Schema.String), releaseVersion: Schema.optional(Schema.String), launchTemplate: Schema.optional(LaunchTemplateSpecification), force: Schema.optional(Schema.Boolean), clientRequestToken: Schema.optional(Schema.String)});
export const UpdatePodIdentityAssociationRequest = Schema.Struct({clusterName: Schema.String, associationId: Schema.String, roleArn: Schema.optional(Schema.String), clientRequestToken: Schema.optional(Schema.String), disableSessionTags: Schema.optional(Schema.Boolean), targetRoleArn: Schema.optional(Schema.String)});
export const CategoryList = Schema.Array(Schema.String);
export const InsightStatusValueList = Schema.Array(Schema.String);
export const labelsKeyList = Schema.Array(Schema.String);
export const AccessScope = Schema.Struct({type: Schema.optional(Schema.String), namespaces: Schema.optional(StringList)});
export const AddonNamespaceConfigRequest = Schema.Struct({namespace: Schema.optional(Schema.String)});
export const VpcConfigRequest = Schema.Struct({subnetIds: Schema.optional(StringList), securityGroupIds: Schema.optional(StringList), endpointPublicAccess: Schema.optional(Schema.Boolean), endpointPrivateAccess: Schema.optional(Schema.Boolean), publicAccessCidrs: Schema.optional(StringList)});
export const CreateAccessConfigRequest = Schema.Struct({bootstrapClusterCreatorAdminPermissions: Schema.optional(Schema.Boolean), authenticationMode: Schema.optional(Schema.String)});
export const UpgradePolicyRequest = Schema.Struct({supportType: Schema.optional(Schema.String)});
export const ZonalShiftConfigRequest = Schema.Struct({enabled: Schema.optional(Schema.Boolean)});
export const ComputeConfigRequest = Schema.Struct({enabled: Schema.optional(Schema.Boolean), nodePools: Schema.optional(StringList), nodeRoleArn: Schema.optional(Schema.String)});
export const EksAnywhereSubscriptionTerm = Schema.Struct({duration: Schema.optional(Schema.Number), unit: Schema.optional(Schema.String)});
export const NodegroupScalingConfig = Schema.Struct({minSize: Schema.optional(Schema.Number), maxSize: Schema.optional(Schema.Number), desiredSize: Schema.optional(Schema.Number)});
export const RemoteAccessConfig = Schema.Struct({ec2SshKey: Schema.optional(Schema.String), sourceSecurityGroups: Schema.optional(StringList)});
export const labelsMap = Schema.Record({key: Schema.String, value: Schema.String});
export const Taint = Schema.Struct({key: Schema.optional(Schema.String), value: Schema.optional(Schema.String), effect: Schema.optional(Schema.String)});
export const taintsList = Schema.Array(Taint);
export const NodegroupUpdateConfig = Schema.Struct({maxUnavailable: Schema.optional(Schema.Number), maxUnavailablePercentage: Schema.optional(Schema.Number), updateStrategy: Schema.optional(Schema.String)});
export const License = Schema.Struct({id: Schema.optional(Schema.String), token: Schema.optional(Schema.String)});
export const LicenseList = Schema.Array(License);
export const EksAnywhereSubscription = Schema.Struct({id: Schema.optional(Schema.String), arn: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), effectiveDate: Schema.optional(Schema.Date), expirationDate: Schema.optional(Schema.Date), licenseQuantity: Schema.optional(Schema.Number), licenseType: Schema.optional(Schema.String), term: Schema.optional(EksAnywhereSubscriptionTerm), status: Schema.optional(Schema.String), autoRenew: Schema.optional(Schema.Boolean), licenseArns: Schema.optional(StringList), licenses: Schema.optional(LicenseList), tags: Schema.optional(TagMap)});
export const EksAnywhereSubscriptionList = Schema.Array(EksAnywhereSubscription);
export const IdentityProviderConfigs = Schema.Array(IdentityProviderConfig);
export const InsightsFilter = Schema.Struct({categories: Schema.optional(CategoryList), kubernetesVersions: Schema.optional(StringList), statuses: Schema.optional(InsightStatusValueList)});
export const ConnectorConfigRequest = Schema.Struct({roleArn: Schema.String, provider: Schema.String});
export const UpdateAccessConfigRequest = Schema.Struct({authenticationMode: Schema.optional(Schema.String)});
export const UpdateLabelsPayload = Schema.Struct({addOrUpdateLabels: Schema.optional(labelsMap), removeLabels: Schema.optional(labelsKeyList)});
export const UpdateTaintsPayload = Schema.Struct({addOrUpdateTaints: Schema.optional(taintsList), removeTaints: Schema.optional(taintsList)});
export const LogTypes = Schema.Array(Schema.String);
export const AssociateAccessPolicyRequest = Schema.Struct({clusterName: Schema.String, principalArn: Schema.String, policyArn: Schema.String, accessScope: AccessScope});
export const CreateAddonRequest = Schema.Struct({clusterName: Schema.String, addonName: Schema.String, addonVersion: Schema.optional(Schema.String), serviceAccountRoleArn: Schema.optional(Schema.String), resolveConflicts: Schema.optional(Schema.String), clientRequestToken: Schema.optional(Schema.String), tags: Schema.optional(TagMap), configurationValues: Schema.optional(Schema.String), podIdentityAssociations: Schema.optional(AddonPodIdentityAssociationsList), namespaceConfig: Schema.optional(AddonNamespaceConfigRequest)});
export const CreateEksAnywhereSubscriptionRequest = Schema.Struct({name: Schema.String, term: EksAnywhereSubscriptionTerm, licenseQuantity: Schema.optional(Schema.Number), licenseType: Schema.optional(Schema.String), autoRenew: Schema.optional(Schema.Boolean), clientRequestToken: Schema.optional(Schema.String), tags: Schema.optional(TagMap)});
export const InvalidRequestException = Schema.Struct({clusterName: Schema.optional(Schema.String), nodegroupName: Schema.optional(Schema.String), addonName: Schema.optional(Schema.String), subscriptionId: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const PodIdentityAssociation = Schema.Struct({clusterName: Schema.optional(Schema.String), namespace: Schema.optional(Schema.String), serviceAccount: Schema.optional(Schema.String), roleArn: Schema.optional(Schema.String), associationArn: Schema.optional(Schema.String), associationId: Schema.optional(Schema.String), tags: Schema.optional(TagMap), createdAt: Schema.optional(Schema.Date), modifiedAt: Schema.optional(Schema.Date), ownerArn: Schema.optional(Schema.String), disableSessionTags: Schema.optional(Schema.Boolean), targetRoleArn: Schema.optional(Schema.String), externalId: Schema.optional(Schema.String)});
export const DeletePodIdentityAssociationResponse = Schema.Struct({association: Schema.optional(PodIdentityAssociation)});
export const VpcConfigResponse = Schema.Struct({subnetIds: Schema.optional(StringList), securityGroupIds: Schema.optional(StringList), clusterSecurityGroupId: Schema.optional(Schema.String), vpcId: Schema.optional(Schema.String), endpointPublicAccess: Schema.optional(Schema.Boolean), endpointPrivateAccess: Schema.optional(Schema.Boolean), publicAccessCidrs: Schema.optional(StringList)});
export const ElasticLoadBalancing = Schema.Struct({enabled: Schema.optional(Schema.Boolean)});
export const KubernetesNetworkConfigResponse = Schema.Struct({serviceIpv4Cidr: Schema.optional(Schema.String), serviceIpv6Cidr: Schema.optional(Schema.String), ipFamily: Schema.optional(Schema.String), elasticLoadBalancing: Schema.optional(ElasticLoadBalancing)});
export const LogSetup = Schema.Struct({types: Schema.optional(LogTypes), enabled: Schema.optional(Schema.Boolean)});
export const LogSetups = Schema.Array(LogSetup);
export const Logging = Schema.Struct({clusterLogging: Schema.optional(LogSetups)});
export const OIDC = Schema.Struct({issuer: Schema.optional(Schema.String)});
export const Identity = Schema.Struct({oidc: Schema.optional(OIDC)});
export const Certificate = Schema.Struct({data: Schema.optional(Schema.String)});
export const Provider = Schema.Struct({keyArn: Schema.optional(Schema.String)});
export const EncryptionConfig = Schema.Struct({resources: Schema.optional(StringList), provider: Schema.optional(Provider)});
export const EncryptionConfigList = Schema.Array(EncryptionConfig);
export const ConnectorConfigResponse = Schema.Struct({activationId: Schema.optional(Schema.String), activationCode: Schema.optional(Schema.String), activationExpiry: Schema.optional(Schema.Date), provider: Schema.optional(Schema.String), roleArn: Schema.optional(Schema.String)});
export const ClusterIssue = Schema.Struct({code: Schema.optional(Schema.String), message: Schema.optional(Schema.String), resourceIds: Schema.optional(StringList)});
export const ClusterIssueList = Schema.Array(ClusterIssue);
export const ClusterHealth = Schema.Struct({issues: Schema.optional(ClusterIssueList)});
export const ControlPlanePlacementResponse = Schema.Struct({groupName: Schema.optional(Schema.String)});
export const OutpostConfigResponse = Schema.Struct({outpostArns: StringList, controlPlaneInstanceType: Schema.String, controlPlanePlacement: Schema.optional(ControlPlanePlacementResponse)});
export const AccessConfigResponse = Schema.Struct({bootstrapClusterCreatorAdminPermissions: Schema.optional(Schema.Boolean), authenticationMode: Schema.optional(Schema.String)});
export const UpgradePolicyResponse = Schema.Struct({supportType: Schema.optional(Schema.String)});
export const ZonalShiftConfigResponse = Schema.Struct({enabled: Schema.optional(Schema.Boolean)});
export const RemoteNodeNetwork = Schema.Struct({cidrs: Schema.optional(StringList)});
export const RemoteNodeNetworkList = Schema.Array(RemoteNodeNetwork);
export const RemotePodNetwork = Schema.Struct({cidrs: Schema.optional(StringList)});
export const RemotePodNetworkList = Schema.Array(RemotePodNetwork);
export const RemoteNetworkConfigResponse = Schema.Struct({remoteNodeNetworks: Schema.optional(RemoteNodeNetworkList), remotePodNetworks: Schema.optional(RemotePodNetworkList)});
export const ComputeConfigResponse = Schema.Struct({enabled: Schema.optional(Schema.Boolean), nodePools: Schema.optional(StringList), nodeRoleArn: Schema.optional(Schema.String)});
export const BlockStorage = Schema.Struct({enabled: Schema.optional(Schema.Boolean)});
export const StorageConfigResponse = Schema.Struct({blockStorage: Schema.optional(BlockStorage)});
export const Cluster = Schema.Struct({name: Schema.optional(Schema.String), arn: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), version: Schema.optional(Schema.String), endpoint: Schema.optional(Schema.String), roleArn: Schema.optional(Schema.String), resourcesVpcConfig: Schema.optional(VpcConfigResponse), kubernetesNetworkConfig: Schema.optional(KubernetesNetworkConfigResponse), logging: Schema.optional(Logging), identity: Schema.optional(Identity), status: Schema.optional(Schema.String), certificateAuthority: Schema.optional(Certificate), clientRequestToken: Schema.optional(Schema.String), platformVersion: Schema.optional(Schema.String), tags: Schema.optional(TagMap), encryptionConfig: Schema.optional(EncryptionConfigList), connectorConfig: Schema.optional(ConnectorConfigResponse), id: Schema.optional(Schema.String), health: Schema.optional(ClusterHealth), outpostConfig: Schema.optional(OutpostConfigResponse), accessConfig: Schema.optional(AccessConfigResponse), upgradePolicy: Schema.optional(UpgradePolicyResponse), zonalShiftConfig: Schema.optional(ZonalShiftConfigResponse), remoteNetworkConfig: Schema.optional(RemoteNetworkConfigResponse), computeConfig: Schema.optional(ComputeConfigResponse), storageConfig: Schema.optional(StorageConfigResponse), deletionProtection: Schema.optional(Schema.Boolean)});
export const DeregisterClusterResponse = Schema.Struct({cluster: Schema.optional(Cluster)});
export const AccessEntry = Schema.Struct({clusterName: Schema.optional(Schema.String), principalArn: Schema.optional(Schema.String), kubernetesGroups: Schema.optional(StringList), accessEntryArn: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), modifiedAt: Schema.optional(Schema.Date), tags: Schema.optional(TagMap), username: Schema.optional(Schema.String), type: Schema.optional(Schema.String)});
export const DescribeAccessEntryResponse = Schema.Struct({accessEntry: Schema.optional(AccessEntry)});
export const AddonIssue = Schema.Struct({code: Schema.optional(Schema.String), message: Schema.optional(Schema.String), resourceIds: Schema.optional(StringList)});
export const AddonIssueList = Schema.Array(AddonIssue);
export const AddonHealth = Schema.Struct({issues: Schema.optional(AddonIssueList)});
export const MarketplaceInformation = Schema.Struct({productId: Schema.optional(Schema.String), productUrl: Schema.optional(Schema.String)});
export const AddonNamespaceConfigResponse = Schema.Struct({namespace: Schema.optional(Schema.String)});
export const Addon = Schema.Struct({addonName: Schema.optional(Schema.String), clusterName: Schema.optional(Schema.String), status: Schema.optional(Schema.String), addonVersion: Schema.optional(Schema.String), health: Schema.optional(AddonHealth), addonArn: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), modifiedAt: Schema.optional(Schema.Date), serviceAccountRoleArn: Schema.optional(Schema.String), tags: Schema.optional(TagMap), publisher: Schema.optional(Schema.String), owner: Schema.optional(Schema.String), marketplaceInformation: Schema.optional(MarketplaceInformation), configurationValues: Schema.optional(Schema.String), podIdentityAssociations: Schema.optional(StringList), namespaceConfig: Schema.optional(AddonNamespaceConfigResponse)});
export const DescribeAddonResponse = Schema.Struct({addon: Schema.optional(Addon)});
export const DescribeClusterResponse = Schema.Struct({cluster: Schema.optional(Cluster)});
export const DescribeEksAnywhereSubscriptionResponse = Schema.Struct({subscription: Schema.optional(EksAnywhereSubscription)});
export const FargateProfileLabel = Schema.Record({key: Schema.String, value: Schema.String});
export const FargateProfileSelector = Schema.Struct({namespace: Schema.optional(Schema.String), labels: Schema.optional(FargateProfileLabel)});
export const FargateProfileSelectors = Schema.Array(FargateProfileSelector);
export const FargateProfileIssue = Schema.Struct({code: Schema.optional(Schema.String), message: Schema.optional(Schema.String), resourceIds: Schema.optional(StringList)});
export const FargateProfileIssueList = Schema.Array(FargateProfileIssue);
export const FargateProfileHealth = Schema.Struct({issues: Schema.optional(FargateProfileIssueList)});
export const FargateProfile = Schema.Struct({fargateProfileName: Schema.optional(Schema.String), fargateProfileArn: Schema.optional(Schema.String), clusterName: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), podExecutionRoleArn: Schema.optional(Schema.String), subnets: Schema.optional(StringList), selectors: Schema.optional(FargateProfileSelectors), status: Schema.optional(Schema.String), tags: Schema.optional(TagMap), health: Schema.optional(FargateProfileHealth)});
export const DescribeFargateProfileResponse = Schema.Struct({fargateProfile: Schema.optional(FargateProfile)});
export const DescribeIdentityProviderConfigRequest = Schema.Struct({clusterName: Schema.String, identityProviderConfig: IdentityProviderConfig});
export const DescribeInsightsRefreshResponse = Schema.Struct({message: Schema.optional(Schema.String), status: Schema.optional(Schema.String), startedAt: Schema.optional(Schema.Date), endedAt: Schema.optional(Schema.Date)});
export const AutoScalingGroup = Schema.Struct({name: Schema.optional(Schema.String)});
export const AutoScalingGroupList = Schema.Array(AutoScalingGroup);
export const NodegroupResources = Schema.Struct({autoScalingGroups: Schema.optional(AutoScalingGroupList), remoteAccessSecurityGroup: Schema.optional(Schema.String)});
export const Issue = Schema.Struct({code: Schema.optional(Schema.String), message: Schema.optional(Schema.String), resourceIds: Schema.optional(StringList)});
export const IssueList = Schema.Array(Issue);
export const NodegroupHealth = Schema.Struct({issues: Schema.optional(IssueList)});
export const NodeRepairConfigOverrides = Schema.Struct({nodeMonitoringCondition: Schema.optional(Schema.String), nodeUnhealthyReason: Schema.optional(Schema.String), minRepairWaitTimeMins: Schema.optional(Schema.Number), repairAction: Schema.optional(Schema.String)});
export const NodeRepairConfigOverridesList = Schema.Array(NodeRepairConfigOverrides);
export const NodeRepairConfig = Schema.Struct({enabled: Schema.optional(Schema.Boolean), maxUnhealthyNodeThresholdCount: Schema.optional(Schema.Number), maxUnhealthyNodeThresholdPercentage: Schema.optional(Schema.Number), maxParallelNodesRepairedCount: Schema.optional(Schema.Number), maxParallelNodesRepairedPercentage: Schema.optional(Schema.Number), nodeRepairConfigOverrides: Schema.optional(NodeRepairConfigOverridesList)});
export const Nodegroup = Schema.Struct({nodegroupName: Schema.optional(Schema.String), nodegroupArn: Schema.optional(Schema.String), clusterName: Schema.optional(Schema.String), version: Schema.optional(Schema.String), releaseVersion: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), modifiedAt: Schema.optional(Schema.Date), status: Schema.optional(Schema.String), capacityType: Schema.optional(Schema.String), scalingConfig: Schema.optional(NodegroupScalingConfig), instanceTypes: Schema.optional(StringList), subnets: Schema.optional(StringList), remoteAccess: Schema.optional(RemoteAccessConfig), amiType: Schema.optional(Schema.String), nodeRole: Schema.optional(Schema.String), labels: Schema.optional(labelsMap), taints: Schema.optional(taintsList), resources: Schema.optional(NodegroupResources), diskSize: Schema.optional(Schema.Number), health: Schema.optional(NodegroupHealth), updateConfig: Schema.optional(NodegroupUpdateConfig), nodeRepairConfig: Schema.optional(NodeRepairConfig), launchTemplate: Schema.optional(LaunchTemplateSpecification), tags: Schema.optional(TagMap)});
export const DescribeNodegroupResponse = Schema.Struct({nodegroup: Schema.optional(Nodegroup)});
export const DescribePodIdentityAssociationResponse = Schema.Struct({association: Schema.optional(PodIdentityAssociation)});
export const ResourceNotFoundException = Schema.Struct({clusterName: Schema.optional(Schema.String), nodegroupName: Schema.optional(Schema.String), fargateProfileName: Schema.optional(Schema.String), addonName: Schema.optional(Schema.String), subscriptionId: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const UpdateParam = Schema.Struct({type: Schema.optional(Schema.String), value: Schema.optional(Schema.String)});
export const UpdateParams = Schema.Array(UpdateParam);
export const ErrorDetail = Schema.Struct({errorCode: Schema.optional(Schema.String), errorMessage: Schema.optional(Schema.String), resourceIds: Schema.optional(StringList)});
export const ErrorDetails = Schema.Array(ErrorDetail);
export const Update = Schema.Struct({id: Schema.optional(Schema.String), status: Schema.optional(Schema.String), type: Schema.optional(Schema.String), params: Schema.optional(UpdateParams), createdAt: Schema.optional(Schema.Date), errors: Schema.optional(ErrorDetails)});
export const DisassociateIdentityProviderConfigResponse = Schema.Struct({update: Schema.optional(Update)});
export const ListAccessEntriesResponse = Schema.Struct({accessEntries: Schema.optional(StringList), nextToken: Schema.optional(Schema.String)});
export const ListAddonsResponse = Schema.Struct({addons: Schema.optional(StringList), nextToken: Schema.optional(Schema.String)});
export const ListClustersResponse = Schema.Struct({clusters: Schema.optional(StringList), nextToken: Schema.optional(Schema.String)});
export const ListEksAnywhereSubscriptionsResponse = Schema.Struct({subscriptions: Schema.optional(EksAnywhereSubscriptionList), nextToken: Schema.optional(Schema.String)});
export const ListFargateProfilesResponse = Schema.Struct({fargateProfileNames: Schema.optional(StringList), nextToken: Schema.optional(Schema.String)});
export const ListIdentityProviderConfigsResponse = Schema.Struct({identityProviderConfigs: Schema.optional(IdentityProviderConfigs), nextToken: Schema.optional(Schema.String)});
export const ListInsightsRequest = Schema.Struct({clusterName: Schema.String, filter: Schema.optional(InsightsFilter), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListNodegroupsResponse = Schema.Struct({nodegroups: Schema.optional(StringList), nextToken: Schema.optional(Schema.String)});
export const ListTagsForResourceResponse = Schema.Struct({tags: Schema.optional(TagMap)});
export const ListUpdatesResponse = Schema.Struct({updateIds: Schema.optional(StringList), nextToken: Schema.optional(Schema.String)});
export const RegisterClusterRequest = Schema.Struct({name: Schema.String, connectorConfig: ConnectorConfigRequest, clientRequestToken: Schema.optional(Schema.String), tags: Schema.optional(TagMap)});
export const StartInsightsRefreshResponse = Schema.Struct({message: Schema.optional(Schema.String), status: Schema.optional(Schema.String)});
export const BadRequestException = Schema.Struct({message: Schema.optional(Schema.String)});
export const NotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdateAccessEntryResponse = Schema.Struct({accessEntry: Schema.optional(AccessEntry)});
export const UpdateAddonResponse = Schema.Struct({update: Schema.optional(Update)});
export const KubernetesNetworkConfigRequest = Schema.Struct({serviceIpv4Cidr: Schema.optional(Schema.String), ipFamily: Schema.optional(Schema.String), elasticLoadBalancing: Schema.optional(ElasticLoadBalancing)});
export const StorageConfigRequest = Schema.Struct({blockStorage: Schema.optional(BlockStorage)});
export const RemoteNetworkConfigRequest = Schema.Struct({remoteNodeNetworks: Schema.optional(RemoteNodeNetworkList), remotePodNetworks: Schema.optional(RemotePodNetworkList)});
export const UpdateClusterConfigRequest = Schema.Struct({name: Schema.String, resourcesVpcConfig: Schema.optional(VpcConfigRequest), logging: Schema.optional(Logging), clientRequestToken: Schema.optional(Schema.String), accessConfig: Schema.optional(UpdateAccessConfigRequest), upgradePolicy: Schema.optional(UpgradePolicyRequest), zonalShiftConfig: Schema.optional(ZonalShiftConfigRequest), computeConfig: Schema.optional(ComputeConfigRequest), kubernetesNetworkConfig: Schema.optional(KubernetesNetworkConfigRequest), storageConfig: Schema.optional(StorageConfigRequest), remoteNetworkConfig: Schema.optional(RemoteNetworkConfigRequest), deletionProtection: Schema.optional(Schema.Boolean)});
export const UpdateClusterVersionResponse = Schema.Struct({update: Schema.optional(Update)});
export const UpdateEksAnywhereSubscriptionResponse = Schema.Struct({subscription: Schema.optional(EksAnywhereSubscription)});
export const UpdateNodegroupConfigRequest = Schema.Struct({clusterName: Schema.String, nodegroupName: Schema.String, labels: Schema.optional(UpdateLabelsPayload), taints: Schema.optional(UpdateTaintsPayload), scalingConfig: Schema.optional(NodegroupScalingConfig), updateConfig: Schema.optional(NodegroupUpdateConfig), nodeRepairConfig: Schema.optional(NodeRepairConfig), clientRequestToken: Schema.optional(Schema.String)});
export const UpdateNodegroupVersionResponse = Schema.Struct({update: Schema.optional(Update)});
export const UpdatePodIdentityAssociationResponse = Schema.Struct({association: Schema.optional(PodIdentityAssociation)});
export const requiredClaimsMap = Schema.Record({key: Schema.String, value: Schema.String});
export const ControlPlanePlacementRequest = Schema.Struct({groupName: Schema.optional(Schema.String)});
export const OidcIdentityProviderConfigRequest = Schema.Struct({identityProviderConfigName: Schema.String, issuerUrl: Schema.String, clientId: Schema.String, usernameClaim: Schema.optional(Schema.String), usernamePrefix: Schema.optional(Schema.String), groupsClaim: Schema.optional(Schema.String), groupsPrefix: Schema.optional(Schema.String), requiredClaims: Schema.optional(requiredClaimsMap)});
export const OutpostConfigRequest = Schema.Struct({outpostArns: StringList, controlPlaneInstanceType: Schema.String, controlPlanePlacement: Schema.optional(ControlPlanePlacementRequest)});
export const AddonPodIdentityConfiguration = Schema.Struct({serviceAccount: Schema.optional(Schema.String), recommendedManagedPolicies: Schema.optional(StringList)});
export const AddonPodIdentityConfigurationList = Schema.Array(AddonPodIdentityConfiguration);
export const ClusterVersionInformation = Schema.Struct({clusterVersion: Schema.optional(Schema.String), clusterType: Schema.optional(Schema.String), defaultPlatformVersion: Schema.optional(Schema.String), defaultVersion: Schema.optional(Schema.Boolean), releaseDate: Schema.optional(Schema.Date), endOfStandardSupportDate: Schema.optional(Schema.Date), endOfExtendedSupportDate: Schema.optional(Schema.Date), status: Schema.optional(Schema.String), versionStatus: Schema.optional(Schema.String), kubernetesPatchVersion: Schema.optional(Schema.String)});
export const ClusterVersionList = Schema.Array(ClusterVersionInformation);
export const AccessPolicy = Schema.Struct({name: Schema.optional(Schema.String), arn: Schema.optional(Schema.String)});
export const AccessPoliciesList = Schema.Array(AccessPolicy);
export const AssociatedAccessPolicy = Schema.Struct({policyArn: Schema.optional(Schema.String), accessScope: Schema.optional(AccessScope), associatedAt: Schema.optional(Schema.Date), modifiedAt: Schema.optional(Schema.Date)});
export const AssociatedAccessPoliciesList = Schema.Array(AssociatedAccessPolicy);
export const PodIdentityAssociationSummary = Schema.Struct({clusterName: Schema.optional(Schema.String), namespace: Schema.optional(Schema.String), serviceAccount: Schema.optional(Schema.String), associationArn: Schema.optional(Schema.String), associationId: Schema.optional(Schema.String), ownerArn: Schema.optional(Schema.String)});
export const PodIdentityAssociationSummaries = Schema.Array(PodIdentityAssociationSummary);
export const AssociateAccessPolicyResponse = Schema.Struct({clusterName: Schema.optional(Schema.String), principalArn: Schema.optional(Schema.String), associatedAccessPolicy: Schema.optional(AssociatedAccessPolicy)});
export const AssociateEncryptionConfigRequest = Schema.Struct({clusterName: Schema.String, encryptionConfig: EncryptionConfigList, clientRequestToken: Schema.optional(Schema.String)});
export const AssociateIdentityProviderConfigRequest = Schema.Struct({clusterName: Schema.String, oidc: OidcIdentityProviderConfigRequest, tags: Schema.optional(TagMap), clientRequestToken: Schema.optional(Schema.String)});
export const CreateAccessEntryResponse = Schema.Struct({accessEntry: Schema.optional(AccessEntry)});
export const CreateAddonResponse = Schema.Struct({addon: Schema.optional(Addon)});
export const CreateClusterRequest = Schema.Struct({name: Schema.String, version: Schema.optional(Schema.String), roleArn: Schema.String, resourcesVpcConfig: VpcConfigRequest, kubernetesNetworkConfig: Schema.optional(KubernetesNetworkConfigRequest), logging: Schema.optional(Logging), clientRequestToken: Schema.optional(Schema.String), tags: Schema.optional(TagMap), encryptionConfig: Schema.optional(EncryptionConfigList), outpostConfig: Schema.optional(OutpostConfigRequest), accessConfig: Schema.optional(CreateAccessConfigRequest), bootstrapSelfManagedAddons: Schema.optional(Schema.Boolean), upgradePolicy: Schema.optional(UpgradePolicyRequest), zonalShiftConfig: Schema.optional(ZonalShiftConfigRequest), remoteNetworkConfig: Schema.optional(RemoteNetworkConfigRequest), computeConfig: Schema.optional(ComputeConfigRequest), storageConfig: Schema.optional(StorageConfigRequest), deletionProtection: Schema.optional(Schema.Boolean)});
export const CreateEksAnywhereSubscriptionResponse = Schema.Struct({subscription: Schema.optional(EksAnywhereSubscription)});
export const CreateFargateProfileRequest = Schema.Struct({fargateProfileName: Schema.String, clusterName: Schema.String, podExecutionRoleArn: Schema.String, subnets: Schema.optional(StringList), selectors: Schema.optional(FargateProfileSelectors), clientRequestToken: Schema.optional(Schema.String), tags: Schema.optional(TagMap)});
export const CreateNodegroupRequest = Schema.Struct({clusterName: Schema.String, nodegroupName: Schema.String, scalingConfig: Schema.optional(NodegroupScalingConfig), diskSize: Schema.optional(Schema.Number), subnets: StringList, instanceTypes: Schema.optional(StringList), amiType: Schema.optional(Schema.String), remoteAccess: Schema.optional(RemoteAccessConfig), nodeRole: Schema.String, labels: Schema.optional(labelsMap), taints: Schema.optional(taintsList), tags: Schema.optional(TagMap), clientRequestToken: Schema.optional(Schema.String), launchTemplate: Schema.optional(LaunchTemplateSpecification), updateConfig: Schema.optional(NodegroupUpdateConfig), nodeRepairConfig: Schema.optional(NodeRepairConfig), capacityType: Schema.optional(Schema.String), version: Schema.optional(Schema.String), releaseVersion: Schema.optional(Schema.String)});
export const CreatePodIdentityAssociationResponse = Schema.Struct({association: Schema.optional(PodIdentityAssociation)});
export const ServerException = Schema.Struct({clusterName: Schema.optional(Schema.String), nodegroupName: Schema.optional(Schema.String), addonName: Schema.optional(Schema.String), subscriptionId: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const InvalidParameterException = Schema.Struct({clusterName: Schema.optional(Schema.String), nodegroupName: Schema.optional(Schema.String), fargateProfileName: Schema.optional(Schema.String), addonName: Schema.optional(Schema.String), subscriptionId: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const AccessDeniedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ClientException = Schema.Struct({clusterName: Schema.optional(Schema.String), nodegroupName: Schema.optional(Schema.String), addonName: Schema.optional(Schema.String), subscriptionId: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const DescribeAddonConfigurationResponse = Schema.Struct({addonName: Schema.optional(Schema.String), addonVersion: Schema.optional(Schema.String), configurationSchema: Schema.optional(Schema.String), podIdentityConfiguration: Schema.optional(AddonPodIdentityConfigurationList)});
export const ServiceUnavailableException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeClusterVersionsResponse = Schema.Struct({nextToken: Schema.optional(Schema.String), clusterVersions: Schema.optional(ClusterVersionList)});
export const ResourceInUseException = Schema.Struct({clusterName: Schema.optional(Schema.String), nodegroupName: Schema.optional(Schema.String), addonName: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const ListAccessPoliciesResponse = Schema.Struct({accessPolicies: Schema.optional(AccessPoliciesList), nextToken: Schema.optional(Schema.String)});
export const ListAssociatedAccessPoliciesResponse = Schema.Struct({clusterName: Schema.optional(Schema.String), principalArn: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), associatedAccessPolicies: Schema.optional(AssociatedAccessPoliciesList)});
export const ListPodIdentityAssociationsResponse = Schema.Struct({associations: Schema.optional(PodIdentityAssociationSummaries), nextToken: Schema.optional(Schema.String)});
export const RegisterClusterResponse = Schema.Struct({cluster: Schema.optional(Cluster)});
export const UpdateClusterConfigResponse = Schema.Struct({update: Schema.optional(Update)});
export const InvalidStateException = Schema.Struct({clusterName: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const UpdateNodegroupConfigResponse = Schema.Struct({update: Schema.optional(Update)});
export const InsightStatus = Schema.Struct({status: Schema.optional(Schema.String), reason: Schema.optional(Schema.String)});
export const AdditionalInfoMap = Schema.Record({key: Schema.String, value: Schema.String});
export const InsightResourceDetail = Schema.Struct({insightStatus: Schema.optional(InsightStatus), kubernetesResourceUri: Schema.optional(Schema.String), arn: Schema.optional(Schema.String)});
export const InsightResourceDetails = Schema.Array(InsightResourceDetail);
export const InsightSummary = Schema.Struct({id: Schema.optional(Schema.String), name: Schema.optional(Schema.String), category: Schema.optional(Schema.String), kubernetesVersion: Schema.optional(Schema.String), lastRefreshTime: Schema.optional(Schema.Date), lastTransitionTime: Schema.optional(Schema.Date), description: Schema.optional(Schema.String), insightStatus: Schema.optional(InsightStatus)});
export const InsightSummaries = Schema.Array(InsightSummary);
export const Compatibility = Schema.Struct({clusterVersion: Schema.optional(Schema.String), platformVersions: Schema.optional(StringList), defaultVersion: Schema.optional(Schema.Boolean)});
export const Compatibilities = Schema.Array(Compatibility);
export const AddonCompatibilityDetail = Schema.Struct({name: Schema.optional(Schema.String), compatibleVersions: Schema.optional(StringList)});
export const AddonCompatibilityDetails = Schema.Array(AddonCompatibilityDetail);
export const AssociateEncryptionConfigResponse = Schema.Struct({update: Schema.optional(Update)});
export const AssociateIdentityProviderConfigResponse = Schema.Struct({update: Schema.optional(Update), tags: Schema.optional(TagMap)});
export const ResourceLimitExceededException = Schema.Struct({clusterName: Schema.optional(Schema.String), nodegroupName: Schema.optional(Schema.String), subscriptionId: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const CreateClusterResponse = Schema.Struct({cluster: Schema.optional(Cluster)});
export const CreateFargateProfileResponse = Schema.Struct({fargateProfile: Schema.optional(FargateProfile)});
export const CreateNodegroupResponse = Schema.Struct({nodegroup: Schema.optional(Nodegroup)});
export const DeleteEksAnywhereSubscriptionResponse = Schema.Struct({subscription: Schema.optional(EksAnywhereSubscription)});
export const DescribeUpdateResponse = Schema.Struct({update: Schema.optional(Update)});
export const ThrottlingException = Schema.Struct({clusterName: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const ListInsightsResponse = Schema.Struct({insights: Schema.optional(InsightSummaries), nextToken: Schema.optional(Schema.String)});
export const ResourcePropagationDelayException = Schema.Struct({message: Schema.optional(Schema.String)});
export const AddonVersionInfo = Schema.Struct({addonVersion: Schema.optional(Schema.String), architecture: Schema.optional(StringList), computeTypes: Schema.optional(StringList), compatibilities: Schema.optional(Compatibilities), requiresConfiguration: Schema.optional(Schema.Boolean), requiresIamPermissions: Schema.optional(Schema.Boolean)});
export const AddonVersionInfoList = Schema.Array(AddonVersionInfo);
export const OidcIdentityProviderConfig = Schema.Struct({identityProviderConfigName: Schema.optional(Schema.String), identityProviderConfigArn: Schema.optional(Schema.String), clusterName: Schema.optional(Schema.String), issuerUrl: Schema.optional(Schema.String), clientId: Schema.optional(Schema.String), usernameClaim: Schema.optional(Schema.String), usernamePrefix: Schema.optional(Schema.String), groupsClaim: Schema.optional(Schema.String), groupsPrefix: Schema.optional(Schema.String), requiredClaims: Schema.optional(requiredClaimsMap), tags: Schema.optional(TagMap), status: Schema.optional(Schema.String)});
export const ClientStat = Schema.Struct({userAgent: Schema.optional(Schema.String), numberOfRequestsLast30Days: Schema.optional(Schema.Number), lastRequestTime: Schema.optional(Schema.Date)});
export const ClientStats = Schema.Array(ClientStat);
export const AddonInfo = Schema.Struct({addonName: Schema.optional(Schema.String), type: Schema.optional(Schema.String), addonVersions: Schema.optional(AddonVersionInfoList), publisher: Schema.optional(Schema.String), owner: Schema.optional(Schema.String), marketplaceInformation: Schema.optional(MarketplaceInformation), defaultNamespace: Schema.optional(Schema.String)});
export const Addons = Schema.Array(AddonInfo);
export const IdentityProviderConfigResponse = Schema.Struct({oidc: Schema.optional(OidcIdentityProviderConfig)});
export const DeprecationDetail = Schema.Struct({usage: Schema.optional(Schema.String), replacedWith: Schema.optional(Schema.String), stopServingVersion: Schema.optional(Schema.String), startServingReplacementVersion: Schema.optional(Schema.String), clientStats: Schema.optional(ClientStats)});
export const DeprecationDetails = Schema.Array(DeprecationDetail);
export const UnsupportedAvailabilityZoneException = Schema.Struct({message: Schema.optional(Schema.String), clusterName: Schema.optional(Schema.String), nodegroupName: Schema.optional(Schema.String), validZones: Schema.optional(StringList)});
export const DeleteAddonResponse = Schema.Struct({addon: Schema.optional(Addon)});
export const DeleteClusterResponse = Schema.Struct({cluster: Schema.optional(Cluster)});
export const DeleteFargateProfileResponse = Schema.Struct({fargateProfile: Schema.optional(FargateProfile)});
export const DeleteNodegroupResponse = Schema.Struct({nodegroup: Schema.optional(Nodegroup)});
export const DescribeAddonVersionsResponse = Schema.Struct({addons: Schema.optional(Addons), nextToken: Schema.optional(Schema.String)});
export const DescribeIdentityProviderConfigResponse = Schema.Struct({identityProviderConfig: Schema.optional(IdentityProviderConfigResponse)});
export const InsightCategorySpecificSummary = Schema.Struct({deprecationDetails: Schema.optional(DeprecationDetails), addonCompatibilityDetails: Schema.optional(AddonCompatibilityDetails)});
export const Insight = Schema.Struct({id: Schema.optional(Schema.String), name: Schema.optional(Schema.String), category: Schema.optional(Schema.String), kubernetesVersion: Schema.optional(Schema.String), lastRefreshTime: Schema.optional(Schema.Date), lastTransitionTime: Schema.optional(Schema.Date), description: Schema.optional(Schema.String), insightStatus: Schema.optional(InsightStatus), recommendation: Schema.optional(Schema.String), additionalInfo: Schema.optional(AdditionalInfoMap), resources: Schema.optional(InsightResourceDetails), categorySpecificSummary: Schema.optional(InsightCategorySpecificSummary)});
export const DescribeInsightResponse = Schema.Struct({insight: Schema.optional(Insight)});

//# Errors
export class InvalidRequestExceptionError extends Schema.TaggedError<InvalidRequestExceptionError>()("InvalidRequestException", InvalidRequestException) {};
export class BadRequestExceptionError extends Schema.TaggedError<BadRequestExceptionError>()("BadRequestException", BadRequestException) {};
export class ResourceNotFoundExceptionError extends Schema.TaggedError<ResourceNotFoundExceptionError>()("ResourceNotFoundException", ResourceNotFoundException) {};
export class ServerExceptionError extends Schema.TaggedError<ServerExceptionError>()("ServerException", ServerException) {};
export class ClientExceptionError extends Schema.TaggedError<ClientExceptionError>()("ClientException", ClientException) {};
export class ServiceUnavailableExceptionError extends Schema.TaggedError<ServiceUnavailableExceptionError>()("ServiceUnavailableException", ServiceUnavailableException) {};
export class InvalidParameterExceptionError extends Schema.TaggedError<InvalidParameterExceptionError>()("InvalidParameterException", InvalidParameterException) {};
export class NotFoundExceptionError extends Schema.TaggedError<NotFoundExceptionError>()("NotFoundException", NotFoundException) {};
export class ResourceInUseExceptionError extends Schema.TaggedError<ResourceInUseExceptionError>()("ResourceInUseException", ResourceInUseException) {};
export class ResourceLimitExceededExceptionError extends Schema.TaggedError<ResourceLimitExceededExceptionError>()("ResourceLimitExceededException", ResourceLimitExceededException) {};
export class AccessDeniedExceptionError extends Schema.TaggedError<AccessDeniedExceptionError>()("AccessDeniedException", AccessDeniedException) {};
export class ThrottlingExceptionError extends Schema.TaggedError<ThrottlingExceptionError>()("ThrottlingException", ThrottlingException) {};
export class InvalidStateExceptionError extends Schema.TaggedError<InvalidStateExceptionError>()("InvalidStateException", InvalidStateException) {};
export class UnsupportedAvailabilityZoneExceptionError extends Schema.TaggedError<UnsupportedAvailabilityZoneExceptionError>()("UnsupportedAvailabilityZoneException", UnsupportedAvailabilityZoneException) {};
export class ResourcePropagationDelayExceptionError extends Schema.TaggedError<ResourcePropagationDelayExceptionError>()("ResourcePropagationDelayException", ResourcePropagationDelayException) {};

//# Operations
export const describeAccessEntry = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/access-entries/{principalArn}", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribeAccessEntry" }, DescribeAccessEntryRequest, DescribeAccessEntryResponse, [InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeEksAnywhereSubscription = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/eks-anywhere-subscriptions/{id}", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribeEksAnywhereSubscription" }, DescribeEksAnywhereSubscriptionRequest, DescribeEksAnywhereSubscriptionResponse, [ClientExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeFargateProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/fargate-profiles/{fargateProfileName}", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribeFargateProfile" }, DescribeFargateProfileRequest, DescribeFargateProfileResponse, [ClientExceptionError, InvalidParameterExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeInsightsRefresh = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/insights-refresh", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribeInsightsRefresh" }, DescribeInsightsRefreshRequest, DescribeInsightsRefreshResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeNodegroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/node-groups/{nodegroupName}", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribeNodegroup" }, DescribeNodegroupRequest, DescribeNodegroupResponse, [ClientExceptionError, InvalidParameterExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describePodIdentityAssociation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/pod-identity-associations/{associationId}", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribePodIdentityAssociation" }, DescribePodIdentityAssociationRequest, DescribePodIdentityAssociationResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const disassociateAccessPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/access-entries/{principalArn}/access-policies/{policyArn}", method: "DELETE", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DisassociateAccessPolicy" }, DisassociateAccessPolicyRequest, DisassociateAccessPolicyResponse, [InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listAccessEntries = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/access-entries", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.ListAccessEntries" }, ListAccessEntriesRequest, ListAccessEntriesResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listAddons = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/addons", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.ListAddons" }, ListAddonsRequest, ListAddonsResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listClusters = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.ListClusters" }, ListClustersRequest, ListClustersResponse, [ClientExceptionError, InvalidParameterExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listEksAnywhereSubscriptions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/eks-anywhere-subscriptions", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.ListEksAnywhereSubscriptions" }, ListEksAnywhereSubscriptionsRequest, ListEksAnywhereSubscriptionsResponse, [ClientExceptionError, InvalidParameterExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listFargateProfiles = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/fargate-profiles", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.ListFargateProfiles" }, ListFargateProfilesRequest, ListFargateProfilesResponse, [ClientExceptionError, InvalidParameterExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listIdentityProviderConfigs = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/identity-provider-configs", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.ListIdentityProviderConfigs" }, ListIdentityProviderConfigsRequest, ListIdentityProviderConfigsResponse, [ClientExceptionError, InvalidParameterExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listNodegroups = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/node-groups", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.ListNodegroups" }, ListNodegroupsRequest, ListNodegroupsResponse, [ClientExceptionError, InvalidParameterExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/tags/{resourceArn}", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, [BadRequestExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listUpdates = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{name}/updates", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.ListUpdates" }, ListUpdatesRequest, ListUpdatesResponse, [ClientExceptionError, InvalidParameterExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const startInsightsRefresh = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/insights-refresh", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.StartInsightsRefresh" }, StartInsightsRefreshRequest, StartInsightsRefreshResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const tagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/tags/{resourceArn}", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.TagResource" }, TagResourceRequest, TagResourceResponse, [BadRequestExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const untagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/tags/{resourceArn}", method: "DELETE", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.UntagResource" }, UntagResourceRequest, UntagResourceResponse, [BadRequestExceptionError, NotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateAccessEntry = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/access-entries/{principalArn}", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.UpdateAccessEntry" }, UpdateAccessEntryRequest, UpdateAccessEntryResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateAddon = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/addons/{addonName}/update", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.UpdateAddon" }, UpdateAddonRequest, UpdateAddonResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateEksAnywhereSubscription = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/eks-anywhere-subscriptions/{id}", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.UpdateEksAnywhereSubscription" }, UpdateEksAnywhereSubscriptionRequest, UpdateEksAnywhereSubscriptionResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateNodegroupVersion = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/node-groups/{nodegroupName}/update-version", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.UpdateNodegroupVersion" }, UpdateNodegroupVersionRequest, UpdateNodegroupVersionResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updatePodIdentityAssociation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/pod-identity-associations/{associationId}", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.UpdatePodIdentityAssociation" }, UpdatePodIdentityAssociationRequest, UpdatePodIdentityAssociationResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const associateAccessPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/access-entries/{principalArn}/access-policies", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.AssociateAccessPolicy" }, AssociateAccessPolicyRequest, AssociateAccessPolicyResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createAddon = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/addons", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.CreateAddon" }, CreateAddonRequest, CreateAddonResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createEksAnywhereSubscription = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/eks-anywhere-subscriptions", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.CreateEksAnywhereSubscription" }, CreateEksAnywhereSubscriptionRequest, CreateEksAnywhereSubscriptionResponse, [ClientExceptionError, InvalidParameterExceptionError, ResourceLimitExceededExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createPodIdentityAssociation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/pod-identity-associations", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.CreatePodIdentityAssociation" }, CreatePodIdentityAssociationRequest, CreatePodIdentityAssociationResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceInUseExceptionError, ResourceLimitExceededExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteAccessEntry = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/access-entries/{principalArn}", method: "DELETE", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DeleteAccessEntry" }, DeleteAccessEntryRequest, DeleteAccessEntryResponse, [InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deletePodIdentityAssociation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/pod-identity-associations/{associationId}", method: "DELETE", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DeletePodIdentityAssociation" }, DeletePodIdentityAssociationRequest, DeletePodIdentityAssociationResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deregisterCluster = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/cluster-registrations/{name}", method: "DELETE", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DeregisterCluster" }, DeregisterClusterRequest, DeregisterClusterResponse, [AccessDeniedExceptionError, ClientExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeAddon = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/addons/{addonName}", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribeAddon" }, DescribeAddonRequest, DescribeAddonResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeAddonConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/addons/configuration-schemas", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribeAddonConfiguration" }, DescribeAddonConfigurationRequest, DescribeAddonConfigurationResponse, [InvalidParameterExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeCluster = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{name}", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribeCluster" }, DescribeClusterRequest, DescribeClusterResponse, [ClientExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeClusterVersions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/cluster-versions", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribeClusterVersions" }, DescribeClusterVersionsRequest, DescribeClusterVersionsResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listAccessPolicies = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/access-policies", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.ListAccessPolicies" }, ListAccessPoliciesRequest, ListAccessPoliciesResponse, [ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listAssociatedAccessPolicies = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/access-entries/{principalArn}/access-policies", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.ListAssociatedAccessPolicies" }, ListAssociatedAccessPoliciesRequest, ListAssociatedAccessPoliciesResponse, [InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listPodIdentityAssociations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/pod-identity-associations", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.ListPodIdentityAssociations" }, ListPodIdentityAssociationsRequest, ListPodIdentityAssociationsResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateClusterConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{name}/update-config", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.UpdateClusterConfig" }, UpdateClusterConfigRequest, UpdateClusterConfigResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ThrottlingExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateClusterVersion = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{name}/updates", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.UpdateClusterVersion" }, UpdateClusterVersionRequest, UpdateClusterVersionResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, InvalidStateExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ThrottlingExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateNodegroupConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/node-groups/{nodegroupName}/update-config", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.UpdateNodegroupConfig" }, UpdateNodegroupConfigRequest, UpdateNodegroupConfigResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const associateEncryptionConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/encryption-config/associate", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.AssociateEncryptionConfig" }, AssociateEncryptionConfigRequest, AssociateEncryptionConfigResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ThrottlingExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const associateIdentityProviderConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/identity-provider-configs/associate", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.AssociateIdentityProviderConfig" }, AssociateIdentityProviderConfigRequest, AssociateIdentityProviderConfigResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ThrottlingExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createAccessEntry = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/access-entries", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.CreateAccessEntry" }, CreateAccessEntryRequest, CreateAccessEntryResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceInUseExceptionError, ResourceLimitExceededExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createFargateProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/fargate-profiles", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.CreateFargateProfile" }, CreateFargateProfileRequest, CreateFargateProfileResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceLimitExceededExceptionError, ServerExceptionError, UnsupportedAvailabilityZoneExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createNodegroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/node-groups", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.CreateNodegroup" }, CreateNodegroupRequest, CreateNodegroupResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceInUseExceptionError, ResourceLimitExceededExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteEksAnywhereSubscription = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/eks-anywhere-subscriptions/{id}", method: "DELETE", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DeleteEksAnywhereSubscription" }, DeleteEksAnywhereSubscriptionRequest, DeleteEksAnywhereSubscriptionResponse, [ClientExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeUpdate = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{name}/updates/{updateId}", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribeUpdate" }, DescribeUpdateRequest, DescribeUpdateResponse, [ClientExceptionError, InvalidParameterExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const disassociateIdentityProviderConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/identity-provider-configs/disassociate", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DisassociateIdentityProviderConfig" }, DisassociateIdentityProviderConfigRequest, DisassociateIdentityProviderConfigResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ThrottlingExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listInsights = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/insights", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.ListInsights" }, ListInsightsRequest, ListInsightsResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const registerCluster = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/cluster-registrations", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.RegisterCluster" }, RegisterClusterRequest, RegisterClusterResponse, [AccessDeniedExceptionError, ClientExceptionError, InvalidParameterExceptionError, ResourceInUseExceptionError, ResourceLimitExceededExceptionError, ResourcePropagationDelayExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createCluster = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.CreateCluster" }, CreateClusterRequest, CreateClusterResponse, [ClientExceptionError, InvalidParameterExceptionError, ResourceInUseExceptionError, ResourceLimitExceededExceptionError, ServerExceptionError, ServiceUnavailableExceptionError, UnsupportedAvailabilityZoneExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteAddon = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/addons/{addonName}", method: "DELETE", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DeleteAddon" }, DeleteAddonRequest, DeleteAddonResponse, [ClientExceptionError, InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteCluster = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{name}", method: "DELETE", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DeleteCluster" }, DeleteClusterRequest, DeleteClusterResponse, [ClientExceptionError, InvalidRequestExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteFargateProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/fargate-profiles/{fargateProfileName}", method: "DELETE", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DeleteFargateProfile" }, DeleteFargateProfileRequest, DeleteFargateProfileResponse, [ClientExceptionError, InvalidParameterExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteNodegroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/node-groups/{nodegroupName}", method: "DELETE", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DeleteNodegroup" }, DeleteNodegroupRequest, DeleteNodegroupResponse, [ClientExceptionError, InvalidParameterExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeAddonVersions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/addons/supported-versions", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribeAddonVersions" }, DescribeAddonVersionsRequest, DescribeAddonVersionsResponse, [InvalidParameterExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeIdentityProviderConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/identity-provider-configs/describe", method: "POST", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribeIdentityProviderConfig" }, DescribeIdentityProviderConfigRequest, DescribeIdentityProviderConfigResponse, [ClientExceptionError, InvalidParameterExceptionError, ResourceNotFoundExceptionError, ServerExceptionError, ServiceUnavailableExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeInsight = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-11-01", uri: "/clusters/{clusterName}/insights/{id}", method: "GET", sdkId: "EKS", sigV4ServiceName: "eks", name: "AWSWesleyFrontend.DescribeInsight" }, DescribeInsightRequest, DescribeInsightResponse, [InvalidParameterExceptionError, InvalidRequestExceptionError, ResourceNotFoundExceptionError, ServerExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
