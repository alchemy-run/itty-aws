import { Schema} from "effect"
import { FormatAwsJSON11Request,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
export const ColumnToJsonKeyMappings = Schema.Record({key: Schema.String, value: Schema.String});
export const HttpEndpointDescription = Schema.Struct({Url: Schema.optional(Schema.String), Name: Schema.optional(Schema.String)});
export const VpcConfigurationDescription = Schema.Struct({SubnetIds: SubnetIdList, RoleARN: Schema.String, SecurityGroupIds: SecurityGroupIdList, VpcId: Schema.String});
export const DatabaseSnapshotInfoList = Schema.Array(DatabaseSnapshotInfo);
export const DatabaseSnapshotInfo = Schema.Struct({Id: Schema.String, Table: Schema.String, RequestTimestamp: Schema.Date, RequestedBy: Schema.String, Status: Schema.String, FailureDescription: Schema.optional(FailureDescription)});
export const ServiceUnavailableException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidSourceException = Schema.Struct({code: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const OrcSerDe = Schema.Struct({StripeSizeBytes: Schema.optional(Schema.Number), BlockSizeBytes: Schema.optional(Schema.Number), RowIndexStride: Schema.optional(Schema.Number), EnablePadding: Schema.optional(Schema.Boolean), PaddingTolerance: Schema.optional(Schema.Number), Compression: Schema.optional(Schema.String), BloomFilterColumns: Schema.optional(ListOfNonEmptyStringsWithoutWhitespace), BloomFilterFalsePositiveProbability: Schema.optional(Schema.Number), DictionaryKeyThreshold: Schema.optional(Schema.Number), FormatVersion: Schema.optional(Schema.String)});
export const ParquetSerDe = Schema.Struct({BlockSizeBytes: Schema.optional(Schema.Number), PageSizeBytes: Schema.optional(Schema.Number), Compression: Schema.optional(Schema.String), EnableDictionaryCompression: Schema.optional(Schema.Boolean), MaxPaddingBytes: Schema.optional(Schema.Number), WriterVersion: Schema.optional(Schema.String)});
export const HiveJsonSerDe = Schema.Struct({TimestampFormats: Schema.optional(ListOfNonEmptyStrings)});
export const IcebergDestinationDescription = Schema.Struct({DestinationTableConfigurationList: Schema.optional(DestinationTableConfigurationList), SchemaEvolutionConfiguration: Schema.optional(SchemaEvolutionConfiguration), TableCreationConfiguration: Schema.optional(TableCreationConfiguration), BufferingHints: Schema.optional(BufferingHints), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), S3BackupMode: Schema.optional(Schema.String), RetryOptions: Schema.optional(RetryOptions), RoleARN: Schema.optional(Schema.String), AppendOnly: Schema.optional(Schema.Boolean), CatalogConfiguration: Schema.optional(CatalogConfiguration), S3DestinationDescription: Schema.optional(S3DestinationDescription)});
export const CreateDeliveryStreamOutput = Schema.Struct({DeliveryStreamARN: Schema.optional(Schema.String)});
export const OpenXJsonSerDe = Schema.Struct({ConvertDotsInJsonKeysToUnderscores: Schema.optional(Schema.Boolean), CaseInsensitive: Schema.optional(Schema.Boolean), ColumnToJsonKeyMappings: Schema.optional(ColumnToJsonKeyMappings)});
export const AmazonOpenSearchServerlessDestinationDescription = Schema.Struct({RoleARN: Schema.optional(Schema.String), CollectionEndpoint: Schema.optional(Schema.String), IndexName: Schema.optional(Schema.String), BufferingHints: Schema.optional(AmazonOpenSearchServerlessBufferingHints), RetryOptions: Schema.optional(AmazonOpenSearchServerlessRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3DestinationDescription: Schema.optional(S3DestinationDescription), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), VpcConfigurationDescription: Schema.optional(VpcConfigurationDescription)});
export const SnowflakeDestinationDescription = Schema.Struct({AccountUrl: Schema.optional(Schema.String), User: Schema.optional(Schema.String), Database: Schema.optional(Schema.String), Schema: Schema.optional(Schema.String), Table: Schema.optional(Schema.String), SnowflakeRoleConfiguration: Schema.optional(SnowflakeRoleConfiguration), DataLoadingOption: Schema.optional(Schema.String), MetaDataColumnName: Schema.optional(Schema.String), ContentColumnName: Schema.optional(Schema.String), SnowflakeVpcConfiguration: Schema.optional(SnowflakeVpcConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), RoleARN: Schema.optional(Schema.String), RetryOptions: Schema.optional(SnowflakeRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3DestinationDescription: Schema.optional(S3DestinationDescription), SecretsManagerConfiguration: Schema.optional(SecretsManagerConfiguration), BufferingHints: Schema.optional(SnowflakeBufferingHints)});
export const SplunkDestinationDescription = Schema.Struct({HECEndpoint: Schema.optional(Schema.String), HECEndpointType: Schema.optional(Schema.String), HECToken: Schema.optional(Schema.String), HECAcknowledgmentTimeoutInSeconds: Schema.optional(Schema.Number), RetryOptions: Schema.optional(SplunkRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3DestinationDescription: Schema.optional(S3DestinationDescription), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), BufferingHints: Schema.optional(SplunkBufferingHints), SecretsManagerConfiguration: Schema.optional(SecretsManagerConfiguration)});
export const HttpEndpointDestinationDescription = Schema.Struct({EndpointConfiguration: Schema.optional(HttpEndpointDescription), BufferingHints: Schema.optional(HttpEndpointBufferingHints), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), RequestConfiguration: Schema.optional(HttpEndpointRequestConfiguration), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), RoleARN: Schema.optional(Schema.String), RetryOptions: Schema.optional(HttpEndpointRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3DestinationDescription: Schema.optional(S3DestinationDescription), SecretsManagerConfiguration: Schema.optional(SecretsManagerConfiguration)});
export const AmazonopensearchserviceDestinationDescription = Schema.Struct({RoleARN: Schema.optional(Schema.String), DomainARN: Schema.optional(Schema.String), ClusterEndpoint: Schema.optional(Schema.String), IndexName: Schema.optional(Schema.String), TypeName: Schema.optional(Schema.String), IndexRotationPeriod: Schema.optional(Schema.String), BufferingHints: Schema.optional(AmazonopensearchserviceBufferingHints), RetryOptions: Schema.optional(AmazonopensearchserviceRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3DestinationDescription: Schema.optional(S3DestinationDescription), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), VpcConfigurationDescription: Schema.optional(VpcConfigurationDescription), DocumentIdOptions: Schema.optional(DocumentIdOptions)});
export const RedshiftDestinationDescription = Schema.Struct({RoleARN: Schema.String, ClusterJDBCURL: Schema.String, CopyCommand: CopyCommand, Username: Schema.optional(Schema.String), RetryOptions: Schema.optional(RedshiftRetryOptions), S3DestinationDescription: S3DestinationDescription, ProcessingConfiguration: Schema.optional(ProcessingConfiguration), S3BackupMode: Schema.optional(Schema.String), S3BackupDescription: Schema.optional(S3DestinationDescription), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), SecretsManagerConfiguration: Schema.optional(SecretsManagerConfiguration)});
export const ElasticsearchDestinationDescription = Schema.Struct({RoleARN: Schema.optional(Schema.String), DomainARN: Schema.optional(Schema.String), ClusterEndpoint: Schema.optional(Schema.String), IndexName: Schema.optional(Schema.String), TypeName: Schema.optional(Schema.String), IndexRotationPeriod: Schema.optional(Schema.String), BufferingHints: Schema.optional(ElasticsearchBufferingHints), RetryOptions: Schema.optional(ElasticsearchRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3DestinationDescription: Schema.optional(S3DestinationDescription), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), VpcConfigurationDescription: Schema.optional(VpcConfigurationDescription), DocumentIdOptions: Schema.optional(DocumentIdOptions)});
export const ExtendedS3DestinationDescription = Schema.Struct({RoleARN: Schema.String, BucketARN: Schema.String, Prefix: Schema.optional(Schema.String), ErrorOutputPrefix: Schema.optional(Schema.String), BufferingHints: BufferingHints, CompressionFormat: Schema.String, EncryptionConfiguration: EncryptionConfiguration, CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), S3BackupMode: Schema.optional(Schema.String), S3BackupDescription: Schema.optional(S3DestinationDescription), DataFormatConversionConfiguration: Schema.optional(DataFormatConversionConfiguration), DynamicPartitioningConfiguration: Schema.optional(DynamicPartitioningConfiguration), FileExtension: Schema.optional(Schema.String), CustomTimeZone: Schema.optional(Schema.String)});
export const S3DestinationDescription = Schema.Struct({RoleARN: Schema.String, BucketARN: Schema.String, Prefix: Schema.optional(Schema.String), ErrorOutputPrefix: Schema.optional(Schema.String), BufferingHints: BufferingHints, CompressionFormat: Schema.String, EncryptionConfiguration: EncryptionConfiguration, CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions)});
export const MSKSourceDescription = Schema.Struct({MSKClusterARN: Schema.optional(Schema.String), TopicName: Schema.optional(Schema.String), AuthenticationConfiguration: Schema.optional(AuthenticationConfiguration), DeliveryStartTimestamp: Schema.optional(Schema.Date), ReadFromTimestamp: Schema.optional(Schema.Date)});
export const DatabaseSourceDescription = Schema.Struct({Type: Schema.optional(Schema.String), Endpoint: Schema.optional(Schema.String), Port: Schema.optional(Schema.Number), SSLMode: Schema.optional(Schema.String), Databases: Schema.optional(DatabaseList), Tables: Schema.optional(DatabaseTableList), Columns: Schema.optional(DatabaseColumnList), SurrogateKeys: Schema.optional(DatabaseColumnIncludeOrExcludeList), SnapshotWatermarkTable: Schema.optional(Schema.String), SnapshotInfo: Schema.optional(DatabaseSnapshotInfoList), DatabaseSourceAuthenticationConfiguration: Schema.optional(DatabaseSourceAuthenticationConfiguration), DatabaseSourceVPCConfiguration: Schema.optional(DatabaseSourceVPCConfiguration)});
export const KinesisStreamSourceDescription = Schema.Struct({KinesisStreamARN: Schema.optional(Schema.String), RoleARN: Schema.optional(Schema.String), DeliveryStartTimestamp: Schema.optional(Schema.Date)});
export const DirectPutSourceDescription = Schema.Struct({ThroughputHintInMBs: Schema.optional(Schema.Number)});
export const ListOfNonEmptyStrings = Schema.Array(Schema.String);
export const Serializer = Schema.Struct({ParquetSerDe: Schema.optional(ParquetSerDe), OrcSerDe: Schema.optional(OrcSerDe)});
export const PartitionFields = Schema.Array(PartitionField);
export const PartitionField = Schema.Struct({SourceName: Schema.String});
export const ProcessorParameterList = Schema.Array(ProcessorParameter);
export const ProcessorParameter = Schema.Struct({ParameterName: Schema.String, ParameterValue: Schema.String});
export const DeliveryStreamEncryptionConfiguration = Schema.Struct({KeyARN: Schema.optional(Schema.String), KeyType: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), FailureDescription: Schema.optional(FailureDescription)});
export const FailureDescription = Schema.Struct({Type: Schema.String, Details: Schema.String});
export const Deserializer = Schema.Struct({OpenXJsonSerDe: Schema.optional(OpenXJsonSerDe), HiveJsonSerDe: Schema.optional(HiveJsonSerDe)});
export const ConcurrentModificationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DestinationDescription = Schema.Struct({DestinationId: Schema.String, S3DestinationDescription: Schema.optional(S3DestinationDescription), ExtendedS3DestinationDescription: Schema.optional(ExtendedS3DestinationDescription), RedshiftDestinationDescription: Schema.optional(RedshiftDestinationDescription), ElasticsearchDestinationDescription: Schema.optional(ElasticsearchDestinationDescription), AmazonopensearchserviceDestinationDescription: Schema.optional(AmazonopensearchserviceDestinationDescription), SplunkDestinationDescription: Schema.optional(SplunkDestinationDescription), HttpEndpointDestinationDescription: Schema.optional(HttpEndpointDestinationDescription), SnowflakeDestinationDescription: Schema.optional(SnowflakeDestinationDescription), AmazonOpenSearchServerlessDestinationDescription: Schema.optional(AmazonOpenSearchServerlessDestinationDescription), IcebergDestinationDescription: Schema.optional(IcebergDestinationDescription)});
export const InvalidKMSResourceException = Schema.Struct({code: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const DestinationDescriptionList = Schema.Array(DestinationDescription);
export const SourceDescription = Schema.Struct({DirectPutSourceDescription: Schema.optional(DirectPutSourceDescription), KinesisStreamSourceDescription: Schema.optional(KinesisStreamSourceDescription), MSKSourceDescription: Schema.optional(MSKSourceDescription), DatabaseSourceDescription: Schema.optional(DatabaseSourceDescription)});
export const PutRecordOutput = Schema.Struct({RecordId: Schema.String, Encrypted: Schema.optional(Schema.Boolean)});
export const HttpEndpointCommonAttributesList = Schema.Array(HttpEndpointCommonAttribute);
export const PartitionSpec = Schema.Struct({Identity: Schema.optional(PartitionFields)});
export const HttpEndpointCommonAttribute = Schema.Struct({AttributeName: Schema.String, AttributeValue: Schema.String});
export const SchemaConfiguration = Schema.Struct({RoleARN: Schema.optional(Schema.String), CatalogId: Schema.optional(Schema.String), DatabaseName: Schema.optional(Schema.String), TableName: Schema.optional(Schema.String), Region: Schema.optional(Schema.String), VersionId: Schema.optional(Schema.String)});
export const KMSEncryptionConfig = Schema.Struct({AWSKMSKeyARN: Schema.String});
export const PutRecordBatchResponseEntryList = Schema.Array(PutRecordBatchResponseEntry);
export const PutRecordBatchResponseEntry = Schema.Struct({RecordId: Schema.optional(Schema.String), ErrorCode: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String)});
export const DatabaseSourceVPCConfiguration = Schema.Struct({VpcEndpointServiceName: Schema.String});
export const DatabaseSourceAuthenticationConfiguration = Schema.Struct({SecretsManagerConfiguration: SecretsManagerConfiguration});
export const Processor = Schema.Struct({Type: Schema.String, Parameters: Schema.optional(ProcessorParameterList)});
export const DatabaseColumnList = Schema.Struct({Include: Schema.optional(DatabaseColumnIncludeOrExcludeList), Exclude: Schema.optional(DatabaseColumnIncludeOrExcludeList)});
export const ProcessorList = Schema.Array(Processor);
export const DatabaseTableList = Schema.Struct({Include: Schema.optional(DatabaseTableIncludeOrExcludeList), Exclude: Schema.optional(DatabaseTableIncludeOrExcludeList)});
export const DatabaseList = Schema.Struct({Include: Schema.optional(DatabaseIncludeOrExcludeList), Exclude: Schema.optional(DatabaseIncludeOrExcludeList)});
export const OutputFormatConfiguration = Schema.Struct({Serializer: Schema.optional(Serializer)});
export const CatalogConfiguration = Schema.Struct({CatalogARN: Schema.optional(Schema.String), WarehouseLocation: Schema.optional(Schema.String)});
export const RetryOptions = Schema.Struct({DurationInSeconds: Schema.optional(Schema.Number)});
export const InputFormatConfiguration = Schema.Struct({Deserializer: Schema.optional(Deserializer)});
export const TableCreationConfiguration = Schema.Struct({Enabled: Schema.Boolean});
export const SchemaEvolutionConfiguration = Schema.Struct({Enabled: Schema.Boolean});
export const SnowflakeBufferingHints = Schema.Struct({SizeInMBs: Schema.optional(Schema.Number), IntervalInSeconds: Schema.optional(Schema.Number)});
export const SnowflakeRetryOptions = Schema.Struct({DurationInSeconds: Schema.optional(Schema.Number)});
export const SnowflakeVpcConfiguration = Schema.Struct({PrivateLinkVpceId: Schema.String});
export const SnowflakeRoleConfiguration = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), SnowflakeRole: Schema.optional(Schema.String)});
export const AuthenticationConfiguration = Schema.Struct({RoleARN: Schema.String, Connectivity: Schema.String});
export const AmazonOpenSearchServerlessRetryOptions = Schema.Struct({DurationInSeconds: Schema.optional(Schema.Number)});
export const DeliveryStreamDescription = Schema.Struct({DeliveryStreamName: Schema.String, DeliveryStreamARN: Schema.String, DeliveryStreamStatus: Schema.String, FailureDescription: Schema.optional(FailureDescription), DeliveryStreamEncryptionConfiguration: Schema.optional(DeliveryStreamEncryptionConfiguration), DeliveryStreamType: Schema.String, VersionId: Schema.String, CreateTimestamp: Schema.optional(Schema.Date), LastUpdateTimestamp: Schema.optional(Schema.Date), Source: Schema.optional(SourceDescription), Destinations: DestinationDescriptionList, HasMoreDestinations: Schema.Boolean});
export const AmazonOpenSearchServerlessBufferingHints = Schema.Struct({IntervalInSeconds: Schema.optional(Schema.Number), SizeInMBs: Schema.optional(Schema.Number)});
export const HttpEndpointRetryOptions = Schema.Struct({DurationInSeconds: Schema.optional(Schema.Number)});
export const HttpEndpointBufferingHints = Schema.Struct({SizeInMBs: Schema.optional(Schema.Number), IntervalInSeconds: Schema.optional(Schema.Number)});
export const HttpEndpointConfiguration = Schema.Struct({Url: Schema.String, Name: Schema.optional(Schema.String), AccessKey: Schema.optional(Schema.String)});
export const SplunkBufferingHints = Schema.Struct({IntervalInSeconds: Schema.optional(Schema.Number), SizeInMBs: Schema.optional(Schema.Number)});
export const SplunkRetryOptions = Schema.Struct({DurationInSeconds: Schema.optional(Schema.Number)});
export const AmazonopensearchserviceRetryOptions = Schema.Struct({DurationInSeconds: Schema.optional(Schema.Number)});
export const AmazonopensearchserviceBufferingHints = Schema.Struct({IntervalInSeconds: Schema.optional(Schema.Number), SizeInMBs: Schema.optional(Schema.Number)});
export const DestinationTableConfiguration = Schema.Struct({DestinationTableName: Schema.String, DestinationDatabaseName: Schema.String, UniqueKeys: Schema.optional(ListOfNonEmptyStringsWithoutWhitespace), PartitionSpec: Schema.optional(PartitionSpec), S3ErrorOutputPrefix: Schema.optional(Schema.String)});
export const DocumentIdOptions = Schema.Struct({DefaultDocumentIdFormat: Schema.String});
export const DestinationTableConfigurationList = Schema.Array(DestinationTableConfiguration);
export const VpcConfiguration = Schema.Struct({SubnetIds: SubnetIdList, RoleARN: Schema.String, SecurityGroupIds: SecurityGroupIdList});
export const ElasticsearchRetryOptions = Schema.Struct({DurationInSeconds: Schema.optional(Schema.Number)});
export const ElasticsearchBufferingHints = Schema.Struct({IntervalInSeconds: Schema.optional(Schema.Number), SizeInMBs: Schema.optional(Schema.Number)});
export const HttpEndpointRequestConfiguration = Schema.Struct({ContentEncoding: Schema.optional(Schema.String), CommonAttributes: Schema.optional(HttpEndpointCommonAttributesList)});
export const SecretsManagerConfiguration = Schema.Struct({SecretARN: Schema.optional(Schema.String), RoleARN: Schema.optional(Schema.String), Enabled: Schema.Boolean});
export const RedshiftRetryOptions = Schema.Struct({DurationInSeconds: Schema.optional(Schema.Number)});
export const CopyCommand = Schema.Struct({DataTableName: Schema.String, DataTableColumns: Schema.optional(Schema.String), CopyOptions: Schema.optional(Schema.String)});
export const DynamicPartitioningConfiguration = Schema.Struct({RetryOptions: Schema.optional(RetryOptions), Enabled: Schema.optional(Schema.Boolean)});
export const CloudWatchLoggingOptions = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), LogGroupName: Schema.optional(Schema.String), LogStreamName: Schema.optional(Schema.String)});
export const UpdateDestinationOutput = Schema.Struct({});
export const BufferingHints = Schema.Struct({SizeInMBs: Schema.optional(Schema.Number), IntervalInSeconds: Schema.optional(Schema.Number)});
export const ResourceNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const LimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidArgumentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ListTagsForDeliveryStreamOutput = Schema.Struct({Tags: ListTagsForDeliveryStreamOutputTagList, HasMoreTags: Schema.Boolean});
export const ListDeliveryStreamsOutput = Schema.Struct({DeliveryStreamNames: DeliveryStreamNameList, HasMoreDeliveryStreams: Schema.Boolean});
export const ResourceInUseException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DatabaseColumnIncludeOrExcludeList = Schema.Array(Schema.String);
export const DatabaseTableIncludeOrExcludeList = Schema.Array(Schema.String);
export const DatabaseIncludeOrExcludeList = Schema.Array(Schema.String);
export const ListOfNonEmptyStringsWithoutWhitespace = Schema.Array(Schema.String);
export const EncryptionConfiguration = Schema.Struct({NoEncryptionConfig: Schema.optional(Schema.String), KMSEncryptionConfig: Schema.optional(KMSEncryptionConfig)});
export const SecurityGroupIdList = Schema.Array(Schema.String);
export const SubnetIdList = Schema.Array(Schema.String);
export const ProcessingConfiguration = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), Processors: Schema.optional(ProcessorList)});
export const IcebergDestinationUpdate = Schema.Struct({DestinationTableConfigurationList: Schema.optional(DestinationTableConfigurationList), SchemaEvolutionConfiguration: Schema.optional(SchemaEvolutionConfiguration), TableCreationConfiguration: Schema.optional(TableCreationConfiguration), BufferingHints: Schema.optional(BufferingHints), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), S3BackupMode: Schema.optional(Schema.String), RetryOptions: Schema.optional(RetryOptions), RoleARN: Schema.optional(Schema.String), AppendOnly: Schema.optional(Schema.Boolean), CatalogConfiguration: Schema.optional(CatalogConfiguration), S3Configuration: Schema.optional(S3DestinationConfiguration)});
export const SnowflakeDestinationUpdate = Schema.Struct({AccountUrl: Schema.optional(Schema.String), PrivateKey: Schema.optional(Schema.String), KeyPassphrase: Schema.optional(Schema.String), User: Schema.optional(Schema.String), Database: Schema.optional(Schema.String), Schema: Schema.optional(Schema.String), Table: Schema.optional(Schema.String), SnowflakeRoleConfiguration: Schema.optional(SnowflakeRoleConfiguration), DataLoadingOption: Schema.optional(Schema.String), MetaDataColumnName: Schema.optional(Schema.String), ContentColumnName: Schema.optional(Schema.String), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), RoleARN: Schema.optional(Schema.String), RetryOptions: Schema.optional(SnowflakeRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3Update: Schema.optional(S3DestinationUpdate), SecretsManagerConfiguration: Schema.optional(SecretsManagerConfiguration), BufferingHints: Schema.optional(SnowflakeBufferingHints)});
export const DataFormatConversionConfiguration = Schema.Struct({SchemaConfiguration: Schema.optional(SchemaConfiguration), InputFormatConfiguration: Schema.optional(InputFormatConfiguration), OutputFormatConfiguration: Schema.optional(OutputFormatConfiguration), Enabled: Schema.optional(Schema.Boolean)});
export const AmazonOpenSearchServerlessDestinationUpdate = Schema.Struct({RoleARN: Schema.optional(Schema.String), CollectionEndpoint: Schema.optional(Schema.String), IndexName: Schema.optional(Schema.String), BufferingHints: Schema.optional(AmazonOpenSearchServerlessBufferingHints), RetryOptions: Schema.optional(AmazonOpenSearchServerlessRetryOptions), S3Update: Schema.optional(S3DestinationUpdate), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions)});
export const HttpEndpointDestinationUpdate = Schema.Struct({EndpointConfiguration: Schema.optional(HttpEndpointConfiguration), BufferingHints: Schema.optional(HttpEndpointBufferingHints), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), RequestConfiguration: Schema.optional(HttpEndpointRequestConfiguration), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), RoleARN: Schema.optional(Schema.String), RetryOptions: Schema.optional(HttpEndpointRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3Update: Schema.optional(S3DestinationUpdate), SecretsManagerConfiguration: Schema.optional(SecretsManagerConfiguration)});
export const PutRecordBatchOutput = Schema.Struct({FailedPutCount: Schema.Number, Encrypted: Schema.optional(Schema.Boolean), RequestResponses: PutRecordBatchResponseEntryList});
export const SplunkDestinationUpdate = Schema.Struct({HECEndpoint: Schema.optional(Schema.String), HECEndpointType: Schema.optional(Schema.String), HECToken: Schema.optional(Schema.String), HECAcknowledgmentTimeoutInSeconds: Schema.optional(Schema.Number), RetryOptions: Schema.optional(SplunkRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3Update: Schema.optional(S3DestinationUpdate), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), BufferingHints: Schema.optional(SplunkBufferingHints), SecretsManagerConfiguration: Schema.optional(SecretsManagerConfiguration)});
export const AmazonopensearchserviceDestinationUpdate = Schema.Struct({RoleARN: Schema.optional(Schema.String), DomainARN: Schema.optional(Schema.String), ClusterEndpoint: Schema.optional(Schema.String), IndexName: Schema.optional(Schema.String), TypeName: Schema.optional(Schema.String), IndexRotationPeriod: Schema.optional(Schema.String), BufferingHints: Schema.optional(AmazonopensearchserviceBufferingHints), RetryOptions: Schema.optional(AmazonopensearchserviceRetryOptions), S3Update: Schema.optional(S3DestinationUpdate), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), DocumentIdOptions: Schema.optional(DocumentIdOptions)});
export const ElasticsearchDestinationUpdate = Schema.Struct({RoleARN: Schema.optional(Schema.String), DomainARN: Schema.optional(Schema.String), ClusterEndpoint: Schema.optional(Schema.String), IndexName: Schema.optional(Schema.String), TypeName: Schema.optional(Schema.String), IndexRotationPeriod: Schema.optional(Schema.String), BufferingHints: Schema.optional(ElasticsearchBufferingHints), RetryOptions: Schema.optional(ElasticsearchRetryOptions), S3Update: Schema.optional(S3DestinationUpdate), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), DocumentIdOptions: Schema.optional(DocumentIdOptions)});
export const RedshiftDestinationUpdate = Schema.Struct({RoleARN: Schema.optional(Schema.String), ClusterJDBCURL: Schema.optional(Schema.String), CopyCommand: Schema.optional(CopyCommand), Username: Schema.optional(Schema.String), Password: Schema.optional(Schema.String), RetryOptions: Schema.optional(RedshiftRetryOptions), S3Update: Schema.optional(S3DestinationUpdate), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), S3BackupMode: Schema.optional(Schema.String), S3BackupUpdate: Schema.optional(S3DestinationUpdate), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), SecretsManagerConfiguration: Schema.optional(SecretsManagerConfiguration)});
export const ExtendedS3DestinationUpdate = Schema.Struct({RoleARN: Schema.optional(Schema.String), BucketARN: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), ErrorOutputPrefix: Schema.optional(Schema.String), BufferingHints: Schema.optional(BufferingHints), CompressionFormat: Schema.optional(Schema.String), EncryptionConfiguration: Schema.optional(EncryptionConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), S3BackupMode: Schema.optional(Schema.String), S3BackupUpdate: Schema.optional(S3DestinationUpdate), DataFormatConversionConfiguration: Schema.optional(DataFormatConversionConfiguration), DynamicPartitioningConfiguration: Schema.optional(DynamicPartitioningConfiguration), FileExtension: Schema.optional(Schema.String), CustomTimeZone: Schema.optional(Schema.String)});
export const S3DestinationUpdate = Schema.Struct({RoleARN: Schema.optional(Schema.String), BucketARN: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String), ErrorOutputPrefix: Schema.optional(Schema.String), BufferingHints: Schema.optional(BufferingHints), CompressionFormat: Schema.optional(Schema.String), EncryptionConfiguration: Schema.optional(EncryptionConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions)});
export const Record = Schema.Struct({Data: StreamBody()});
export const ListTagsForDeliveryStreamOutputTagList = Schema.Array(Tag);
export const DeliveryStreamNameList = Schema.Array(Schema.String);
export const TagDeliveryStreamInputTagList = Schema.Array(Tag);
export const DescribeDeliveryStreamOutput = Schema.Struct({DeliveryStreamDescription: DeliveryStreamDescription});
export const Tag = Schema.Struct({Key: Schema.String, Value: Schema.optional(Schema.String)});
export const DatabaseSurrogateKeyList = Schema.Array(Schema.String);
export const UntagDeliveryStreamOutput = Schema.Struct({});
export const TagDeliveryStreamOutput = Schema.Struct({});
export const StopDeliveryStreamEncryptionOutput = Schema.Struct({});
export const StartDeliveryStreamEncryptionOutput = Schema.Struct({});
export const DeleteDeliveryStreamOutput = Schema.Struct({});
export const DeliveryStreamEncryptionConfigurationInput = Schema.Struct({KeyARN: Schema.optional(Schema.String), KeyType: Schema.String});
export const DatabaseSourceConfiguration = Schema.Struct({Type: Schema.String, Endpoint: Schema.String, Port: Schema.Number, SSLMode: Schema.optional(Schema.String), Databases: DatabaseList, Tables: DatabaseTableList, Columns: Schema.optional(DatabaseColumnList), SurrogateKeys: Schema.optional(DatabaseSurrogateKeyList), SnapshotWatermarkTable: Schema.String, DatabaseSourceAuthenticationConfiguration: DatabaseSourceAuthenticationConfiguration, DatabaseSourceVPCConfiguration: DatabaseSourceVPCConfiguration});
export const KinesisStreamSourceConfiguration = Schema.Struct({KinesisStreamARN: Schema.String, RoleARN: Schema.String});
export const SnowflakeDestinationConfiguration = Schema.Struct({AccountUrl: Schema.String, PrivateKey: Schema.optional(Schema.String), KeyPassphrase: Schema.optional(Schema.String), User: Schema.optional(Schema.String), Database: Schema.String, Schema: Schema.String, Table: Schema.String, SnowflakeRoleConfiguration: Schema.optional(SnowflakeRoleConfiguration), DataLoadingOption: Schema.optional(Schema.String), MetaDataColumnName: Schema.optional(Schema.String), ContentColumnName: Schema.optional(Schema.String), SnowflakeVpcConfiguration: Schema.optional(SnowflakeVpcConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), RoleARN: Schema.String, RetryOptions: Schema.optional(SnowflakeRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3Configuration: S3DestinationConfiguration, SecretsManagerConfiguration: Schema.optional(SecretsManagerConfiguration), BufferingHints: Schema.optional(SnowflakeBufferingHints)});
export const MSKSourceConfiguration = Schema.Struct({MSKClusterARN: Schema.String, TopicName: Schema.String, AuthenticationConfiguration: AuthenticationConfiguration, ReadFromTimestamp: Schema.optional(Schema.Date)});
export const AmazonOpenSearchServerlessDestinationConfiguration = Schema.Struct({RoleARN: Schema.String, CollectionEndpoint: Schema.optional(Schema.String), IndexName: Schema.String, BufferingHints: Schema.optional(AmazonOpenSearchServerlessBufferingHints), RetryOptions: Schema.optional(AmazonOpenSearchServerlessRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3Configuration: S3DestinationConfiguration, ProcessingConfiguration: Schema.optional(ProcessingConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), VpcConfiguration: Schema.optional(VpcConfiguration)});
export const DirectPutSourceConfiguration = Schema.Struct({ThroughputHintInMBs: Schema.Number});
export const UntagDeliveryStreamInput = Schema.Struct({DeliveryStreamName: Schema.String, TagKeys: TagKeyList});
export const TagDeliveryStreamInput = Schema.Struct({DeliveryStreamName: Schema.String, Tags: TagDeliveryStreamInputTagList});
export const IcebergDestinationConfiguration = Schema.Struct({DestinationTableConfigurationList: Schema.optional(DestinationTableConfigurationList), SchemaEvolutionConfiguration: Schema.optional(SchemaEvolutionConfiguration), TableCreationConfiguration: Schema.optional(TableCreationConfiguration), BufferingHints: Schema.optional(BufferingHints), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), S3BackupMode: Schema.optional(Schema.String), RetryOptions: Schema.optional(RetryOptions), RoleARN: Schema.String, AppendOnly: Schema.optional(Schema.Boolean), CatalogConfiguration: CatalogConfiguration, S3Configuration: S3DestinationConfiguration});
export const SplunkDestinationConfiguration = Schema.Struct({HECEndpoint: Schema.String, HECEndpointType: Schema.String, HECToken: Schema.optional(Schema.String), HECAcknowledgmentTimeoutInSeconds: Schema.optional(Schema.Number), RetryOptions: Schema.optional(SplunkRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3Configuration: S3DestinationConfiguration, ProcessingConfiguration: Schema.optional(ProcessingConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), BufferingHints: Schema.optional(SplunkBufferingHints), SecretsManagerConfiguration: Schema.optional(SecretsManagerConfiguration)});
export const AmazonopensearchserviceDestinationConfiguration = Schema.Struct({RoleARN: Schema.String, DomainARN: Schema.optional(Schema.String), ClusterEndpoint: Schema.optional(Schema.String), IndexName: Schema.String, TypeName: Schema.optional(Schema.String), IndexRotationPeriod: Schema.optional(Schema.String), BufferingHints: Schema.optional(AmazonopensearchserviceBufferingHints), RetryOptions: Schema.optional(AmazonopensearchserviceRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3Configuration: S3DestinationConfiguration, ProcessingConfiguration: Schema.optional(ProcessingConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), VpcConfiguration: Schema.optional(VpcConfiguration), DocumentIdOptions: Schema.optional(DocumentIdOptions)});
export const ElasticsearchDestinationConfiguration = Schema.Struct({RoleARN: Schema.String, DomainARN: Schema.optional(Schema.String), ClusterEndpoint: Schema.optional(Schema.String), IndexName: Schema.String, TypeName: Schema.optional(Schema.String), IndexRotationPeriod: Schema.optional(Schema.String), BufferingHints: Schema.optional(ElasticsearchBufferingHints), RetryOptions: Schema.optional(ElasticsearchRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3Configuration: S3DestinationConfiguration, ProcessingConfiguration: Schema.optional(ProcessingConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), VpcConfiguration: Schema.optional(VpcConfiguration), DocumentIdOptions: Schema.optional(DocumentIdOptions)});
export const HttpEndpointDestinationConfiguration = Schema.Struct({EndpointConfiguration: HttpEndpointConfiguration, BufferingHints: Schema.optional(HttpEndpointBufferingHints), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), RequestConfiguration: Schema.optional(HttpEndpointRequestConfiguration), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), RoleARN: Schema.optional(Schema.String), RetryOptions: Schema.optional(HttpEndpointRetryOptions), S3BackupMode: Schema.optional(Schema.String), S3Configuration: S3DestinationConfiguration, SecretsManagerConfiguration: Schema.optional(SecretsManagerConfiguration)});
export const RedshiftDestinationConfiguration = Schema.Struct({RoleARN: Schema.String, ClusterJDBCURL: Schema.String, CopyCommand: CopyCommand, Username: Schema.optional(Schema.String), Password: Schema.optional(Schema.String), RetryOptions: Schema.optional(RedshiftRetryOptions), S3Configuration: S3DestinationConfiguration, ProcessingConfiguration: Schema.optional(ProcessingConfiguration), S3BackupMode: Schema.optional(Schema.String), S3BackupConfiguration: Schema.optional(S3DestinationConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), SecretsManagerConfiguration: Schema.optional(SecretsManagerConfiguration)});
export const StopDeliveryStreamEncryptionInput = Schema.Struct({DeliveryStreamName: Schema.String});
export const StartDeliveryStreamEncryptionInput = Schema.Struct({DeliveryStreamName: Schema.String, DeliveryStreamEncryptionConfigurationInput: Schema.optional(DeliveryStreamEncryptionConfigurationInput)});
export const PutRecordBatchInput = Schema.Struct({DeliveryStreamName: Schema.String, Records: PutRecordBatchRequestEntryList});
export const TagKeyList = Schema.Array(Schema.String);
export const S3DestinationConfiguration = Schema.Struct({RoleARN: Schema.String, BucketARN: Schema.String, Prefix: Schema.optional(Schema.String), ErrorOutputPrefix: Schema.optional(Schema.String), BufferingHints: Schema.optional(BufferingHints), CompressionFormat: Schema.optional(Schema.String), EncryptionConfiguration: Schema.optional(EncryptionConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions)});
export const ListTagsForDeliveryStreamInput = Schema.Struct({DeliveryStreamName: Schema.String, ExclusiveStartTagKey: Schema.optional(Schema.String), Limit: Schema.optional(Schema.Number)});
export const UpdateDestinationInput = Schema.Struct({DeliveryStreamName: Schema.String, CurrentDeliveryStreamVersionId: Schema.String, DestinationId: Schema.String, S3DestinationUpdate: Schema.optional(S3DestinationUpdate), ExtendedS3DestinationUpdate: Schema.optional(ExtendedS3DestinationUpdate), RedshiftDestinationUpdate: Schema.optional(RedshiftDestinationUpdate), ElasticsearchDestinationUpdate: Schema.optional(ElasticsearchDestinationUpdate), AmazonopensearchserviceDestinationUpdate: Schema.optional(AmazonopensearchserviceDestinationUpdate), SplunkDestinationUpdate: Schema.optional(SplunkDestinationUpdate), HttpEndpointDestinationUpdate: Schema.optional(HttpEndpointDestinationUpdate), AmazonOpenSearchServerlessDestinationUpdate: Schema.optional(AmazonOpenSearchServerlessDestinationUpdate), SnowflakeDestinationUpdate: Schema.optional(SnowflakeDestinationUpdate), IcebergDestinationUpdate: Schema.optional(IcebergDestinationUpdate)});
export const ExtendedS3DestinationConfiguration = Schema.Struct({RoleARN: Schema.String, BucketARN: Schema.String, Prefix: Schema.optional(Schema.String), ErrorOutputPrefix: Schema.optional(Schema.String), BufferingHints: Schema.optional(BufferingHints), CompressionFormat: Schema.optional(Schema.String), EncryptionConfiguration: Schema.optional(EncryptionConfiguration), CloudWatchLoggingOptions: Schema.optional(CloudWatchLoggingOptions), ProcessingConfiguration: Schema.optional(ProcessingConfiguration), S3BackupMode: Schema.optional(Schema.String), S3BackupConfiguration: Schema.optional(S3DestinationConfiguration), DataFormatConversionConfiguration: Schema.optional(DataFormatConversionConfiguration), DynamicPartitioningConfiguration: Schema.optional(DynamicPartitioningConfiguration), FileExtension: Schema.optional(Schema.String), CustomTimeZone: Schema.optional(Schema.String)});
export const ListDeliveryStreamsInput = Schema.Struct({Limit: Schema.optional(Schema.Number), DeliveryStreamType: Schema.optional(Schema.String), ExclusiveStartDeliveryStreamName: Schema.optional(Schema.String)});
export const DescribeDeliveryStreamInput = Schema.Struct({DeliveryStreamName: Schema.String, Limit: Schema.optional(Schema.Number), ExclusiveStartDestinationId: Schema.optional(Schema.String)});
export const DeleteDeliveryStreamInput = Schema.Struct({DeliveryStreamName: Schema.String, AllowForceDelete: Schema.optional(Schema.Boolean)});
export const PutRecordInput = Schema.Struct({DeliveryStreamName: Schema.String, Record: Record});
export const PutRecordBatchRequestEntryList = Schema.Array(Record);
export const UntagDeliveryStream = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Firehose", sigV4ServiceName: "firehose", name: "Firehose_20150804.UntagDeliveryStream" }, UntagDeliveryStreamInput, UntagDeliveryStreamOutput, Schema.Union(ErrorAnnotation("InvalidArgumentException", InvalidArgumentException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteDeliveryStream = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Firehose", sigV4ServiceName: "firehose", name: "Firehose_20150804.DeleteDeliveryStream" }, DeleteDeliveryStreamInput, DeleteDeliveryStreamOutput, Schema.Union(ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListDeliveryStreams = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Firehose", sigV4ServiceName: "firehose", name: "Firehose_20150804.ListDeliveryStreams" }, ListDeliveryStreamsInput, ListDeliveryStreamsOutput, Schema.Void), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTagsForDeliveryStream = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Firehose", sigV4ServiceName: "firehose", name: "Firehose_20150804.ListTagsForDeliveryStream" }, ListTagsForDeliveryStreamInput, ListTagsForDeliveryStreamOutput, Schema.Union(ErrorAnnotation("InvalidArgumentException", InvalidArgumentException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const StopDeliveryStreamEncryption = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Firehose", sigV4ServiceName: "firehose", name: "Firehose_20150804.StopDeliveryStreamEncryption" }, StopDeliveryStreamEncryptionInput, StopDeliveryStreamEncryptionOutput, Schema.Union(ErrorAnnotation("InvalidArgumentException", InvalidArgumentException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const TagDeliveryStream = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Firehose", sigV4ServiceName: "firehose", name: "Firehose_20150804.TagDeliveryStream" }, TagDeliveryStreamInput, TagDeliveryStreamOutput, Schema.Union(ErrorAnnotation("InvalidArgumentException", InvalidArgumentException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const StartDeliveryStreamEncryption = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Firehose", sigV4ServiceName: "firehose", name: "Firehose_20150804.StartDeliveryStreamEncryption" }, StartDeliveryStreamEncryptionInput, StartDeliveryStreamEncryptionOutput, Schema.Union(ErrorAnnotation("InvalidArgumentException", InvalidArgumentException), ErrorAnnotation("InvalidKMSResourceException", InvalidKMSResourceException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateDestination = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Firehose", sigV4ServiceName: "firehose", name: "Firehose_20150804.UpdateDestination" }, UpdateDestinationInput, UpdateDestinationOutput, Schema.Union(ErrorAnnotation("ConcurrentModificationException", ConcurrentModificationException), ErrorAnnotation("InvalidArgumentException", InvalidArgumentException), ErrorAnnotation("ResourceInUseException", ResourceInUseException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PutRecord = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Firehose", sigV4ServiceName: "firehose", name: "Firehose_20150804.PutRecord" }, PutRecordInput, PutRecordOutput, Schema.Union(ErrorAnnotation("InvalidArgumentException", InvalidArgumentException), ErrorAnnotation("InvalidKMSResourceException", InvalidKMSResourceException), ErrorAnnotation("InvalidSourceException", InvalidSourceException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PutRecordBatch = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Firehose", sigV4ServiceName: "firehose", name: "Firehose_20150804.PutRecordBatch" }, PutRecordBatchInput, PutRecordBatchOutput, Schema.Union(ErrorAnnotation("InvalidArgumentException", InvalidArgumentException), ErrorAnnotation("InvalidKMSResourceException", InvalidKMSResourceException), ErrorAnnotation("InvalidSourceException", InvalidSourceException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeDeliveryStream = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Firehose", sigV4ServiceName: "firehose", name: "Firehose_20150804.DescribeDeliveryStream" }, DescribeDeliveryStreamInput, DescribeDeliveryStreamOutput, ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException)), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateDeliveryStreamInput = Schema.Struct({DeliveryStreamName: Schema.String, DeliveryStreamType: Schema.optional(Schema.String), DirectPutSourceConfiguration: Schema.optional(DirectPutSourceConfiguration), KinesisStreamSourceConfiguration: Schema.optional(KinesisStreamSourceConfiguration), DeliveryStreamEncryptionConfigurationInput: Schema.optional(DeliveryStreamEncryptionConfigurationInput), S3DestinationConfiguration: Schema.optional(S3DestinationConfiguration), ExtendedS3DestinationConfiguration: Schema.optional(ExtendedS3DestinationConfiguration), RedshiftDestinationConfiguration: Schema.optional(RedshiftDestinationConfiguration), ElasticsearchDestinationConfiguration: Schema.optional(ElasticsearchDestinationConfiguration), AmazonopensearchserviceDestinationConfiguration: Schema.optional(AmazonopensearchserviceDestinationConfiguration), SplunkDestinationConfiguration: Schema.optional(SplunkDestinationConfiguration), HttpEndpointDestinationConfiguration: Schema.optional(HttpEndpointDestinationConfiguration), Tags: Schema.optional(TagDeliveryStreamInputTagList), AmazonOpenSearchServerlessDestinationConfiguration: Schema.optional(AmazonOpenSearchServerlessDestinationConfiguration), MSKSourceConfiguration: Schema.optional(MSKSourceConfiguration), SnowflakeDestinationConfiguration: Schema.optional(SnowflakeDestinationConfiguration), IcebergDestinationConfiguration: Schema.optional(IcebergDestinationConfiguration), DatabaseSourceConfiguration: Schema.optional(DatabaseSourceConfiguration)});
export const CreateDeliveryStream = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Firehose", sigV4ServiceName: "firehose", name: "Firehose_20150804.CreateDeliveryStream" }, CreateDeliveryStreamInput, CreateDeliveryStreamOutput, Schema.Union(ErrorAnnotation("InvalidArgumentException", InvalidArgumentException), ErrorAnnotation("InvalidKMSResourceException", InvalidKMSResourceException), ErrorAnnotation("LimitExceededException", LimitExceededException), ErrorAnnotation("ResourceInUseException", ResourceInUseException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
