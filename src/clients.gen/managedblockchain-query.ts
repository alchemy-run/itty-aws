import { Schema} from "effect"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
export const GetTransactionInput = Schema.Struct({transactionHash: Schema.optional(Schema.String), transactionId: Schema.optional(Schema.String), network: Schema.String});
export const ListTransactionEventsInput = Schema.Struct({transactionHash: Schema.optional(Schema.String), transactionId: Schema.optional(Schema.String), network: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ChainAddresses = Schema.Array(Schema.String);
export const ConfirmationStatusIncludeList = Schema.Array(Schema.String);
export const TokenIdentifier = Schema.Struct({network: Schema.String, contractAddress: Schema.optional(Schema.String), tokenId: Schema.optional(Schema.String)});
export const OwnerIdentifier = Schema.Struct({address: Schema.String});
export const BlockchainInstant = Schema.Struct({time: Schema.optional(Schema.Date)});
export const BatchGetTokenBalanceInputItem = Schema.Struct({tokenIdentifier: TokenIdentifier, ownerIdentifier: OwnerIdentifier, atBlockchainInstant: Schema.optional(BlockchainInstant)});
export const GetTokenBalanceInputList = Schema.Array(BatchGetTokenBalanceInputItem);
export const ContractIdentifier = Schema.Struct({network: Schema.String, contractAddress: Schema.String});
export const ContractFilter = Schema.Struct({network: Schema.String, tokenStandard: Schema.String, deployerAddress: Schema.String});
export const AddressIdentifierFilter = Schema.Struct({transactionEventToAddress: ChainAddresses});
export const TimeFilter = Schema.Struct({from: Schema.optional(BlockchainInstant), to: Schema.optional(BlockchainInstant)});
export const VoutFilter = Schema.Struct({voutSpent: Schema.Boolean});
export const ConfirmationStatusFilter = Schema.Struct({include: ConfirmationStatusIncludeList});
export const ListFilteredTransactionEventsSort = Schema.Struct({sortBy: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String)});
export const OwnerFilter = Schema.Struct({address: Schema.String});
export const TokenFilter = Schema.Struct({network: Schema.String, contractAddress: Schema.optional(Schema.String), tokenId: Schema.optional(Schema.String)});
export const ListTransactionsSort = Schema.Struct({sortBy: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String)});
export const BatchGetTokenBalanceInput = Schema.Struct({getTokenBalanceInputs: Schema.optional(GetTokenBalanceInputList)});
export const GetAssetContractInput = Schema.Struct({contractIdentifier: ContractIdentifier});
export const GetTokenBalanceInput = Schema.Struct({tokenIdentifier: TokenIdentifier, ownerIdentifier: OwnerIdentifier, atBlockchainInstant: Schema.optional(BlockchainInstant)});
export const ListAssetContractsInput = Schema.Struct({contractFilter: ContractFilter, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListFilteredTransactionEventsInput = Schema.Struct({network: Schema.String, addressIdentifierFilter: AddressIdentifierFilter, timeFilter: Schema.optional(TimeFilter), voutFilter: Schema.optional(VoutFilter), confirmationStatusFilter: Schema.optional(ConfirmationStatusFilter), sort: Schema.optional(ListFilteredTransactionEventsSort), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListTokenBalancesInput = Schema.Struct({ownerFilter: Schema.optional(OwnerFilter), tokenFilter: TokenFilter, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListTransactionsInput = Schema.Struct({address: Schema.String, network: Schema.String, fromBlockchainInstant: Schema.optional(BlockchainInstant), toBlockchainInstant: Schema.optional(BlockchainInstant), sort: Schema.optional(ListTransactionsSort), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), confirmationStatusFilter: Schema.optional(ConfirmationStatusFilter)});
export const Transaction = Schema.Struct({network: Schema.String, blockHash: Schema.optional(Schema.String), transactionHash: Schema.String, blockNumber: Schema.optional(Schema.String), transactionTimestamp: Schema.Date, transactionIndex: Schema.Number, numberOfTransactions: Schema.Number, to: Schema.String, from: Schema.optional(Schema.String), contractAddress: Schema.optional(Schema.String), gasUsed: Schema.optional(Schema.String), cumulativeGasUsed: Schema.optional(Schema.String), effectiveGasPrice: Schema.optional(Schema.String), signatureV: Schema.optional(Schema.Number), signatureR: Schema.optional(Schema.String), signatureS: Schema.optional(Schema.String), transactionFee: Schema.optional(Schema.String), transactionId: Schema.optional(Schema.String), confirmationStatus: Schema.optional(Schema.String), executionStatus: Schema.optional(Schema.String)});
export const TransactionEvent = Schema.Struct({network: Schema.String, transactionHash: Schema.String, eventType: Schema.String, from: Schema.optional(Schema.String), to: Schema.optional(Schema.String), value: Schema.optional(Schema.String), contractAddress: Schema.optional(Schema.String), tokenId: Schema.optional(Schema.String), transactionId: Schema.optional(Schema.String), voutIndex: Schema.optional(Schema.Number), voutSpent: Schema.optional(Schema.Boolean), spentVoutTransactionId: Schema.optional(Schema.String), spentVoutTransactionHash: Schema.optional(Schema.String), spentVoutIndex: Schema.optional(Schema.Number), blockchainInstant: Schema.optional(BlockchainInstant), confirmationStatus: Schema.optional(Schema.String)});
export const TransactionEventList = Schema.Array(TransactionEvent);
export const GetTokenBalanceOutput = Schema.Struct({ownerIdentifier: Schema.optional(OwnerIdentifier), tokenIdentifier: Schema.optional(TokenIdentifier), balance: Schema.String, atBlockchainInstant: BlockchainInstant, lastUpdatedTime: Schema.optional(BlockchainInstant)});
export const GetTransactionOutput = Schema.Struct({transaction: Transaction});
export const ListFilteredTransactionEventsOutput = Schema.Struct({events: TransactionEventList, nextToken: Schema.optional(Schema.String)});
export const ListTransactionEventsOutput = Schema.Struct({events: TransactionEventList, nextToken: Schema.optional(Schema.String)});
export const BatchGetTokenBalanceOutputItem = Schema.Struct({ownerIdentifier: Schema.optional(OwnerIdentifier), tokenIdentifier: Schema.optional(TokenIdentifier), balance: Schema.String, atBlockchainInstant: BlockchainInstant, lastUpdatedTime: Schema.optional(BlockchainInstant)});
export const BatchGetTokenBalanceOutputList = Schema.Array(BatchGetTokenBalanceOutputItem);
export const BatchGetTokenBalanceErrorItem = Schema.Struct({tokenIdentifier: Schema.optional(TokenIdentifier), ownerIdentifier: Schema.optional(OwnerIdentifier), atBlockchainInstant: Schema.optional(BlockchainInstant), errorCode: Schema.String, errorMessage: Schema.String, errorType: Schema.String});
export const BatchGetTokenBalanceErrors = Schema.Array(BatchGetTokenBalanceErrorItem);
export const ContractMetadata = Schema.Struct({name: Schema.optional(Schema.String), symbol: Schema.optional(Schema.String), decimals: Schema.optional(Schema.Number)});
export const AssetContract = Schema.Struct({contractIdentifier: ContractIdentifier, tokenStandard: Schema.String, deployerAddress: Schema.String});
export const AssetContractList = Schema.Array(AssetContract);
export const TokenBalance = Schema.Struct({ownerIdentifier: Schema.optional(OwnerIdentifier), tokenIdentifier: Schema.optional(TokenIdentifier), balance: Schema.String, atBlockchainInstant: BlockchainInstant, lastUpdatedTime: Schema.optional(BlockchainInstant)});
export const TokenBalanceList = Schema.Array(TokenBalance);
export const TransactionOutputItem = Schema.Struct({transactionHash: Schema.String, transactionId: Schema.optional(Schema.String), network: Schema.String, transactionTimestamp: Schema.Date, confirmationStatus: Schema.optional(Schema.String)});
export const TransactionOutputList = Schema.Array(TransactionOutputItem);
export const BatchGetTokenBalanceOutput = Schema.Struct({tokenBalances: BatchGetTokenBalanceOutputList, errors: BatchGetTokenBalanceErrors});
export const GetAssetContractOutput = Schema.Struct({contractIdentifier: ContractIdentifier, tokenStandard: Schema.String, deployerAddress: Schema.String, metadata: Schema.optional(ContractMetadata)});
export const AccessDeniedException = Schema.Struct({message: Schema.String});
export const InternalServerException = Schema.Struct({message: Schema.String, retryAfterSeconds: Schema.optional(Header("Retry-After", Schema.Number))});
export const ListAssetContractsOutput = Schema.Struct({contracts: AssetContractList, nextToken: Schema.optional(Schema.String)});
export const ServiceQuotaExceededException = Schema.Struct({message: Schema.String, resourceId: Schema.String, resourceType: Schema.String, serviceCode: Schema.String, quotaCode: Schema.String});
export const ListTokenBalancesOutput = Schema.Struct({tokenBalances: TokenBalanceList, nextToken: Schema.optional(Schema.String)});
export const ThrottlingException = Schema.Struct({message: Schema.String, serviceCode: Schema.String, quotaCode: Schema.String, retryAfterSeconds: Schema.optional(Header("Retry-After", Schema.Number))});
export const ListTransactionsOutput = Schema.Struct({transactions: TransactionOutputList, nextToken: Schema.optional(Schema.String)});
export const ResourceNotFoundException = Schema.Struct({message: Schema.String, resourceId: Schema.String, resourceType: Schema.String});
export const ValidationExceptionField = Schema.Struct({name: Schema.String, message: Schema.String});
export const ValidationExceptionFieldList = Schema.Array(ValidationExceptionField);
export const ValidationException = Schema.Struct({message: Schema.String, reason: Schema.String, fieldList: Schema.optional(ValidationExceptionFieldList)});
export const GetTokenBalance = /*#__PURE__*/ makeOperation(() => Operation({ version: "2023-05-04", uri: "/get-token-balance", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "TietonChainQueryService.GetTokenBalance" }, GetTokenBalanceInput, GetTokenBalanceOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const GetTransaction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2023-05-04", uri: "/get-transaction", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "TietonChainQueryService.GetTransaction" }, GetTransactionInput, GetTransactionOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListAssetContracts = /*#__PURE__*/ makeOperation(() => Operation({ version: "2023-05-04", uri: "/list-asset-contracts", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "TietonChainQueryService.ListAssetContracts" }, ListAssetContractsInput, ListAssetContractsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListFilteredTransactionEvents = /*#__PURE__*/ makeOperation(() => Operation({ version: "2023-05-04", uri: "/list-filtered-transaction-events", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "TietonChainQueryService.ListFilteredTransactionEvents" }, ListFilteredTransactionEventsInput, ListFilteredTransactionEventsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTokenBalances = /*#__PURE__*/ makeOperation(() => Operation({ version: "2023-05-04", uri: "/list-token-balances", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "TietonChainQueryService.ListTokenBalances" }, ListTokenBalancesInput, ListTokenBalancesOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTransactionEvents = /*#__PURE__*/ makeOperation(() => Operation({ version: "2023-05-04", uri: "/list-transaction-events", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "TietonChainQueryService.ListTransactionEvents" }, ListTransactionEventsInput, ListTransactionEventsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTransactions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2023-05-04", uri: "/list-transactions", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "TietonChainQueryService.ListTransactions" }, ListTransactionsInput, ListTransactionsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const BatchGetTokenBalance = /*#__PURE__*/ makeOperation(() => Operation({ version: "2023-05-04", uri: "/batch-get-token-balance", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "TietonChainQueryService.BatchGetTokenBalance" }, BatchGetTokenBalanceInput, BatchGetTokenBalanceOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const GetAssetContract = /*#__PURE__*/ makeOperation(() => Operation({ version: "2023-05-04", uri: "/get-asset-contract", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "TietonChainQueryService.GetAssetContract" }, GetAssetContractInput, GetAssetContractOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
