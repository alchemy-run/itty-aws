import { Schema} from "effect"
import { FormatXMLRequest, FormatXMLResponse, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
const GetTransactionInput = Schema.Struct({transactionHash: Schema.optional(Schema.String), transactionId: Schema.optional(Schema.String), network: Schema.String})
const ListTransactionEventsInput = Schema.Struct({transactionHash: Schema.optional(Schema.String), transactionId: Schema.optional(Schema.String), network: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ChainAddresses = Schema.Array(Schema.String)
const ConfirmationStatusIncludeList = Schema.Array(Schema.String)
const BatchGetTokenBalanceInputItem = Schema.Struct({tokenIdentifier: TokenIdentifier, ownerIdentifier: OwnerIdentifier, atBlockchainInstant: Schema.optional(BlockchainInstant)})
const GetTokenBalanceInputList = Schema.Array(BatchGetTokenBalanceInputItem)
const ContractIdentifier = Schema.Struct({network: Schema.String, contractAddress: Schema.String})
const TokenIdentifier = Schema.Struct({network: Schema.String, contractAddress: Schema.optional(Schema.String), tokenId: Schema.optional(Schema.String)})
const OwnerIdentifier = Schema.Struct({address: Schema.String})
const BlockchainInstant = Schema.Struct({time: Schema.optional(Schema.Date)})
const ContractFilter = Schema.Struct({network: Schema.String, tokenStandard: Schema.String, deployerAddress: Schema.String})
const AddressIdentifierFilter = Schema.Struct({transactionEventToAddress: ChainAddresses})
const TimeFilter = Schema.Struct({from: Schema.optional(BlockchainInstant), to: Schema.optional(BlockchainInstant)})
const VoutFilter = Schema.Struct({voutSpent: Schema.Boolean})
const ConfirmationStatusFilter = Schema.Struct({include: ConfirmationStatusIncludeList})
const ListFilteredTransactionEventsSort = Schema.Struct({sortBy: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String)})
const OwnerFilter = Schema.Struct({address: Schema.String})
const TokenFilter = Schema.Struct({network: Schema.String, contractAddress: Schema.optional(Schema.String), tokenId: Schema.optional(Schema.String)})
const ListTransactionsSort = Schema.Struct({sortBy: Schema.optional(Schema.String), sortOrder: Schema.optional(Schema.String)})
const BatchGetTokenBalanceInput = Schema.Struct({getTokenBalanceInputs: Schema.optional(GetTokenBalanceInputList)})
const GetAssetContractInput = Schema.Struct({contractIdentifier: ContractIdentifier})
const GetTokenBalanceInput = Schema.Struct({tokenIdentifier: TokenIdentifier, ownerIdentifier: OwnerIdentifier, atBlockchainInstant: Schema.optional(BlockchainInstant)})
const ListAssetContractsInput = Schema.Struct({contractFilter: ContractFilter, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListFilteredTransactionEventsInput = Schema.Struct({network: Schema.String, addressIdentifierFilter: AddressIdentifierFilter, timeFilter: Schema.optional(TimeFilter), voutFilter: Schema.optional(VoutFilter), confirmationStatusFilter: Schema.optional(ConfirmationStatusFilter), sort: Schema.optional(ListFilteredTransactionEventsSort), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListTokenBalancesInput = Schema.Struct({ownerFilter: Schema.optional(OwnerFilter), tokenFilter: TokenFilter, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)})
const ListTransactionsInput = Schema.Struct({address: Schema.String, network: Schema.String, fromBlockchainInstant: Schema.optional(BlockchainInstant), toBlockchainInstant: Schema.optional(BlockchainInstant), sort: Schema.optional(ListTransactionsSort), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), confirmationStatusFilter: Schema.optional(ConfirmationStatusFilter)})
const Transaction = Schema.Struct({network: Schema.String, blockHash: Schema.optional(Schema.String), transactionHash: Schema.String, blockNumber: Schema.optional(Schema.String), transactionTimestamp: Schema.Date, transactionIndex: Schema.Number, numberOfTransactions: Schema.Number, to: Schema.String, from: Schema.optional(Schema.String), contractAddress: Schema.optional(Schema.String), gasUsed: Schema.optional(Schema.String), cumulativeGasUsed: Schema.optional(Schema.String), effectiveGasPrice: Schema.optional(Schema.String), signatureV: Schema.optional(Schema.Number), signatureR: Schema.optional(Schema.String), signatureS: Schema.optional(Schema.String), transactionFee: Schema.optional(Schema.String), transactionId: Schema.optional(Schema.String), confirmationStatus: Schema.optional(Schema.String), executionStatus: Schema.optional(Schema.String)})
const TransactionEvent = Schema.Struct({network: Schema.String, transactionHash: Schema.String, eventType: Schema.String, from: Schema.optional(Schema.String), to: Schema.optional(Schema.String), value: Schema.optional(Schema.String), contractAddress: Schema.optional(Schema.String), tokenId: Schema.optional(Schema.String), transactionId: Schema.optional(Schema.String), voutIndex: Schema.optional(Schema.Number), voutSpent: Schema.optional(Schema.Boolean), spentVoutTransactionId: Schema.optional(Schema.String), spentVoutTransactionHash: Schema.optional(Schema.String), spentVoutIndex: Schema.optional(Schema.Number), blockchainInstant: Schema.optional(BlockchainInstant), confirmationStatus: Schema.optional(Schema.String)})
const TransactionEventList = Schema.Array(TransactionEvent)
const GetTokenBalanceOutput = Schema.Struct({ownerIdentifier: Schema.optional(OwnerIdentifier), tokenIdentifier: Schema.optional(TokenIdentifier), balance: Schema.String, atBlockchainInstant: BlockchainInstant, lastUpdatedTime: Schema.optional(BlockchainInstant)})
const GetTransactionOutput = Schema.Struct({transaction: Transaction})
const ListFilteredTransactionEventsOutput = Schema.Struct({events: TransactionEventList, nextToken: Schema.optional(Schema.String)})
const ListTransactionEventsOutput = Schema.Struct({events: TransactionEventList, nextToken: Schema.optional(Schema.String)})
const BatchGetTokenBalanceOutputItem = Schema.Struct({ownerIdentifier: Schema.optional(OwnerIdentifier), tokenIdentifier: Schema.optional(TokenIdentifier), balance: Schema.String, atBlockchainInstant: BlockchainInstant, lastUpdatedTime: Schema.optional(BlockchainInstant)})
const BatchGetTokenBalanceOutputList = Schema.Array(BatchGetTokenBalanceOutputItem)
const BatchGetTokenBalanceErrorItem = Schema.Struct({tokenIdentifier: Schema.optional(TokenIdentifier), ownerIdentifier: Schema.optional(OwnerIdentifier), atBlockchainInstant: Schema.optional(BlockchainInstant), errorCode: Schema.String, errorMessage: Schema.String, errorType: Schema.String})
const BatchGetTokenBalanceErrors = Schema.Array(BatchGetTokenBalanceErrorItem)
const ContractMetadata = Schema.Struct({name: Schema.optional(Schema.String), symbol: Schema.optional(Schema.String), decimals: Schema.optional(Schema.Number)})
const AssetContract = Schema.Struct({contractIdentifier: ContractIdentifier, tokenStandard: Schema.String, deployerAddress: Schema.String})
const AssetContractList = Schema.Array(AssetContract)
const TokenBalance = Schema.Struct({ownerIdentifier: Schema.optional(OwnerIdentifier), tokenIdentifier: Schema.optional(TokenIdentifier), balance: Schema.String, atBlockchainInstant: BlockchainInstant, lastUpdatedTime: Schema.optional(BlockchainInstant)})
const TokenBalanceList = Schema.Array(TokenBalance)
const TransactionOutputItem = Schema.Struct({transactionHash: Schema.String, transactionId: Schema.optional(Schema.String), network: Schema.String, transactionTimestamp: Schema.Date, confirmationStatus: Schema.optional(Schema.String)})
const TransactionOutputList = Schema.Array(TransactionOutputItem)
const BatchGetTokenBalanceOutput = Schema.Struct({tokenBalances: BatchGetTokenBalanceOutputList, errors: BatchGetTokenBalanceErrors})
const GetAssetContractOutput = Schema.Struct({contractIdentifier: ContractIdentifier, tokenStandard: Schema.String, deployerAddress: Schema.String, metadata: Schema.optional(ContractMetadata)})
const AccessDeniedException = Schema.Struct({message: Schema.String})
export const GetTokenBalance = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/get-token-balance", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "GetTokenBalance" }, GetTokenBalanceInput, GetTokenBalanceOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InternalServerException = Schema.Struct({message: Schema.String, retryAfterSeconds: Schema.optional(Header("Retry-After", Schema.Number))})
export const GetTransaction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/get-transaction", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "GetTransaction" }, GetTransactionInput, GetTransactionOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListAssetContractsOutput = Schema.Struct({contracts: AssetContractList, nextToken: Schema.optional(Schema.String)})
export const ListAssetContracts = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/list-asset-contracts", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "ListAssetContracts" }, ListAssetContractsInput, ListAssetContractsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ServiceQuotaExceededException = Schema.Struct({message: Schema.String, resourceId: Schema.String, resourceType: Schema.String, serviceCode: Schema.String, quotaCode: Schema.String})
export const ListFilteredTransactionEvents = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/list-filtered-transaction-events", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "ListFilteredTransactionEvents" }, ListFilteredTransactionEventsInput, ListFilteredTransactionEventsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListTokenBalancesOutput = Schema.Struct({tokenBalances: TokenBalanceList, nextToken: Schema.optional(Schema.String)})
export const ListTokenBalances = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/list-token-balances", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "ListTokenBalances" }, ListTokenBalancesInput, ListTokenBalancesOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ThrottlingException = Schema.Struct({message: Schema.String, serviceCode: Schema.String, quotaCode: Schema.String, retryAfterSeconds: Schema.optional(Header("Retry-After", Schema.Number))})
export const ListTransactionEvents = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/list-transaction-events", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "ListTransactionEvents" }, ListTransactionEventsInput, ListTransactionEventsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListTransactionsOutput = Schema.Struct({transactions: TransactionOutputList, nextToken: Schema.optional(Schema.String)})
export const ListTransactions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/list-transactions", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "ListTransactions" }, ListTransactionsInput, ListTransactionsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ResourceNotFoundException = Schema.Struct({message: Schema.String, resourceId: Schema.String, resourceType: Schema.String})
export const BatchGetTokenBalance = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/batch-get-token-balance", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "BatchGetTokenBalance" }, BatchGetTokenBalanceInput, BatchGetTokenBalanceOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ValidationExceptionField = Schema.Struct({name: Schema.String, message: Schema.String})
const ValidationExceptionFieldList = Schema.Array(ValidationExceptionField)
const ValidationException = Schema.Struct({message: Schema.String, reason: Schema.String, fieldList: Schema.optional(ValidationExceptionFieldList)})
export const GetAssetContract = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/get-asset-contract", method: "POST", sdkId: "ManagedBlockchain Query", sigV4ServiceName: "managedblockchain-query", name: "GetAssetContract" }, GetAssetContractInput, GetAssetContractOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
