import { Schema} from "effect"
import { FormatAwsJSON11Request,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const RepositoryNameList = Schema.Array(Schema.String);
export const FilePaths = Schema.Array(Schema.String);
export const CommitIdsInputList = Schema.Array(Schema.String);
export const TagKeysList = Schema.Array(Schema.String);
export const AssociateApprovalRuleTemplateWithRepositoryInput = Schema.Struct({approvalRuleTemplateName: Schema.String, repositoryName: Schema.String});
export const BatchAssociateApprovalRuleTemplateWithRepositoriesInput = Schema.Struct({approvalRuleTemplateName: Schema.String, repositoryNames: RepositoryNameList});
export const BatchDescribeMergeConflictsInput = Schema.Struct({repositoryName: Schema.String, destinationCommitSpecifier: Schema.String, sourceCommitSpecifier: Schema.String, mergeOption: Schema.String, maxMergeHunks: Schema.optional(Schema.Number), maxConflictFiles: Schema.optional(Schema.Number), filePaths: Schema.optional(FilePaths), conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String)});
export const BatchDisassociateApprovalRuleTemplateFromRepositoriesInput = Schema.Struct({approvalRuleTemplateName: Schema.String, repositoryNames: RepositoryNameList});
export const BatchGetCommitsInput = Schema.Struct({commitIds: CommitIdsInputList, repositoryName: Schema.String});
export const BatchGetRepositoriesInput = Schema.Struct({repositoryNames: RepositoryNameList});
export const CreateApprovalRuleTemplateInput = Schema.Struct({approvalRuleTemplateName: Schema.String, approvalRuleTemplateContent: Schema.String, approvalRuleTemplateDescription: Schema.optional(Schema.String)});
export const CreateBranchInput = Schema.Struct({repositoryName: Schema.String, branchName: Schema.String, commitId: Schema.String});
export const CreatePullRequestApprovalRuleInput = Schema.Struct({pullRequestId: Schema.String, approvalRuleName: Schema.String, approvalRuleContent: Schema.String});
export const DeleteApprovalRuleTemplateInput = Schema.Struct({approvalRuleTemplateName: Schema.String});
export const DeleteBranchInput = Schema.Struct({repositoryName: Schema.String, branchName: Schema.String});
export const DeleteCommentContentInput = Schema.Struct({commentId: Schema.String});
export const DeleteFileInput = Schema.Struct({repositoryName: Schema.String, branchName: Schema.String, filePath: Schema.String, parentCommitId: Schema.String, keepEmptyFolders: Schema.optional(Schema.Boolean), commitMessage: Schema.optional(Schema.String), name: Schema.optional(Schema.String), email: Schema.optional(Schema.String)});
export const DeletePullRequestApprovalRuleInput = Schema.Struct({pullRequestId: Schema.String, approvalRuleName: Schema.String});
export const DeleteRepositoryInput = Schema.Struct({repositoryName: Schema.String});
export const DescribeMergeConflictsInput = Schema.Struct({repositoryName: Schema.String, destinationCommitSpecifier: Schema.String, sourceCommitSpecifier: Schema.String, mergeOption: Schema.String, maxMergeHunks: Schema.optional(Schema.Number), filePath: Schema.String, conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String)});
export const DescribePullRequestEventsInput = Schema.Struct({pullRequestId: Schema.String, pullRequestEventType: Schema.optional(Schema.String), actorArn: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const DisassociateApprovalRuleTemplateFromRepositoryInput = Schema.Struct({approvalRuleTemplateName: Schema.String, repositoryName: Schema.String});
export const EvaluatePullRequestApprovalRulesInput = Schema.Struct({pullRequestId: Schema.String, revisionId: Schema.String});
export const GetApprovalRuleTemplateInput = Schema.Struct({approvalRuleTemplateName: Schema.String});
export const GetBlobInput = Schema.Struct({repositoryName: Schema.String, blobId: Schema.String});
export const GetBranchInput = Schema.Struct({repositoryName: Schema.optional(Schema.String), branchName: Schema.optional(Schema.String)});
export const GetCommentInput = Schema.Struct({commentId: Schema.String});
export const GetCommentReactionsInput = Schema.Struct({commentId: Schema.String, reactionUserArn: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const GetCommentsForComparedCommitInput = Schema.Struct({repositoryName: Schema.String, beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const GetCommentsForPullRequestInput = Schema.Struct({pullRequestId: Schema.String, repositoryName: Schema.optional(Schema.String), beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const GetCommitInput = Schema.Struct({repositoryName: Schema.String, commitId: Schema.String});
export const GetDifferencesInput = Schema.Struct({repositoryName: Schema.String, beforeCommitSpecifier: Schema.optional(Schema.String), afterCommitSpecifier: Schema.String, beforePath: Schema.optional(Schema.String), afterPath: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const GetFileInput = Schema.Struct({repositoryName: Schema.String, commitSpecifier: Schema.optional(Schema.String), filePath: Schema.String});
export const GetFolderInput = Schema.Struct({repositoryName: Schema.String, commitSpecifier: Schema.optional(Schema.String), folderPath: Schema.String});
export const GetMergeCommitInput = Schema.Struct({repositoryName: Schema.String, sourceCommitSpecifier: Schema.String, destinationCommitSpecifier: Schema.String, conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String)});
export const GetMergeConflictsInput = Schema.Struct({repositoryName: Schema.String, destinationCommitSpecifier: Schema.String, sourceCommitSpecifier: Schema.String, mergeOption: Schema.String, conflictDetailLevel: Schema.optional(Schema.String), maxConflictFiles: Schema.optional(Schema.Number), conflictResolutionStrategy: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String)});
export const GetMergeOptionsInput = Schema.Struct({repositoryName: Schema.String, sourceCommitSpecifier: Schema.String, destinationCommitSpecifier: Schema.String, conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String)});
export const GetPullRequestInput = Schema.Struct({pullRequestId: Schema.String});
export const GetPullRequestApprovalStatesInput = Schema.Struct({pullRequestId: Schema.String, revisionId: Schema.String});
export const GetPullRequestOverrideStateInput = Schema.Struct({pullRequestId: Schema.String, revisionId: Schema.String});
export const GetRepositoryInput = Schema.Struct({repositoryName: Schema.String});
export const GetRepositoryTriggersInput = Schema.Struct({repositoryName: Schema.String});
export const ListApprovalRuleTemplatesInput = Schema.Struct({nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListAssociatedApprovalRuleTemplatesForRepositoryInput = Schema.Struct({repositoryName: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListBranchesInput = Schema.Struct({repositoryName: Schema.String, nextToken: Schema.optional(Schema.String)});
export const ListFileCommitHistoryRequest = Schema.Struct({repositoryName: Schema.String, commitSpecifier: Schema.optional(Schema.String), filePath: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListPullRequestsInput = Schema.Struct({repositoryName: Schema.String, authorArn: Schema.optional(Schema.String), pullRequestStatus: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListRepositoriesInput = Schema.Struct({nextToken: Schema.optional(Schema.String), sortBy: Schema.optional(Schema.String), order: Schema.optional(Schema.String)});
export const ListRepositoriesForApprovalRuleTemplateInput = Schema.Struct({approvalRuleTemplateName: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListTagsForResourceInput = Schema.Struct({resourceArn: Schema.String, nextToken: Schema.optional(Schema.String)});
export const MergeBranchesByFastForwardInput = Schema.Struct({repositoryName: Schema.String, sourceCommitSpecifier: Schema.String, destinationCommitSpecifier: Schema.String, targetBranch: Schema.optional(Schema.String)});
export const ReplaceContentEntry = Schema.Struct({filePath: Schema.String, replacementType: Schema.String, content: Schema.optional(StreamBody()), fileMode: Schema.optional(Schema.String)});
export const ReplaceContentEntries = Schema.Array(ReplaceContentEntry);
export const DeleteFileEntry = Schema.Struct({filePath: Schema.String});
export const DeleteFileEntries = Schema.Array(DeleteFileEntry);
export const SetFileModeEntry = Schema.Struct({filePath: Schema.String, fileMode: Schema.String});
export const SetFileModeEntries = Schema.Array(SetFileModeEntry);
export const ConflictResolution = Schema.Struct({replaceContents: Schema.optional(ReplaceContentEntries), deleteFiles: Schema.optional(DeleteFileEntries), setFileModes: Schema.optional(SetFileModeEntries)});
export const MergeBranchesBySquashInput = Schema.Struct({repositoryName: Schema.String, sourceCommitSpecifier: Schema.String, destinationCommitSpecifier: Schema.String, targetBranch: Schema.optional(Schema.String), conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), authorName: Schema.optional(Schema.String), email: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), keepEmptyFolders: Schema.optional(Schema.Boolean), conflictResolution: Schema.optional(ConflictResolution)});
export const MergeBranchesByThreeWayInput = Schema.Struct({repositoryName: Schema.String, sourceCommitSpecifier: Schema.String, destinationCommitSpecifier: Schema.String, targetBranch: Schema.optional(Schema.String), conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), authorName: Schema.optional(Schema.String), email: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), keepEmptyFolders: Schema.optional(Schema.Boolean), conflictResolution: Schema.optional(ConflictResolution)});
export const MergePullRequestByFastForwardInput = Schema.Struct({pullRequestId: Schema.String, repositoryName: Schema.String, sourceCommitId: Schema.optional(Schema.String)});
export const MergePullRequestBySquashInput = Schema.Struct({pullRequestId: Schema.String, repositoryName: Schema.String, sourceCommitId: Schema.optional(Schema.String), conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), authorName: Schema.optional(Schema.String), email: Schema.optional(Schema.String), keepEmptyFolders: Schema.optional(Schema.Boolean), conflictResolution: Schema.optional(ConflictResolution)});
export const MergePullRequestByThreeWayInput = Schema.Struct({pullRequestId: Schema.String, repositoryName: Schema.String, sourceCommitId: Schema.optional(Schema.String), conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), authorName: Schema.optional(Schema.String), email: Schema.optional(Schema.String), keepEmptyFolders: Schema.optional(Schema.Boolean), conflictResolution: Schema.optional(ConflictResolution)});
export const OverridePullRequestApprovalRulesInput = Schema.Struct({pullRequestId: Schema.String, revisionId: Schema.String, overrideStatus: Schema.String});
export const Location = Schema.Struct({filePath: Schema.optional(Schema.String), filePosition: Schema.optional(Schema.Number), relativeFileVersion: Schema.optional(Schema.String)});
export const PostCommentForPullRequestInput = Schema.Struct({pullRequestId: Schema.String, repositoryName: Schema.String, beforeCommitId: Schema.String, afterCommitId: Schema.String, location: Schema.optional(Location), content: Schema.String, clientRequestToken: Schema.optional(Schema.String)});
export const PostCommentReplyInput = Schema.Struct({inReplyTo: Schema.String, clientRequestToken: Schema.optional(Schema.String), content: Schema.String});
export const PutCommentReactionInput = Schema.Struct({commentId: Schema.String, reactionValue: Schema.String});
export const PutFileInput = Schema.Struct({repositoryName: Schema.String, branchName: Schema.String, fileContent: StreamBody(), filePath: Schema.String, fileMode: Schema.optional(Schema.String), parentCommitId: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), name: Schema.optional(Schema.String), email: Schema.optional(Schema.String)});
export const TagsMap = Schema.Record({key: Schema.String, value: Schema.String});
export const TagResourceInput = Schema.Struct({resourceArn: Schema.String, tags: TagsMap});
export const BranchNameList = Schema.Array(Schema.String);
export const RepositoryTriggerEventList = Schema.Array(Schema.String);
export const RepositoryTrigger = Schema.Struct({name: Schema.String, destinationArn: Schema.String, customData: Schema.optional(Schema.String), branches: Schema.optional(BranchNameList), events: RepositoryTriggerEventList});
export const RepositoryTriggersList = Schema.Array(RepositoryTrigger);
export const TestRepositoryTriggersInput = Schema.Struct({repositoryName: Schema.String, triggers: RepositoryTriggersList});
export const UntagResourceInput = Schema.Struct({resourceArn: Schema.String, tagKeys: TagKeysList});
export const UpdateApprovalRuleTemplateContentInput = Schema.Struct({approvalRuleTemplateName: Schema.String, newRuleContent: Schema.String, existingRuleContentSha256: Schema.optional(Schema.String)});
export const UpdateApprovalRuleTemplateDescriptionInput = Schema.Struct({approvalRuleTemplateName: Schema.String, approvalRuleTemplateDescription: Schema.String});
export const UpdateApprovalRuleTemplateNameInput = Schema.Struct({oldApprovalRuleTemplateName: Schema.String, newApprovalRuleTemplateName: Schema.String});
export const UpdateCommentInput = Schema.Struct({commentId: Schema.String, content: Schema.String});
export const UpdateDefaultBranchInput = Schema.Struct({repositoryName: Schema.String, defaultBranchName: Schema.String});
export const UpdatePullRequestApprovalRuleContentInput = Schema.Struct({pullRequestId: Schema.String, approvalRuleName: Schema.String, existingRuleContentSha256: Schema.optional(Schema.String), newRuleContent: Schema.String});
export const UpdatePullRequestApprovalStateInput = Schema.Struct({pullRequestId: Schema.String, revisionId: Schema.String, approvalState: Schema.String});
export const UpdatePullRequestDescriptionInput = Schema.Struct({pullRequestId: Schema.String, description: Schema.String});
export const UpdatePullRequestStatusInput = Schema.Struct({pullRequestId: Schema.String, pullRequestStatus: Schema.String});
export const UpdatePullRequestTitleInput = Schema.Struct({pullRequestId: Schema.String, title: Schema.String});
export const UpdateRepositoryDescriptionInput = Schema.Struct({repositoryName: Schema.String, repositoryDescription: Schema.optional(Schema.String)});
export const UpdateRepositoryEncryptionKeyInput = Schema.Struct({repositoryName: Schema.String, kmsKeyId: Schema.String});
export const UpdateRepositoryNameInput = Schema.Struct({oldName: Schema.String, newName: Schema.String});
export const RepositoryNotFoundList = Schema.Array(Schema.String);
export const Target = Schema.Struct({repositoryName: Schema.String, sourceReference: Schema.String, destinationReference: Schema.optional(Schema.String)});
export const TargetList = Schema.Array(Target);
export const FileSizes = Schema.Struct({source: Schema.optional(Schema.Number), destination: Schema.optional(Schema.Number), base: Schema.optional(Schema.Number)});
export const FileModes = Schema.Struct({source: Schema.optional(Schema.String), destination: Schema.optional(Schema.String), base: Schema.optional(Schema.String)});
export const ObjectTypes = Schema.Struct({source: Schema.optional(Schema.String), destination: Schema.optional(Schema.String), base: Schema.optional(Schema.String)});
export const IsBinaryFile = Schema.Struct({source: Schema.optional(Schema.Boolean), destination: Schema.optional(Schema.Boolean), base: Schema.optional(Schema.Boolean)});
export const MergeOperations = Schema.Struct({source: Schema.optional(Schema.String), destination: Schema.optional(Schema.String)});
export const ConflictMetadata = Schema.Struct({filePath: Schema.optional(Schema.String), fileSizes: Schema.optional(FileSizes), fileModes: Schema.optional(FileModes), objectTypes: Schema.optional(ObjectTypes), numberOfConflicts: Schema.optional(Schema.Number), isBinaryFile: Schema.optional(IsBinaryFile), contentConflict: Schema.optional(Schema.Boolean), fileModeConflict: Schema.optional(Schema.Boolean), objectTypeConflict: Schema.optional(Schema.Boolean), mergeOperations: Schema.optional(MergeOperations)});
export const ConflictMetadataList = Schema.Array(ConflictMetadata);
export const MergeOptions = Schema.Array(Schema.String);
export const ApprovalRuleTemplateNameList = Schema.Array(Schema.String);
export const PullRequestIdList = Schema.Array(Schema.String);
export const RepositoryTriggerNameList = Schema.Array(Schema.String);
export const ApprovalRuleTemplateDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const BranchNameExistsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreatePullRequestInput = Schema.Struct({title: Schema.String, description: Schema.optional(Schema.String), targets: TargetList, clientRequestToken: Schema.optional(Schema.String)});
export const CreateRepositoryInput = Schema.Struct({repositoryName: Schema.String, repositoryDescription: Schema.optional(Schema.String), tags: Schema.optional(TagsMap), kmsKeyId: Schema.optional(Schema.String)});
export const DeleteApprovalRuleTemplateOutput = Schema.Struct({approvalRuleTemplateId: Schema.String});
export const DeleteFileOutput = Schema.Struct({commitId: Schema.String, blobId: Schema.String, treeId: Schema.String, filePath: Schema.String});
export const DeletePullRequestApprovalRuleOutput = Schema.Struct({approvalRuleId: Schema.String});
export const DeleteRepositoryOutput = Schema.Struct({repositoryId: Schema.optional(Schema.String)});
export const ApprovalRuleTemplateNameRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleTemplate = Schema.Struct({approvalRuleTemplateId: Schema.optional(Schema.String), approvalRuleTemplateName: Schema.optional(Schema.String), approvalRuleTemplateDescription: Schema.optional(Schema.String), approvalRuleTemplateContent: Schema.optional(Schema.String), ruleContentSha256: Schema.optional(Schema.String), lastModifiedDate: Schema.optional(Schema.Date), creationDate: Schema.optional(Schema.Date), lastModifiedUser: Schema.optional(Schema.String)});
export const GetApprovalRuleTemplateOutput = Schema.Struct({approvalRuleTemplate: ApprovalRuleTemplate});
export const GetBlobOutput = Schema.Struct({content: StreamBody()});
export const BranchInfo = Schema.Struct({branchName: Schema.optional(Schema.String), commitId: Schema.optional(Schema.String)});
export const GetBranchOutput = Schema.Struct({branch: Schema.optional(BranchInfo)});
export const CallerReactions = Schema.Array(Schema.String);
export const ReactionCountsMap = Schema.Record({key: Schema.String, value: Schema.Number});
export const Comment = Schema.Struct({commentId: Schema.optional(Schema.String), content: Schema.optional(Schema.String), inReplyTo: Schema.optional(Schema.String), creationDate: Schema.optional(Schema.Date), lastModifiedDate: Schema.optional(Schema.Date), authorArn: Schema.optional(Schema.String), deleted: Schema.optional(Schema.Boolean), clientRequestToken: Schema.optional(Schema.String), callerReactions: Schema.optional(CallerReactions), reactionCounts: Schema.optional(ReactionCountsMap)});
export const GetCommentOutput = Schema.Struct({comment: Schema.optional(Comment)});
export const ParentList = Schema.Array(Schema.String);
export const UserInfo = Schema.Struct({name: Schema.optional(Schema.String), email: Schema.optional(Schema.String), date: Schema.optional(Schema.String)});
export const Commit = Schema.Struct({commitId: Schema.optional(Schema.String), treeId: Schema.optional(Schema.String), parents: Schema.optional(ParentList), message: Schema.optional(Schema.String), author: Schema.optional(UserInfo), committer: Schema.optional(UserInfo), additionalData: Schema.optional(Schema.String)});
export const GetCommitOutput = Schema.Struct({commit: Commit});
export const GetFileOutput = Schema.Struct({commitId: Schema.String, blobId: Schema.String, filePath: Schema.String, fileMode: Schema.String, fileSize: Schema.Number, fileContent: StreamBody()});
export const GetMergeCommitOutput = Schema.Struct({sourceCommitId: Schema.optional(Schema.String), destinationCommitId: Schema.optional(Schema.String), baseCommitId: Schema.optional(Schema.String), mergedCommitId: Schema.optional(Schema.String)});
export const GetMergeConflictsOutput = Schema.Struct({mergeable: Schema.Boolean, destinationCommitId: Schema.String, sourceCommitId: Schema.String, baseCommitId: Schema.optional(Schema.String), conflictMetadataList: ConflictMetadataList, nextToken: Schema.optional(Schema.String)});
export const GetMergeOptionsOutput = Schema.Struct({mergeOptions: MergeOptions, sourceCommitId: Schema.String, destinationCommitId: Schema.String, baseCommitId: Schema.String});
export const GetPullRequestOverrideStateOutput = Schema.Struct({overridden: Schema.optional(Schema.Boolean), overrider: Schema.optional(Schema.String)});
export const RepositoryMetadata = Schema.Struct({accountId: Schema.optional(Schema.String), repositoryId: Schema.optional(Schema.String), repositoryName: Schema.optional(Schema.String), repositoryDescription: Schema.optional(Schema.String), defaultBranch: Schema.optional(Schema.String), lastModifiedDate: Schema.optional(Schema.Date), creationDate: Schema.optional(Schema.Date), cloneUrlHttp: Schema.optional(Schema.String), cloneUrlSsh: Schema.optional(Schema.String), Arn: Schema.optional(Schema.String), kmsKeyId: Schema.optional(Schema.String)});
export const GetRepositoryOutput = Schema.Struct({repositoryMetadata: Schema.optional(RepositoryMetadata)});
export const GetRepositoryTriggersOutput = Schema.Struct({configurationId: Schema.optional(Schema.String), triggers: Schema.optional(RepositoryTriggersList)});
export const ListApprovalRuleTemplatesOutput = Schema.Struct({approvalRuleTemplateNames: Schema.optional(ApprovalRuleTemplateNameList), nextToken: Schema.optional(Schema.String)});
export const ListAssociatedApprovalRuleTemplatesForRepositoryOutput = Schema.Struct({approvalRuleTemplateNames: Schema.optional(ApprovalRuleTemplateNameList), nextToken: Schema.optional(Schema.String)});
export const ListBranchesOutput = Schema.Struct({branches: Schema.optional(BranchNameList), nextToken: Schema.optional(Schema.String)});
export const ListPullRequestsOutput = Schema.Struct({pullRequestIds: PullRequestIdList, nextToken: Schema.optional(Schema.String)});
export const ListRepositoriesForApprovalRuleTemplateOutput = Schema.Struct({repositoryNames: Schema.optional(RepositoryNameList), nextToken: Schema.optional(Schema.String)});
export const ListTagsForResourceOutput = Schema.Struct({tags: Schema.optional(TagsMap), nextToken: Schema.optional(Schema.String)});
export const MergeBranchesByFastForwardOutput = Schema.Struct({commitId: Schema.optional(Schema.String), treeId: Schema.optional(Schema.String)});
export const MergeBranchesBySquashOutput = Schema.Struct({commitId: Schema.optional(Schema.String), treeId: Schema.optional(Schema.String)});
export const MergeBranchesByThreeWayOutput = Schema.Struct({commitId: Schema.optional(Schema.String), treeId: Schema.optional(Schema.String)});
export const MergeMetadata = Schema.Struct({isMerged: Schema.optional(Schema.Boolean), mergedBy: Schema.optional(Schema.String), mergeCommitId: Schema.optional(Schema.String), mergeOption: Schema.optional(Schema.String)});
export const PullRequestTarget = Schema.Struct({repositoryName: Schema.optional(Schema.String), sourceReference: Schema.optional(Schema.String), destinationReference: Schema.optional(Schema.String), destinationCommit: Schema.optional(Schema.String), sourceCommit: Schema.optional(Schema.String), mergeBase: Schema.optional(Schema.String), mergeMetadata: Schema.optional(MergeMetadata)});
export const PullRequestTargetList = Schema.Array(PullRequestTarget);
export const OriginApprovalRuleTemplate = Schema.Struct({approvalRuleTemplateId: Schema.optional(Schema.String), approvalRuleTemplateName: Schema.optional(Schema.String)});
export const ApprovalRule = Schema.Struct({approvalRuleId: Schema.optional(Schema.String), approvalRuleName: Schema.optional(Schema.String), approvalRuleContent: Schema.optional(Schema.String), ruleContentSha256: Schema.optional(Schema.String), lastModifiedDate: Schema.optional(Schema.Date), creationDate: Schema.optional(Schema.Date), lastModifiedUser: Schema.optional(Schema.String), originApprovalRuleTemplate: Schema.optional(OriginApprovalRuleTemplate)});
export const ApprovalRulesList = Schema.Array(ApprovalRule);
export const PullRequest = Schema.Struct({pullRequestId: Schema.optional(Schema.String), title: Schema.optional(Schema.String), description: Schema.optional(Schema.String), lastActivityDate: Schema.optional(Schema.Date), creationDate: Schema.optional(Schema.Date), pullRequestStatus: Schema.optional(Schema.String), authorArn: Schema.optional(Schema.String), pullRequestTargets: Schema.optional(PullRequestTargetList), clientRequestToken: Schema.optional(Schema.String), revisionId: Schema.optional(Schema.String), approvalRules: Schema.optional(ApprovalRulesList)});
export const MergePullRequestByFastForwardOutput = Schema.Struct({pullRequest: Schema.optional(PullRequest)});
export const MergePullRequestBySquashOutput = Schema.Struct({pullRequest: Schema.optional(PullRequest)});
export const MergePullRequestByThreeWayOutput = Schema.Struct({pullRequest: Schema.optional(PullRequest)});
export const EncryptionIntegrityChecksFailedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PostCommentForComparedCommitInput = Schema.Struct({repositoryName: Schema.String, beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.String, location: Schema.optional(Location), content: Schema.String, clientRequestToken: Schema.optional(Schema.String)});
export const PostCommentForPullRequestOutput = Schema.Struct({repositoryName: Schema.optional(Schema.String), pullRequestId: Schema.optional(Schema.String), beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.optional(Schema.String), beforeBlobId: Schema.optional(Schema.String), afterBlobId: Schema.optional(Schema.String), location: Schema.optional(Location), comment: Schema.optional(Comment)});
export const PostCommentReplyOutput = Schema.Struct({comment: Schema.optional(Comment)});
export const CommentDeletedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PutFileOutput = Schema.Struct({commitId: Schema.String, blobId: Schema.String, treeId: Schema.String});
export const PutRepositoryTriggersInput = Schema.Struct({repositoryName: Schema.String, triggers: RepositoryTriggersList});
export const InvalidRepositoryNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidResourceArnException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdateApprovalRuleTemplateContentOutput = Schema.Struct({approvalRuleTemplate: ApprovalRuleTemplate});
export const UpdateApprovalRuleTemplateDescriptionOutput = Schema.Struct({approvalRuleTemplate: ApprovalRuleTemplate});
export const UpdateApprovalRuleTemplateNameOutput = Schema.Struct({approvalRuleTemplate: ApprovalRuleTemplate});
export const UpdateCommentOutput = Schema.Struct({comment: Schema.optional(Comment)});
export const BranchDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdatePullRequestApprovalRuleContentOutput = Schema.Struct({approvalRule: ApprovalRule});
export const ApprovalStateRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdatePullRequestDescriptionOutput = Schema.Struct({pullRequest: PullRequest});
export const UpdatePullRequestStatusOutput = Schema.Struct({pullRequest: PullRequest});
export const UpdatePullRequestTitleOutput = Schema.Struct({pullRequest: PullRequest});
export const EncryptionKeyAccessDeniedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdateRepositoryEncryptionKeyOutput = Schema.Struct({repositoryId: Schema.optional(Schema.String), kmsKeyId: Schema.optional(Schema.String), originalKmsKeyId: Schema.optional(Schema.String)});
export const RepositoryDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SourceFileSpecifier = Schema.Struct({filePath: Schema.String, isMove: Schema.optional(Schema.Boolean)});
export const ApprovalRulesSatisfiedList = Schema.Array(Schema.String);
export const ApprovalRulesNotSatisfiedList = Schema.Array(Schema.String);
export const ReactionUsersList = Schema.Array(Schema.String);
export const Comments = Schema.Array(Comment);
export const RevisionChildren = Schema.Array(Schema.String);
export const BatchAssociateApprovalRuleTemplateWithRepositoriesError = Schema.Struct({repositoryName: Schema.optional(Schema.String), errorCode: Schema.optional(Schema.String), errorMessage: Schema.optional(Schema.String)});
export const BatchAssociateApprovalRuleTemplateWithRepositoriesErrorsList = Schema.Array(BatchAssociateApprovalRuleTemplateWithRepositoriesError);
export const MergeHunkDetail = Schema.Struct({startLine: Schema.optional(Schema.Number), endLine: Schema.optional(Schema.Number), hunkContent: Schema.optional(Schema.String)});
export const MergeHunk = Schema.Struct({isConflict: Schema.optional(Schema.Boolean), source: Schema.optional(MergeHunkDetail), destination: Schema.optional(MergeHunkDetail), base: Schema.optional(MergeHunkDetail)});
export const MergeHunks = Schema.Array(MergeHunk);
export const Conflict = Schema.Struct({conflictMetadata: Schema.optional(ConflictMetadata), mergeHunks: Schema.optional(MergeHunks)});
export const Conflicts = Schema.Array(Conflict);
export const BatchDescribeMergeConflictsError = Schema.Struct({filePath: Schema.String, exceptionName: Schema.String, message: Schema.String});
export const BatchDescribeMergeConflictsErrors = Schema.Array(BatchDescribeMergeConflictsError);
export const BatchDisassociateApprovalRuleTemplateFromRepositoriesError = Schema.Struct({repositoryName: Schema.optional(Schema.String), errorCode: Schema.optional(Schema.String), errorMessage: Schema.optional(Schema.String)});
export const BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorsList = Schema.Array(BatchDisassociateApprovalRuleTemplateFromRepositoriesError);
export const BatchGetCommitsError = Schema.Struct({commitId: Schema.optional(Schema.String), errorCode: Schema.optional(Schema.String), errorMessage: Schema.optional(Schema.String)});
export const BatchGetCommitsErrorsList = Schema.Array(BatchGetCommitsError);
export const RepositoryMetadataList = Schema.Array(RepositoryMetadata);
export const BatchGetRepositoriesError = Schema.Struct({repositoryId: Schema.optional(Schema.String), repositoryName: Schema.optional(Schema.String), errorCode: Schema.optional(Schema.String), errorMessage: Schema.optional(Schema.String)});
export const BatchGetRepositoriesErrorsList = Schema.Array(BatchGetRepositoriesError);
export const PutFileEntry = Schema.Struct({filePath: Schema.String, fileMode: Schema.optional(Schema.String), fileContent: Schema.optional(StreamBody()), sourceFile: Schema.optional(SourceFileSpecifier)});
export const PutFileEntries = Schema.Array(PutFileEntry);
export const Evaluation = Schema.Struct({approved: Schema.optional(Schema.Boolean), overridden: Schema.optional(Schema.Boolean), approvalRulesSatisfied: Schema.optional(ApprovalRulesSatisfiedList), approvalRulesNotSatisfied: Schema.optional(ApprovalRulesNotSatisfiedList)});
export const CommentsForComparedCommit = Schema.Struct({repositoryName: Schema.optional(Schema.String), beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.optional(Schema.String), beforeBlobId: Schema.optional(Schema.String), afterBlobId: Schema.optional(Schema.String), location: Schema.optional(Location), comments: Schema.optional(Comments)});
export const CommentsForComparedCommitData = Schema.Array(CommentsForComparedCommit);
export const CommentsForPullRequest = Schema.Struct({pullRequestId: Schema.optional(Schema.String), repositoryName: Schema.optional(Schema.String), beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.optional(Schema.String), beforeBlobId: Schema.optional(Schema.String), afterBlobId: Schema.optional(Schema.String), location: Schema.optional(Location), comments: Schema.optional(Comments)});
export const CommentsForPullRequestData = Schema.Array(CommentsForPullRequest);
export const Folder = Schema.Struct({treeId: Schema.optional(Schema.String), absolutePath: Schema.optional(Schema.String), relativePath: Schema.optional(Schema.String)});
export const FolderList = Schema.Array(Folder);
export const File = Schema.Struct({blobId: Schema.optional(Schema.String), absolutePath: Schema.optional(Schema.String), relativePath: Schema.optional(Schema.String), fileMode: Schema.optional(Schema.String)});
export const FileList = Schema.Array(File);
export const SymbolicLink = Schema.Struct({blobId: Schema.optional(Schema.String), absolutePath: Schema.optional(Schema.String), relativePath: Schema.optional(Schema.String), fileMode: Schema.optional(Schema.String)});
export const SymbolicLinkList = Schema.Array(SymbolicLink);
export const SubModule = Schema.Struct({commitId: Schema.optional(Schema.String), absolutePath: Schema.optional(Schema.String), relativePath: Schema.optional(Schema.String)});
export const SubModuleList = Schema.Array(SubModule);
export const Approval = Schema.Struct({userArn: Schema.optional(Schema.String), approvalState: Schema.optional(Schema.String)});
export const ApprovalList = Schema.Array(Approval);
export const FileVersion = Schema.Struct({commit: Schema.optional(Commit), blobId: Schema.optional(Schema.String), path: Schema.optional(Schema.String), revisionChildren: Schema.optional(RevisionChildren)});
export const RevisionDag = Schema.Array(FileVersion);
export const RepositoryNameIdPair = Schema.Struct({repositoryName: Schema.optional(Schema.String), repositoryId: Schema.optional(Schema.String)});
export const RepositoryNameIdPairList = Schema.Array(RepositoryNameIdPair);
export const RepositoryTriggerExecutionFailure = Schema.Struct({trigger: Schema.optional(Schema.String), failureMessage: Schema.optional(Schema.String)});
export const RepositoryTriggerExecutionFailureList = Schema.Array(RepositoryTriggerExecutionFailure);
export const EncryptionKeyDisabledException = Schema.Struct({message: Schema.optional(Schema.String)});
export const BatchAssociateApprovalRuleTemplateWithRepositoriesOutput = Schema.Struct({associatedRepositoryNames: RepositoryNameList, errors: BatchAssociateApprovalRuleTemplateWithRepositoriesErrorsList});
export const BatchDescribeMergeConflictsOutput = Schema.Struct({conflicts: Conflicts, nextToken: Schema.optional(Schema.String), errors: Schema.optional(BatchDescribeMergeConflictsErrors), destinationCommitId: Schema.String, sourceCommitId: Schema.String, baseCommitId: Schema.optional(Schema.String)});
export const BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput = Schema.Struct({disassociatedRepositoryNames: RepositoryNameList, errors: BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorsList});
export const BatchGetRepositoriesOutput = Schema.Struct({repositories: Schema.optional(RepositoryMetadataList), repositoriesNotFound: Schema.optional(RepositoryNotFoundList), errors: Schema.optional(BatchGetRepositoriesErrorsList)});
export const CreateApprovalRuleTemplateOutput = Schema.Struct({approvalRuleTemplate: ApprovalRuleTemplate});
export const BranchNameRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreateCommitInput = Schema.Struct({repositoryName: Schema.String, branchName: Schema.String, parentCommitId: Schema.optional(Schema.String), authorName: Schema.optional(Schema.String), email: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), keepEmptyFolders: Schema.optional(Schema.Boolean), putFiles: Schema.optional(PutFileEntries), deleteFiles: Schema.optional(DeleteFileEntries), setFileModes: Schema.optional(SetFileModeEntries)});
export const CreatePullRequestOutput = Schema.Struct({pullRequest: PullRequest});
export const CreateRepositoryOutput = Schema.Struct({repositoryMetadata: Schema.optional(RepositoryMetadata)});
export const CreateUnreferencedMergeCommitInput = Schema.Struct({repositoryName: Schema.String, sourceCommitSpecifier: Schema.String, destinationCommitSpecifier: Schema.String, mergeOption: Schema.String, conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), authorName: Schema.optional(Schema.String), email: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), keepEmptyFolders: Schema.optional(Schema.Boolean), conflictResolution: Schema.optional(ConflictResolution)});
export const ApprovalRuleTemplateInUseException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DeleteBranchOutput = Schema.Struct({deletedBranch: Schema.optional(BranchInfo)});
export const BranchNameIsTagNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleNameRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const EncryptionKeyNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const EncryptionKeyUnavailableException = Schema.Struct({message: Schema.optional(Schema.String)});
export const EvaluatePullRequestApprovalRulesOutput = Schema.Struct({evaluation: Evaluation});
export const InvalidApprovalRuleTemplateNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const BlobIdDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidBranchNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommentDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GetCommentsForComparedCommitOutput = Schema.Struct({commentsForComparedCommitData: Schema.optional(CommentsForComparedCommitData), nextToken: Schema.optional(Schema.String)});
export const GetCommentsForPullRequestOutput = Schema.Struct({commentsForPullRequestData: Schema.optional(CommentsForPullRequestData), nextToken: Schema.optional(Schema.String)});
export const CommitIdDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommitDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GetFolderOutput = Schema.Struct({commitId: Schema.String, folderPath: Schema.String, treeId: Schema.optional(Schema.String), subFolders: Schema.optional(FolderList), files: Schema.optional(FileList), symbolicLinks: Schema.optional(SymbolicLinkList), subModules: Schema.optional(SubModuleList)});
export const CommitRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidCommitException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidConflictDetailLevelException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GetPullRequestApprovalStatesOutput = Schema.Struct({approvals: Schema.optional(ApprovalList)});
export const InvalidPullRequestIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryNameRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidContinuationTokenException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidMaxResultsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ListFileCommitHistoryResponse = Schema.Struct({revisionDag: RevisionDag, nextToken: Schema.optional(Schema.String)});
export const AuthorDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ListRepositoriesOutput = Schema.Struct({repositories: Schema.optional(RepositoryNameIdPairList), nextToken: Schema.optional(Schema.String)});
export const ResourceArnRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ConcurrentReferenceUpdateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommitMessageLengthExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileContentSizeLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidCommitIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FolderContentSizeLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidConflictResolutionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidOverrideStatusException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PostCommentForComparedCommitOutput = Schema.Struct({repositoryName: Schema.optional(Schema.String), beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.optional(Schema.String), beforeBlobId: Schema.optional(Schema.String), afterBlobId: Schema.optional(Schema.String), location: Schema.optional(Location), comment: Schema.optional(Comment)});
export const BeforeCommitIdAndAfterCommitIdAreSameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ClientRequestTokenRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommentIdRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DirectoryNameConflictsWithFileNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PutRepositoryTriggersOutput = Schema.Struct({configurationId: Schema.optional(Schema.String)});
export const InvalidSystemTagUsageException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TestRepositoryTriggersOutput = Schema.Struct({successfulExecutions: Schema.optional(RepositoryTriggerNameList), failedExecutions: Schema.optional(RepositoryTriggerExecutionFailureList)});
export const InvalidTagKeysListException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleTemplateContentRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidApprovalRuleTemplateDescriptionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleTemplateNameAlreadyExistsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommentContentRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleContentRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidApprovalStateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidDescriptionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidPullRequestStatusException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTitleException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryDescriptionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const EncryptionKeyInvalidIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryNameExistsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestCreatedEventMetadata = Schema.Struct({repositoryName: Schema.optional(Schema.String), sourceCommitId: Schema.optional(Schema.String), destinationCommitId: Schema.optional(Schema.String), mergeBase: Schema.optional(Schema.String)});
export const PullRequestStatusChangedEventMetadata = Schema.Struct({pullRequestStatus: Schema.optional(Schema.String)});
export const PullRequestSourceReferenceUpdatedEventMetadata = Schema.Struct({repositoryName: Schema.optional(Schema.String), beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.optional(Schema.String), mergeBase: Schema.optional(Schema.String)});
export const ApprovalRuleEventMetadata = Schema.Struct({approvalRuleName: Schema.optional(Schema.String), approvalRuleId: Schema.optional(Schema.String), approvalRuleContent: Schema.optional(Schema.String)});
export const ApprovalStateChangedEventMetadata = Schema.Struct({revisionId: Schema.optional(Schema.String), approvalStatus: Schema.optional(Schema.String)});
export const ApprovalRuleOverriddenEventMetadata = Schema.Struct({revisionId: Schema.optional(Schema.String), overrideStatus: Schema.optional(Schema.String)});
export const ReactionValueFormats = Schema.Struct({emoji: Schema.optional(Schema.String), shortCode: Schema.optional(Schema.String), unicode: Schema.optional(Schema.String)});
export const BlobMetadata = Schema.Struct({blobId: Schema.optional(Schema.String), path: Schema.optional(Schema.String), mode: Schema.optional(Schema.String)});
export const CommitObjectsList = Schema.Array(Commit);
export const ReactionForComment = Schema.Struct({reaction: Schema.optional(ReactionValueFormats), reactionUsers: Schema.optional(ReactionUsersList), reactionsFromDeletedUsersCount: Schema.optional(Schema.Number)});
export const ReactionsForCommentList = Schema.Array(ReactionForComment);
export const Difference = Schema.Struct({beforeBlob: Schema.optional(BlobMetadata), afterBlob: Schema.optional(BlobMetadata), changeType: Schema.optional(Schema.String)});
export const DifferenceList = Schema.Array(Difference);
export const MaximumRuleTemplatesAssociatedWithRepositoryException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumRepositoryNamesExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidConflictResolutionStrategyException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryNamesRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const BatchGetCommitsOutput = Schema.Struct({commits: Schema.optional(CommitObjectsList), errors: Schema.optional(BatchGetCommitsErrorsList)});
export const InvalidApprovalRuleTemplateContentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommitIdRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const IdempotencyParameterMismatchException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreatePullRequestApprovalRuleOutput = Schema.Struct({approvalRule: ApprovalRule});
export const EncryptionKeyInvalidUsageException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreateUnreferencedMergeCommitOutput = Schema.Struct({commitId: Schema.optional(Schema.String), treeId: Schema.optional(Schema.String)});
export const DefaultBranchCannotBeDeletedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DeleteCommentContentOutput = Schema.Struct({comment: Schema.optional(Comment)});
export const FileDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CannotDeleteApprovalRuleFromTemplateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeMergeConflictsOutput = Schema.Struct({conflictMetadata: ConflictMetadata, mergeHunks: MergeHunks, nextToken: Schema.optional(Schema.String), destinationCommitId: Schema.String, sourceCommitId: Schema.String, baseCommitId: Schema.optional(Schema.String)});
export const InvalidRevisionIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const BlobIdRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidCommentIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GetCommentReactionsOutput = Schema.Struct({reactionsForComment: ReactionsForCommentList, nextToken: Schema.optional(Schema.String)});
export const PullRequestDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GetDifferencesOutput = Schema.Struct({differences: Schema.optional(DifferenceList), NextToken: Schema.optional(Schema.String)});
export const FileTooLargeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FolderDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidDestinationCommitSpecifierException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumFileContentToLoadExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GetPullRequestOutput = Schema.Struct({pullRequest: PullRequest});
export const PullRequestIdRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RevisionIdRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TipsDivergenceExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidAuthorArnException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidOrderException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTargetBranchException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileModeRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidEmailException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ManualMergeRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidFileModeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidPathException = Schema.Struct({message: Schema.optional(Schema.String)});
export const OverrideAlreadySetException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommentContentSizeLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidClientRequestTokenException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidReactionValueException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileContentRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryTriggerBranchNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTagsMapException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryTriggerCustomDataException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TagKeysListRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRuleContentSha256Exception = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommentNotCreatedByCallerException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumNumberOfApprovalsExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestAlreadyClosedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidPullRequestStatusUpdateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TitleRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const EncryptionKeyRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestMergedStateChangedEventMetadata = Schema.Struct({repositoryName: Schema.optional(Schema.String), destinationReference: Schema.optional(Schema.String), mergeMetadata: Schema.optional(MergeMetadata)});
export const FileMetadata = Schema.Struct({absolutePath: Schema.optional(Schema.String), blobId: Schema.optional(Schema.String), fileMode: Schema.optional(Schema.String)});
export const FilesMetadata = Schema.Array(FileMetadata);
export const PullRequestEvent = Schema.Struct({pullRequestId: Schema.optional(Schema.String), eventDate: Schema.optional(Schema.Date), pullRequestEventType: Schema.optional(Schema.String), actorArn: Schema.optional(Schema.String), pullRequestCreatedEventMetadata: Schema.optional(PullRequestCreatedEventMetadata), pullRequestStatusChangedEventMetadata: Schema.optional(PullRequestStatusChangedEventMetadata), pullRequestSourceReferenceUpdatedEventMetadata: Schema.optional(PullRequestSourceReferenceUpdatedEventMetadata), pullRequestMergedStateChangedEventMetadata: Schema.optional(PullRequestMergedStateChangedEventMetadata), approvalRuleEventMetadata: Schema.optional(ApprovalRuleEventMetadata), approvalStateChangedEventMetadata: Schema.optional(ApprovalStateChangedEventMetadata), approvalRuleOverriddenEventMetadata: Schema.optional(ApprovalRuleOverriddenEventMetadata)});
export const PullRequestEventList = Schema.Array(PullRequestEvent);
export const InvalidMaxConflictFilesException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommitIdsLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const NumberOfRuleTemplatesExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreateCommitOutput = Schema.Struct({commitId: Schema.optional(Schema.String), treeId: Schema.optional(Schema.String), filesAdded: Schema.optional(FilesMetadata), filesUpdated: Schema.optional(FilesMetadata), filesDeleted: Schema.optional(FilesMetadata)});
export const InvalidReferenceNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleNameAlreadyExistsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const OperationNotAllowedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidMergeOptionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidParentCommitIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidApprovalRuleNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidMaxMergeHunksException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribePullRequestEventsOutput = Schema.Struct({pullRequestEvents: PullRequestEventList, nextToken: Schema.optional(Schema.String)});
export const RevisionNotCurrentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidBlobIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidReactionUserArnException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryNotAssociatedWithPullRequestException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PathDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PathRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidSourceCommitSpecifierException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumItemsToCompareExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidSortByException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidReplacementContentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidReplacementTypeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestApprovalRulesNotSatisfiedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumConflictResolutionEntriesExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MultipleConflictResolutionEntriesException = Schema.Struct({message: Schema.optional(Schema.String)});
export const OverrideStatusRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidFileLocationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidFilePositionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReactionLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileNameConflictsWithDirectoryNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryTriggerDestinationArnException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TagPolicyException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryTriggerEventsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TooManyTagsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CannotModifyApprovalRuleFromTemplateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestCannotBeApprovedByAuthorException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestStatusRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MergeOptionRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommitIdsListRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileContentAndSourceFileSpecifiedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTargetException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidApprovalRuleContentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const NameLengthExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ParentCommitDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ActorDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReplacementContentRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReplacementTypeRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReferenceDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TipOfSourceReferenceIsDifferentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRelativeFileVersionEnumException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReactionValueRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FilePathConflictsWithSubmodulePathException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryTriggerNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TagsMapRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryTriggerRegionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileEntryRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTargetsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const NumberOfRulesExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ParentCommitIdOutdatedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidActorArnException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidDeletionParameterException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumBranchesExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumRepositoryTriggersExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumFileEntriesExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumOpenPullRequestsExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ParentCommitIdRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidPullRequestEventTypeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SameFileContentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryTriggerBranchNameListRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryTriggerDestinationArnRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const NoChangeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MultipleRepositoriesInPullRequestException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryTriggerEventsListRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryTriggerNameRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PutFileEntryConflictException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReferenceNameRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryTriggersListRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RestrictedSourceFileException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReferenceTypeNotSupportedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SamePathRequestException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SourceAndDestinationAreSameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SourceFileOrContentRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TargetRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TargetsRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});

//# Errors
export class ApprovalRuleTemplateDoesNotExistExceptionError extends Schema.TaggedError<ApprovalRuleTemplateDoesNotExistExceptionError>()("ApprovalRuleTemplateDoesNotExistException", ApprovalRuleTemplateDoesNotExistException) {};
export class InvalidRepositoryNameExceptionError extends Schema.TaggedError<InvalidRepositoryNameExceptionError>()("InvalidRepositoryNameException", InvalidRepositoryNameException) {};
export class EncryptionIntegrityChecksFailedExceptionError extends Schema.TaggedError<EncryptionIntegrityChecksFailedExceptionError>()("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException) {};
export class ApprovalRuleTemplateNameRequiredExceptionError extends Schema.TaggedError<ApprovalRuleTemplateNameRequiredExceptionError>()("ApprovalRuleTemplateNameRequiredException", ApprovalRuleTemplateNameRequiredException) {};
export class EncryptionKeyAccessDeniedExceptionError extends Schema.TaggedError<EncryptionKeyAccessDeniedExceptionError>()("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException) {};
export class BranchNameExistsExceptionError extends Schema.TaggedError<BranchNameExistsExceptionError>()("BranchNameExistsException", BranchNameExistsException) {};
export class BranchDoesNotExistExceptionError extends Schema.TaggedError<BranchDoesNotExistExceptionError>()("BranchDoesNotExistException", BranchDoesNotExistException) {};
export class EncryptionKeyDisabledExceptionError extends Schema.TaggedError<EncryptionKeyDisabledExceptionError>()("EncryptionKeyDisabledException", EncryptionKeyDisabledException) {};
export class EncryptionKeyNotFoundExceptionError extends Schema.TaggedError<EncryptionKeyNotFoundExceptionError>()("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException) {};
export class BranchNameRequiredExceptionError extends Schema.TaggedError<BranchNameRequiredExceptionError>()("BranchNameRequiredException", BranchNameRequiredException) {};
export class EncryptionKeyUnavailableExceptionError extends Schema.TaggedError<EncryptionKeyUnavailableExceptionError>()("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException) {};
export class CommentDeletedExceptionError extends Schema.TaggedError<CommentDeletedExceptionError>()("CommentDeletedException", CommentDeletedException) {};
export class CommitDoesNotExistExceptionError extends Schema.TaggedError<CommitDoesNotExistExceptionError>()("CommitDoesNotExistException", CommitDoesNotExistException) {};
export class CommitRequiredExceptionError extends Schema.TaggedError<CommitRequiredExceptionError>()("CommitRequiredException", CommitRequiredException) {};
export class InvalidCommitExceptionError extends Schema.TaggedError<InvalidCommitExceptionError>()("InvalidCommitException", InvalidCommitException) {};
export class RepositoryDoesNotExistExceptionError extends Schema.TaggedError<RepositoryDoesNotExistExceptionError>()("RepositoryDoesNotExistException", RepositoryDoesNotExistException) {};
export class RepositoryNameRequiredExceptionError extends Schema.TaggedError<RepositoryNameRequiredExceptionError>()("RepositoryNameRequiredException", RepositoryNameRequiredException) {};
export class InvalidContinuationTokenExceptionError extends Schema.TaggedError<InvalidContinuationTokenExceptionError>()("InvalidContinuationTokenException", InvalidContinuationTokenException) {};
export class InvalidApprovalRuleTemplateNameExceptionError extends Schema.TaggedError<InvalidApprovalRuleTemplateNameExceptionError>()("InvalidApprovalRuleTemplateNameException", InvalidApprovalRuleTemplateNameException) {};
export class InvalidMaxResultsExceptionError extends Schema.TaggedError<InvalidMaxResultsExceptionError>()("InvalidMaxResultsException", InvalidMaxResultsException) {};
export class InvalidResourceArnExceptionError extends Schema.TaggedError<InvalidResourceArnExceptionError>()("InvalidResourceArnException", InvalidResourceArnException) {};
export class BranchNameIsTagNameExceptionError extends Schema.TaggedError<BranchNameIsTagNameExceptionError>()("BranchNameIsTagNameException", BranchNameIsTagNameException) {};
export class CommitMessageLengthExceededExceptionError extends Schema.TaggedError<CommitMessageLengthExceededExceptionError>()("CommitMessageLengthExceededException", CommitMessageLengthExceededException) {};
export class ConcurrentReferenceUpdateExceptionError extends Schema.TaggedError<ConcurrentReferenceUpdateExceptionError>()("ConcurrentReferenceUpdateException", ConcurrentReferenceUpdateException) {};
export class FileContentSizeLimitExceededExceptionError extends Schema.TaggedError<FileContentSizeLimitExceededExceptionError>()("FileContentSizeLimitExceededException", FileContentSizeLimitExceededException) {};
export class FolderContentSizeLimitExceededExceptionError extends Schema.TaggedError<FolderContentSizeLimitExceededExceptionError>()("FolderContentSizeLimitExceededException", FolderContentSizeLimitExceededException) {};
export class InvalidCommitIdExceptionError extends Schema.TaggedError<InvalidCommitIdExceptionError>()("InvalidCommitIdException", InvalidCommitIdException) {};
export class InvalidConflictDetailLevelExceptionError extends Schema.TaggedError<InvalidConflictDetailLevelExceptionError>()("InvalidConflictDetailLevelException", InvalidConflictDetailLevelException) {};
export class CommentDoesNotExistExceptionError extends Schema.TaggedError<CommentDoesNotExistExceptionError>()("CommentDoesNotExistException", CommentDoesNotExistException) {};
export class InvalidSystemTagUsageExceptionError extends Schema.TaggedError<InvalidSystemTagUsageExceptionError>()("InvalidSystemTagUsageException", InvalidSystemTagUsageException) {};
export class InvalidBranchNameExceptionError extends Schema.TaggedError<InvalidBranchNameExceptionError>()("InvalidBranchNameException", InvalidBranchNameException) {};
export class ApprovalStateRequiredExceptionError extends Schema.TaggedError<ApprovalStateRequiredExceptionError>()("ApprovalStateRequiredException", ApprovalStateRequiredException) {};
export class InvalidPullRequestIdExceptionError extends Schema.TaggedError<InvalidPullRequestIdExceptionError>()("InvalidPullRequestIdException", InvalidPullRequestIdException) {};
export class MaximumRepositoryNamesExceededExceptionError extends Schema.TaggedError<MaximumRepositoryNamesExceededExceptionError>()("MaximumRepositoryNamesExceededException", MaximumRepositoryNamesExceededException) {};
export class RepositoryNamesRequiredExceptionError extends Schema.TaggedError<RepositoryNamesRequiredExceptionError>()("RepositoryNamesRequiredException", RepositoryNamesRequiredException) {};
export class ApprovalRuleTemplateContentRequiredExceptionError extends Schema.TaggedError<ApprovalRuleTemplateContentRequiredExceptionError>()("ApprovalRuleTemplateContentRequiredException", ApprovalRuleTemplateContentRequiredException) {};
export class ApprovalRuleTemplateNameAlreadyExistsExceptionError extends Schema.TaggedError<ApprovalRuleTemplateNameAlreadyExistsExceptionError>()("ApprovalRuleTemplateNameAlreadyExistsException", ApprovalRuleTemplateNameAlreadyExistsException) {};
export class ClientRequestTokenRequiredExceptionError extends Schema.TaggedError<ClientRequestTokenRequiredExceptionError>()("ClientRequestTokenRequiredException", ClientRequestTokenRequiredException) {};
export class EncryptionKeyInvalidIdExceptionError extends Schema.TaggedError<EncryptionKeyInvalidIdExceptionError>()("EncryptionKeyInvalidIdException", EncryptionKeyInvalidIdException) {};
export class ApprovalRuleTemplateInUseExceptionError extends Schema.TaggedError<ApprovalRuleTemplateInUseExceptionError>()("ApprovalRuleTemplateInUseException", ApprovalRuleTemplateInUseException) {};
export class ApprovalRuleNameRequiredExceptionError extends Schema.TaggedError<ApprovalRuleNameRequiredExceptionError>()("ApprovalRuleNameRequiredException", ApprovalRuleNameRequiredException) {};
export class BlobIdDoesNotExistExceptionError extends Schema.TaggedError<BlobIdDoesNotExistExceptionError>()("BlobIdDoesNotExistException", BlobIdDoesNotExistException) {};
export class CommentIdRequiredExceptionError extends Schema.TaggedError<CommentIdRequiredExceptionError>()("CommentIdRequiredException", CommentIdRequiredException) {};
export class CommitIdRequiredExceptionError extends Schema.TaggedError<CommitIdRequiredExceptionError>()("CommitIdRequiredException", CommitIdRequiredException) {};
export class CommitIdDoesNotExistExceptionError extends Schema.TaggedError<CommitIdDoesNotExistExceptionError>()("CommitIdDoesNotExistException", CommitIdDoesNotExistException) {};
export class FileDoesNotExistExceptionError extends Schema.TaggedError<FileDoesNotExistExceptionError>()("FileDoesNotExistException", FileDoesNotExistException) {};
export class InvalidConflictResolutionStrategyExceptionError extends Schema.TaggedError<InvalidConflictResolutionStrategyExceptionError>()("InvalidConflictResolutionStrategyException", InvalidConflictResolutionStrategyException) {};
export class InvalidRevisionIdExceptionError extends Schema.TaggedError<InvalidRevisionIdExceptionError>()("InvalidRevisionIdException", InvalidRevisionIdException) {};
export class PullRequestDoesNotExistExceptionError extends Schema.TaggedError<PullRequestDoesNotExistExceptionError>()("PullRequestDoesNotExistException", PullRequestDoesNotExistException) {};
export class PullRequestIdRequiredExceptionError extends Schema.TaggedError<PullRequestIdRequiredExceptionError>()("PullRequestIdRequiredException", PullRequestIdRequiredException) {};
export class AuthorDoesNotExistExceptionError extends Schema.TaggedError<AuthorDoesNotExistExceptionError>()("AuthorDoesNotExistException", AuthorDoesNotExistException) {};
export class ResourceArnRequiredExceptionError extends Schema.TaggedError<ResourceArnRequiredExceptionError>()("ResourceArnRequiredException", ResourceArnRequiredException) {};
export class FileModeRequiredExceptionError extends Schema.TaggedError<FileModeRequiredExceptionError>()("FileModeRequiredException", FileModeRequiredException) {};
export class InvalidConflictResolutionExceptionError extends Schema.TaggedError<InvalidConflictResolutionExceptionError>()("InvalidConflictResolutionException", InvalidConflictResolutionException) {};
export class InvalidEmailExceptionError extends Schema.TaggedError<InvalidEmailExceptionError>()("InvalidEmailException", InvalidEmailException) {};
export class InvalidFileModeExceptionError extends Schema.TaggedError<InvalidFileModeExceptionError>()("InvalidFileModeException", InvalidFileModeException) {};
export class InvalidOverrideStatusExceptionError extends Schema.TaggedError<InvalidOverrideStatusExceptionError>()("InvalidOverrideStatusException", InvalidOverrideStatusException) {};
export class BeforeCommitIdAndAfterCommitIdAreSameExceptionError extends Schema.TaggedError<BeforeCommitIdAndAfterCommitIdAreSameExceptionError>()("BeforeCommitIdAndAfterCommitIdAreSameException", BeforeCommitIdAndAfterCommitIdAreSameException) {};
export class CommentContentRequiredExceptionError extends Schema.TaggedError<CommentContentRequiredExceptionError>()("CommentContentRequiredException", CommentContentRequiredException) {};
export class CommentContentSizeLimitExceededExceptionError extends Schema.TaggedError<CommentContentSizeLimitExceededExceptionError>()("CommentContentSizeLimitExceededException", CommentContentSizeLimitExceededException) {};
export class IdempotencyParameterMismatchExceptionError extends Schema.TaggedError<IdempotencyParameterMismatchExceptionError>()("IdempotencyParameterMismatchException", IdempotencyParameterMismatchException) {};
export class InvalidClientRequestTokenExceptionError extends Schema.TaggedError<InvalidClientRequestTokenExceptionError>()("InvalidClientRequestTokenException", InvalidClientRequestTokenException) {};
export class InvalidCommentIdExceptionError extends Schema.TaggedError<InvalidCommentIdExceptionError>()("InvalidCommentIdException", InvalidCommentIdException) {};
export class DirectoryNameConflictsWithFileNameExceptionError extends Schema.TaggedError<DirectoryNameConflictsWithFileNameExceptionError>()("DirectoryNameConflictsWithFileNameException", DirectoryNameConflictsWithFileNameException) {};
export class InvalidRepositoryTriggerBranchNameExceptionError extends Schema.TaggedError<InvalidRepositoryTriggerBranchNameExceptionError>()("InvalidRepositoryTriggerBranchNameException", InvalidRepositoryTriggerBranchNameException) {};
export class InvalidTagKeysListExceptionError extends Schema.TaggedError<InvalidTagKeysListExceptionError>()("InvalidTagKeysListException", InvalidTagKeysListException) {};
export class InvalidApprovalRuleTemplateContentExceptionError extends Schema.TaggedError<InvalidApprovalRuleTemplateContentExceptionError>()("InvalidApprovalRuleTemplateContentException", InvalidApprovalRuleTemplateContentException) {};
export class InvalidApprovalRuleTemplateDescriptionExceptionError extends Schema.TaggedError<InvalidApprovalRuleTemplateDescriptionExceptionError>()("InvalidApprovalRuleTemplateDescriptionException", InvalidApprovalRuleTemplateDescriptionException) {};
export class ApprovalRuleContentRequiredExceptionError extends Schema.TaggedError<ApprovalRuleContentRequiredExceptionError>()("ApprovalRuleContentRequiredException", ApprovalRuleContentRequiredException) {};
export class InvalidApprovalStateExceptionError extends Schema.TaggedError<InvalidApprovalStateExceptionError>()("InvalidApprovalStateException", InvalidApprovalStateException) {};
export class InvalidDescriptionExceptionError extends Schema.TaggedError<InvalidDescriptionExceptionError>()("InvalidDescriptionException", InvalidDescriptionException) {};
export class InvalidPullRequestStatusExceptionError extends Schema.TaggedError<InvalidPullRequestStatusExceptionError>()("InvalidPullRequestStatusException", InvalidPullRequestStatusException) {};
export class InvalidTitleExceptionError extends Schema.TaggedError<InvalidTitleExceptionError>()("InvalidTitleException", InvalidTitleException) {};
export class PullRequestAlreadyClosedExceptionError extends Schema.TaggedError<PullRequestAlreadyClosedExceptionError>()("PullRequestAlreadyClosedException", PullRequestAlreadyClosedException) {};
export class InvalidRepositoryDescriptionExceptionError extends Schema.TaggedError<InvalidRepositoryDescriptionExceptionError>()("InvalidRepositoryDescriptionException", InvalidRepositoryDescriptionException) {};
export class EncryptionKeyInvalidUsageExceptionError extends Schema.TaggedError<EncryptionKeyInvalidUsageExceptionError>()("EncryptionKeyInvalidUsageException", EncryptionKeyInvalidUsageException) {};
export class RepositoryNameExistsExceptionError extends Schema.TaggedError<RepositoryNameExistsExceptionError>()("RepositoryNameExistsException", RepositoryNameExistsException) {};
export class MaximumRuleTemplatesAssociatedWithRepositoryExceptionError extends Schema.TaggedError<MaximumRuleTemplatesAssociatedWithRepositoryExceptionError>()("MaximumRuleTemplatesAssociatedWithRepositoryException", MaximumRuleTemplatesAssociatedWithRepositoryException) {};
export class InvalidTagsMapExceptionError extends Schema.TaggedError<InvalidTagsMapExceptionError>()("InvalidTagsMapException", InvalidTagsMapException) {};
export class DefaultBranchCannotBeDeletedExceptionError extends Schema.TaggedError<DefaultBranchCannotBeDeletedExceptionError>()("DefaultBranchCannotBeDeletedException", DefaultBranchCannotBeDeletedException) {};
export class CannotDeleteApprovalRuleFromTemplateExceptionError extends Schema.TaggedError<CannotDeleteApprovalRuleFromTemplateExceptionError>()("CannotDeleteApprovalRuleFromTemplateException", CannotDeleteApprovalRuleFromTemplateException) {};
export class RevisionIdRequiredExceptionError extends Schema.TaggedError<RevisionIdRequiredExceptionError>()("RevisionIdRequiredException", RevisionIdRequiredException) {};
export class BlobIdRequiredExceptionError extends Schema.TaggedError<BlobIdRequiredExceptionError>()("BlobIdRequiredException", BlobIdRequiredException) {};
export class FileTooLargeExceptionError extends Schema.TaggedError<FileTooLargeExceptionError>()("FileTooLargeException", FileTooLargeException) {};
export class InvalidPathExceptionError extends Schema.TaggedError<InvalidPathExceptionError>()("InvalidPathException", InvalidPathException) {};
export class FolderDoesNotExistExceptionError extends Schema.TaggedError<FolderDoesNotExistExceptionError>()("FolderDoesNotExistException", FolderDoesNotExistException) {};
export class PathRequiredExceptionError extends Schema.TaggedError<PathRequiredExceptionError>()("PathRequiredException", PathRequiredException) {};
export class InvalidDestinationCommitSpecifierExceptionError extends Schema.TaggedError<InvalidDestinationCommitSpecifierExceptionError>()("InvalidDestinationCommitSpecifierException", InvalidDestinationCommitSpecifierException) {};
export class InvalidMaxConflictFilesExceptionError extends Schema.TaggedError<InvalidMaxConflictFilesExceptionError>()("InvalidMaxConflictFilesException", InvalidMaxConflictFilesException) {};
export class InvalidMergeOptionExceptionError extends Schema.TaggedError<InvalidMergeOptionExceptionError>()("InvalidMergeOptionException", InvalidMergeOptionException) {};
export class MaximumFileContentToLoadExceededExceptionError extends Schema.TaggedError<MaximumFileContentToLoadExceededExceptionError>()("MaximumFileContentToLoadExceededException", MaximumFileContentToLoadExceededException) {};
export class TipsDivergenceExceededExceptionError extends Schema.TaggedError<TipsDivergenceExceededExceptionError>()("TipsDivergenceExceededException", TipsDivergenceExceededException) {};
export class InvalidAuthorArnExceptionError extends Schema.TaggedError<InvalidAuthorArnExceptionError>()("InvalidAuthorArnException", InvalidAuthorArnException) {};
export class InvalidOrderExceptionError extends Schema.TaggedError<InvalidOrderExceptionError>()("InvalidOrderException", InvalidOrderException) {};
export class InvalidTargetBranchExceptionError extends Schema.TaggedError<InvalidTargetBranchExceptionError>()("InvalidTargetBranchException", InvalidTargetBranchException) {};
export class ManualMergeRequiredExceptionError extends Schema.TaggedError<ManualMergeRequiredExceptionError>()("ManualMergeRequiredException", ManualMergeRequiredException) {};
export class InvalidReplacementContentExceptionError extends Schema.TaggedError<InvalidReplacementContentExceptionError>()("InvalidReplacementContentException", InvalidReplacementContentException) {};
export class InvalidReplacementTypeExceptionError extends Schema.TaggedError<InvalidReplacementTypeExceptionError>()("InvalidReplacementTypeException", InvalidReplacementTypeException) {};
export class MaximumConflictResolutionEntriesExceededExceptionError extends Schema.TaggedError<MaximumConflictResolutionEntriesExceededExceptionError>()("MaximumConflictResolutionEntriesExceededException", MaximumConflictResolutionEntriesExceededException) {};
export class MaximumItemsToCompareExceededExceptionError extends Schema.TaggedError<MaximumItemsToCompareExceededExceptionError>()("MaximumItemsToCompareExceededException", MaximumItemsToCompareExceededException) {};
export class OverrideAlreadySetExceptionError extends Schema.TaggedError<OverrideAlreadySetExceptionError>()("OverrideAlreadySetException", OverrideAlreadySetException) {};
export class InvalidFileLocationExceptionError extends Schema.TaggedError<InvalidFileLocationExceptionError>()("InvalidFileLocationException", InvalidFileLocationException) {};
export class InvalidReactionValueExceptionError extends Schema.TaggedError<InvalidReactionValueExceptionError>()("InvalidReactionValueException", InvalidReactionValueException) {};
export class FileContentRequiredExceptionError extends Schema.TaggedError<FileContentRequiredExceptionError>()("FileContentRequiredException", FileContentRequiredException) {};
export class InvalidRepositoryTriggerCustomDataExceptionError extends Schema.TaggedError<InvalidRepositoryTriggerCustomDataExceptionError>()("InvalidRepositoryTriggerCustomDataException", InvalidRepositoryTriggerCustomDataException) {};
export class InvalidRepositoryTriggerDestinationArnExceptionError extends Schema.TaggedError<InvalidRepositoryTriggerDestinationArnExceptionError>()("InvalidRepositoryTriggerDestinationArnException", InvalidRepositoryTriggerDestinationArnException) {};
export class TagKeysListRequiredExceptionError extends Schema.TaggedError<TagKeysListRequiredExceptionError>()("TagKeysListRequiredException", TagKeysListRequiredException) {};
export class TagPolicyExceptionError extends Schema.TaggedError<TagPolicyExceptionError>()("TagPolicyException", TagPolicyException) {};
export class InvalidRuleContentSha256ExceptionError extends Schema.TaggedError<InvalidRuleContentSha256ExceptionError>()("InvalidRuleContentSha256Exception", InvalidRuleContentSha256Exception) {};
export class CommentNotCreatedByCallerExceptionError extends Schema.TaggedError<CommentNotCreatedByCallerExceptionError>()("CommentNotCreatedByCallerException", CommentNotCreatedByCallerException) {};
export class ApprovalRuleDoesNotExistExceptionError extends Schema.TaggedError<ApprovalRuleDoesNotExistExceptionError>()("ApprovalRuleDoesNotExistException", ApprovalRuleDoesNotExistException) {};
export class MaximumNumberOfApprovalsExceededExceptionError extends Schema.TaggedError<MaximumNumberOfApprovalsExceededExceptionError>()("MaximumNumberOfApprovalsExceededException", MaximumNumberOfApprovalsExceededException) {};
export class InvalidPullRequestStatusUpdateExceptionError extends Schema.TaggedError<InvalidPullRequestStatusUpdateExceptionError>()("InvalidPullRequestStatusUpdateException", InvalidPullRequestStatusUpdateException) {};
export class TitleRequiredExceptionError extends Schema.TaggedError<TitleRequiredExceptionError>()("TitleRequiredException", TitleRequiredException) {};
export class EncryptionKeyRequiredExceptionError extends Schema.TaggedError<EncryptionKeyRequiredExceptionError>()("EncryptionKeyRequiredException", EncryptionKeyRequiredException) {};
export class InvalidMaxMergeHunksExceptionError extends Schema.TaggedError<InvalidMaxMergeHunksExceptionError>()("InvalidMaxMergeHunksException", InvalidMaxMergeHunksException) {};
export class CommitIdsLimitExceededExceptionError extends Schema.TaggedError<CommitIdsLimitExceededExceptionError>()("CommitIdsLimitExceededException", CommitIdsLimitExceededException) {};
export class NumberOfRuleTemplatesExceededExceptionError extends Schema.TaggedError<NumberOfRuleTemplatesExceededExceptionError>()("NumberOfRuleTemplatesExceededException", NumberOfRuleTemplatesExceededException) {};
export class InvalidReferenceNameExceptionError extends Schema.TaggedError<InvalidReferenceNameExceptionError>()("InvalidReferenceNameException", InvalidReferenceNameException) {};
export class ApprovalRuleNameAlreadyExistsExceptionError extends Schema.TaggedError<ApprovalRuleNameAlreadyExistsExceptionError>()("ApprovalRuleNameAlreadyExistsException", ApprovalRuleNameAlreadyExistsException) {};
export class OperationNotAllowedExceptionError extends Schema.TaggedError<OperationNotAllowedExceptionError>()("OperationNotAllowedException", OperationNotAllowedException) {};
export class MergeOptionRequiredExceptionError extends Schema.TaggedError<MergeOptionRequiredExceptionError>()("MergeOptionRequiredException", MergeOptionRequiredException) {};
export class MultipleConflictResolutionEntriesExceptionError extends Schema.TaggedError<MultipleConflictResolutionEntriesExceptionError>()("MultipleConflictResolutionEntriesException", MultipleConflictResolutionEntriesException) {};
export class InvalidParentCommitIdExceptionError extends Schema.TaggedError<InvalidParentCommitIdExceptionError>()("InvalidParentCommitIdException", InvalidParentCommitIdException) {};
export class NameLengthExceededExceptionError extends Schema.TaggedError<NameLengthExceededExceptionError>()("NameLengthExceededException", NameLengthExceededException) {};
export class InvalidApprovalRuleNameExceptionError extends Schema.TaggedError<InvalidApprovalRuleNameExceptionError>()("InvalidApprovalRuleNameException", InvalidApprovalRuleNameException) {};
export class RevisionNotCurrentExceptionError extends Schema.TaggedError<RevisionNotCurrentExceptionError>()("RevisionNotCurrentException", RevisionNotCurrentException) {};
export class InvalidBlobIdExceptionError extends Schema.TaggedError<InvalidBlobIdExceptionError>()("InvalidBlobIdException", InvalidBlobIdException) {};
export class InvalidReactionUserArnExceptionError extends Schema.TaggedError<InvalidReactionUserArnExceptionError>()("InvalidReactionUserArnException", InvalidReactionUserArnException) {};
export class RepositoryNotAssociatedWithPullRequestExceptionError extends Schema.TaggedError<RepositoryNotAssociatedWithPullRequestExceptionError>()("RepositoryNotAssociatedWithPullRequestException", RepositoryNotAssociatedWithPullRequestException) {};
export class PathDoesNotExistExceptionError extends Schema.TaggedError<PathDoesNotExistExceptionError>()("PathDoesNotExistException", PathDoesNotExistException) {};
export class InvalidSourceCommitSpecifierExceptionError extends Schema.TaggedError<InvalidSourceCommitSpecifierExceptionError>()("InvalidSourceCommitSpecifierException", InvalidSourceCommitSpecifierException) {};
export class InvalidSortByExceptionError extends Schema.TaggedError<InvalidSortByExceptionError>()("InvalidSortByException", InvalidSortByException) {};
export class ReplacementContentRequiredExceptionError extends Schema.TaggedError<ReplacementContentRequiredExceptionError>()("ReplacementContentRequiredException", ReplacementContentRequiredException) {};
export class PullRequestApprovalRulesNotSatisfiedExceptionError extends Schema.TaggedError<PullRequestApprovalRulesNotSatisfiedExceptionError>()("PullRequestApprovalRulesNotSatisfiedException", PullRequestApprovalRulesNotSatisfiedException) {};
export class ReplacementTypeRequiredExceptionError extends Schema.TaggedError<ReplacementTypeRequiredExceptionError>()("ReplacementTypeRequiredException", ReplacementTypeRequiredException) {};
export class TipOfSourceReferenceIsDifferentExceptionError extends Schema.TaggedError<TipOfSourceReferenceIsDifferentExceptionError>()("TipOfSourceReferenceIsDifferentException", TipOfSourceReferenceIsDifferentException) {};
export class OverrideStatusRequiredExceptionError extends Schema.TaggedError<OverrideStatusRequiredExceptionError>()("OverrideStatusRequiredException", OverrideStatusRequiredException) {};
export class InvalidFilePositionExceptionError extends Schema.TaggedError<InvalidFilePositionExceptionError>()("InvalidFilePositionException", InvalidFilePositionException) {};
export class InvalidRelativeFileVersionEnumExceptionError extends Schema.TaggedError<InvalidRelativeFileVersionEnumExceptionError>()("InvalidRelativeFileVersionEnumException", InvalidRelativeFileVersionEnumException) {};
export class ReactionLimitExceededExceptionError extends Schema.TaggedError<ReactionLimitExceededExceptionError>()("ReactionLimitExceededException", ReactionLimitExceededException) {};
export class FileNameConflictsWithDirectoryNameExceptionError extends Schema.TaggedError<FileNameConflictsWithDirectoryNameExceptionError>()("FileNameConflictsWithDirectoryNameException", FileNameConflictsWithDirectoryNameException) {};
export class InvalidRepositoryTriggerEventsExceptionError extends Schema.TaggedError<InvalidRepositoryTriggerEventsExceptionError>()("InvalidRepositoryTriggerEventsException", InvalidRepositoryTriggerEventsException) {};
export class InvalidRepositoryTriggerNameExceptionError extends Schema.TaggedError<InvalidRepositoryTriggerNameExceptionError>()("InvalidRepositoryTriggerNameException", InvalidRepositoryTriggerNameException) {};
export class TooManyTagsExceptionError extends Schema.TaggedError<TooManyTagsExceptionError>()("TooManyTagsException", TooManyTagsException) {};
export class CannotModifyApprovalRuleFromTemplateExceptionError extends Schema.TaggedError<CannotModifyApprovalRuleFromTemplateExceptionError>()("CannotModifyApprovalRuleFromTemplateException", CannotModifyApprovalRuleFromTemplateException) {};
export class InvalidApprovalRuleContentExceptionError extends Schema.TaggedError<InvalidApprovalRuleContentExceptionError>()("InvalidApprovalRuleContentException", InvalidApprovalRuleContentException) {};
export class PullRequestCannotBeApprovedByAuthorExceptionError extends Schema.TaggedError<PullRequestCannotBeApprovedByAuthorExceptionError>()("PullRequestCannotBeApprovedByAuthorException", PullRequestCannotBeApprovedByAuthorException) {};
export class PullRequestStatusRequiredExceptionError extends Schema.TaggedError<PullRequestStatusRequiredExceptionError>()("PullRequestStatusRequiredException", PullRequestStatusRequiredException) {};
export class CommitIdsListRequiredExceptionError extends Schema.TaggedError<CommitIdsListRequiredExceptionError>()("CommitIdsListRequiredException", CommitIdsListRequiredException) {};
export class FileContentAndSourceFileSpecifiedExceptionError extends Schema.TaggedError<FileContentAndSourceFileSpecifiedExceptionError>()("FileContentAndSourceFileSpecifiedException", FileContentAndSourceFileSpecifiedException) {};
export class InvalidTargetExceptionError extends Schema.TaggedError<InvalidTargetExceptionError>()("InvalidTargetException", InvalidTargetException) {};
export class RepositoryLimitExceededExceptionError extends Schema.TaggedError<RepositoryLimitExceededExceptionError>()("RepositoryLimitExceededException", RepositoryLimitExceededException) {};
export class ParentCommitDoesNotExistExceptionError extends Schema.TaggedError<ParentCommitDoesNotExistExceptionError>()("ParentCommitDoesNotExistException", ParentCommitDoesNotExistException) {};
export class ActorDoesNotExistExceptionError extends Schema.TaggedError<ActorDoesNotExistExceptionError>()("ActorDoesNotExistException", ActorDoesNotExistException) {};
export class ReferenceDoesNotExistExceptionError extends Schema.TaggedError<ReferenceDoesNotExistExceptionError>()("ReferenceDoesNotExistException", ReferenceDoesNotExistException) {};
export class ReactionValueRequiredExceptionError extends Schema.TaggedError<ReactionValueRequiredExceptionError>()("ReactionValueRequiredException", ReactionValueRequiredException) {};
export class FilePathConflictsWithSubmodulePathExceptionError extends Schema.TaggedError<FilePathConflictsWithSubmodulePathExceptionError>()("FilePathConflictsWithSubmodulePathException", FilePathConflictsWithSubmodulePathException) {};
export class InvalidRepositoryTriggerRegionExceptionError extends Schema.TaggedError<InvalidRepositoryTriggerRegionExceptionError>()("InvalidRepositoryTriggerRegionException", InvalidRepositoryTriggerRegionException) {};
export class TagsMapRequiredExceptionError extends Schema.TaggedError<TagsMapRequiredExceptionError>()("TagsMapRequiredException", TagsMapRequiredException) {};
export class MaximumBranchesExceededExceptionError extends Schema.TaggedError<MaximumBranchesExceededExceptionError>()("MaximumBranchesExceededException", MaximumBranchesExceededException) {};
export class FileEntryRequiredExceptionError extends Schema.TaggedError<FileEntryRequiredExceptionError>()("FileEntryRequiredException", FileEntryRequiredException) {};
export class InvalidDeletionParameterExceptionError extends Schema.TaggedError<InvalidDeletionParameterExceptionError>()("InvalidDeletionParameterException", InvalidDeletionParameterException) {};
export class InvalidTargetsExceptionError extends Schema.TaggedError<InvalidTargetsExceptionError>()("InvalidTargetsException", InvalidTargetsException) {};
export class NumberOfRulesExceededExceptionError extends Schema.TaggedError<NumberOfRulesExceededExceptionError>()("NumberOfRulesExceededException", NumberOfRulesExceededException) {};
export class ParentCommitIdOutdatedExceptionError extends Schema.TaggedError<ParentCommitIdOutdatedExceptionError>()("ParentCommitIdOutdatedException", ParentCommitIdOutdatedException) {};
export class InvalidActorArnExceptionError extends Schema.TaggedError<InvalidActorArnExceptionError>()("InvalidActorArnException", InvalidActorArnException) {};
export class ParentCommitIdRequiredExceptionError extends Schema.TaggedError<ParentCommitIdRequiredExceptionError>()("ParentCommitIdRequiredException", ParentCommitIdRequiredException) {};
export class MaximumRepositoryTriggersExceededExceptionError extends Schema.TaggedError<MaximumRepositoryTriggersExceededExceptionError>()("MaximumRepositoryTriggersExceededException", MaximumRepositoryTriggersExceededException) {};
export class RepositoryTriggerBranchNameListRequiredExceptionError extends Schema.TaggedError<RepositoryTriggerBranchNameListRequiredExceptionError>()("RepositoryTriggerBranchNameListRequiredException", RepositoryTriggerBranchNameListRequiredException) {};
export class MaximumFileEntriesExceededExceptionError extends Schema.TaggedError<MaximumFileEntriesExceededExceptionError>()("MaximumFileEntriesExceededException", MaximumFileEntriesExceededException) {};
export class MaximumOpenPullRequestsExceededExceptionError extends Schema.TaggedError<MaximumOpenPullRequestsExceededExceptionError>()("MaximumOpenPullRequestsExceededException", MaximumOpenPullRequestsExceededException) {};
export class InvalidPullRequestEventTypeExceptionError extends Schema.TaggedError<InvalidPullRequestEventTypeExceptionError>()("InvalidPullRequestEventTypeException", InvalidPullRequestEventTypeException) {};
export class SameFileContentExceptionError extends Schema.TaggedError<SameFileContentExceptionError>()("SameFileContentException", SameFileContentException) {};
export class RepositoryTriggerDestinationArnRequiredExceptionError extends Schema.TaggedError<RepositoryTriggerDestinationArnRequiredExceptionError>()("RepositoryTriggerDestinationArnRequiredException", RepositoryTriggerDestinationArnRequiredException) {};
export class RepositoryTriggerEventsListRequiredExceptionError extends Schema.TaggedError<RepositoryTriggerEventsListRequiredExceptionError>()("RepositoryTriggerEventsListRequiredException", RepositoryTriggerEventsListRequiredException) {};
export class NoChangeExceptionError extends Schema.TaggedError<NoChangeExceptionError>()("NoChangeException", NoChangeException) {};
export class MultipleRepositoriesInPullRequestExceptionError extends Schema.TaggedError<MultipleRepositoriesInPullRequestExceptionError>()("MultipleRepositoriesInPullRequestException", MultipleRepositoriesInPullRequestException) {};
export class RepositoryTriggerNameRequiredExceptionError extends Schema.TaggedError<RepositoryTriggerNameRequiredExceptionError>()("RepositoryTriggerNameRequiredException", RepositoryTriggerNameRequiredException) {};
export class RepositoryTriggersListRequiredExceptionError extends Schema.TaggedError<RepositoryTriggersListRequiredExceptionError>()("RepositoryTriggersListRequiredException", RepositoryTriggersListRequiredException) {};
export class PutFileEntryConflictExceptionError extends Schema.TaggedError<PutFileEntryConflictExceptionError>()("PutFileEntryConflictException", PutFileEntryConflictException) {};
export class ReferenceNameRequiredExceptionError extends Schema.TaggedError<ReferenceNameRequiredExceptionError>()("ReferenceNameRequiredException", ReferenceNameRequiredException) {};
export class RestrictedSourceFileExceptionError extends Schema.TaggedError<RestrictedSourceFileExceptionError>()("RestrictedSourceFileException", RestrictedSourceFileException) {};
export class ReferenceTypeNotSupportedExceptionError extends Schema.TaggedError<ReferenceTypeNotSupportedExceptionError>()("ReferenceTypeNotSupportedException", ReferenceTypeNotSupportedException) {};
export class SamePathRequestExceptionError extends Schema.TaggedError<SamePathRequestExceptionError>()("SamePathRequestException", SamePathRequestException) {};
export class SourceAndDestinationAreSameExceptionError extends Schema.TaggedError<SourceAndDestinationAreSameExceptionError>()("SourceAndDestinationAreSameException", SourceAndDestinationAreSameException) {};
export class SourceFileOrContentRequiredExceptionError extends Schema.TaggedError<SourceFileOrContentRequiredExceptionError>()("SourceFileOrContentRequiredException", SourceFileOrContentRequiredException) {};
export class TargetRequiredExceptionError extends Schema.TaggedError<TargetRequiredExceptionError>()("TargetRequiredException", TargetRequiredException) {};
export class TargetsRequiredExceptionError extends Schema.TaggedError<TargetsRequiredExceptionError>()("TargetsRequiredException", TargetsRequiredException) {};

//# Operations
export const getRepositoryTriggers = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetRepositoryTriggers" }, GetRepositoryTriggersInput, GetRepositoryTriggersOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listBranches = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListBranches" }, ListBranchesInput, ListBranchesOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidContinuationTokenExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listRepositoriesForApprovalRuleTemplate = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListRepositoriesForApprovalRuleTemplate" }, ListRepositoriesForApprovalRuleTemplateInput, ListRepositoriesForApprovalRuleTemplateOutput, [ApprovalRuleTemplateDoesNotExistExceptionError, ApprovalRuleTemplateNameRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidApprovalRuleTemplateNameExceptionError, InvalidContinuationTokenExceptionError, InvalidMaxResultsExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateDefaultBranch = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateDefaultBranch" }, UpdateDefaultBranchInput, Schema.Struct({}), [BranchDoesNotExistExceptionError, BranchNameRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidBranchNameExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchGetRepositories = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.BatchGetRepositories" }, BatchGetRepositoriesInput, BatchGetRepositoriesOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidRepositoryNameExceptionError, MaximumRepositoryNamesExceededExceptionError, RepositoryNamesRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteApprovalRuleTemplate = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DeleteApprovalRuleTemplate" }, DeleteApprovalRuleTemplateInput, DeleteApprovalRuleTemplateOutput, [ApprovalRuleTemplateInUseExceptionError, ApprovalRuleTemplateNameRequiredExceptionError, InvalidApprovalRuleTemplateNameExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteRepository = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DeleteRepository" }, DeleteRepositoryInput, DeleteRepositoryOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidRepositoryNameExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const disassociateApprovalRuleTemplateFromRepository = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DisassociateApprovalRuleTemplateFromRepository" }, DisassociateApprovalRuleTemplateFromRepositoryInput, Schema.Struct({}), [ApprovalRuleTemplateDoesNotExistExceptionError, ApprovalRuleTemplateNameRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidApprovalRuleTemplateNameExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getApprovalRuleTemplate = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetApprovalRuleTemplate" }, GetApprovalRuleTemplateInput, GetApprovalRuleTemplateOutput, [ApprovalRuleTemplateDoesNotExistExceptionError, ApprovalRuleTemplateNameRequiredExceptionError, InvalidApprovalRuleTemplateNameExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getBranch = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetBranch" }, GetBranchInput, GetBranchOutput, [BranchDoesNotExistExceptionError, BranchNameRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidBranchNameExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getCommentsForComparedCommit = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetCommentsForComparedCommit" }, GetCommentsForComparedCommitInput, GetCommentsForComparedCommitOutput, [CommitDoesNotExistExceptionError, CommitIdRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidCommitIdExceptionError, InvalidContinuationTokenExceptionError, InvalidMaxResultsExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getCommit = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetCommit" }, GetCommitInput, GetCommitOutput, [CommitIdDoesNotExistExceptionError, CommitIdRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidCommitIdExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getMergeCommit = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetMergeCommit" }, GetMergeCommitInput, GetMergeCommitOutput, [CommitDoesNotExistExceptionError, CommitRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidCommitExceptionError, InvalidConflictDetailLevelExceptionError, InvalidConflictResolutionStrategyExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getRepository = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetRepository" }, GetRepositoryInput, GetRepositoryOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listApprovalRuleTemplates = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListApprovalRuleTemplates" }, ListApprovalRuleTemplatesInput, ListApprovalRuleTemplatesOutput, [InvalidContinuationTokenExceptionError, InvalidMaxResultsExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listAssociatedApprovalRuleTemplatesForRepository = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListAssociatedApprovalRuleTemplatesForRepository" }, ListAssociatedApprovalRuleTemplatesForRepositoryInput, ListAssociatedApprovalRuleTemplatesForRepositoryOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidContinuationTokenExceptionError, InvalidMaxResultsExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListTagsForResource" }, ListTagsForResourceInput, ListTagsForResourceOutput, [InvalidRepositoryNameExceptionError, InvalidResourceArnExceptionError, RepositoryDoesNotExistExceptionError, ResourceArnRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const postCommentReply = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.PostCommentReply" }, PostCommentReplyInput, PostCommentReplyOutput, [ClientRequestTokenRequiredExceptionError, CommentContentRequiredExceptionError, CommentContentSizeLimitExceededExceptionError, CommentDoesNotExistExceptionError, CommentIdRequiredExceptionError, IdempotencyParameterMismatchExceptionError, InvalidClientRequestTokenExceptionError, InvalidCommentIdExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateApprovalRuleTemplateDescription = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateApprovalRuleTemplateDescription" }, UpdateApprovalRuleTemplateDescriptionInput, UpdateApprovalRuleTemplateDescriptionOutput, [ApprovalRuleTemplateDoesNotExistExceptionError, ApprovalRuleTemplateNameRequiredExceptionError, InvalidApprovalRuleTemplateDescriptionExceptionError, InvalidApprovalRuleTemplateNameExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateApprovalRuleTemplateName = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateApprovalRuleTemplateName" }, UpdateApprovalRuleTemplateNameInput, UpdateApprovalRuleTemplateNameOutput, [ApprovalRuleTemplateDoesNotExistExceptionError, ApprovalRuleTemplateNameAlreadyExistsExceptionError, ApprovalRuleTemplateNameRequiredExceptionError, InvalidApprovalRuleTemplateNameExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateRepositoryDescription = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateRepositoryDescription" }, UpdateRepositoryDescriptionInput, Schema.Struct({}), [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidRepositoryDescriptionExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateRepositoryName = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateRepositoryName" }, UpdateRepositoryNameInput, Schema.Struct({}), [InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameExistsExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const associateApprovalRuleTemplateWithRepository = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.AssociateApprovalRuleTemplateWithRepository" }, AssociateApprovalRuleTemplateWithRepositoryInput, Schema.Struct({}), [ApprovalRuleTemplateDoesNotExistExceptionError, ApprovalRuleTemplateNameRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidApprovalRuleTemplateNameExceptionError, InvalidRepositoryNameExceptionError, MaximumRuleTemplatesAssociatedWithRepositoryExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchAssociateApprovalRuleTemplateWithRepositories = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.BatchAssociateApprovalRuleTemplateWithRepositories" }, BatchAssociateApprovalRuleTemplateWithRepositoriesInput, BatchAssociateApprovalRuleTemplateWithRepositoriesOutput, [ApprovalRuleTemplateDoesNotExistExceptionError, ApprovalRuleTemplateNameRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidApprovalRuleTemplateNameExceptionError, MaximumRepositoryNamesExceededExceptionError, RepositoryNamesRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchDisassociateApprovalRuleTemplateFromRepositories = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.BatchDisassociateApprovalRuleTemplateFromRepositories" }, BatchDisassociateApprovalRuleTemplateFromRepositoriesInput, BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput, [ApprovalRuleTemplateDoesNotExistExceptionError, ApprovalRuleTemplateNameRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidApprovalRuleTemplateNameExceptionError, MaximumRepositoryNamesExceededExceptionError, RepositoryNamesRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createBranch = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreateBranch" }, CreateBranchInput, Schema.Struct({}), [BranchNameExistsExceptionError, BranchNameRequiredExceptionError, CommitDoesNotExistExceptionError, CommitIdRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidBranchNameExceptionError, InvalidCommitIdExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteBranch = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DeleteBranch" }, DeleteBranchInput, DeleteBranchOutput, [BranchNameRequiredExceptionError, DefaultBranchCannotBeDeletedExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidBranchNameExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteCommentContent = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DeleteCommentContent" }, DeleteCommentContentInput, DeleteCommentContentOutput, [CommentDeletedExceptionError, CommentDoesNotExistExceptionError, CommentIdRequiredExceptionError, InvalidCommentIdExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getComment = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetComment" }, GetCommentInput, GetCommentOutput, [CommentDeletedExceptionError, CommentDoesNotExistExceptionError, CommentIdRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidCommentIdExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getFolder = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetFolder" }, GetFolderInput, GetFolderOutput, [CommitDoesNotExistExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, FolderDoesNotExistExceptionError, InvalidCommitExceptionError, InvalidPathExceptionError, InvalidRepositoryNameExceptionError, PathRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getPullRequest = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetPullRequest" }, GetPullRequestInput, GetPullRequestOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidPullRequestIdExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getPullRequestApprovalStates = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetPullRequestApprovalStates" }, GetPullRequestApprovalStatesInput, GetPullRequestApprovalStatesOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidPullRequestIdExceptionError, InvalidRevisionIdExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError, RevisionIdRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getPullRequestOverrideState = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetPullRequestOverrideState" }, GetPullRequestOverrideStateInput, GetPullRequestOverrideStateOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidPullRequestIdExceptionError, InvalidRevisionIdExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError, RevisionIdRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listFileCommitHistory = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListFileCommitHistory" }, ListFileCommitHistoryRequest, ListFileCommitHistoryResponse, [CommitDoesNotExistExceptionError, CommitRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidCommitExceptionError, InvalidContinuationTokenExceptionError, InvalidMaxResultsExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, TipsDivergenceExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listPullRequests = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListPullRequests" }, ListPullRequestsInput, ListPullRequestsOutput, [AuthorDoesNotExistExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidAuthorArnExceptionError, InvalidContinuationTokenExceptionError, InvalidMaxResultsExceptionError, InvalidPullRequestStatusExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const mergeBranchesByFastForward = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.MergeBranchesByFastForward" }, MergeBranchesByFastForwardInput, MergeBranchesByFastForwardOutput, [BranchDoesNotExistExceptionError, BranchNameIsTagNameExceptionError, BranchNameRequiredExceptionError, CommitDoesNotExistExceptionError, CommitRequiredExceptionError, ConcurrentReferenceUpdateExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidBranchNameExceptionError, InvalidCommitExceptionError, InvalidRepositoryNameExceptionError, InvalidTargetBranchExceptionError, ManualMergeRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, TipsDivergenceExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateApprovalRuleTemplateContent = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateApprovalRuleTemplateContent" }, UpdateApprovalRuleTemplateContentInput, UpdateApprovalRuleTemplateContentOutput, [ApprovalRuleTemplateContentRequiredExceptionError, ApprovalRuleTemplateDoesNotExistExceptionError, ApprovalRuleTemplateNameRequiredExceptionError, InvalidApprovalRuleTemplateContentExceptionError, InvalidApprovalRuleTemplateNameExceptionError, InvalidRuleContentSha256ExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateComment = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateComment" }, UpdateCommentInput, UpdateCommentOutput, [CommentContentRequiredExceptionError, CommentContentSizeLimitExceededExceptionError, CommentDeletedExceptionError, CommentDoesNotExistExceptionError, CommentIdRequiredExceptionError, CommentNotCreatedByCallerExceptionError, InvalidCommentIdExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updatePullRequestDescription = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdatePullRequestDescription" }, UpdatePullRequestDescriptionInput, UpdatePullRequestDescriptionOutput, [InvalidDescriptionExceptionError, InvalidPullRequestIdExceptionError, PullRequestAlreadyClosedExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updatePullRequestTitle = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdatePullRequestTitle" }, UpdatePullRequestTitleInput, UpdatePullRequestTitleOutput, [InvalidPullRequestIdExceptionError, InvalidTitleExceptionError, PullRequestAlreadyClosedExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError, TitleRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateRepositoryEncryptionKey = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateRepositoryEncryptionKey" }, UpdateRepositoryEncryptionKeyInput, UpdateRepositoryEncryptionKeyOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyInvalidIdExceptionError, EncryptionKeyInvalidUsageExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyRequiredExceptionError, EncryptionKeyUnavailableExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createApprovalRuleTemplate = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreateApprovalRuleTemplate" }, CreateApprovalRuleTemplateInput, CreateApprovalRuleTemplateOutput, [ApprovalRuleTemplateContentRequiredExceptionError, ApprovalRuleTemplateNameAlreadyExistsExceptionError, ApprovalRuleTemplateNameRequiredExceptionError, InvalidApprovalRuleTemplateContentExceptionError, InvalidApprovalRuleTemplateDescriptionExceptionError, InvalidApprovalRuleTemplateNameExceptionError, NumberOfRuleTemplatesExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deletePullRequestApprovalRule = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DeletePullRequestApprovalRule" }, DeletePullRequestApprovalRuleInput, DeletePullRequestApprovalRuleOutput, [ApprovalRuleNameRequiredExceptionError, CannotDeleteApprovalRuleFromTemplateExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidApprovalRuleNameExceptionError, InvalidPullRequestIdExceptionError, PullRequestAlreadyClosedExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeMergeConflicts = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DescribeMergeConflicts" }, DescribeMergeConflictsInput, DescribeMergeConflictsOutput, [CommitDoesNotExistExceptionError, CommitRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, FileDoesNotExistExceptionError, InvalidCommitExceptionError, InvalidConflictDetailLevelExceptionError, InvalidConflictResolutionStrategyExceptionError, InvalidContinuationTokenExceptionError, InvalidMaxMergeHunksExceptionError, InvalidMergeOptionExceptionError, InvalidPathExceptionError, InvalidRepositoryNameExceptionError, MaximumFileContentToLoadExceededExceptionError, MaximumItemsToCompareExceededExceptionError, MergeOptionRequiredExceptionError, PathRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, TipsDivergenceExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const evaluatePullRequestApprovalRules = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.EvaluatePullRequestApprovalRules" }, EvaluatePullRequestApprovalRulesInput, EvaluatePullRequestApprovalRulesOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidPullRequestIdExceptionError, InvalidRevisionIdExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError, RevisionIdRequiredExceptionError, RevisionNotCurrentExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getBlob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetBlob" }, GetBlobInput, GetBlobOutput, [BlobIdDoesNotExistExceptionError, BlobIdRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, FileTooLargeExceptionError, InvalidBlobIdExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getCommentReactions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetCommentReactions" }, GetCommentReactionsInput, GetCommentReactionsOutput, [CommentDeletedExceptionError, CommentDoesNotExistExceptionError, CommentIdRequiredExceptionError, InvalidCommentIdExceptionError, InvalidContinuationTokenExceptionError, InvalidMaxResultsExceptionError, InvalidReactionUserArnExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getCommentsForPullRequest = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetCommentsForPullRequest" }, GetCommentsForPullRequestInput, GetCommentsForPullRequestOutput, [CommitDoesNotExistExceptionError, CommitIdRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidCommitIdExceptionError, InvalidContinuationTokenExceptionError, InvalidMaxResultsExceptionError, InvalidPullRequestIdExceptionError, InvalidRepositoryNameExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, RepositoryNotAssociatedWithPullRequestExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getDifferences = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetDifferences" }, GetDifferencesInput, GetDifferencesOutput, [CommitDoesNotExistExceptionError, CommitRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidCommitExceptionError, InvalidCommitIdExceptionError, InvalidContinuationTokenExceptionError, InvalidMaxResultsExceptionError, InvalidPathExceptionError, InvalidRepositoryNameExceptionError, PathDoesNotExistExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getFile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetFile" }, GetFileInput, GetFileOutput, [CommitDoesNotExistExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, FileDoesNotExistExceptionError, FileTooLargeExceptionError, InvalidCommitExceptionError, InvalidPathExceptionError, InvalidRepositoryNameExceptionError, PathRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getMergeConflicts = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetMergeConflicts" }, GetMergeConflictsInput, GetMergeConflictsOutput, [CommitDoesNotExistExceptionError, CommitRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidCommitExceptionError, InvalidConflictDetailLevelExceptionError, InvalidConflictResolutionStrategyExceptionError, InvalidContinuationTokenExceptionError, InvalidDestinationCommitSpecifierExceptionError, InvalidMaxConflictFilesExceptionError, InvalidMergeOptionExceptionError, InvalidRepositoryNameExceptionError, InvalidSourceCommitSpecifierExceptionError, MaximumFileContentToLoadExceededExceptionError, MaximumItemsToCompareExceededExceptionError, MergeOptionRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, TipsDivergenceExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getMergeOptions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetMergeOptions" }, GetMergeOptionsInput, GetMergeOptionsOutput, [CommitDoesNotExistExceptionError, CommitRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidCommitExceptionError, InvalidConflictDetailLevelExceptionError, InvalidConflictResolutionStrategyExceptionError, InvalidRepositoryNameExceptionError, MaximumFileContentToLoadExceededExceptionError, MaximumItemsToCompareExceededExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, TipsDivergenceExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listRepositories = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListRepositories" }, ListRepositoriesInput, ListRepositoriesOutput, [InvalidContinuationTokenExceptionError, InvalidOrderExceptionError, InvalidSortByExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const mergePullRequestByThreeWay = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.MergePullRequestByThreeWay" }, MergePullRequestByThreeWayInput, MergePullRequestByThreeWayOutput, [CommitMessageLengthExceededExceptionError, ConcurrentReferenceUpdateExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, FileContentSizeLimitExceededExceptionError, FolderContentSizeLimitExceededExceptionError, InvalidCommitIdExceptionError, InvalidConflictDetailLevelExceptionError, InvalidConflictResolutionExceptionError, InvalidConflictResolutionStrategyExceptionError, InvalidEmailExceptionError, InvalidFileModeExceptionError, InvalidPathExceptionError, InvalidPullRequestIdExceptionError, InvalidReplacementContentExceptionError, InvalidReplacementTypeExceptionError, InvalidRepositoryNameExceptionError, ManualMergeRequiredExceptionError, MaximumConflictResolutionEntriesExceededExceptionError, MaximumFileContentToLoadExceededExceptionError, MaximumItemsToCompareExceededExceptionError, MultipleConflictResolutionEntriesExceptionError, NameLengthExceededExceptionError, PathRequiredExceptionError, PullRequestAlreadyClosedExceptionError, PullRequestApprovalRulesNotSatisfiedExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError, ReplacementContentRequiredExceptionError, ReplacementTypeRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, RepositoryNotAssociatedWithPullRequestExceptionError, TipOfSourceReferenceIsDifferentExceptionError, TipsDivergenceExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const overridePullRequestApprovalRules = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.OverridePullRequestApprovalRules" }, OverridePullRequestApprovalRulesInput, Schema.Struct({}), [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidOverrideStatusExceptionError, InvalidPullRequestIdExceptionError, InvalidRevisionIdExceptionError, OverrideAlreadySetExceptionError, OverrideStatusRequiredExceptionError, PullRequestAlreadyClosedExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError, RevisionIdRequiredExceptionError, RevisionNotCurrentExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const postCommentForPullRequest = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.PostCommentForPullRequest" }, PostCommentForPullRequestInput, PostCommentForPullRequestOutput, [BeforeCommitIdAndAfterCommitIdAreSameExceptionError, ClientRequestTokenRequiredExceptionError, CommentContentRequiredExceptionError, CommentContentSizeLimitExceededExceptionError, CommitDoesNotExistExceptionError, CommitIdRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, IdempotencyParameterMismatchExceptionError, InvalidClientRequestTokenExceptionError, InvalidCommitIdExceptionError, InvalidFileLocationExceptionError, InvalidFilePositionExceptionError, InvalidPathExceptionError, InvalidPullRequestIdExceptionError, InvalidRelativeFileVersionEnumExceptionError, InvalidRepositoryNameExceptionError, PathDoesNotExistExceptionError, PathRequiredExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, RepositoryNotAssociatedWithPullRequestExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const untagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UntagResource" }, UntagResourceInput, Schema.Struct({}), [InvalidRepositoryNameExceptionError, InvalidResourceArnExceptionError, InvalidSystemTagUsageExceptionError, InvalidTagKeysListExceptionError, RepositoryDoesNotExistExceptionError, ResourceArnRequiredExceptionError, TagKeysListRequiredExceptionError, TagPolicyExceptionError, TooManyTagsExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updatePullRequestApprovalRuleContent = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdatePullRequestApprovalRuleContent" }, UpdatePullRequestApprovalRuleContentInput, UpdatePullRequestApprovalRuleContentOutput, [ApprovalRuleContentRequiredExceptionError, ApprovalRuleDoesNotExistExceptionError, ApprovalRuleNameRequiredExceptionError, CannotModifyApprovalRuleFromTemplateExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidApprovalRuleContentExceptionError, InvalidApprovalRuleNameExceptionError, InvalidPullRequestIdExceptionError, InvalidRuleContentSha256ExceptionError, PullRequestAlreadyClosedExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updatePullRequestApprovalState = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdatePullRequestApprovalState" }, UpdatePullRequestApprovalStateInput, Schema.Struct({}), [ApprovalStateRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidApprovalStateExceptionError, InvalidPullRequestIdExceptionError, InvalidRevisionIdExceptionError, MaximumNumberOfApprovalsExceededExceptionError, PullRequestAlreadyClosedExceptionError, PullRequestCannotBeApprovedByAuthorExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError, RevisionIdRequiredExceptionError, RevisionNotCurrentExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updatePullRequestStatus = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdatePullRequestStatus" }, UpdatePullRequestStatusInput, UpdatePullRequestStatusOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidPullRequestIdExceptionError, InvalidPullRequestStatusExceptionError, InvalidPullRequestStatusUpdateExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError, PullRequestStatusRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchDescribeMergeConflicts = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.BatchDescribeMergeConflicts" }, BatchDescribeMergeConflictsInput, BatchDescribeMergeConflictsOutput, [CommitDoesNotExistExceptionError, CommitRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidCommitExceptionError, InvalidConflictDetailLevelExceptionError, InvalidConflictResolutionStrategyExceptionError, InvalidContinuationTokenExceptionError, InvalidMaxConflictFilesExceptionError, InvalidMaxMergeHunksExceptionError, InvalidMergeOptionExceptionError, InvalidRepositoryNameExceptionError, MaximumFileContentToLoadExceededExceptionError, MaximumItemsToCompareExceededExceptionError, MergeOptionRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, TipsDivergenceExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const batchGetCommits = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.BatchGetCommits" }, BatchGetCommitsInput, BatchGetCommitsOutput, [CommitIdsLimitExceededExceptionError, CommitIdsListRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidRepositoryNameExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createRepository = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreateRepository" }, CreateRepositoryInput, CreateRepositoryOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyInvalidIdExceptionError, EncryptionKeyInvalidUsageExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidRepositoryDescriptionExceptionError, InvalidRepositoryNameExceptionError, InvalidSystemTagUsageExceptionError, InvalidTagsMapExceptionError, OperationNotAllowedExceptionError, RepositoryLimitExceededExceptionError, RepositoryNameExistsExceptionError, RepositoryNameRequiredExceptionError, TagPolicyExceptionError, TooManyTagsExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createUnreferencedMergeCommit = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreateUnreferencedMergeCommit" }, CreateUnreferencedMergeCommitInput, CreateUnreferencedMergeCommitOutput, [CommitDoesNotExistExceptionError, CommitMessageLengthExceededExceptionError, CommitRequiredExceptionError, ConcurrentReferenceUpdateExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, FileContentSizeLimitExceededExceptionError, FileModeRequiredExceptionError, FolderContentSizeLimitExceededExceptionError, InvalidCommitExceptionError, InvalidConflictDetailLevelExceptionError, InvalidConflictResolutionExceptionError, InvalidConflictResolutionStrategyExceptionError, InvalidEmailExceptionError, InvalidFileModeExceptionError, InvalidMergeOptionExceptionError, InvalidPathExceptionError, InvalidReplacementContentExceptionError, InvalidReplacementTypeExceptionError, InvalidRepositoryNameExceptionError, ManualMergeRequiredExceptionError, MaximumConflictResolutionEntriesExceededExceptionError, MaximumFileContentToLoadExceededExceptionError, MaximumItemsToCompareExceededExceptionError, MergeOptionRequiredExceptionError, MultipleConflictResolutionEntriesExceptionError, NameLengthExceededExceptionError, PathRequiredExceptionError, ReplacementContentRequiredExceptionError, ReplacementTypeRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, TipsDivergenceExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const mergeBranchesBySquash = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.MergeBranchesBySquash" }, MergeBranchesBySquashInput, MergeBranchesBySquashOutput, [BranchDoesNotExistExceptionError, BranchNameIsTagNameExceptionError, BranchNameRequiredExceptionError, CommitDoesNotExistExceptionError, CommitMessageLengthExceededExceptionError, CommitRequiredExceptionError, ConcurrentReferenceUpdateExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, FileContentSizeLimitExceededExceptionError, FileModeRequiredExceptionError, FolderContentSizeLimitExceededExceptionError, InvalidBranchNameExceptionError, InvalidCommitExceptionError, InvalidConflictDetailLevelExceptionError, InvalidConflictResolutionExceptionError, InvalidConflictResolutionStrategyExceptionError, InvalidEmailExceptionError, InvalidFileModeExceptionError, InvalidPathExceptionError, InvalidReplacementContentExceptionError, InvalidReplacementTypeExceptionError, InvalidRepositoryNameExceptionError, InvalidTargetBranchExceptionError, ManualMergeRequiredExceptionError, MaximumConflictResolutionEntriesExceededExceptionError, MaximumFileContentToLoadExceededExceptionError, MaximumItemsToCompareExceededExceptionError, MultipleConflictResolutionEntriesExceptionError, NameLengthExceededExceptionError, PathRequiredExceptionError, ReplacementContentRequiredExceptionError, ReplacementTypeRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, TipsDivergenceExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const mergeBranchesByThreeWay = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.MergeBranchesByThreeWay" }, MergeBranchesByThreeWayInput, MergeBranchesByThreeWayOutput, [BranchDoesNotExistExceptionError, BranchNameIsTagNameExceptionError, BranchNameRequiredExceptionError, CommitDoesNotExistExceptionError, CommitMessageLengthExceededExceptionError, CommitRequiredExceptionError, ConcurrentReferenceUpdateExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, FileContentSizeLimitExceededExceptionError, FileModeRequiredExceptionError, FolderContentSizeLimitExceededExceptionError, InvalidBranchNameExceptionError, InvalidCommitExceptionError, InvalidConflictDetailLevelExceptionError, InvalidConflictResolutionExceptionError, InvalidConflictResolutionStrategyExceptionError, InvalidEmailExceptionError, InvalidFileModeExceptionError, InvalidPathExceptionError, InvalidReplacementContentExceptionError, InvalidReplacementTypeExceptionError, InvalidRepositoryNameExceptionError, InvalidTargetBranchExceptionError, ManualMergeRequiredExceptionError, MaximumConflictResolutionEntriesExceededExceptionError, MaximumFileContentToLoadExceededExceptionError, MaximumItemsToCompareExceededExceptionError, MultipleConflictResolutionEntriesExceptionError, NameLengthExceededExceptionError, PathRequiredExceptionError, ReplacementContentRequiredExceptionError, ReplacementTypeRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, TipsDivergenceExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const mergePullRequestByFastForward = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.MergePullRequestByFastForward" }, MergePullRequestByFastForwardInput, MergePullRequestByFastForwardOutput, [ConcurrentReferenceUpdateExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidCommitIdExceptionError, InvalidPullRequestIdExceptionError, InvalidRepositoryNameExceptionError, ManualMergeRequiredExceptionError, PullRequestAlreadyClosedExceptionError, PullRequestApprovalRulesNotSatisfiedExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError, ReferenceDoesNotExistExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, RepositoryNotAssociatedWithPullRequestExceptionError, TipOfSourceReferenceIsDifferentExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const mergePullRequestBySquash = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.MergePullRequestBySquash" }, MergePullRequestBySquashInput, MergePullRequestBySquashOutput, [CommitMessageLengthExceededExceptionError, ConcurrentReferenceUpdateExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, FileContentSizeLimitExceededExceptionError, FolderContentSizeLimitExceededExceptionError, InvalidCommitIdExceptionError, InvalidConflictDetailLevelExceptionError, InvalidConflictResolutionExceptionError, InvalidConflictResolutionStrategyExceptionError, InvalidEmailExceptionError, InvalidFileModeExceptionError, InvalidPathExceptionError, InvalidPullRequestIdExceptionError, InvalidReplacementContentExceptionError, InvalidReplacementTypeExceptionError, InvalidRepositoryNameExceptionError, ManualMergeRequiredExceptionError, MaximumConflictResolutionEntriesExceededExceptionError, MaximumFileContentToLoadExceededExceptionError, MaximumItemsToCompareExceededExceptionError, MultipleConflictResolutionEntriesExceptionError, NameLengthExceededExceptionError, PathRequiredExceptionError, PullRequestAlreadyClosedExceptionError, PullRequestApprovalRulesNotSatisfiedExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError, ReplacementContentRequiredExceptionError, ReplacementTypeRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, RepositoryNotAssociatedWithPullRequestExceptionError, TipOfSourceReferenceIsDifferentExceptionError, TipsDivergenceExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const postCommentForComparedCommit = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.PostCommentForComparedCommit" }, PostCommentForComparedCommitInput, PostCommentForComparedCommitOutput, [BeforeCommitIdAndAfterCommitIdAreSameExceptionError, ClientRequestTokenRequiredExceptionError, CommentContentRequiredExceptionError, CommentContentSizeLimitExceededExceptionError, CommitDoesNotExistExceptionError, CommitIdRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, IdempotencyParameterMismatchExceptionError, InvalidClientRequestTokenExceptionError, InvalidCommitIdExceptionError, InvalidFileLocationExceptionError, InvalidFilePositionExceptionError, InvalidPathExceptionError, InvalidRelativeFileVersionEnumExceptionError, InvalidRepositoryNameExceptionError, PathDoesNotExistExceptionError, PathRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putCommentReaction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.PutCommentReaction" }, PutCommentReactionInput, Schema.Struct({}), [CommentDeletedExceptionError, CommentDoesNotExistExceptionError, CommentIdRequiredExceptionError, InvalidCommentIdExceptionError, InvalidReactionValueExceptionError, ReactionLimitExceededExceptionError, ReactionValueRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const tagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.TagResource" }, TagResourceInput, Schema.Struct({}), [InvalidRepositoryNameExceptionError, InvalidResourceArnExceptionError, InvalidSystemTagUsageExceptionError, InvalidTagsMapExceptionError, RepositoryDoesNotExistExceptionError, ResourceArnRequiredExceptionError, TagPolicyExceptionError, TagsMapRequiredExceptionError, TooManyTagsExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createPullRequestApprovalRule = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreatePullRequestApprovalRule" }, CreatePullRequestApprovalRuleInput, CreatePullRequestApprovalRuleOutput, [ApprovalRuleContentRequiredExceptionError, ApprovalRuleNameAlreadyExistsExceptionError, ApprovalRuleNameRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidApprovalRuleContentExceptionError, InvalidApprovalRuleNameExceptionError, InvalidPullRequestIdExceptionError, NumberOfRulesExceededExceptionError, PullRequestAlreadyClosedExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteFile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DeleteFile" }, DeleteFileInput, DeleteFileOutput, [BranchDoesNotExistExceptionError, BranchNameIsTagNameExceptionError, BranchNameRequiredExceptionError, CommitMessageLengthExceededExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, FileDoesNotExistExceptionError, InvalidBranchNameExceptionError, InvalidEmailExceptionError, InvalidParentCommitIdExceptionError, InvalidPathExceptionError, InvalidRepositoryNameExceptionError, NameLengthExceededExceptionError, ParentCommitDoesNotExistExceptionError, ParentCommitIdOutdatedExceptionError, ParentCommitIdRequiredExceptionError, PathRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describePullRequestEvents = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DescribePullRequestEvents" }, DescribePullRequestEventsInput, DescribePullRequestEventsOutput, [ActorDoesNotExistExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidActorArnExceptionError, InvalidContinuationTokenExceptionError, InvalidMaxResultsExceptionError, InvalidPullRequestEventTypeExceptionError, InvalidPullRequestIdExceptionError, PullRequestDoesNotExistExceptionError, PullRequestIdRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putFile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.PutFile" }, PutFileInput, PutFileOutput, [BranchDoesNotExistExceptionError, BranchNameIsTagNameExceptionError, BranchNameRequiredExceptionError, CommitMessageLengthExceededExceptionError, DirectoryNameConflictsWithFileNameExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, FileContentRequiredExceptionError, FileContentSizeLimitExceededExceptionError, FileNameConflictsWithDirectoryNameExceptionError, FilePathConflictsWithSubmodulePathExceptionError, FolderContentSizeLimitExceededExceptionError, InvalidBranchNameExceptionError, InvalidDeletionParameterExceptionError, InvalidEmailExceptionError, InvalidFileModeExceptionError, InvalidParentCommitIdExceptionError, InvalidPathExceptionError, InvalidRepositoryNameExceptionError, NameLengthExceededExceptionError, ParentCommitDoesNotExistExceptionError, ParentCommitIdOutdatedExceptionError, ParentCommitIdRequiredExceptionError, PathRequiredExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, SameFileContentExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const testRepositoryTriggers = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.TestRepositoryTriggers" }, TestRepositoryTriggersInput, TestRepositoryTriggersOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidRepositoryNameExceptionError, InvalidRepositoryTriggerBranchNameExceptionError, InvalidRepositoryTriggerCustomDataExceptionError, InvalidRepositoryTriggerDestinationArnExceptionError, InvalidRepositoryTriggerEventsExceptionError, InvalidRepositoryTriggerNameExceptionError, InvalidRepositoryTriggerRegionExceptionError, MaximumBranchesExceededExceptionError, MaximumRepositoryTriggersExceededExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, RepositoryTriggerBranchNameListRequiredExceptionError, RepositoryTriggerDestinationArnRequiredExceptionError, RepositoryTriggerEventsListRequiredExceptionError, RepositoryTriggerNameRequiredExceptionError, RepositoryTriggersListRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putRepositoryTriggers = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.PutRepositoryTriggers" }, PutRepositoryTriggersInput, PutRepositoryTriggersOutput, [EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, InvalidRepositoryNameExceptionError, InvalidRepositoryTriggerBranchNameExceptionError, InvalidRepositoryTriggerCustomDataExceptionError, InvalidRepositoryTriggerDestinationArnExceptionError, InvalidRepositoryTriggerEventsExceptionError, InvalidRepositoryTriggerNameExceptionError, InvalidRepositoryTriggerRegionExceptionError, MaximumBranchesExceededExceptionError, MaximumRepositoryTriggersExceededExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, RepositoryTriggerBranchNameListRequiredExceptionError, RepositoryTriggerDestinationArnRequiredExceptionError, RepositoryTriggerEventsListRequiredExceptionError, RepositoryTriggerNameRequiredExceptionError, RepositoryTriggersListRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createCommit = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreateCommit" }, CreateCommitInput, CreateCommitOutput, [BranchDoesNotExistExceptionError, BranchNameIsTagNameExceptionError, BranchNameRequiredExceptionError, CommitMessageLengthExceededExceptionError, DirectoryNameConflictsWithFileNameExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, FileContentAndSourceFileSpecifiedExceptionError, FileContentSizeLimitExceededExceptionError, FileDoesNotExistExceptionError, FileEntryRequiredExceptionError, FileModeRequiredExceptionError, FileNameConflictsWithDirectoryNameExceptionError, FilePathConflictsWithSubmodulePathExceptionError, FolderContentSizeLimitExceededExceptionError, InvalidBranchNameExceptionError, InvalidDeletionParameterExceptionError, InvalidEmailExceptionError, InvalidFileModeExceptionError, InvalidParentCommitIdExceptionError, InvalidPathExceptionError, InvalidRepositoryNameExceptionError, MaximumFileEntriesExceededExceptionError, NameLengthExceededExceptionError, NoChangeExceptionError, ParentCommitDoesNotExistExceptionError, ParentCommitIdOutdatedExceptionError, ParentCommitIdRequiredExceptionError, PathRequiredExceptionError, PutFileEntryConflictExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, RestrictedSourceFileExceptionError, SamePathRequestExceptionError, SourceFileOrContentRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createPullRequest = /*#__PURE__*/ makeOperation(() => Operation({ version: "2015-04-13", uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreatePullRequest" }, CreatePullRequestInput, CreatePullRequestOutput, [ClientRequestTokenRequiredExceptionError, EncryptionIntegrityChecksFailedExceptionError, EncryptionKeyAccessDeniedExceptionError, EncryptionKeyDisabledExceptionError, EncryptionKeyNotFoundExceptionError, EncryptionKeyUnavailableExceptionError, IdempotencyParameterMismatchExceptionError, InvalidClientRequestTokenExceptionError, InvalidDescriptionExceptionError, InvalidReferenceNameExceptionError, InvalidRepositoryNameExceptionError, InvalidTargetExceptionError, InvalidTargetsExceptionError, InvalidTitleExceptionError, MaximumOpenPullRequestsExceededExceptionError, MultipleRepositoriesInPullRequestExceptionError, ReferenceDoesNotExistExceptionError, ReferenceNameRequiredExceptionError, ReferenceTypeNotSupportedExceptionError, RepositoryDoesNotExistExceptionError, RepositoryNameRequiredExceptionError, SourceAndDestinationAreSameExceptionError, TargetRequiredExceptionError, TargetsRequiredExceptionError, TitleRequiredExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
