import { Schema} from "effect"
import { FormatAwsJSON11Request,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
export const PullRequestTarget = Schema.Struct({repositoryName: Schema.optional(Schema.String), sourceReference: Schema.optional(Schema.String), destinationReference: Schema.optional(Schema.String), destinationCommit: Schema.optional(Schema.String), sourceCommit: Schema.optional(Schema.String), mergeBase: Schema.optional(Schema.String), mergeMetadata: Schema.optional(MergeMetadata)});
export const AuthorDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestTargetList = Schema.Array(PullRequestTarget);
export const BlobMetadata = Schema.Struct({blobId: Schema.optional(Schema.String), path: Schema.optional(Schema.String), mode: Schema.optional(Schema.String)});
export const ResourceArnRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ClientRequestTokenRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReactionValueFormats = Schema.Struct({emoji: Schema.optional(Schema.String), shortCode: Schema.optional(Schema.String), unicode: Schema.optional(Schema.String)});
export const InvalidSystemTagUsageException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidApprovalRuleTemplateDescriptionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleOverriddenEventMetadata = Schema.Struct({revisionId: Schema.optional(Schema.String), overrideStatus: Schema.optional(Schema.String)});
export const ApprovalStateChangedEventMetadata = Schema.Struct({revisionId: Schema.optional(Schema.String), approvalStatus: Schema.optional(Schema.String)});
export const MaximumRuleTemplatesAssociatedWithRepositoryException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumRepositoryNamesExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryNamesRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidConflictResolutionStrategyException = Schema.Struct({message: Schema.optional(Schema.String)});
export const IdempotencyParameterMismatchException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DefaultBranchCannotBeDeletedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreateUnreferencedMergeCommitOutput = Schema.Struct({commitId: Schema.optional(Schema.String), treeId: Schema.optional(Schema.String)});
export const EncryptionKeyInvalidUsageException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CannotDeleteApprovalRuleFromTemplateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidCommentIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const BlobIdRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FolderDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumFileContentToLoadExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidDestinationCommitSpecifierException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestIdRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RevisionIdRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TipsDivergenceExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidAuthorArnException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTargetBranchException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRuleContentSha256Exception = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommentNotCreatedByCallerException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestAlreadyClosedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TitleRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const EncryptionKeyRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileMetadata = Schema.Struct({absolutePath: Schema.optional(Schema.String), blobId: Schema.optional(Schema.String), fileMode: Schema.optional(Schema.String)});
export const InvalidPullRequestStatusUpdateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FilesMetadata = Schema.Array(FileMetadata);
export const NumberOfRuleTemplatesExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommitIdsLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidApprovalRuleNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidMaxMergeHunksException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidParentCommitIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RevisionNotCurrentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidBlobIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidReactionUserArnException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryNotAssociatedWithPullRequestException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PathDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PathRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidSourceCommitSpecifierException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumItemsToCompareExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidSortByException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MultipleConflictResolutionEntriesException = Schema.Struct({message: Schema.optional(Schema.String)});
export const OverrideStatusRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidFilePositionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TooManyTagsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CannotModifyApprovalRuleFromTemplateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestCannotBeApprovedByAuthorException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestStatusRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MergeOptionRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommitIdsListRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const NameLengthExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReplacementContentRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReplacementTypeRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReferenceDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TipOfSourceReferenceIsDifferentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRelativeFileVersionEnumException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReactionValueRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TagsMapRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const NumberOfRulesExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ParentCommitIdRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidPullRequestEventTypeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SameFileContentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryTriggerNameRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryTriggersListRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SourceFileOrContentRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TargetsRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TargetRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SourceAndDestinationAreSameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SamePathRequestException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReferenceTypeNotSupportedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RestrictedSourceFileException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReferenceNameRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PutFileEntryConflictException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryTriggerEventsListRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MultipleRepositoriesInPullRequestException = Schema.Struct({message: Schema.optional(Schema.String)});
export const NoChangeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryTriggerDestinationArnRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryTriggerBranchNameListRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumOpenPullRequestsExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumFileEntriesExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumRepositoryTriggersExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumBranchesExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidDeletionParameterException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidActorArnException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ParentCommitIdOutdatedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTargetsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileEntryRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryTriggerRegionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryTriggerNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FilePathConflictsWithSubmodulePathException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ActorDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ParentCommitDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidApprovalRuleContentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTargetException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileContentAndSourceFileSpecifiedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryTriggerEventsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TagPolicyException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryTriggerDestinationArnException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileNameConflictsWithDirectoryNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ReactionLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidFileLocationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumConflictResolutionEntriesExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestApprovalRulesNotSatisfiedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidReplacementTypeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidReplacementContentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidMergeOptionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const OperationNotAllowedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleNameAlreadyExistsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidReferenceNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidMaxConflictFilesException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MaximumNumberOfApprovalsExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TagKeysListRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryTriggerCustomDataException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTagsMapException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryTriggerBranchNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileContentRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidReactionValueException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidClientRequestTokenException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommentContentSizeLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const OverrideAlreadySetException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidPathException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidFileModeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ManualMergeRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidEmailException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileModeRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidOrderException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileTooLargeException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRevisionIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommitIdRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidApprovalRuleTemplateContentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MergeMetadata = Schema.Struct({isMerged: Schema.optional(Schema.Boolean), mergedBy: Schema.optional(Schema.String), mergeCommitId: Schema.optional(Schema.String), mergeOption: Schema.optional(Schema.String)});
export const ApprovalRuleEventMetadata = Schema.Struct({approvalRuleName: Schema.optional(Schema.String), approvalRuleId: Schema.optional(Schema.String), approvalRuleContent: Schema.optional(Schema.String)});
export const ApprovalRuleTemplateNameAlreadyExistsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestSourceReferenceUpdatedEventMetadata = Schema.Struct({repositoryName: Schema.optional(Schema.String), beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.optional(Schema.String), mergeBase: Schema.optional(Schema.String)});
export const PullRequestStatusChangedEventMetadata = Schema.Struct({pullRequestStatus: Schema.optional(Schema.String)});
export const PullRequestCreatedEventMetadata = Schema.Struct({repositoryName: Schema.optional(Schema.String), sourceCommitId: Schema.optional(Schema.String), destinationCommitId: Schema.optional(Schema.String), mergeBase: Schema.optional(Schema.String)});
export const MergeHunkDetail = Schema.Struct({startLine: Schema.optional(Schema.Number), endLine: Schema.optional(Schema.Number), hunkContent: Schema.optional(Schema.String)});
export const MergeOperations = Schema.Struct({source: Schema.optional(Schema.String), destination: Schema.optional(Schema.String)});
export const IsBinaryFile = Schema.Struct({source: Schema.optional(Schema.Boolean), destination: Schema.optional(Schema.Boolean), base: Schema.optional(Schema.Boolean)});
export const ObjectTypes = Schema.Struct({source: Schema.optional(Schema.String), destination: Schema.optional(Schema.String), base: Schema.optional(Schema.String)});
export const FileModes = Schema.Struct({source: Schema.optional(Schema.String), destination: Schema.optional(Schema.String), base: Schema.optional(Schema.String)});
export const FileSizes = Schema.Struct({source: Schema.optional(Schema.Number), destination: Schema.optional(Schema.Number), base: Schema.optional(Schema.Number)});
export const ReactionCountsMap = Schema.Record({key: Schema.String, value: Schema.Number});
export const InvalidRepositoryDescriptionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const OriginApprovalRuleTemplate = Schema.Struct({approvalRuleTemplateId: Schema.optional(Schema.String), approvalRuleTemplateName: Schema.optional(Schema.String)});
export const UserInfo = Schema.Struct({name: Schema.optional(Schema.String), email: Schema.optional(Schema.String), date: Schema.optional(Schema.String)});
export const RepositoryNameExistsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const EncryptionKeyInvalidIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTitleException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidPullRequestStatusException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidDescriptionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidApprovalStateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleContentRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommentContentRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreateCommitOutput = Schema.Struct({commitId: Schema.optional(Schema.String), treeId: Schema.optional(Schema.String), filesAdded: Schema.optional(FilesMetadata), filesUpdated: Schema.optional(FilesMetadata), filesDeleted: Schema.optional(FilesMetadata)});
export const ApprovalRuleTemplateContentRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTagKeysListException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PutRepositoryTriggersOutput = Schema.Struct({configurationId: Schema.optional(Schema.String)});
export const DirectoryNameConflictsWithFileNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommentIdRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const BeforeCommitIdAndAfterCommitIdAreSameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PostCommentForComparedCommitOutput = Schema.Struct({repositoryName: Schema.optional(Schema.String), beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.optional(Schema.String), beforeBlobId: Schema.optional(Schema.String), afterBlobId: Schema.optional(Schema.String), location: Schema.optional(Location), comment: Schema.optional(Comment)});
export const InvalidOverrideStatusException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidConflictResolutionException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FolderContentSizeLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidCommitIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const FileContentSizeLimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommitMessageLengthExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ConcurrentReferenceUpdateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidMaxResultsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidContinuationTokenException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryNameRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PullRequestMergedStateChangedEventMetadata = Schema.Struct({repositoryName: Schema.optional(Schema.String), destinationReference: Schema.optional(Schema.String), mergeMetadata: Schema.optional(MergeMetadata)});
export const InvalidPullRequestIdException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidConflictDetailLevelException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidCommitException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommitRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommitDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommitIdDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommentDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidBranchNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const BlobIdDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidApprovalRuleTemplateNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const EncryptionKeyUnavailableException = Schema.Struct({message: Schema.optional(Schema.String)});
export const EncryptionKeyNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleNameRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const BranchNameIsTagNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleTemplateInUseException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreateRepositoryOutput = Schema.Struct({repositoryMetadata: Schema.optional(RepositoryMetadata)});
export const CreatePullRequestOutput = Schema.Struct({pullRequest: PullRequest});
export const BranchNameRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const EncryptionKeyDisabledException = Schema.Struct({message: Schema.optional(Schema.String)});
export const RepositoryTriggerExecutionFailureList = Schema.Array(RepositoryTriggerExecutionFailure);
export const RepositoryTriggerExecutionFailure = Schema.Struct({trigger: Schema.optional(Schema.String), failureMessage: Schema.optional(Schema.String)});
export const RepositoryNameIdPairList = Schema.Array(RepositoryNameIdPair);
export const RepositoryNameIdPair = Schema.Struct({repositoryName: Schema.optional(Schema.String), repositoryId: Schema.optional(Schema.String)});
export const RevisionDag = Schema.Array(FileVersion);
export const FileVersion = Schema.Struct({commit: Schema.optional(Commit), blobId: Schema.optional(Schema.String), path: Schema.optional(Schema.String), revisionChildren: Schema.optional(RevisionChildren)});
export const ApprovalList = Schema.Array(Approval);
export const Approval = Schema.Struct({userArn: Schema.optional(Schema.String), approvalState: Schema.optional(Schema.String)});
export const SubModuleList = Schema.Array(SubModule);
export const SubModule = Schema.Struct({commitId: Schema.optional(Schema.String), absolutePath: Schema.optional(Schema.String), relativePath: Schema.optional(Schema.String)});
export const SymbolicLinkList = Schema.Array(SymbolicLink);
export const SymbolicLink = Schema.Struct({blobId: Schema.optional(Schema.String), absolutePath: Schema.optional(Schema.String), relativePath: Schema.optional(Schema.String), fileMode: Schema.optional(Schema.String)});
export const FileList = Schema.Array(File);
export const File = Schema.Struct({blobId: Schema.optional(Schema.String), absolutePath: Schema.optional(Schema.String), relativePath: Schema.optional(Schema.String), fileMode: Schema.optional(Schema.String)});
export const FolderList = Schema.Array(Folder);
export const Folder = Schema.Struct({treeId: Schema.optional(Schema.String), absolutePath: Schema.optional(Schema.String), relativePath: Schema.optional(Schema.String)});
export const CommentsForPullRequestData = Schema.Array(CommentsForPullRequest);
export const CommentsForPullRequest = Schema.Struct({pullRequestId: Schema.optional(Schema.String), repositoryName: Schema.optional(Schema.String), beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.optional(Schema.String), beforeBlobId: Schema.optional(Schema.String), afterBlobId: Schema.optional(Schema.String), location: Schema.optional(Location), comments: Schema.optional(Comments)});
export const CommentsForComparedCommitData = Schema.Array(CommentsForComparedCommit);
export const CommentsForComparedCommit = Schema.Struct({repositoryName: Schema.optional(Schema.String), beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.optional(Schema.String), beforeBlobId: Schema.optional(Schema.String), afterBlobId: Schema.optional(Schema.String), location: Schema.optional(Location), comments: Schema.optional(Comments)});
export const Evaluation = Schema.Struct({approved: Schema.optional(Schema.Boolean), overridden: Schema.optional(Schema.Boolean), approvalRulesSatisfied: Schema.optional(ApprovalRulesSatisfiedList), approvalRulesNotSatisfied: Schema.optional(ApprovalRulesNotSatisfiedList)});
export const BranchInfo = Schema.Struct({branchName: Schema.optional(Schema.String), commitId: Schema.optional(Schema.String)});
export const ApprovalRuleTemplate = Schema.Struct({approvalRuleTemplateId: Schema.optional(Schema.String), approvalRuleTemplateName: Schema.optional(Schema.String), approvalRuleTemplateDescription: Schema.optional(Schema.String), approvalRuleTemplateContent: Schema.optional(Schema.String), ruleContentSha256: Schema.optional(Schema.String), lastModifiedDate: Schema.optional(Schema.Date), creationDate: Schema.optional(Schema.Date), lastModifiedUser: Schema.optional(Schema.String)});
export const BatchGetRepositoriesErrorsList = Schema.Array(BatchGetRepositoriesError);
export const BatchGetRepositoriesError = Schema.Struct({repositoryId: Schema.optional(Schema.String), repositoryName: Schema.optional(Schema.String), errorCode: Schema.optional(Schema.String), errorMessage: Schema.optional(Schema.String)});
export const RepositoryMetadataList = Schema.Array(RepositoryMetadata);
export const RepositoryMetadata = Schema.Struct({accountId: Schema.optional(Schema.String), repositoryId: Schema.optional(Schema.String), repositoryName: Schema.optional(Schema.String), repositoryDescription: Schema.optional(Schema.String), defaultBranch: Schema.optional(Schema.String), lastModifiedDate: Schema.optional(Schema.Date), creationDate: Schema.optional(Schema.Date), cloneUrlHttp: Schema.optional(Schema.String), cloneUrlSsh: Schema.optional(Schema.String), Arn: Schema.optional(Schema.String), kmsKeyId: Schema.optional(Schema.String)});
export const BatchGetCommitsErrorsList = Schema.Array(BatchGetCommitsError);
export const BatchGetCommitsError = Schema.Struct({commitId: Schema.optional(Schema.String), errorCode: Schema.optional(Schema.String), errorMessage: Schema.optional(Schema.String)});
export const BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorsList = Schema.Array(BatchDisassociateApprovalRuleTemplateFromRepositoriesError);
export const BatchDisassociateApprovalRuleTemplateFromRepositoriesError = Schema.Struct({repositoryName: Schema.optional(Schema.String), errorCode: Schema.optional(Schema.String), errorMessage: Schema.optional(Schema.String)});
export const PullRequest = Schema.Struct({pullRequestId: Schema.optional(Schema.String), title: Schema.optional(Schema.String), description: Schema.optional(Schema.String), lastActivityDate: Schema.optional(Schema.Date), creationDate: Schema.optional(Schema.Date), pullRequestStatus: Schema.optional(Schema.String), authorArn: Schema.optional(Schema.String), pullRequestTargets: Schema.optional(PullRequestTargetList), clientRequestToken: Schema.optional(Schema.String), revisionId: Schema.optional(Schema.String), approvalRules: Schema.optional(ApprovalRulesList)});
export const BatchDescribeMergeConflictsErrors = Schema.Array(BatchDescribeMergeConflictsError);
export const BatchDescribeMergeConflictsError = Schema.Struct({filePath: Schema.String, exceptionName: Schema.String, message: Schema.String});
export const Conflicts = Schema.Array(Conflict);
export const Conflict = Schema.Struct({conflictMetadata: Schema.optional(ConflictMetadata), mergeHunks: Schema.optional(MergeHunks)});
export const BatchAssociateApprovalRuleTemplateWithRepositoriesErrorsList = Schema.Array(BatchAssociateApprovalRuleTemplateWithRepositoriesError);
export const BatchAssociateApprovalRuleTemplateWithRepositoriesError = Schema.Struct({repositoryName: Schema.optional(Schema.String), errorCode: Schema.optional(Schema.String), errorMessage: Schema.optional(Schema.String)});
export const RevisionChildren = Schema.Array(Schema.String);
export const ApprovalRulesList = Schema.Array(ApprovalRule);
export const Comments = Schema.Array(Comment);
export const Difference = Schema.Struct({beforeBlob: Schema.optional(BlobMetadata), afterBlob: Schema.optional(BlobMetadata), changeType: Schema.optional(Schema.String)});
export const ReactionUsersList = Schema.Array(Schema.String);
export const DifferenceList = Schema.Array(Difference);
export const ApprovalRulesNotSatisfiedList = Schema.Array(Schema.String);
export const ApprovalRulesSatisfiedList = Schema.Array(Schema.String);
export const CallerReactions = Schema.Array(Schema.String);
export const ReactionForComment = Schema.Struct({reaction: Schema.optional(ReactionValueFormats), reactionUsers: Schema.optional(ReactionUsersList), reactionsFromDeletedUsersCount: Schema.optional(Schema.Number)});
export const ReplaceContentEntries = Schema.Array(ReplaceContentEntry);
export const ReactionsForCommentList = Schema.Array(ReactionForComment);
export const ReplaceContentEntry = Schema.Struct({filePath: Schema.String, replacementType: Schema.String, content: Schema.optional(StreamBody()), fileMode: Schema.optional(Schema.String)});
export const SourceFileSpecifier = Schema.Struct({filePath: Schema.String, isMove: Schema.optional(Schema.Boolean)});
export const MergeHunk = Schema.Struct({isConflict: Schema.optional(Schema.Boolean), source: Schema.optional(MergeHunkDetail), destination: Schema.optional(MergeHunkDetail), base: Schema.optional(MergeHunkDetail)});
export const ParentList = Schema.Array(Schema.String);
export const MergeHunks = Schema.Array(MergeHunk);
export const ConflictMetadata = Schema.Struct({filePath: Schema.optional(Schema.String), fileSizes: Schema.optional(FileSizes), fileModes: Schema.optional(FileModes), objectTypes: Schema.optional(ObjectTypes), numberOfConflicts: Schema.optional(Schema.Number), isBinaryFile: Schema.optional(IsBinaryFile), contentConflict: Schema.optional(Schema.Boolean), fileModeConflict: Schema.optional(Schema.Boolean), objectTypeConflict: Schema.optional(Schema.Boolean), mergeOperations: Schema.optional(MergeOperations)});
export const Comment = Schema.Struct({commentId: Schema.optional(Schema.String), content: Schema.optional(Schema.String), inReplyTo: Schema.optional(Schema.String), creationDate: Schema.optional(Schema.Date), lastModifiedDate: Schema.optional(Schema.Date), authorArn: Schema.optional(Schema.String), deleted: Schema.optional(Schema.Boolean), clientRequestToken: Schema.optional(Schema.String), callerReactions: Schema.optional(CallerReactions), reactionCounts: Schema.optional(ReactionCountsMap)});
export const RepositoryDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRule = Schema.Struct({approvalRuleId: Schema.optional(Schema.String), approvalRuleName: Schema.optional(Schema.String), approvalRuleContent: Schema.optional(Schema.String), ruleContentSha256: Schema.optional(Schema.String), lastModifiedDate: Schema.optional(Schema.Date), creationDate: Schema.optional(Schema.Date), lastModifiedUser: Schema.optional(Schema.String), originApprovalRuleTemplate: Schema.optional(OriginApprovalRuleTemplate)});
export const UpdateRepositoryEncryptionKeyOutput = Schema.Struct({repositoryId: Schema.optional(Schema.String), kmsKeyId: Schema.optional(Schema.String), originalKmsKeyId: Schema.optional(Schema.String)});
export const EncryptionKeyAccessDeniedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdatePullRequestTitleOutput = Schema.Struct({pullRequest: PullRequest});
export const UpdatePullRequestStatusOutput = Schema.Struct({pullRequest: PullRequest});
export const UpdatePullRequestDescriptionOutput = Schema.Struct({pullRequest: PullRequest});
export const ApprovalStateRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdatePullRequestApprovalRuleContentOutput = Schema.Struct({approvalRule: ApprovalRule});
export const Commit = Schema.Struct({commitId: Schema.optional(Schema.String), treeId: Schema.optional(Schema.String), parents: Schema.optional(ParentList), message: Schema.optional(Schema.String), author: Schema.optional(UserInfo), committer: Schema.optional(UserInfo), additionalData: Schema.optional(Schema.String)});
export const BranchDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const CommitObjectsList = Schema.Array(Commit);
export const UpdateCommentOutput = Schema.Struct({comment: Schema.optional(Comment)});
export const UpdateApprovalRuleTemplateNameOutput = Schema.Struct({approvalRuleTemplate: ApprovalRuleTemplate});
export const UpdateApprovalRuleTemplateDescriptionOutput = Schema.Struct({approvalRuleTemplate: ApprovalRuleTemplate});
export const UpdateApprovalRuleTemplateContentOutput = Schema.Struct({approvalRuleTemplate: ApprovalRuleTemplate});
export const InvalidResourceArnException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidRepositoryNameException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PutFileOutput = Schema.Struct({commitId: Schema.String, blobId: Schema.String, treeId: Schema.String});
export const CommentDeletedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PostCommentReplyOutput = Schema.Struct({comment: Schema.optional(Comment)});
export const PullRequestEvent = Schema.Struct({pullRequestId: Schema.optional(Schema.String), eventDate: Schema.optional(Schema.Date), pullRequestEventType: Schema.optional(Schema.String), actorArn: Schema.optional(Schema.String), pullRequestCreatedEventMetadata: Schema.optional(PullRequestCreatedEventMetadata), pullRequestStatusChangedEventMetadata: Schema.optional(PullRequestStatusChangedEventMetadata), pullRequestSourceReferenceUpdatedEventMetadata: Schema.optional(PullRequestSourceReferenceUpdatedEventMetadata), pullRequestMergedStateChangedEventMetadata: Schema.optional(PullRequestMergedStateChangedEventMetadata), approvalRuleEventMetadata: Schema.optional(ApprovalRuleEventMetadata), approvalStateChangedEventMetadata: Schema.optional(ApprovalStateChangedEventMetadata), approvalRuleOverriddenEventMetadata: Schema.optional(ApprovalRuleOverriddenEventMetadata)});
export const PostCommentForPullRequestOutput = Schema.Struct({repositoryName: Schema.optional(Schema.String), pullRequestId: Schema.optional(Schema.String), beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.optional(Schema.String), beforeBlobId: Schema.optional(Schema.String), afterBlobId: Schema.optional(Schema.String), location: Schema.optional(Location), comment: Schema.optional(Comment)});
export const PullRequestEventList = Schema.Array(PullRequestEvent);
export const EncryptionIntegrityChecksFailedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const MergePullRequestByThreeWayOutput = Schema.Struct({pullRequest: Schema.optional(PullRequest)});
export const MergePullRequestBySquashOutput = Schema.Struct({pullRequest: Schema.optional(PullRequest)});
export const MergePullRequestByFastForwardOutput = Schema.Struct({pullRequest: Schema.optional(PullRequest)});
export const MergeBranchesByThreeWayOutput = Schema.Struct({commitId: Schema.optional(Schema.String), treeId: Schema.optional(Schema.String)});
export const MergeBranchesBySquashOutput = Schema.Struct({commitId: Schema.optional(Schema.String), treeId: Schema.optional(Schema.String)});
export const MergeBranchesByFastForwardOutput = Schema.Struct({commitId: Schema.optional(Schema.String), treeId: Schema.optional(Schema.String)});
export const ListTagsForResourceOutput = Schema.Struct({tags: Schema.optional(TagsMap), nextToken: Schema.optional(Schema.String)});
export const ListRepositoriesForApprovalRuleTemplateOutput = Schema.Struct({repositoryNames: Schema.optional(RepositoryNameList), nextToken: Schema.optional(Schema.String)});
export const ListPullRequestsOutput = Schema.Struct({pullRequestIds: PullRequestIdList, nextToken: Schema.optional(Schema.String)});
export const ListBranchesOutput = Schema.Struct({branches: Schema.optional(BranchNameList), nextToken: Schema.optional(Schema.String)});
export const ListAssociatedApprovalRuleTemplatesForRepositoryOutput = Schema.Struct({approvalRuleTemplateNames: Schema.optional(ApprovalRuleTemplateNameList), nextToken: Schema.optional(Schema.String)});
export const ListApprovalRuleTemplatesOutput = Schema.Struct({approvalRuleTemplateNames: Schema.optional(ApprovalRuleTemplateNameList), nextToken: Schema.optional(Schema.String)});
export const TestRepositoryTriggersOutput = Schema.Struct({successfulExecutions: Schema.optional(RepositoryTriggerNameList), failedExecutions: Schema.optional(RepositoryTriggerExecutionFailureList)});
export const GetRepositoryTriggersOutput = Schema.Struct({configurationId: Schema.optional(Schema.String), triggers: Schema.optional(RepositoryTriggersList)});
export const GetRepositoryOutput = Schema.Struct({repositoryMetadata: Schema.optional(RepositoryMetadata)});
export const GetPullRequestOverrideStateOutput = Schema.Struct({overridden: Schema.optional(Schema.Boolean), overrider: Schema.optional(Schema.String)});
export const GetMergeOptionsOutput = Schema.Struct({mergeOptions: MergeOptions, sourceCommitId: Schema.String, destinationCommitId: Schema.String, baseCommitId: Schema.String});
export const GetMergeConflictsOutput = Schema.Struct({mergeable: Schema.Boolean, destinationCommitId: Schema.String, sourceCommitId: Schema.String, baseCommitId: Schema.optional(Schema.String), conflictMetadataList: ConflictMetadataList, nextToken: Schema.optional(Schema.String)});
export const GetMergeCommitOutput = Schema.Struct({sourceCommitId: Schema.optional(Schema.String), destinationCommitId: Schema.optional(Schema.String), baseCommitId: Schema.optional(Schema.String), mergedCommitId: Schema.optional(Schema.String)});
export const GetFileOutput = Schema.Struct({commitId: Schema.String, blobId: Schema.String, filePath: Schema.String, fileMode: Schema.String, fileSize: Schema.Number, fileContent: StreamBody()});
export const GetCommitOutput = Schema.Struct({commit: Commit});
export const GetCommentOutput = Schema.Struct({comment: Schema.optional(Comment)});
export const GetBranchOutput = Schema.Struct({branch: Schema.optional(BranchInfo)});
export const GetBlobOutput = Schema.Struct({content: StreamBody()});
export const GetApprovalRuleTemplateOutput = Schema.Struct({approvalRuleTemplate: ApprovalRuleTemplate});
export const ListRepositoriesOutput = Schema.Struct({repositories: Schema.optional(RepositoryNameIdPairList), nextToken: Schema.optional(Schema.String)});
export const ApprovalRuleTemplateNameRequiredException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ListFileCommitHistoryResponse = Schema.Struct({revisionDag: RevisionDag, nextToken: Schema.optional(Schema.String)});
export const DeleteRepositoryOutput = Schema.Struct({repositoryId: Schema.optional(Schema.String)});
export const DeletePullRequestApprovalRuleOutput = Schema.Struct({approvalRuleId: Schema.String});
export const DeleteFileOutput = Schema.Struct({commitId: Schema.String, blobId: Schema.String, treeId: Schema.String, filePath: Schema.String});
export const GetPullRequestApprovalStatesOutput = Schema.Struct({approvals: Schema.optional(ApprovalList)});
export const DeleteApprovalRuleTemplateOutput = Schema.Struct({approvalRuleTemplateId: Schema.String});
export const BranchNameExistsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ApprovalRuleTemplateDoesNotExistException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GetFolderOutput = Schema.Struct({commitId: Schema.String, folderPath: Schema.String, treeId: Schema.optional(Schema.String), subFolders: Schema.optional(FolderList), files: Schema.optional(FileList), symbolicLinks: Schema.optional(SymbolicLinkList), subModules: Schema.optional(SubModuleList)});
export const RepositoryTriggerNameList = Schema.Array(Schema.String);
export const GetCommentsForComparedCommitOutput = Schema.Struct({commentsForComparedCommitData: Schema.optional(CommentsForComparedCommitData), nextToken: Schema.optional(Schema.String)});
export const GetCommentsForPullRequestOutput = Schema.Struct({commentsForPullRequestData: Schema.optional(CommentsForPullRequestData), nextToken: Schema.optional(Schema.String)});
export const RepositoryTriggersList = Schema.Array(RepositoryTrigger);
export const RepositoryTrigger = Schema.Struct({name: Schema.String, destinationArn: Schema.String, customData: Schema.optional(Schema.String), branches: Schema.optional(BranchNameList), events: RepositoryTriggerEventList});
export const Location = Schema.Struct({filePath: Schema.optional(Schema.String), filePosition: Schema.optional(Schema.Number), relativeFileVersion: Schema.optional(Schema.String)});
export const EvaluatePullRequestApprovalRulesOutput = Schema.Struct({evaluation: Evaluation});
export const PullRequestIdList = Schema.Array(Schema.String);
export const ApprovalRuleTemplateNameList = Schema.Array(Schema.String);
export const MergeOptions = Schema.Array(Schema.String);
export const ConflictMetadataList = Schema.Array(ConflictMetadata);
export const BatchGetRepositoriesOutput = Schema.Struct({repositories: Schema.optional(RepositoryMetadataList), repositoriesNotFound: Schema.optional(RepositoryNotFoundList), errors: Schema.optional(BatchGetRepositoriesErrorsList)});
export const DeleteBranchOutput = Schema.Struct({deletedBranch: Schema.optional(BranchInfo)});
export const CreateApprovalRuleTemplateOutput = Schema.Struct({approvalRuleTemplate: ApprovalRuleTemplate});
export const TagsMap = Schema.Record({key: Schema.String, value: Schema.String});
export const BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput = Schema.Struct({disassociatedRepositoryNames: RepositoryNameList, errors: BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorsList});
export const BatchDescribeMergeConflictsOutput = Schema.Struct({conflicts: Conflicts, nextToken: Schema.optional(Schema.String), errors: Schema.optional(BatchDescribeMergeConflictsErrors), destinationCommitId: Schema.String, sourceCommitId: Schema.String, baseCommitId: Schema.optional(Schema.String)});
export const BatchAssociateApprovalRuleTemplateWithRepositoriesOutput = Schema.Struct({associatedRepositoryNames: RepositoryNameList, errors: BatchAssociateApprovalRuleTemplateWithRepositoriesErrorsList});
export const TargetList = Schema.Array(Target);
export const Target = Schema.Struct({repositoryName: Schema.String, sourceReference: Schema.String, destinationReference: Schema.optional(Schema.String)});
export const GetPullRequestOutput = Schema.Struct({pullRequest: PullRequest});
export const SetFileModeEntries = Schema.Array(SetFileModeEntry);
export const SetFileModeEntry = Schema.Struct({filePath: Schema.String, fileMode: Schema.String});
export const DeleteFileEntries = Schema.Array(DeleteFileEntry);
export const ConflictResolution = Schema.Struct({replaceContents: Schema.optional(ReplaceContentEntries), deleteFiles: Schema.optional(DeleteFileEntries), setFileModes: Schema.optional(SetFileModeEntries)});
export const GetDifferencesOutput = Schema.Struct({differences: Schema.optional(DifferenceList), NextToken: Schema.optional(Schema.String)});
export const DeleteFileEntry = Schema.Struct({filePath: Schema.String});
export const RepositoryNotFoundList = Schema.Array(Schema.String);
export const RepositoryTriggerEventList = Schema.Array(Schema.String);
export const GetCommentReactionsOutput = Schema.Struct({reactionsForComment: ReactionsForCommentList, nextToken: Schema.optional(Schema.String)});
export const BranchNameList = Schema.Array(Schema.String);
export const UpdateRepositoryNameInput = Schema.Struct({oldName: Schema.String, newName: Schema.String});
export const UpdateRepositoryEncryptionKeyInput = Schema.Struct({repositoryName: Schema.String, kmsKeyId: Schema.String});
export const PutFileEntry = Schema.Struct({filePath: Schema.String, fileMode: Schema.optional(Schema.String), fileContent: Schema.optional(StreamBody()), sourceFile: Schema.optional(SourceFileSpecifier)});
export const UpdateRepositoryDescriptionInput = Schema.Struct({repositoryName: Schema.String, repositoryDescription: Schema.optional(Schema.String)});
export const PutFileEntries = Schema.Array(PutFileEntry);
export const DescribeMergeConflictsOutput = Schema.Struct({conflictMetadata: ConflictMetadata, mergeHunks: MergeHunks, nextToken: Schema.optional(Schema.String), destinationCommitId: Schema.String, sourceCommitId: Schema.String, baseCommitId: Schema.optional(Schema.String)});
export const UpdatePullRequestTitleInput = Schema.Struct({pullRequestId: Schema.String, title: Schema.String});
export const UpdatePullRequestStatusInput = Schema.Struct({pullRequestId: Schema.String, pullRequestStatus: Schema.String});
export const DeleteCommentContentOutput = Schema.Struct({comment: Schema.optional(Comment)});
export const UpdatePullRequestDescriptionInput = Schema.Struct({pullRequestId: Schema.String, description: Schema.String});
export const CreatePullRequestApprovalRuleOutput = Schema.Struct({approvalRule: ApprovalRule});
export const UpdatePullRequestApprovalStateInput = Schema.Struct({pullRequestId: Schema.String, revisionId: Schema.String, approvalState: Schema.String});
export const UpdatePullRequestApprovalRuleContentInput = Schema.Struct({pullRequestId: Schema.String, approvalRuleName: Schema.String, existingRuleContentSha256: Schema.optional(Schema.String), newRuleContent: Schema.String});
export const BatchGetCommitsOutput = Schema.Struct({commits: Schema.optional(CommitObjectsList), errors: Schema.optional(BatchGetCommitsErrorsList)});
export const UpdateDefaultBranchInput = Schema.Struct({repositoryName: Schema.String, defaultBranchName: Schema.String});
export const UpdateCommentInput = Schema.Struct({commentId: Schema.String, content: Schema.String});
export const UpdateApprovalRuleTemplateNameInput = Schema.Struct({oldApprovalRuleTemplateName: Schema.String, newApprovalRuleTemplateName: Schema.String});
export const UpdateApprovalRuleTemplateDescriptionInput = Schema.Struct({approvalRuleTemplateName: Schema.String, approvalRuleTemplateDescription: Schema.String});
export const UpdateApprovalRuleTemplateContentInput = Schema.Struct({approvalRuleTemplateName: Schema.String, newRuleContent: Schema.String, existingRuleContentSha256: Schema.optional(Schema.String)});
export const UntagResourceInput = Schema.Struct({resourceArn: Schema.String, tagKeys: TagKeysList});
export const TestRepositoryTriggersInput = Schema.Struct({repositoryName: Schema.String, triggers: RepositoryTriggersList});
export const DescribePullRequestEventsOutput = Schema.Struct({pullRequestEvents: PullRequestEventList, nextToken: Schema.optional(Schema.String)});
export const TagResourceInput = Schema.Struct({resourceArn: Schema.String, tags: TagsMap});
export const PutFileInput = Schema.Struct({repositoryName: Schema.String, branchName: Schema.String, fileContent: StreamBody(), filePath: Schema.String, fileMode: Schema.optional(Schema.String), parentCommitId: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), name: Schema.optional(Schema.String), email: Schema.optional(Schema.String)});
export const PutCommentReactionInput = Schema.Struct({commentId: Schema.String, reactionValue: Schema.String});
export const PostCommentReplyInput = Schema.Struct({inReplyTo: Schema.String, clientRequestToken: Schema.optional(Schema.String), content: Schema.String});
export const PostCommentForPullRequestInput = Schema.Struct({pullRequestId: Schema.String, repositoryName: Schema.String, beforeCommitId: Schema.String, afterCommitId: Schema.String, location: Schema.optional(Location), content: Schema.String, clientRequestToken: Schema.optional(Schema.String)});
export const OverridePullRequestApprovalRulesInput = Schema.Struct({pullRequestId: Schema.String, revisionId: Schema.String, overrideStatus: Schema.String});
export const PutRepositoryTriggersInput = Schema.Struct({repositoryName: Schema.String, triggers: RepositoryTriggersList});
export const MergePullRequestByThreeWayInput = Schema.Struct({pullRequestId: Schema.String, repositoryName: Schema.String, sourceCommitId: Schema.optional(Schema.String), conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), authorName: Schema.optional(Schema.String), email: Schema.optional(Schema.String), keepEmptyFolders: Schema.optional(Schema.Boolean), conflictResolution: Schema.optional(ConflictResolution)});
export const MergePullRequestBySquashInput = Schema.Struct({pullRequestId: Schema.String, repositoryName: Schema.String, sourceCommitId: Schema.optional(Schema.String), conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), authorName: Schema.optional(Schema.String), email: Schema.optional(Schema.String), keepEmptyFolders: Schema.optional(Schema.Boolean), conflictResolution: Schema.optional(ConflictResolution)});
export const MergePullRequestByFastForwardInput = Schema.Struct({pullRequestId: Schema.String, repositoryName: Schema.String, sourceCommitId: Schema.optional(Schema.String)});
export const MergeBranchesByThreeWayInput = Schema.Struct({repositoryName: Schema.String, sourceCommitSpecifier: Schema.String, destinationCommitSpecifier: Schema.String, targetBranch: Schema.optional(Schema.String), conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), authorName: Schema.optional(Schema.String), email: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), keepEmptyFolders: Schema.optional(Schema.Boolean), conflictResolution: Schema.optional(ConflictResolution)});
export const PostCommentForComparedCommitInput = Schema.Struct({repositoryName: Schema.String, beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.String, location: Schema.optional(Location), content: Schema.String, clientRequestToken: Schema.optional(Schema.String)});
export const MergeBranchesBySquashInput = Schema.Struct({repositoryName: Schema.String, sourceCommitSpecifier: Schema.String, destinationCommitSpecifier: Schema.String, targetBranch: Schema.optional(Schema.String), conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), authorName: Schema.optional(Schema.String), email: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), keepEmptyFolders: Schema.optional(Schema.Boolean), conflictResolution: Schema.optional(ConflictResolution)});
export const MergeBranchesByFastForwardInput = Schema.Struct({repositoryName: Schema.String, sourceCommitSpecifier: Schema.String, destinationCommitSpecifier: Schema.String, targetBranch: Schema.optional(Schema.String)});
export const ListTagsForResourceInput = Schema.Struct({resourceArn: Schema.String, nextToken: Schema.optional(Schema.String)});
export const ListRepositoriesForApprovalRuleTemplateInput = Schema.Struct({approvalRuleTemplateName: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListRepositoriesInput = Schema.Struct({nextToken: Schema.optional(Schema.String), sortBy: Schema.optional(Schema.String), order: Schema.optional(Schema.String)});
export const ListPullRequestsInput = Schema.Struct({repositoryName: Schema.String, authorArn: Schema.optional(Schema.String), pullRequestStatus: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListFileCommitHistoryRequest = Schema.Struct({repositoryName: Schema.String, commitSpecifier: Schema.optional(Schema.String), filePath: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListBranchesInput = Schema.Struct({repositoryName: Schema.String, nextToken: Schema.optional(Schema.String)});
export const ListAssociatedApprovalRuleTemplatesForRepositoryInput = Schema.Struct({repositoryName: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListApprovalRuleTemplatesInput = Schema.Struct({nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const GetRepositoryTriggersInput = Schema.Struct({repositoryName: Schema.String});
export const GetRepositoryInput = Schema.Struct({repositoryName: Schema.String});
export const GetPullRequestOverrideStateInput = Schema.Struct({pullRequestId: Schema.String, revisionId: Schema.String});
export const GetPullRequestApprovalStatesInput = Schema.Struct({pullRequestId: Schema.String, revisionId: Schema.String});
export const GetPullRequestInput = Schema.Struct({pullRequestId: Schema.String});
export const GetMergeOptionsInput = Schema.Struct({repositoryName: Schema.String, sourceCommitSpecifier: Schema.String, destinationCommitSpecifier: Schema.String, conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String)});
export const GetMergeConflictsInput = Schema.Struct({repositoryName: Schema.String, destinationCommitSpecifier: Schema.String, sourceCommitSpecifier: Schema.String, mergeOption: Schema.String, conflictDetailLevel: Schema.optional(Schema.String), maxConflictFiles: Schema.optional(Schema.Number), conflictResolutionStrategy: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String)});
export const GetMergeCommitInput = Schema.Struct({repositoryName: Schema.String, sourceCommitSpecifier: Schema.String, destinationCommitSpecifier: Schema.String, conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String)});
export const GetFolderInput = Schema.Struct({repositoryName: Schema.String, commitSpecifier: Schema.optional(Schema.String), folderPath: Schema.String});
export const GetFileInput = Schema.Struct({repositoryName: Schema.String, commitSpecifier: Schema.optional(Schema.String), filePath: Schema.String});
export const GetDifferencesInput = Schema.Struct({repositoryName: Schema.String, beforeCommitSpecifier: Schema.optional(Schema.String), afterCommitSpecifier: Schema.String, beforePath: Schema.optional(Schema.String), afterPath: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)});
export const GetCommitInput = Schema.Struct({repositoryName: Schema.String, commitId: Schema.String});
export const GetCommentsForPullRequestInput = Schema.Struct({pullRequestId: Schema.String, repositoryName: Schema.optional(Schema.String), beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const GetCommentsForComparedCommitInput = Schema.Struct({repositoryName: Schema.String, beforeCommitId: Schema.optional(Schema.String), afterCommitId: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const GetCommentReactionsInput = Schema.Struct({commentId: Schema.String, reactionUserArn: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const GetCommentInput = Schema.Struct({commentId: Schema.String});
export const GetBranchInput = Schema.Struct({repositoryName: Schema.optional(Schema.String), branchName: Schema.optional(Schema.String)});
export const GetBlobInput = Schema.Struct({repositoryName: Schema.String, blobId: Schema.String});
export const GetApprovalRuleTemplateInput = Schema.Struct({approvalRuleTemplateName: Schema.String});
export const EvaluatePullRequestApprovalRulesInput = Schema.Struct({pullRequestId: Schema.String, revisionId: Schema.String});
export const DisassociateApprovalRuleTemplateFromRepositoryInput = Schema.Struct({approvalRuleTemplateName: Schema.String, repositoryName: Schema.String});
export const DescribePullRequestEventsInput = Schema.Struct({pullRequestId: Schema.String, pullRequestEventType: Schema.optional(Schema.String), actorArn: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const DescribeMergeConflictsInput = Schema.Struct({repositoryName: Schema.String, destinationCommitSpecifier: Schema.String, sourceCommitSpecifier: Schema.String, mergeOption: Schema.String, maxMergeHunks: Schema.optional(Schema.Number), filePath: Schema.String, conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String)});
export const DeleteRepositoryInput = Schema.Struct({repositoryName: Schema.String});
export const DeletePullRequestApprovalRuleInput = Schema.Struct({pullRequestId: Schema.String, approvalRuleName: Schema.String});
export const DeleteFileInput = Schema.Struct({repositoryName: Schema.String, branchName: Schema.String, filePath: Schema.String, parentCommitId: Schema.String, keepEmptyFolders: Schema.optional(Schema.Boolean), commitMessage: Schema.optional(Schema.String), name: Schema.optional(Schema.String), email: Schema.optional(Schema.String)});
export const DeleteCommentContentInput = Schema.Struct({commentId: Schema.String});
export const DeleteBranchInput = Schema.Struct({repositoryName: Schema.String, branchName: Schema.String});
export const DeleteApprovalRuleTemplateInput = Schema.Struct({approvalRuleTemplateName: Schema.String});
export const TagKeysList = Schema.Array(Schema.String);
export const CommitIdsInputList = Schema.Array(Schema.String);
export const CreatePullRequestApprovalRuleInput = Schema.Struct({pullRequestId: Schema.String, approvalRuleName: Schema.String, approvalRuleContent: Schema.String});
export const CreateRepositoryInput = Schema.Struct({repositoryName: Schema.String, repositoryDescription: Schema.optional(Schema.String), tags: Schema.optional(TagsMap), kmsKeyId: Schema.optional(Schema.String)});
export const FilePaths = Schema.Array(Schema.String);
export const CreatePullRequestInput = Schema.Struct({title: Schema.String, description: Schema.optional(Schema.String), targets: TargetList, clientRequestToken: Schema.optional(Schema.String)});
export const RepositoryNameList = Schema.Array(Schema.String);
export const CreateBranchInput = Schema.Struct({repositoryName: Schema.String, branchName: Schema.String, commitId: Schema.String});
export const CreateApprovalRuleTemplateInput = Schema.Struct({approvalRuleTemplateName: Schema.String, approvalRuleTemplateContent: Schema.String, approvalRuleTemplateDescription: Schema.optional(Schema.String)});
export const CreateUnreferencedMergeCommitInput = Schema.Struct({repositoryName: Schema.String, sourceCommitSpecifier: Schema.String, destinationCommitSpecifier: Schema.String, mergeOption: Schema.String, conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), authorName: Schema.optional(Schema.String), email: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), keepEmptyFolders: Schema.optional(Schema.Boolean), conflictResolution: Schema.optional(ConflictResolution)});
export const BatchGetRepositoriesInput = Schema.Struct({repositoryNames: RepositoryNameList});
export const BatchGetCommitsInput = Schema.Struct({commitIds: CommitIdsInputList, repositoryName: Schema.String});
export const BatchDisassociateApprovalRuleTemplateFromRepositoriesInput = Schema.Struct({approvalRuleTemplateName: Schema.String, repositoryNames: RepositoryNameList});
export const CreateCommitInput = Schema.Struct({repositoryName: Schema.String, branchName: Schema.String, parentCommitId: Schema.optional(Schema.String), authorName: Schema.optional(Schema.String), email: Schema.optional(Schema.String), commitMessage: Schema.optional(Schema.String), keepEmptyFolders: Schema.optional(Schema.Boolean), putFiles: Schema.optional(PutFileEntries), deleteFiles: Schema.optional(DeleteFileEntries), setFileModes: Schema.optional(SetFileModeEntries)});
export const BatchDescribeMergeConflictsInput = Schema.Struct({repositoryName: Schema.String, destinationCommitSpecifier: Schema.String, sourceCommitSpecifier: Schema.String, mergeOption: Schema.String, maxMergeHunks: Schema.optional(Schema.Number), maxConflictFiles: Schema.optional(Schema.Number), filePaths: Schema.optional(FilePaths), conflictDetailLevel: Schema.optional(Schema.String), conflictResolutionStrategy: Schema.optional(Schema.String), nextToken: Schema.optional(Schema.String)});
export const BatchAssociateApprovalRuleTemplateWithRepositoriesInput = Schema.Struct({approvalRuleTemplateName: Schema.String, repositoryNames: RepositoryNameList});
export const AssociateApprovalRuleTemplateWithRepositoryInput = Schema.Struct({approvalRuleTemplateName: Schema.String, repositoryName: Schema.String});
export const GetRepositoryTriggers = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetRepositoryTriggers" }, GetRepositoryTriggersInput, GetRepositoryTriggersOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListBranches = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListBranches" }, ListBranchesInput, ListBranchesOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListRepositoriesForApprovalRuleTemplate = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListRepositoriesForApprovalRuleTemplate" }, ListRepositoriesForApprovalRuleTemplateInput, ListRepositoriesForApprovalRuleTemplateOutput, Schema.Union(ErrorAnnotation("ApprovalRuleTemplateDoesNotExistException", ApprovalRuleTemplateDoesNotExistException), ErrorAnnotation("ApprovalRuleTemplateNameRequiredException", ApprovalRuleTemplateNameRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidApprovalRuleTemplateNameException", InvalidApprovalRuleTemplateNameException), ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidMaxResultsException", InvalidMaxResultsException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateDefaultBranch = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateDefaultBranch" }, UpdateDefaultBranchInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("BranchDoesNotExistException", BranchDoesNotExistException), ErrorAnnotation("BranchNameRequiredException", BranchNameRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidBranchNameException", InvalidBranchNameException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const BatchGetRepositories = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.BatchGetRepositories" }, BatchGetRepositoriesInput, BatchGetRepositoriesOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("MaximumRepositoryNamesExceededException", MaximumRepositoryNamesExceededException), ErrorAnnotation("RepositoryNamesRequiredException", RepositoryNamesRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteApprovalRuleTemplate = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DeleteApprovalRuleTemplate" }, DeleteApprovalRuleTemplateInput, DeleteApprovalRuleTemplateOutput, Schema.Union(ErrorAnnotation("ApprovalRuleTemplateInUseException", ApprovalRuleTemplateInUseException), ErrorAnnotation("ApprovalRuleTemplateNameRequiredException", ApprovalRuleTemplateNameRequiredException), ErrorAnnotation("InvalidApprovalRuleTemplateNameException", InvalidApprovalRuleTemplateNameException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteRepository = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DeleteRepository" }, DeleteRepositoryInput, DeleteRepositoryOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DisassociateApprovalRuleTemplateFromRepository = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DisassociateApprovalRuleTemplateFromRepository" }, DisassociateApprovalRuleTemplateFromRepositoryInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("ApprovalRuleTemplateDoesNotExistException", ApprovalRuleTemplateDoesNotExistException), ErrorAnnotation("ApprovalRuleTemplateNameRequiredException", ApprovalRuleTemplateNameRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidApprovalRuleTemplateNameException", InvalidApprovalRuleTemplateNameException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetApprovalRuleTemplate = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetApprovalRuleTemplate" }, GetApprovalRuleTemplateInput, GetApprovalRuleTemplateOutput, Schema.Union(ErrorAnnotation("ApprovalRuleTemplateDoesNotExistException", ApprovalRuleTemplateDoesNotExistException), ErrorAnnotation("ApprovalRuleTemplateNameRequiredException", ApprovalRuleTemplateNameRequiredException), ErrorAnnotation("InvalidApprovalRuleTemplateNameException", InvalidApprovalRuleTemplateNameException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetBranch = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetBranch" }, GetBranchInput, GetBranchOutput, Schema.Union(ErrorAnnotation("BranchDoesNotExistException", BranchDoesNotExistException), ErrorAnnotation("BranchNameRequiredException", BranchNameRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidBranchNameException", InvalidBranchNameException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetCommentsForComparedCommit = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetCommentsForComparedCommit" }, GetCommentsForComparedCommitInput, GetCommentsForComparedCommitOutput, Schema.Union(ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitIdRequiredException", CommitIdRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidCommitIdException", InvalidCommitIdException), ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidMaxResultsException", InvalidMaxResultsException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetCommit = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetCommit" }, GetCommitInput, GetCommitOutput, Schema.Union(ErrorAnnotation("CommitIdDoesNotExistException", CommitIdDoesNotExistException), ErrorAnnotation("CommitIdRequiredException", CommitIdRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidCommitIdException", InvalidCommitIdException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetMergeCommit = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetMergeCommit" }, GetMergeCommitInput, GetMergeCommitOutput, Schema.Union(ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitRequiredException", CommitRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidCommitException", InvalidCommitException), ErrorAnnotation("InvalidConflictDetailLevelException", InvalidConflictDetailLevelException), ErrorAnnotation("InvalidConflictResolutionStrategyException", InvalidConflictResolutionStrategyException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetRepository = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetRepository" }, GetRepositoryInput, GetRepositoryOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListApprovalRuleTemplates = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListApprovalRuleTemplates" }, ListApprovalRuleTemplatesInput, ListApprovalRuleTemplatesOutput, Schema.Union(ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidMaxResultsException", InvalidMaxResultsException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListAssociatedApprovalRuleTemplatesForRepository = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListAssociatedApprovalRuleTemplatesForRepository" }, ListAssociatedApprovalRuleTemplatesForRepositoryInput, ListAssociatedApprovalRuleTemplatesForRepositoryOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidMaxResultsException", InvalidMaxResultsException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListTagsForResource" }, ListTagsForResourceInput, ListTagsForResourceOutput, Schema.Union(ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("InvalidResourceArnException", InvalidResourceArnException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("ResourceArnRequiredException", ResourceArnRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PostCommentReply = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.PostCommentReply" }, PostCommentReplyInput, PostCommentReplyOutput, Schema.Union(ErrorAnnotation("ClientRequestTokenRequiredException", ClientRequestTokenRequiredException), ErrorAnnotation("CommentContentRequiredException", CommentContentRequiredException), ErrorAnnotation("CommentContentSizeLimitExceededException", CommentContentSizeLimitExceededException), ErrorAnnotation("CommentDoesNotExistException", CommentDoesNotExistException), ErrorAnnotation("CommentIdRequiredException", CommentIdRequiredException), ErrorAnnotation("IdempotencyParameterMismatchException", IdempotencyParameterMismatchException), ErrorAnnotation("InvalidClientRequestTokenException", InvalidClientRequestTokenException), ErrorAnnotation("InvalidCommentIdException", InvalidCommentIdException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateApprovalRuleTemplateDescription = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateApprovalRuleTemplateDescription" }, UpdateApprovalRuleTemplateDescriptionInput, UpdateApprovalRuleTemplateDescriptionOutput, Schema.Union(ErrorAnnotation("ApprovalRuleTemplateDoesNotExistException", ApprovalRuleTemplateDoesNotExistException), ErrorAnnotation("ApprovalRuleTemplateNameRequiredException", ApprovalRuleTemplateNameRequiredException), ErrorAnnotation("InvalidApprovalRuleTemplateDescriptionException", InvalidApprovalRuleTemplateDescriptionException), ErrorAnnotation("InvalidApprovalRuleTemplateNameException", InvalidApprovalRuleTemplateNameException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateApprovalRuleTemplateName = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateApprovalRuleTemplateName" }, UpdateApprovalRuleTemplateNameInput, UpdateApprovalRuleTemplateNameOutput, Schema.Union(ErrorAnnotation("ApprovalRuleTemplateDoesNotExistException", ApprovalRuleTemplateDoesNotExistException), ErrorAnnotation("ApprovalRuleTemplateNameAlreadyExistsException", ApprovalRuleTemplateNameAlreadyExistsException), ErrorAnnotation("ApprovalRuleTemplateNameRequiredException", ApprovalRuleTemplateNameRequiredException), ErrorAnnotation("InvalidApprovalRuleTemplateNameException", InvalidApprovalRuleTemplateNameException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateRepositoryDescription = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateRepositoryDescription" }, UpdateRepositoryDescriptionInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidRepositoryDescriptionException", InvalidRepositoryDescriptionException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateRepositoryName = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateRepositoryName" }, UpdateRepositoryNameInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameExistsException", RepositoryNameExistsException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const AssociateApprovalRuleTemplateWithRepository = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.AssociateApprovalRuleTemplateWithRepository" }, AssociateApprovalRuleTemplateWithRepositoryInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("ApprovalRuleTemplateDoesNotExistException", ApprovalRuleTemplateDoesNotExistException), ErrorAnnotation("ApprovalRuleTemplateNameRequiredException", ApprovalRuleTemplateNameRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidApprovalRuleTemplateNameException", InvalidApprovalRuleTemplateNameException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("MaximumRuleTemplatesAssociatedWithRepositoryException", MaximumRuleTemplatesAssociatedWithRepositoryException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const BatchAssociateApprovalRuleTemplateWithRepositories = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.BatchAssociateApprovalRuleTemplateWithRepositories" }, BatchAssociateApprovalRuleTemplateWithRepositoriesInput, BatchAssociateApprovalRuleTemplateWithRepositoriesOutput, Schema.Union(ErrorAnnotation("ApprovalRuleTemplateDoesNotExistException", ApprovalRuleTemplateDoesNotExistException), ErrorAnnotation("ApprovalRuleTemplateNameRequiredException", ApprovalRuleTemplateNameRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidApprovalRuleTemplateNameException", InvalidApprovalRuleTemplateNameException), ErrorAnnotation("MaximumRepositoryNamesExceededException", MaximumRepositoryNamesExceededException), ErrorAnnotation("RepositoryNamesRequiredException", RepositoryNamesRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const BatchDisassociateApprovalRuleTemplateFromRepositories = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.BatchDisassociateApprovalRuleTemplateFromRepositories" }, BatchDisassociateApprovalRuleTemplateFromRepositoriesInput, BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput, Schema.Union(ErrorAnnotation("ApprovalRuleTemplateDoesNotExistException", ApprovalRuleTemplateDoesNotExistException), ErrorAnnotation("ApprovalRuleTemplateNameRequiredException", ApprovalRuleTemplateNameRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidApprovalRuleTemplateNameException", InvalidApprovalRuleTemplateNameException), ErrorAnnotation("MaximumRepositoryNamesExceededException", MaximumRepositoryNamesExceededException), ErrorAnnotation("RepositoryNamesRequiredException", RepositoryNamesRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateBranch = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreateBranch" }, CreateBranchInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("BranchNameExistsException", BranchNameExistsException), ErrorAnnotation("BranchNameRequiredException", BranchNameRequiredException), ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitIdRequiredException", CommitIdRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidBranchNameException", InvalidBranchNameException), ErrorAnnotation("InvalidCommitIdException", InvalidCommitIdException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteBranch = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DeleteBranch" }, DeleteBranchInput, DeleteBranchOutput, Schema.Union(ErrorAnnotation("BranchNameRequiredException", BranchNameRequiredException), ErrorAnnotation("DefaultBranchCannotBeDeletedException", DefaultBranchCannotBeDeletedException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidBranchNameException", InvalidBranchNameException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteCommentContent = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DeleteCommentContent" }, DeleteCommentContentInput, DeleteCommentContentOutput, Schema.Union(ErrorAnnotation("CommentDeletedException", CommentDeletedException), ErrorAnnotation("CommentDoesNotExistException", CommentDoesNotExistException), ErrorAnnotation("CommentIdRequiredException", CommentIdRequiredException), ErrorAnnotation("InvalidCommentIdException", InvalidCommentIdException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetComment = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetComment" }, GetCommentInput, GetCommentOutput, Schema.Union(ErrorAnnotation("CommentDeletedException", CommentDeletedException), ErrorAnnotation("CommentDoesNotExistException", CommentDoesNotExistException), ErrorAnnotation("CommentIdRequiredException", CommentIdRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidCommentIdException", InvalidCommentIdException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetFolder = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetFolder" }, GetFolderInput, GetFolderOutput, Schema.Union(ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("FolderDoesNotExistException", FolderDoesNotExistException), ErrorAnnotation("InvalidCommitException", InvalidCommitException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("PathRequiredException", PathRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetPullRequest = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetPullRequest" }, GetPullRequestInput, GetPullRequestOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetPullRequestApprovalStates = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetPullRequestApprovalStates" }, GetPullRequestApprovalStatesInput, GetPullRequestApprovalStatesOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("InvalidRevisionIdException", InvalidRevisionIdException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException), ErrorAnnotation("RevisionIdRequiredException", RevisionIdRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetPullRequestOverrideState = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetPullRequestOverrideState" }, GetPullRequestOverrideStateInput, GetPullRequestOverrideStateOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("InvalidRevisionIdException", InvalidRevisionIdException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException), ErrorAnnotation("RevisionIdRequiredException", RevisionIdRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListFileCommitHistory = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListFileCommitHistory" }, ListFileCommitHistoryRequest, ListFileCommitHistoryResponse, Schema.Union(ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitRequiredException", CommitRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidCommitException", InvalidCommitException), ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidMaxResultsException", InvalidMaxResultsException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("TipsDivergenceExceededException", TipsDivergenceExceededException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListPullRequests = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListPullRequests" }, ListPullRequestsInput, ListPullRequestsOutput, Schema.Union(ErrorAnnotation("AuthorDoesNotExistException", AuthorDoesNotExistException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidAuthorArnException", InvalidAuthorArnException), ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidMaxResultsException", InvalidMaxResultsException), ErrorAnnotation("InvalidPullRequestStatusException", InvalidPullRequestStatusException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const MergeBranchesByFastForward = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.MergeBranchesByFastForward" }, MergeBranchesByFastForwardInput, MergeBranchesByFastForwardOutput, Schema.Union(ErrorAnnotation("BranchDoesNotExistException", BranchDoesNotExistException), ErrorAnnotation("BranchNameIsTagNameException", BranchNameIsTagNameException), ErrorAnnotation("BranchNameRequiredException", BranchNameRequiredException), ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitRequiredException", CommitRequiredException), ErrorAnnotation("ConcurrentReferenceUpdateException", ConcurrentReferenceUpdateException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidBranchNameException", InvalidBranchNameException), ErrorAnnotation("InvalidCommitException", InvalidCommitException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("InvalidTargetBranchException", InvalidTargetBranchException), ErrorAnnotation("ManualMergeRequiredException", ManualMergeRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("TipsDivergenceExceededException", TipsDivergenceExceededException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateApprovalRuleTemplateContent = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateApprovalRuleTemplateContent" }, UpdateApprovalRuleTemplateContentInput, UpdateApprovalRuleTemplateContentOutput, Schema.Union(ErrorAnnotation("ApprovalRuleTemplateContentRequiredException", ApprovalRuleTemplateContentRequiredException), ErrorAnnotation("ApprovalRuleTemplateDoesNotExistException", ApprovalRuleTemplateDoesNotExistException), ErrorAnnotation("ApprovalRuleTemplateNameRequiredException", ApprovalRuleTemplateNameRequiredException), ErrorAnnotation("InvalidApprovalRuleTemplateContentException", InvalidApprovalRuleTemplateContentException), ErrorAnnotation("InvalidApprovalRuleTemplateNameException", InvalidApprovalRuleTemplateNameException), ErrorAnnotation("InvalidRuleContentSha256Exception", InvalidRuleContentSha256Exception))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateComment = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateComment" }, UpdateCommentInput, UpdateCommentOutput, Schema.Union(ErrorAnnotation("CommentContentRequiredException", CommentContentRequiredException), ErrorAnnotation("CommentContentSizeLimitExceededException", CommentContentSizeLimitExceededException), ErrorAnnotation("CommentDeletedException", CommentDeletedException), ErrorAnnotation("CommentDoesNotExistException", CommentDoesNotExistException), ErrorAnnotation("CommentIdRequiredException", CommentIdRequiredException), ErrorAnnotation("CommentNotCreatedByCallerException", CommentNotCreatedByCallerException), ErrorAnnotation("InvalidCommentIdException", InvalidCommentIdException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdatePullRequestDescription = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdatePullRequestDescription" }, UpdatePullRequestDescriptionInput, UpdatePullRequestDescriptionOutput, Schema.Union(ErrorAnnotation("InvalidDescriptionException", InvalidDescriptionException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("PullRequestAlreadyClosedException", PullRequestAlreadyClosedException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdatePullRequestTitle = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdatePullRequestTitle" }, UpdatePullRequestTitleInput, UpdatePullRequestTitleOutput, Schema.Union(ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("InvalidTitleException", InvalidTitleException), ErrorAnnotation("PullRequestAlreadyClosedException", PullRequestAlreadyClosedException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException), ErrorAnnotation("TitleRequiredException", TitleRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateRepositoryEncryptionKey = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdateRepositoryEncryptionKey" }, UpdateRepositoryEncryptionKeyInput, UpdateRepositoryEncryptionKeyOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyInvalidIdException", EncryptionKeyInvalidIdException), ErrorAnnotation("EncryptionKeyInvalidUsageException", EncryptionKeyInvalidUsageException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyRequiredException", EncryptionKeyRequiredException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateApprovalRuleTemplate = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreateApprovalRuleTemplate" }, CreateApprovalRuleTemplateInput, CreateApprovalRuleTemplateOutput, Schema.Union(ErrorAnnotation("ApprovalRuleTemplateContentRequiredException", ApprovalRuleTemplateContentRequiredException), ErrorAnnotation("ApprovalRuleTemplateNameAlreadyExistsException", ApprovalRuleTemplateNameAlreadyExistsException), ErrorAnnotation("ApprovalRuleTemplateNameRequiredException", ApprovalRuleTemplateNameRequiredException), ErrorAnnotation("InvalidApprovalRuleTemplateContentException", InvalidApprovalRuleTemplateContentException), ErrorAnnotation("InvalidApprovalRuleTemplateDescriptionException", InvalidApprovalRuleTemplateDescriptionException), ErrorAnnotation("InvalidApprovalRuleTemplateNameException", InvalidApprovalRuleTemplateNameException), ErrorAnnotation("NumberOfRuleTemplatesExceededException", NumberOfRuleTemplatesExceededException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeletePullRequestApprovalRule = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DeletePullRequestApprovalRule" }, DeletePullRequestApprovalRuleInput, DeletePullRequestApprovalRuleOutput, Schema.Union(ErrorAnnotation("ApprovalRuleNameRequiredException", ApprovalRuleNameRequiredException), ErrorAnnotation("CannotDeleteApprovalRuleFromTemplateException", CannotDeleteApprovalRuleFromTemplateException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidApprovalRuleNameException", InvalidApprovalRuleNameException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("PullRequestAlreadyClosedException", PullRequestAlreadyClosedException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeMergeConflicts = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DescribeMergeConflicts" }, DescribeMergeConflictsInput, DescribeMergeConflictsOutput, Schema.Union(ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitRequiredException", CommitRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("FileDoesNotExistException", FileDoesNotExistException), ErrorAnnotation("InvalidCommitException", InvalidCommitException), ErrorAnnotation("InvalidConflictDetailLevelException", InvalidConflictDetailLevelException), ErrorAnnotation("InvalidConflictResolutionStrategyException", InvalidConflictResolutionStrategyException), ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidMaxMergeHunksException", InvalidMaxMergeHunksException), ErrorAnnotation("InvalidMergeOptionException", InvalidMergeOptionException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("MaximumFileContentToLoadExceededException", MaximumFileContentToLoadExceededException), ErrorAnnotation("MaximumItemsToCompareExceededException", MaximumItemsToCompareExceededException), ErrorAnnotation("MergeOptionRequiredException", MergeOptionRequiredException), ErrorAnnotation("PathRequiredException", PathRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("TipsDivergenceExceededException", TipsDivergenceExceededException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const EvaluatePullRequestApprovalRules = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.EvaluatePullRequestApprovalRules" }, EvaluatePullRequestApprovalRulesInput, EvaluatePullRequestApprovalRulesOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("InvalidRevisionIdException", InvalidRevisionIdException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException), ErrorAnnotation("RevisionIdRequiredException", RevisionIdRequiredException), ErrorAnnotation("RevisionNotCurrentException", RevisionNotCurrentException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetBlob = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetBlob" }, GetBlobInput, GetBlobOutput, Schema.Union(ErrorAnnotation("BlobIdDoesNotExistException", BlobIdDoesNotExistException), ErrorAnnotation("BlobIdRequiredException", BlobIdRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("FileTooLargeException", FileTooLargeException), ErrorAnnotation("InvalidBlobIdException", InvalidBlobIdException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetCommentReactions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetCommentReactions" }, GetCommentReactionsInput, GetCommentReactionsOutput, Schema.Union(ErrorAnnotation("CommentDeletedException", CommentDeletedException), ErrorAnnotation("CommentDoesNotExistException", CommentDoesNotExistException), ErrorAnnotation("CommentIdRequiredException", CommentIdRequiredException), ErrorAnnotation("InvalidCommentIdException", InvalidCommentIdException), ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidMaxResultsException", InvalidMaxResultsException), ErrorAnnotation("InvalidReactionUserArnException", InvalidReactionUserArnException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetCommentsForPullRequest = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetCommentsForPullRequest" }, GetCommentsForPullRequestInput, GetCommentsForPullRequestOutput, Schema.Union(ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitIdRequiredException", CommitIdRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidCommitIdException", InvalidCommitIdException), ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidMaxResultsException", InvalidMaxResultsException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("RepositoryNotAssociatedWithPullRequestException", RepositoryNotAssociatedWithPullRequestException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetDifferences = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetDifferences" }, GetDifferencesInput, GetDifferencesOutput, Schema.Union(ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitRequiredException", CommitRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidCommitException", InvalidCommitException), ErrorAnnotation("InvalidCommitIdException", InvalidCommitIdException), ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidMaxResultsException", InvalidMaxResultsException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("PathDoesNotExistException", PathDoesNotExistException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetFile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetFile" }, GetFileInput, GetFileOutput, Schema.Union(ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("FileDoesNotExistException", FileDoesNotExistException), ErrorAnnotation("FileTooLargeException", FileTooLargeException), ErrorAnnotation("InvalidCommitException", InvalidCommitException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("PathRequiredException", PathRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetMergeConflicts = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetMergeConflicts" }, GetMergeConflictsInput, GetMergeConflictsOutput, Schema.Union(ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitRequiredException", CommitRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidCommitException", InvalidCommitException), ErrorAnnotation("InvalidConflictDetailLevelException", InvalidConflictDetailLevelException), ErrorAnnotation("InvalidConflictResolutionStrategyException", InvalidConflictResolutionStrategyException), ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidDestinationCommitSpecifierException", InvalidDestinationCommitSpecifierException), ErrorAnnotation("InvalidMaxConflictFilesException", InvalidMaxConflictFilesException), ErrorAnnotation("InvalidMergeOptionException", InvalidMergeOptionException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("InvalidSourceCommitSpecifierException", InvalidSourceCommitSpecifierException), ErrorAnnotation("MaximumFileContentToLoadExceededException", MaximumFileContentToLoadExceededException), ErrorAnnotation("MaximumItemsToCompareExceededException", MaximumItemsToCompareExceededException), ErrorAnnotation("MergeOptionRequiredException", MergeOptionRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("TipsDivergenceExceededException", TipsDivergenceExceededException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetMergeOptions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.GetMergeOptions" }, GetMergeOptionsInput, GetMergeOptionsOutput, Schema.Union(ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitRequiredException", CommitRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidCommitException", InvalidCommitException), ErrorAnnotation("InvalidConflictDetailLevelException", InvalidConflictDetailLevelException), ErrorAnnotation("InvalidConflictResolutionStrategyException", InvalidConflictResolutionStrategyException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("MaximumFileContentToLoadExceededException", MaximumFileContentToLoadExceededException), ErrorAnnotation("MaximumItemsToCompareExceededException", MaximumItemsToCompareExceededException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("TipsDivergenceExceededException", TipsDivergenceExceededException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListRepositories = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.ListRepositories" }, ListRepositoriesInput, ListRepositoriesOutput, Schema.Union(ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidOrderException", InvalidOrderException), ErrorAnnotation("InvalidSortByException", InvalidSortByException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const MergePullRequestByThreeWay = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.MergePullRequestByThreeWay" }, MergePullRequestByThreeWayInput, MergePullRequestByThreeWayOutput, Schema.Union(ErrorAnnotation("CommitMessageLengthExceededException", CommitMessageLengthExceededException), ErrorAnnotation("ConcurrentReferenceUpdateException", ConcurrentReferenceUpdateException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("FileContentSizeLimitExceededException", FileContentSizeLimitExceededException), ErrorAnnotation("FolderContentSizeLimitExceededException", FolderContentSizeLimitExceededException), ErrorAnnotation("InvalidCommitIdException", InvalidCommitIdException), ErrorAnnotation("InvalidConflictDetailLevelException", InvalidConflictDetailLevelException), ErrorAnnotation("InvalidConflictResolutionException", InvalidConflictResolutionException), ErrorAnnotation("InvalidConflictResolutionStrategyException", InvalidConflictResolutionStrategyException), ErrorAnnotation("InvalidEmailException", InvalidEmailException), ErrorAnnotation("InvalidFileModeException", InvalidFileModeException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("InvalidReplacementContentException", InvalidReplacementContentException), ErrorAnnotation("InvalidReplacementTypeException", InvalidReplacementTypeException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("ManualMergeRequiredException", ManualMergeRequiredException), ErrorAnnotation("MaximumConflictResolutionEntriesExceededException", MaximumConflictResolutionEntriesExceededException), ErrorAnnotation("MaximumFileContentToLoadExceededException", MaximumFileContentToLoadExceededException), ErrorAnnotation("MaximumItemsToCompareExceededException", MaximumItemsToCompareExceededException), ErrorAnnotation("MultipleConflictResolutionEntriesException", MultipleConflictResolutionEntriesException), ErrorAnnotation("NameLengthExceededException", NameLengthExceededException), ErrorAnnotation("PathRequiredException", PathRequiredException), ErrorAnnotation("PullRequestAlreadyClosedException", PullRequestAlreadyClosedException), ErrorAnnotation("PullRequestApprovalRulesNotSatisfiedException", PullRequestApprovalRulesNotSatisfiedException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException), ErrorAnnotation("ReplacementContentRequiredException", ReplacementContentRequiredException), ErrorAnnotation("ReplacementTypeRequiredException", ReplacementTypeRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("RepositoryNotAssociatedWithPullRequestException", RepositoryNotAssociatedWithPullRequestException), ErrorAnnotation("TipOfSourceReferenceIsDifferentException", TipOfSourceReferenceIsDifferentException), ErrorAnnotation("TipsDivergenceExceededException", TipsDivergenceExceededException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const OverridePullRequestApprovalRules = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.OverridePullRequestApprovalRules" }, OverridePullRequestApprovalRulesInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidOverrideStatusException", InvalidOverrideStatusException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("InvalidRevisionIdException", InvalidRevisionIdException), ErrorAnnotation("OverrideAlreadySetException", OverrideAlreadySetException), ErrorAnnotation("OverrideStatusRequiredException", OverrideStatusRequiredException), ErrorAnnotation("PullRequestAlreadyClosedException", PullRequestAlreadyClosedException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException), ErrorAnnotation("RevisionIdRequiredException", RevisionIdRequiredException), ErrorAnnotation("RevisionNotCurrentException", RevisionNotCurrentException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PostCommentForPullRequest = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.PostCommentForPullRequest" }, PostCommentForPullRequestInput, PostCommentForPullRequestOutput, Schema.Union(ErrorAnnotation("BeforeCommitIdAndAfterCommitIdAreSameException", BeforeCommitIdAndAfterCommitIdAreSameException), ErrorAnnotation("ClientRequestTokenRequiredException", ClientRequestTokenRequiredException), ErrorAnnotation("CommentContentRequiredException", CommentContentRequiredException), ErrorAnnotation("CommentContentSizeLimitExceededException", CommentContentSizeLimitExceededException), ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitIdRequiredException", CommitIdRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("IdempotencyParameterMismatchException", IdempotencyParameterMismatchException), ErrorAnnotation("InvalidClientRequestTokenException", InvalidClientRequestTokenException), ErrorAnnotation("InvalidCommitIdException", InvalidCommitIdException), ErrorAnnotation("InvalidFileLocationException", InvalidFileLocationException), ErrorAnnotation("InvalidFilePositionException", InvalidFilePositionException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("InvalidRelativeFileVersionEnumException", InvalidRelativeFileVersionEnumException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("PathDoesNotExistException", PathDoesNotExistException), ErrorAnnotation("PathRequiredException", PathRequiredException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("RepositoryNotAssociatedWithPullRequestException", RepositoryNotAssociatedWithPullRequestException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UntagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UntagResource" }, UntagResourceInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("InvalidResourceArnException", InvalidResourceArnException), ErrorAnnotation("InvalidSystemTagUsageException", InvalidSystemTagUsageException), ErrorAnnotation("InvalidTagKeysListException", InvalidTagKeysListException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("ResourceArnRequiredException", ResourceArnRequiredException), ErrorAnnotation("TagKeysListRequiredException", TagKeysListRequiredException), ErrorAnnotation("TagPolicyException", TagPolicyException), ErrorAnnotation("TooManyTagsException", TooManyTagsException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdatePullRequestApprovalRuleContent = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdatePullRequestApprovalRuleContent" }, UpdatePullRequestApprovalRuleContentInput, UpdatePullRequestApprovalRuleContentOutput, Schema.Union(ErrorAnnotation("ApprovalRuleContentRequiredException", ApprovalRuleContentRequiredException), ErrorAnnotation("ApprovalRuleDoesNotExistException", ApprovalRuleDoesNotExistException), ErrorAnnotation("ApprovalRuleNameRequiredException", ApprovalRuleNameRequiredException), ErrorAnnotation("CannotModifyApprovalRuleFromTemplateException", CannotModifyApprovalRuleFromTemplateException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidApprovalRuleContentException", InvalidApprovalRuleContentException), ErrorAnnotation("InvalidApprovalRuleNameException", InvalidApprovalRuleNameException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("InvalidRuleContentSha256Exception", InvalidRuleContentSha256Exception), ErrorAnnotation("PullRequestAlreadyClosedException", PullRequestAlreadyClosedException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdatePullRequestApprovalState = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdatePullRequestApprovalState" }, UpdatePullRequestApprovalStateInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("ApprovalStateRequiredException", ApprovalStateRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidApprovalStateException", InvalidApprovalStateException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("InvalidRevisionIdException", InvalidRevisionIdException), ErrorAnnotation("MaximumNumberOfApprovalsExceededException", MaximumNumberOfApprovalsExceededException), ErrorAnnotation("PullRequestAlreadyClosedException", PullRequestAlreadyClosedException), ErrorAnnotation("PullRequestCannotBeApprovedByAuthorException", PullRequestCannotBeApprovedByAuthorException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException), ErrorAnnotation("RevisionIdRequiredException", RevisionIdRequiredException), ErrorAnnotation("RevisionNotCurrentException", RevisionNotCurrentException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdatePullRequestStatus = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.UpdatePullRequestStatus" }, UpdatePullRequestStatusInput, UpdatePullRequestStatusOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("InvalidPullRequestStatusException", InvalidPullRequestStatusException), ErrorAnnotation("InvalidPullRequestStatusUpdateException", InvalidPullRequestStatusUpdateException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException), ErrorAnnotation("PullRequestStatusRequiredException", PullRequestStatusRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const BatchDescribeMergeConflicts = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.BatchDescribeMergeConflicts" }, BatchDescribeMergeConflictsInput, BatchDescribeMergeConflictsOutput, Schema.Union(ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitRequiredException", CommitRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidCommitException", InvalidCommitException), ErrorAnnotation("InvalidConflictDetailLevelException", InvalidConflictDetailLevelException), ErrorAnnotation("InvalidConflictResolutionStrategyException", InvalidConflictResolutionStrategyException), ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidMaxConflictFilesException", InvalidMaxConflictFilesException), ErrorAnnotation("InvalidMaxMergeHunksException", InvalidMaxMergeHunksException), ErrorAnnotation("InvalidMergeOptionException", InvalidMergeOptionException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("MaximumFileContentToLoadExceededException", MaximumFileContentToLoadExceededException), ErrorAnnotation("MaximumItemsToCompareExceededException", MaximumItemsToCompareExceededException), ErrorAnnotation("MergeOptionRequiredException", MergeOptionRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("TipsDivergenceExceededException", TipsDivergenceExceededException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const BatchGetCommits = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.BatchGetCommits" }, BatchGetCommitsInput, BatchGetCommitsOutput, Schema.Union(ErrorAnnotation("CommitIdsLimitExceededException", CommitIdsLimitExceededException), ErrorAnnotation("CommitIdsListRequiredException", CommitIdsListRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateRepository = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreateRepository" }, CreateRepositoryInput, CreateRepositoryOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyInvalidIdException", EncryptionKeyInvalidIdException), ErrorAnnotation("EncryptionKeyInvalidUsageException", EncryptionKeyInvalidUsageException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidRepositoryDescriptionException", InvalidRepositoryDescriptionException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("InvalidSystemTagUsageException", InvalidSystemTagUsageException), ErrorAnnotation("InvalidTagsMapException", InvalidTagsMapException), ErrorAnnotation("OperationNotAllowedException", OperationNotAllowedException), ErrorAnnotation("RepositoryLimitExceededException", RepositoryLimitExceededException), ErrorAnnotation("RepositoryNameExistsException", RepositoryNameExistsException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("TagPolicyException", TagPolicyException), ErrorAnnotation("TooManyTagsException", TooManyTagsException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateUnreferencedMergeCommit = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreateUnreferencedMergeCommit" }, CreateUnreferencedMergeCommitInput, CreateUnreferencedMergeCommitOutput, Schema.Union(ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitMessageLengthExceededException", CommitMessageLengthExceededException), ErrorAnnotation("CommitRequiredException", CommitRequiredException), ErrorAnnotation("ConcurrentReferenceUpdateException", ConcurrentReferenceUpdateException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("FileContentSizeLimitExceededException", FileContentSizeLimitExceededException), ErrorAnnotation("FileModeRequiredException", FileModeRequiredException), ErrorAnnotation("FolderContentSizeLimitExceededException", FolderContentSizeLimitExceededException), ErrorAnnotation("InvalidCommitException", InvalidCommitException), ErrorAnnotation("InvalidConflictDetailLevelException", InvalidConflictDetailLevelException), ErrorAnnotation("InvalidConflictResolutionException", InvalidConflictResolutionException), ErrorAnnotation("InvalidConflictResolutionStrategyException", InvalidConflictResolutionStrategyException), ErrorAnnotation("InvalidEmailException", InvalidEmailException), ErrorAnnotation("InvalidFileModeException", InvalidFileModeException), ErrorAnnotation("InvalidMergeOptionException", InvalidMergeOptionException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidReplacementContentException", InvalidReplacementContentException), ErrorAnnotation("InvalidReplacementTypeException", InvalidReplacementTypeException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("ManualMergeRequiredException", ManualMergeRequiredException), ErrorAnnotation("MaximumConflictResolutionEntriesExceededException", MaximumConflictResolutionEntriesExceededException), ErrorAnnotation("MaximumFileContentToLoadExceededException", MaximumFileContentToLoadExceededException), ErrorAnnotation("MaximumItemsToCompareExceededException", MaximumItemsToCompareExceededException), ErrorAnnotation("MergeOptionRequiredException", MergeOptionRequiredException), ErrorAnnotation("MultipleConflictResolutionEntriesException", MultipleConflictResolutionEntriesException), ErrorAnnotation("NameLengthExceededException", NameLengthExceededException), ErrorAnnotation("PathRequiredException", PathRequiredException), ErrorAnnotation("ReplacementContentRequiredException", ReplacementContentRequiredException), ErrorAnnotation("ReplacementTypeRequiredException", ReplacementTypeRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("TipsDivergenceExceededException", TipsDivergenceExceededException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const MergeBranchesBySquash = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.MergeBranchesBySquash" }, MergeBranchesBySquashInput, MergeBranchesBySquashOutput, Schema.Union(ErrorAnnotation("BranchDoesNotExistException", BranchDoesNotExistException), ErrorAnnotation("BranchNameIsTagNameException", BranchNameIsTagNameException), ErrorAnnotation("BranchNameRequiredException", BranchNameRequiredException), ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitMessageLengthExceededException", CommitMessageLengthExceededException), ErrorAnnotation("CommitRequiredException", CommitRequiredException), ErrorAnnotation("ConcurrentReferenceUpdateException", ConcurrentReferenceUpdateException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("FileContentSizeLimitExceededException", FileContentSizeLimitExceededException), ErrorAnnotation("FileModeRequiredException", FileModeRequiredException), ErrorAnnotation("FolderContentSizeLimitExceededException", FolderContentSizeLimitExceededException), ErrorAnnotation("InvalidBranchNameException", InvalidBranchNameException), ErrorAnnotation("InvalidCommitException", InvalidCommitException), ErrorAnnotation("InvalidConflictDetailLevelException", InvalidConflictDetailLevelException), ErrorAnnotation("InvalidConflictResolutionException", InvalidConflictResolutionException), ErrorAnnotation("InvalidConflictResolutionStrategyException", InvalidConflictResolutionStrategyException), ErrorAnnotation("InvalidEmailException", InvalidEmailException), ErrorAnnotation("InvalidFileModeException", InvalidFileModeException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidReplacementContentException", InvalidReplacementContentException), ErrorAnnotation("InvalidReplacementTypeException", InvalidReplacementTypeException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("InvalidTargetBranchException", InvalidTargetBranchException), ErrorAnnotation("ManualMergeRequiredException", ManualMergeRequiredException), ErrorAnnotation("MaximumConflictResolutionEntriesExceededException", MaximumConflictResolutionEntriesExceededException), ErrorAnnotation("MaximumFileContentToLoadExceededException", MaximumFileContentToLoadExceededException), ErrorAnnotation("MaximumItemsToCompareExceededException", MaximumItemsToCompareExceededException), ErrorAnnotation("MultipleConflictResolutionEntriesException", MultipleConflictResolutionEntriesException), ErrorAnnotation("NameLengthExceededException", NameLengthExceededException), ErrorAnnotation("PathRequiredException", PathRequiredException), ErrorAnnotation("ReplacementContentRequiredException", ReplacementContentRequiredException), ErrorAnnotation("ReplacementTypeRequiredException", ReplacementTypeRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("TipsDivergenceExceededException", TipsDivergenceExceededException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const MergeBranchesByThreeWay = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.MergeBranchesByThreeWay" }, MergeBranchesByThreeWayInput, MergeBranchesByThreeWayOutput, Schema.Union(ErrorAnnotation("BranchDoesNotExistException", BranchDoesNotExistException), ErrorAnnotation("BranchNameIsTagNameException", BranchNameIsTagNameException), ErrorAnnotation("BranchNameRequiredException", BranchNameRequiredException), ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitMessageLengthExceededException", CommitMessageLengthExceededException), ErrorAnnotation("CommitRequiredException", CommitRequiredException), ErrorAnnotation("ConcurrentReferenceUpdateException", ConcurrentReferenceUpdateException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("FileContentSizeLimitExceededException", FileContentSizeLimitExceededException), ErrorAnnotation("FileModeRequiredException", FileModeRequiredException), ErrorAnnotation("FolderContentSizeLimitExceededException", FolderContentSizeLimitExceededException), ErrorAnnotation("InvalidBranchNameException", InvalidBranchNameException), ErrorAnnotation("InvalidCommitException", InvalidCommitException), ErrorAnnotation("InvalidConflictDetailLevelException", InvalidConflictDetailLevelException), ErrorAnnotation("InvalidConflictResolutionException", InvalidConflictResolutionException), ErrorAnnotation("InvalidConflictResolutionStrategyException", InvalidConflictResolutionStrategyException), ErrorAnnotation("InvalidEmailException", InvalidEmailException), ErrorAnnotation("InvalidFileModeException", InvalidFileModeException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidReplacementContentException", InvalidReplacementContentException), ErrorAnnotation("InvalidReplacementTypeException", InvalidReplacementTypeException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("InvalidTargetBranchException", InvalidTargetBranchException), ErrorAnnotation("ManualMergeRequiredException", ManualMergeRequiredException), ErrorAnnotation("MaximumConflictResolutionEntriesExceededException", MaximumConflictResolutionEntriesExceededException), ErrorAnnotation("MaximumFileContentToLoadExceededException", MaximumFileContentToLoadExceededException), ErrorAnnotation("MaximumItemsToCompareExceededException", MaximumItemsToCompareExceededException), ErrorAnnotation("MultipleConflictResolutionEntriesException", MultipleConflictResolutionEntriesException), ErrorAnnotation("NameLengthExceededException", NameLengthExceededException), ErrorAnnotation("PathRequiredException", PathRequiredException), ErrorAnnotation("ReplacementContentRequiredException", ReplacementContentRequiredException), ErrorAnnotation("ReplacementTypeRequiredException", ReplacementTypeRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("TipsDivergenceExceededException", TipsDivergenceExceededException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const MergePullRequestByFastForward = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.MergePullRequestByFastForward" }, MergePullRequestByFastForwardInput, MergePullRequestByFastForwardOutput, Schema.Union(ErrorAnnotation("ConcurrentReferenceUpdateException", ConcurrentReferenceUpdateException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidCommitIdException", InvalidCommitIdException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("ManualMergeRequiredException", ManualMergeRequiredException), ErrorAnnotation("PullRequestAlreadyClosedException", PullRequestAlreadyClosedException), ErrorAnnotation("PullRequestApprovalRulesNotSatisfiedException", PullRequestApprovalRulesNotSatisfiedException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException), ErrorAnnotation("ReferenceDoesNotExistException", ReferenceDoesNotExistException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("RepositoryNotAssociatedWithPullRequestException", RepositoryNotAssociatedWithPullRequestException), ErrorAnnotation("TipOfSourceReferenceIsDifferentException", TipOfSourceReferenceIsDifferentException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const MergePullRequestBySquash = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.MergePullRequestBySquash" }, MergePullRequestBySquashInput, MergePullRequestBySquashOutput, Schema.Union(ErrorAnnotation("CommitMessageLengthExceededException", CommitMessageLengthExceededException), ErrorAnnotation("ConcurrentReferenceUpdateException", ConcurrentReferenceUpdateException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("FileContentSizeLimitExceededException", FileContentSizeLimitExceededException), ErrorAnnotation("FolderContentSizeLimitExceededException", FolderContentSizeLimitExceededException), ErrorAnnotation("InvalidCommitIdException", InvalidCommitIdException), ErrorAnnotation("InvalidConflictDetailLevelException", InvalidConflictDetailLevelException), ErrorAnnotation("InvalidConflictResolutionException", InvalidConflictResolutionException), ErrorAnnotation("InvalidConflictResolutionStrategyException", InvalidConflictResolutionStrategyException), ErrorAnnotation("InvalidEmailException", InvalidEmailException), ErrorAnnotation("InvalidFileModeException", InvalidFileModeException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("InvalidReplacementContentException", InvalidReplacementContentException), ErrorAnnotation("InvalidReplacementTypeException", InvalidReplacementTypeException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("ManualMergeRequiredException", ManualMergeRequiredException), ErrorAnnotation("MaximumConflictResolutionEntriesExceededException", MaximumConflictResolutionEntriesExceededException), ErrorAnnotation("MaximumFileContentToLoadExceededException", MaximumFileContentToLoadExceededException), ErrorAnnotation("MaximumItemsToCompareExceededException", MaximumItemsToCompareExceededException), ErrorAnnotation("MultipleConflictResolutionEntriesException", MultipleConflictResolutionEntriesException), ErrorAnnotation("NameLengthExceededException", NameLengthExceededException), ErrorAnnotation("PathRequiredException", PathRequiredException), ErrorAnnotation("PullRequestAlreadyClosedException", PullRequestAlreadyClosedException), ErrorAnnotation("PullRequestApprovalRulesNotSatisfiedException", PullRequestApprovalRulesNotSatisfiedException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException), ErrorAnnotation("ReplacementContentRequiredException", ReplacementContentRequiredException), ErrorAnnotation("ReplacementTypeRequiredException", ReplacementTypeRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("RepositoryNotAssociatedWithPullRequestException", RepositoryNotAssociatedWithPullRequestException), ErrorAnnotation("TipOfSourceReferenceIsDifferentException", TipOfSourceReferenceIsDifferentException), ErrorAnnotation("TipsDivergenceExceededException", TipsDivergenceExceededException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PostCommentForComparedCommit = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.PostCommentForComparedCommit" }, PostCommentForComparedCommitInput, PostCommentForComparedCommitOutput, Schema.Union(ErrorAnnotation("BeforeCommitIdAndAfterCommitIdAreSameException", BeforeCommitIdAndAfterCommitIdAreSameException), ErrorAnnotation("ClientRequestTokenRequiredException", ClientRequestTokenRequiredException), ErrorAnnotation("CommentContentRequiredException", CommentContentRequiredException), ErrorAnnotation("CommentContentSizeLimitExceededException", CommentContentSizeLimitExceededException), ErrorAnnotation("CommitDoesNotExistException", CommitDoesNotExistException), ErrorAnnotation("CommitIdRequiredException", CommitIdRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("IdempotencyParameterMismatchException", IdempotencyParameterMismatchException), ErrorAnnotation("InvalidClientRequestTokenException", InvalidClientRequestTokenException), ErrorAnnotation("InvalidCommitIdException", InvalidCommitIdException), ErrorAnnotation("InvalidFileLocationException", InvalidFileLocationException), ErrorAnnotation("InvalidFilePositionException", InvalidFilePositionException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidRelativeFileVersionEnumException", InvalidRelativeFileVersionEnumException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("PathDoesNotExistException", PathDoesNotExistException), ErrorAnnotation("PathRequiredException", PathRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PutCommentReaction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.PutCommentReaction" }, PutCommentReactionInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("CommentDeletedException", CommentDeletedException), ErrorAnnotation("CommentDoesNotExistException", CommentDoesNotExistException), ErrorAnnotation("CommentIdRequiredException", CommentIdRequiredException), ErrorAnnotation("InvalidCommentIdException", InvalidCommentIdException), ErrorAnnotation("InvalidReactionValueException", InvalidReactionValueException), ErrorAnnotation("ReactionLimitExceededException", ReactionLimitExceededException), ErrorAnnotation("ReactionValueRequiredException", ReactionValueRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const TagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.TagResource" }, TagResourceInput, Schema.Struct({}), Schema.Union(ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("InvalidResourceArnException", InvalidResourceArnException), ErrorAnnotation("InvalidSystemTagUsageException", InvalidSystemTagUsageException), ErrorAnnotation("InvalidTagsMapException", InvalidTagsMapException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("ResourceArnRequiredException", ResourceArnRequiredException), ErrorAnnotation("TagPolicyException", TagPolicyException), ErrorAnnotation("TagsMapRequiredException", TagsMapRequiredException), ErrorAnnotation("TooManyTagsException", TooManyTagsException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreatePullRequestApprovalRule = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreatePullRequestApprovalRule" }, CreatePullRequestApprovalRuleInput, CreatePullRequestApprovalRuleOutput, Schema.Union(ErrorAnnotation("ApprovalRuleContentRequiredException", ApprovalRuleContentRequiredException), ErrorAnnotation("ApprovalRuleNameAlreadyExistsException", ApprovalRuleNameAlreadyExistsException), ErrorAnnotation("ApprovalRuleNameRequiredException", ApprovalRuleNameRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidApprovalRuleContentException", InvalidApprovalRuleContentException), ErrorAnnotation("InvalidApprovalRuleNameException", InvalidApprovalRuleNameException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("NumberOfRulesExceededException", NumberOfRulesExceededException), ErrorAnnotation("PullRequestAlreadyClosedException", PullRequestAlreadyClosedException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteFile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DeleteFile" }, DeleteFileInput, DeleteFileOutput, Schema.Union(ErrorAnnotation("BranchDoesNotExistException", BranchDoesNotExistException), ErrorAnnotation("BranchNameIsTagNameException", BranchNameIsTagNameException), ErrorAnnotation("BranchNameRequiredException", BranchNameRequiredException), ErrorAnnotation("CommitMessageLengthExceededException", CommitMessageLengthExceededException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("FileDoesNotExistException", FileDoesNotExistException), ErrorAnnotation("InvalidBranchNameException", InvalidBranchNameException), ErrorAnnotation("InvalidEmailException", InvalidEmailException), ErrorAnnotation("InvalidParentCommitIdException", InvalidParentCommitIdException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("NameLengthExceededException", NameLengthExceededException), ErrorAnnotation("ParentCommitDoesNotExistException", ParentCommitDoesNotExistException), ErrorAnnotation("ParentCommitIdOutdatedException", ParentCommitIdOutdatedException), ErrorAnnotation("ParentCommitIdRequiredException", ParentCommitIdRequiredException), ErrorAnnotation("PathRequiredException", PathRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribePullRequestEvents = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.DescribePullRequestEvents" }, DescribePullRequestEventsInput, DescribePullRequestEventsOutput, Schema.Union(ErrorAnnotation("ActorDoesNotExistException", ActorDoesNotExistException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidActorArnException", InvalidActorArnException), ErrorAnnotation("InvalidContinuationTokenException", InvalidContinuationTokenException), ErrorAnnotation("InvalidMaxResultsException", InvalidMaxResultsException), ErrorAnnotation("InvalidPullRequestEventTypeException", InvalidPullRequestEventTypeException), ErrorAnnotation("InvalidPullRequestIdException", InvalidPullRequestIdException), ErrorAnnotation("PullRequestDoesNotExistException", PullRequestDoesNotExistException), ErrorAnnotation("PullRequestIdRequiredException", PullRequestIdRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PutFile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.PutFile" }, PutFileInput, PutFileOutput, Schema.Union(ErrorAnnotation("BranchDoesNotExistException", BranchDoesNotExistException), ErrorAnnotation("BranchNameIsTagNameException", BranchNameIsTagNameException), ErrorAnnotation("BranchNameRequiredException", BranchNameRequiredException), ErrorAnnotation("CommitMessageLengthExceededException", CommitMessageLengthExceededException), ErrorAnnotation("DirectoryNameConflictsWithFileNameException", DirectoryNameConflictsWithFileNameException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("FileContentRequiredException", FileContentRequiredException), ErrorAnnotation("FileContentSizeLimitExceededException", FileContentSizeLimitExceededException), ErrorAnnotation("FileNameConflictsWithDirectoryNameException", FileNameConflictsWithDirectoryNameException), ErrorAnnotation("FilePathConflictsWithSubmodulePathException", FilePathConflictsWithSubmodulePathException), ErrorAnnotation("FolderContentSizeLimitExceededException", FolderContentSizeLimitExceededException), ErrorAnnotation("InvalidBranchNameException", InvalidBranchNameException), ErrorAnnotation("InvalidDeletionParameterException", InvalidDeletionParameterException), ErrorAnnotation("InvalidEmailException", InvalidEmailException), ErrorAnnotation("InvalidFileModeException", InvalidFileModeException), ErrorAnnotation("InvalidParentCommitIdException", InvalidParentCommitIdException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("NameLengthExceededException", NameLengthExceededException), ErrorAnnotation("ParentCommitDoesNotExistException", ParentCommitDoesNotExistException), ErrorAnnotation("ParentCommitIdOutdatedException", ParentCommitIdOutdatedException), ErrorAnnotation("ParentCommitIdRequiredException", ParentCommitIdRequiredException), ErrorAnnotation("PathRequiredException", PathRequiredException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("SameFileContentException", SameFileContentException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const TestRepositoryTriggers = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.TestRepositoryTriggers" }, TestRepositoryTriggersInput, TestRepositoryTriggersOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("InvalidRepositoryTriggerBranchNameException", InvalidRepositoryTriggerBranchNameException), ErrorAnnotation("InvalidRepositoryTriggerCustomDataException", InvalidRepositoryTriggerCustomDataException), ErrorAnnotation("InvalidRepositoryTriggerDestinationArnException", InvalidRepositoryTriggerDestinationArnException), ErrorAnnotation("InvalidRepositoryTriggerEventsException", InvalidRepositoryTriggerEventsException), ErrorAnnotation("InvalidRepositoryTriggerNameException", InvalidRepositoryTriggerNameException), ErrorAnnotation("InvalidRepositoryTriggerRegionException", InvalidRepositoryTriggerRegionException), ErrorAnnotation("MaximumBranchesExceededException", MaximumBranchesExceededException), ErrorAnnotation("MaximumRepositoryTriggersExceededException", MaximumRepositoryTriggersExceededException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("RepositoryTriggerBranchNameListRequiredException", RepositoryTriggerBranchNameListRequiredException), ErrorAnnotation("RepositoryTriggerDestinationArnRequiredException", RepositoryTriggerDestinationArnRequiredException), ErrorAnnotation("RepositoryTriggerEventsListRequiredException", RepositoryTriggerEventsListRequiredException), ErrorAnnotation("RepositoryTriggerNameRequiredException", RepositoryTriggerNameRequiredException), ErrorAnnotation("RepositoryTriggersListRequiredException", RepositoryTriggersListRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PutRepositoryTriggers = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.PutRepositoryTriggers" }, PutRepositoryTriggersInput, PutRepositoryTriggersOutput, Schema.Union(ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("InvalidRepositoryTriggerBranchNameException", InvalidRepositoryTriggerBranchNameException), ErrorAnnotation("InvalidRepositoryTriggerCustomDataException", InvalidRepositoryTriggerCustomDataException), ErrorAnnotation("InvalidRepositoryTriggerDestinationArnException", InvalidRepositoryTriggerDestinationArnException), ErrorAnnotation("InvalidRepositoryTriggerEventsException", InvalidRepositoryTriggerEventsException), ErrorAnnotation("InvalidRepositoryTriggerNameException", InvalidRepositoryTriggerNameException), ErrorAnnotation("InvalidRepositoryTriggerRegionException", InvalidRepositoryTriggerRegionException), ErrorAnnotation("MaximumBranchesExceededException", MaximumBranchesExceededException), ErrorAnnotation("MaximumRepositoryTriggersExceededException", MaximumRepositoryTriggersExceededException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("RepositoryTriggerBranchNameListRequiredException", RepositoryTriggerBranchNameListRequiredException), ErrorAnnotation("RepositoryTriggerDestinationArnRequiredException", RepositoryTriggerDestinationArnRequiredException), ErrorAnnotation("RepositoryTriggerEventsListRequiredException", RepositoryTriggerEventsListRequiredException), ErrorAnnotation("RepositoryTriggerNameRequiredException", RepositoryTriggerNameRequiredException), ErrorAnnotation("RepositoryTriggersListRequiredException", RepositoryTriggersListRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateCommit = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreateCommit" }, CreateCommitInput, CreateCommitOutput, Schema.Union(ErrorAnnotation("BranchDoesNotExistException", BranchDoesNotExistException), ErrorAnnotation("BranchNameIsTagNameException", BranchNameIsTagNameException), ErrorAnnotation("BranchNameRequiredException", BranchNameRequiredException), ErrorAnnotation("CommitMessageLengthExceededException", CommitMessageLengthExceededException), ErrorAnnotation("DirectoryNameConflictsWithFileNameException", DirectoryNameConflictsWithFileNameException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("FileContentAndSourceFileSpecifiedException", FileContentAndSourceFileSpecifiedException), ErrorAnnotation("FileContentSizeLimitExceededException", FileContentSizeLimitExceededException), ErrorAnnotation("FileDoesNotExistException", FileDoesNotExistException), ErrorAnnotation("FileEntryRequiredException", FileEntryRequiredException), ErrorAnnotation("FileModeRequiredException", FileModeRequiredException), ErrorAnnotation("FileNameConflictsWithDirectoryNameException", FileNameConflictsWithDirectoryNameException), ErrorAnnotation("FilePathConflictsWithSubmodulePathException", FilePathConflictsWithSubmodulePathException), ErrorAnnotation("FolderContentSizeLimitExceededException", FolderContentSizeLimitExceededException), ErrorAnnotation("InvalidBranchNameException", InvalidBranchNameException), ErrorAnnotation("InvalidDeletionParameterException", InvalidDeletionParameterException), ErrorAnnotation("InvalidEmailException", InvalidEmailException), ErrorAnnotation("InvalidFileModeException", InvalidFileModeException), ErrorAnnotation("InvalidParentCommitIdException", InvalidParentCommitIdException), ErrorAnnotation("InvalidPathException", InvalidPathException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("MaximumFileEntriesExceededException", MaximumFileEntriesExceededException), ErrorAnnotation("NameLengthExceededException", NameLengthExceededException), ErrorAnnotation("NoChangeException", NoChangeException), ErrorAnnotation("ParentCommitDoesNotExistException", ParentCommitDoesNotExistException), ErrorAnnotation("ParentCommitIdOutdatedException", ParentCommitIdOutdatedException), ErrorAnnotation("ParentCommitIdRequiredException", ParentCommitIdRequiredException), ErrorAnnotation("PathRequiredException", PathRequiredException), ErrorAnnotation("PutFileEntryConflictException", PutFileEntryConflictException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("RestrictedSourceFileException", RestrictedSourceFileException), ErrorAnnotation("SamePathRequestException", SamePathRequestException), ErrorAnnotation("SourceFileOrContentRequiredException", SourceFileOrContentRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreatePullRequest = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "CodeCommit", sigV4ServiceName: "codecommit", name: "CodeCommit_20150413.CreatePullRequest" }, CreatePullRequestInput, CreatePullRequestOutput, Schema.Union(ErrorAnnotation("ClientRequestTokenRequiredException", ClientRequestTokenRequiredException), ErrorAnnotation("EncryptionIntegrityChecksFailedException", EncryptionIntegrityChecksFailedException), ErrorAnnotation("EncryptionKeyAccessDeniedException", EncryptionKeyAccessDeniedException), ErrorAnnotation("EncryptionKeyDisabledException", EncryptionKeyDisabledException), ErrorAnnotation("EncryptionKeyNotFoundException", EncryptionKeyNotFoundException), ErrorAnnotation("EncryptionKeyUnavailableException", EncryptionKeyUnavailableException), ErrorAnnotation("IdempotencyParameterMismatchException", IdempotencyParameterMismatchException), ErrorAnnotation("InvalidClientRequestTokenException", InvalidClientRequestTokenException), ErrorAnnotation("InvalidDescriptionException", InvalidDescriptionException), ErrorAnnotation("InvalidReferenceNameException", InvalidReferenceNameException), ErrorAnnotation("InvalidRepositoryNameException", InvalidRepositoryNameException), ErrorAnnotation("InvalidTargetException", InvalidTargetException), ErrorAnnotation("InvalidTargetsException", InvalidTargetsException), ErrorAnnotation("InvalidTitleException", InvalidTitleException), ErrorAnnotation("MaximumOpenPullRequestsExceededException", MaximumOpenPullRequestsExceededException), ErrorAnnotation("MultipleRepositoriesInPullRequestException", MultipleRepositoriesInPullRequestException), ErrorAnnotation("ReferenceDoesNotExistException", ReferenceDoesNotExistException), ErrorAnnotation("ReferenceNameRequiredException", ReferenceNameRequiredException), ErrorAnnotation("ReferenceTypeNotSupportedException", ReferenceTypeNotSupportedException), ErrorAnnotation("RepositoryDoesNotExistException", RepositoryDoesNotExistException), ErrorAnnotation("RepositoryNameRequiredException", RepositoryNameRequiredException), ErrorAnnotation("SourceAndDestinationAreSameException", SourceAndDestinationAreSameException), ErrorAnnotation("TargetRequiredException", TargetRequiredException), ErrorAnnotation("TargetsRequiredException", TargetsRequiredException), ErrorAnnotation("TitleRequiredException", TitleRequiredException))), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
