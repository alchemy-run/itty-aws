import * as Schema from "effect/Schema"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const FragmentNumberList = Schema.Array(Schema.String);
export class GetMediaForFragmentListInput extends Schema.Class<GetMediaForFragmentListInput>("GetMediaForFragmentListInput")({StreamName: Schema.optional(Schema.String), StreamARN: Schema.optional(Schema.String), Fragments: FragmentNumberList}) {}
export const FormatConfig = Schema.Record({key: Schema.String, value: Schema.String});
export class GetImagesInput extends Schema.Class<GetImagesInput>("GetImagesInput")({StreamName: Schema.optional(Schema.String), StreamARN: Schema.optional(Schema.String), ImageSelectorType: Schema.String, StartTimestamp: Schema.Date, EndTimestamp: Schema.Date, SamplingInterval: Schema.optional(Schema.Number), Format: Schema.String, FormatConfig: Schema.optional(FormatConfig), WidthPixels: Schema.optional(Schema.Number), HeightPixels: Schema.optional(Schema.Number), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String)}) {}
export class GetMediaForFragmentListOutput extends Schema.Class<GetMediaForFragmentListOutput>("GetMediaForFragmentListOutput")({ContentType: Schema.optional(Header("Content-Type")), Payload: Schema.optional(Body("undefined", StreamBody()))}) {}
export class ClipTimestampRange extends Schema.Class<ClipTimestampRange>("ClipTimestampRange")({StartTimestamp: Schema.Date, EndTimestamp: Schema.Date}) {}
export class DASHTimestampRange extends Schema.Class<DASHTimestampRange>("DASHTimestampRange")({StartTimestamp: Schema.optional(Schema.Date), EndTimestamp: Schema.optional(Schema.Date)}) {}
export class HLSTimestampRange extends Schema.Class<HLSTimestampRange>("HLSTimestampRange")({StartTimestamp: Schema.optional(Schema.Date), EndTimestamp: Schema.optional(Schema.Date)}) {}
export class TimestampRange extends Schema.Class<TimestampRange>("TimestampRange")({StartTimestamp: Schema.Date, EndTimestamp: Schema.Date}) {}
export class ClipFragmentSelector extends Schema.Class<ClipFragmentSelector>("ClipFragmentSelector")({FragmentSelectorType: Schema.String, TimestampRange: ClipTimestampRange}) {}
export class DASHFragmentSelector extends Schema.Class<DASHFragmentSelector>("DASHFragmentSelector")({FragmentSelectorType: Schema.optional(Schema.String), TimestampRange: Schema.optional(DASHTimestampRange)}) {}
export class HLSFragmentSelector extends Schema.Class<HLSFragmentSelector>("HLSFragmentSelector")({FragmentSelectorType: Schema.optional(Schema.String), TimestampRange: Schema.optional(HLSTimestampRange)}) {}
export class FragmentSelector extends Schema.Class<FragmentSelector>("FragmentSelector")({FragmentSelectorType: Schema.String, TimestampRange: TimestampRange}) {}
export class GetClipInput extends Schema.Class<GetClipInput>("GetClipInput")({StreamName: Schema.optional(Schema.String), StreamARN: Schema.optional(Schema.String), ClipFragmentSelector: ClipFragmentSelector}) {}
export class GetDASHStreamingSessionURLInput extends Schema.Class<GetDASHStreamingSessionURLInput>("GetDASHStreamingSessionURLInput")({StreamName: Schema.optional(Schema.String), StreamARN: Schema.optional(Schema.String), PlaybackMode: Schema.optional(Schema.String), DisplayFragmentTimestamp: Schema.optional(Schema.String), DisplayFragmentNumber: Schema.optional(Schema.String), DASHFragmentSelector: Schema.optional(DASHFragmentSelector), Expires: Schema.optional(Schema.Number), MaxManifestFragmentResults: Schema.optional(Schema.Number)}) {}
export class GetHLSStreamingSessionURLInput extends Schema.Class<GetHLSStreamingSessionURLInput>("GetHLSStreamingSessionURLInput")({StreamName: Schema.optional(Schema.String), StreamARN: Schema.optional(Schema.String), PlaybackMode: Schema.optional(Schema.String), HLSFragmentSelector: Schema.optional(HLSFragmentSelector), ContainerFormat: Schema.optional(Schema.String), DiscontinuityMode: Schema.optional(Schema.String), DisplayFragmentTimestamp: Schema.optional(Schema.String), Expires: Schema.optional(Schema.Number), MaxMediaPlaylistFragmentResults: Schema.optional(Schema.Number)}) {}
export class ClientLimitExceededException extends Schema.Class<ClientLimitExceededException>("ClientLimitExceededException")({Message: Schema.optional(Schema.String)}) {}
export class ListFragmentsInput extends Schema.Class<ListFragmentsInput>("ListFragmentsInput")({StreamName: Schema.optional(Schema.String), StreamARN: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), NextToken: Schema.optional(Schema.String), FragmentSelector: Schema.optional(FragmentSelector)}) {}
export class Image extends Schema.Class<Image>("Image")({TimeStamp: Schema.optional(Schema.Date), Error: Schema.optional(Schema.String), ImageContent: Schema.optional(Schema.String)}) {}
export const Images = Schema.Array(Image);
export class GetClipOutput extends Schema.Class<GetClipOutput>("GetClipOutput")({ContentType: Schema.optional(Header("Content-Type")), Payload: Schema.optional(Body("undefined", StreamBody()))}) {}
export class GetDASHStreamingSessionURLOutput extends Schema.Class<GetDASHStreamingSessionURLOutput>("GetDASHStreamingSessionURLOutput")({DASHStreamingSessionURL: Schema.optional(Schema.String)}) {}
export class GetHLSStreamingSessionURLOutput extends Schema.Class<GetHLSStreamingSessionURLOutput>("GetHLSStreamingSessionURLOutput")({HLSStreamingSessionURL: Schema.optional(Schema.String)}) {}
export class GetImagesOutput extends Schema.Class<GetImagesOutput>("GetImagesOutput")({Images: Schema.optional(Images), NextToken: Schema.optional(Schema.String)}) {}
export class InvalidArgumentException extends Schema.Class<InvalidArgumentException>("InvalidArgumentException")({Message: Schema.optional(Schema.String)}) {}
export class Fragment extends Schema.Class<Fragment>("Fragment")({FragmentNumber: Schema.optional(Schema.String), FragmentSizeInBytes: Schema.optional(Schema.Number), ProducerTimestamp: Schema.optional(Schema.Date), ServerTimestamp: Schema.optional(Schema.Date), FragmentLengthInMilliseconds: Schema.optional(Schema.Number)}) {}
export const FragmentList = Schema.Array(Fragment);
export class InvalidCodecPrivateDataException extends Schema.Class<InvalidCodecPrivateDataException>("InvalidCodecPrivateDataException")({Message: Schema.optional(Schema.String)}) {}
export class MissingCodecPrivateDataException extends Schema.Class<MissingCodecPrivateDataException>("MissingCodecPrivateDataException")({Message: Schema.optional(Schema.String)}) {}
export class NoDataRetentionException extends Schema.Class<NoDataRetentionException>("NoDataRetentionException")({Message: Schema.optional(Schema.String)}) {}
export class NotAuthorizedException extends Schema.Class<NotAuthorizedException>("NotAuthorizedException")({Message: Schema.optional(Schema.String)}) {}
export class ResourceNotFoundException extends Schema.Class<ResourceNotFoundException>("ResourceNotFoundException")({Message: Schema.optional(Schema.String)}) {}
export class ListFragmentsOutput extends Schema.Class<ListFragmentsOutput>("ListFragmentsOutput")({Fragments: Schema.optional(FragmentList), NextToken: Schema.optional(Schema.String)}) {}
export class InvalidMediaFrameException extends Schema.Class<InvalidMediaFrameException>("InvalidMediaFrameException")({Message: Schema.optional(Schema.String)}) {}
export class UnsupportedStreamMediaTypeException extends Schema.Class<UnsupportedStreamMediaTypeException>("UnsupportedStreamMediaTypeException")({Message: Schema.optional(Schema.String)}) {}

//# Errors
export class ClientLimitExceededExceptionError extends Schema.TaggedError<ClientLimitExceededExceptionError>()("ClientLimitExceededException", ClientLimitExceededException.fields) {};
export class InvalidArgumentExceptionError extends Schema.TaggedError<InvalidArgumentExceptionError>()("InvalidArgumentException", InvalidArgumentException.fields) {};
export class InvalidCodecPrivateDataExceptionError extends Schema.TaggedError<InvalidCodecPrivateDataExceptionError>()("InvalidCodecPrivateDataException", InvalidCodecPrivateDataException.fields) {};
export class MissingCodecPrivateDataExceptionError extends Schema.TaggedError<MissingCodecPrivateDataExceptionError>()("MissingCodecPrivateDataException", MissingCodecPrivateDataException.fields) {};
export class NoDataRetentionExceptionError extends Schema.TaggedError<NoDataRetentionExceptionError>()("NoDataRetentionException", NoDataRetentionException.fields) {};
export class NotAuthorizedExceptionError extends Schema.TaggedError<NotAuthorizedExceptionError>()("NotAuthorizedException", NotAuthorizedException.fields) {};
export class ResourceNotFoundExceptionError extends Schema.TaggedError<ResourceNotFoundExceptionError>()("ResourceNotFoundException", ResourceNotFoundException.fields) {};
export class UnsupportedStreamMediaTypeExceptionError extends Schema.TaggedError<UnsupportedStreamMediaTypeExceptionError>()("UnsupportedStreamMediaTypeException", UnsupportedStreamMediaTypeException.fields) {};
export class InvalidMediaFrameExceptionError extends Schema.TaggedError<InvalidMediaFrameExceptionError>()("InvalidMediaFrameException", InvalidMediaFrameException.fields) {};

//# Operations
export const getHLSStreamingSessionURL = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-09-30", uri: "/getHLSStreamingSessionURL", method: "POST", sdkId: "Kinesis Video Archived Media", sigV4ServiceName: "kinesisvideo", name: "AWSAcuityReader.GetHLSStreamingSessionURL" }, GetHLSStreamingSessionURLInput, GetHLSStreamingSessionURLOutput, [ClientLimitExceededExceptionError, InvalidArgumentExceptionError, InvalidCodecPrivateDataExceptionError, MissingCodecPrivateDataExceptionError, NoDataRetentionExceptionError, NotAuthorizedExceptionError, ResourceNotFoundExceptionError, UnsupportedStreamMediaTypeExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getImages = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-09-30", uri: "/getImages", method: "POST", sdkId: "Kinesis Video Archived Media", sigV4ServiceName: "kinesisvideo", name: "AWSAcuityReader.GetImages" }, GetImagesInput, GetImagesOutput, [ClientLimitExceededExceptionError, InvalidArgumentExceptionError, NoDataRetentionExceptionError, NotAuthorizedExceptionError, ResourceNotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getMediaForFragmentList = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-09-30", uri: "/getMediaForFragmentList", method: "POST", sdkId: "Kinesis Video Archived Media", sigV4ServiceName: "kinesisvideo", name: "AWSAcuityReader.GetMediaForFragmentList" }, GetMediaForFragmentListInput, GetMediaForFragmentListOutput, [ClientLimitExceededExceptionError, InvalidArgumentExceptionError, NotAuthorizedExceptionError, ResourceNotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listFragments = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-09-30", uri: "/listFragments", method: "POST", sdkId: "Kinesis Video Archived Media", sigV4ServiceName: "kinesisvideo", name: "AWSAcuityReader.ListFragments" }, ListFragmentsInput, ListFragmentsOutput, [ClientLimitExceededExceptionError, InvalidArgumentExceptionError, NotAuthorizedExceptionError, ResourceNotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getClip = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-09-30", uri: "/getClip", method: "POST", sdkId: "Kinesis Video Archived Media", sigV4ServiceName: "kinesisvideo", name: "AWSAcuityReader.GetClip" }, GetClipInput, GetClipOutput, [ClientLimitExceededExceptionError, InvalidArgumentExceptionError, InvalidCodecPrivateDataExceptionError, InvalidMediaFrameExceptionError, MissingCodecPrivateDataExceptionError, NoDataRetentionExceptionError, NotAuthorizedExceptionError, ResourceNotFoundExceptionError, UnsupportedStreamMediaTypeExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getDASHStreamingSessionURL = /*#__PURE__*/ makeOperation(() => Operation({ version: "2017-09-30", uri: "/getDASHStreamingSessionURL", method: "POST", sdkId: "Kinesis Video Archived Media", sigV4ServiceName: "kinesisvideo", name: "AWSAcuityReader.GetDASHStreamingSessionURL" }, GetDASHStreamingSessionURLInput, GetDASHStreamingSessionURLOutput, [ClientLimitExceededExceptionError, InvalidArgumentExceptionError, InvalidCodecPrivateDataExceptionError, MissingCodecPrivateDataExceptionError, NoDataRetentionExceptionError, NotAuthorizedExceptionError, ResourceNotFoundExceptionError, UnsupportedStreamMediaTypeExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
