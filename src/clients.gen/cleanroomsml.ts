import { Schema} from "effect"
import { FormatXMLRequest, FormatXMLResponse, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
const TagKeys = Schema.Array(Schema.String)
const ListCollaborationConfiguredModelAlgorithmAssociationsRequest = Schema.Struct({nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), collaborationIdentifier: Schema.String})
const ListCollaborationMLInputChannelsRequest = Schema.Struct({nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), collaborationIdentifier: Schema.String})
const ListCollaborationTrainedModelExportJobsRequest = Schema.Struct({nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), collaborationIdentifier: Schema.String, trainedModelArn: Schema.String, trainedModelVersionIdentifier: Schema.optional(Schema.String)})
const ListCollaborationTrainedModelInferenceJobsRequest = Schema.Struct({nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), collaborationIdentifier: Schema.String, trainedModelArn: Schema.optional(Schema.String), trainedModelVersionIdentifier: Schema.optional(Schema.String)})
const ListCollaborationTrainedModelsRequest = Schema.Struct({nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), collaborationIdentifier: Schema.String})
const ListTagsForResourceRequest = Schema.Struct({resourceArn: Schema.String})
const UntagResourceRequest = Schema.Struct({resourceArn: Schema.String, tagKeys: TagKeys})
const UntagResourceResponse = Schema.Struct({})
const TagMap = Schema.Record({key: Schema.String, value: Schema.String})
const ListTagsForResourceResponse = Schema.Struct({tags: TagMap})
const TagResourceRequest = Schema.Struct({resourceArn: Schema.String, tags: TagMap})
const TagResourceResponse = Schema.Struct({})
const AccessDeniedException = Schema.Struct({message: Schema.String})
export const UntagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/tags/{resourceArn}", method: "DELETE", sdkId: "CleanRoomsML", sigV4ServiceName: "cleanrooms-ml", name: "UntagResource" }, UntagResourceRequest, UntagResourceResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ConfiguredModelAlgorithmAssociationArnList = Schema.Array(Schema.String)
const CollaborationConfiguredModelAlgorithmAssociationSummary = Schema.Struct({createTime: Schema.Date, updateTime: Schema.Date, configuredModelAlgorithmAssociationArn: Schema.String, name: Schema.String, description: Schema.optional(Schema.String), membershipIdentifier: Schema.String, collaborationIdentifier: Schema.String, configuredModelAlgorithmArn: Schema.String, creatorAccountId: Schema.String})
const CollaborationConfiguredModelAlgorithmAssociationList = Schema.Array(CollaborationConfiguredModelAlgorithmAssociationSummary)
const CollaborationMLInputChannelSummary = Schema.Struct({createTime: Schema.Date, updateTime: Schema.Date, membershipIdentifier: Schema.String, collaborationIdentifier: Schema.String, name: Schema.String, configuredModelAlgorithmAssociations: ConfiguredModelAlgorithmAssociationArnList, mlInputChannelArn: Schema.String, status: Schema.String, creatorAccountId: Schema.String, description: Schema.optional(Schema.String)})
const CollaborationMLInputChannelsList = Schema.Array(CollaborationMLInputChannelSummary)
const ListCollaborationConfiguredModelAlgorithmAssociationsResponse = Schema.Struct({nextToken: Schema.optional(Schema.String), collaborationConfiguredModelAlgorithmAssociations: CollaborationConfiguredModelAlgorithmAssociationList})
const ListCollaborationMLInputChannelsResponse = Schema.Struct({nextToken: Schema.optional(Schema.String), collaborationMLInputChannelsList: CollaborationMLInputChannelsList})
export const ListCollaborationMLInputChannels = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/collaborations/{collaborationIdentifier}/ml-input-channels", method: "GET", sdkId: "CleanRoomsML", sigV4ServiceName: "cleanrooms-ml", name: "ListCollaborationMLInputChannels" }, ListCollaborationMLInputChannelsRequest, ListCollaborationMLInputChannelsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ResourceNotFoundException = Schema.Struct({message: Schema.String})
export const ListTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/tags/{resourceArn}", method: "GET", sdkId: "CleanRoomsML", sigV4ServiceName: "cleanrooms-ml", name: "ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ValidationException = Schema.Struct({message: Schema.String})
export const TagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/tags/{resourceArn}", method: "POST", sdkId: "CleanRoomsML", sigV4ServiceName: "cleanrooms-ml", name: "TagResource" }, TagResourceRequest, TagResourceResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const StatusDetails = Schema.Struct({statusCode: Schema.optional(Schema.String), message: Schema.optional(Schema.String)})
const IncrementalTrainingDataChannelOutput = Schema.Struct({channelName: Schema.String, versionIdentifier: Schema.optional(Schema.String), modelName: Schema.String})
const IncrementalTrainingDataChannelsOutput = Schema.Array(IncrementalTrainingDataChannelOutput)
const CollaborationTrainedModelSummary = Schema.Struct({createTime: Schema.Date, updateTime: Schema.Date, trainedModelArn: Schema.String, name: Schema.String, versionIdentifier: Schema.optional(Schema.String), incrementalTrainingDataChannels: Schema.optional(IncrementalTrainingDataChannelsOutput), description: Schema.optional(Schema.String), membershipIdentifier: Schema.String, collaborationIdentifier: Schema.String, status: Schema.String, configuredModelAlgorithmAssociationArn: Schema.String, creatorAccountId: Schema.String})
const CollaborationTrainedModelList = Schema.Array(CollaborationTrainedModelSummary)
const TrainedModelExportReceiverMember = Schema.Struct({accountId: Schema.String})
const TrainedModelExportReceiverMembers = Schema.Array(TrainedModelExportReceiverMember)
const InferenceReceiverMember = Schema.Struct({accountId: Schema.String})
const InferenceReceiverMembers = Schema.Array(InferenceReceiverMember)
const ThrottlingException = Schema.Struct({message: Schema.String})
export const ListCollaborationConfiguredModelAlgorithmAssociations = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/collaborations/{collaborationIdentifier}/configured-model-algorithm-associations", method: "GET", sdkId: "CleanRoomsML", sigV4ServiceName: "cleanrooms-ml", name: "ListCollaborationConfiguredModelAlgorithmAssociations" }, ListCollaborationConfiguredModelAlgorithmAssociationsRequest, ListCollaborationConfiguredModelAlgorithmAssociationsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListCollaborationTrainedModelsResponse = Schema.Struct({nextToken: Schema.optional(Schema.String), collaborationTrainedModels: CollaborationTrainedModelList})
export const ListCollaborationTrainedModels = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/collaborations/{collaborationIdentifier}/trained-models", method: "GET", sdkId: "CleanRoomsML", sigV4ServiceName: "cleanrooms-ml", name: "ListCollaborationTrainedModels" }, ListCollaborationTrainedModelsRequest, ListCollaborationTrainedModelsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TrainedModelExportOutputConfiguration = Schema.Struct({members: TrainedModelExportReceiverMembers})
const InferenceOutputConfiguration = Schema.Struct({accept: Schema.optional(Schema.String), members: InferenceReceiverMembers})
const CollaborationTrainedModelExportJobSummary = Schema.Struct({createTime: Schema.Date, updateTime: Schema.Date, name: Schema.String, outputConfiguration: TrainedModelExportOutputConfiguration, status: Schema.String, statusDetails: Schema.optional(StatusDetails), description: Schema.optional(Schema.String), creatorAccountId: Schema.String, trainedModelArn: Schema.String, trainedModelVersionIdentifier: Schema.optional(Schema.String), membershipIdentifier: Schema.String, collaborationIdentifier: Schema.String})
const CollaborationTrainedModelExportJobList = Schema.Array(CollaborationTrainedModelExportJobSummary)
const CollaborationTrainedModelInferenceJobSummary = Schema.Struct({trainedModelInferenceJobArn: Schema.String, configuredModelAlgorithmAssociationArn: Schema.optional(Schema.String), membershipIdentifier: Schema.String, trainedModelArn: Schema.String, trainedModelVersionIdentifier: Schema.optional(Schema.String), collaborationIdentifier: Schema.String, status: Schema.String, outputConfiguration: InferenceOutputConfiguration, name: Schema.String, description: Schema.optional(Schema.String), metricsStatus: Schema.optional(Schema.String), metricsStatusDetails: Schema.optional(Schema.String), logsStatus: Schema.optional(Schema.String), logsStatusDetails: Schema.optional(Schema.String), createTime: Schema.Date, updateTime: Schema.Date, creatorAccountId: Schema.String})
const CollaborationTrainedModelInferenceJobList = Schema.Array(CollaborationTrainedModelInferenceJobSummary)
const ListCollaborationTrainedModelExportJobsResponse = Schema.Struct({nextToken: Schema.optional(Schema.String), collaborationTrainedModelExportJobs: CollaborationTrainedModelExportJobList})
export const ListCollaborationTrainedModelExportJobs = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/collaborations/{collaborationIdentifier}/trained-models/{trainedModelArn}/export-jobs", method: "GET", sdkId: "CleanRoomsML", sigV4ServiceName: "cleanrooms-ml", name: "ListCollaborationTrainedModelExportJobs" }, ListCollaborationTrainedModelExportJobsRequest, ListCollaborationTrainedModelExportJobsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListCollaborationTrainedModelInferenceJobsResponse = Schema.Struct({nextToken: Schema.optional(Schema.String), collaborationTrainedModelInferenceJobs: CollaborationTrainedModelInferenceJobList})
export const ListCollaborationTrainedModelInferenceJobs = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/collaborations/{collaborationIdentifier}/trained-model-inference-jobs", method: "GET", sdkId: "CleanRoomsML", sigV4ServiceName: "cleanrooms-ml", name: "ListCollaborationTrainedModelInferenceJobs" }, ListCollaborationTrainedModelInferenceJobsRequest, ListCollaborationTrainedModelInferenceJobsResponse, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
