import { Schema} from "effect"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const ExecutionIds = Schema.Array(Schema.String);
export const ConnectorProfileNameList = Schema.Array(Schema.String);
export const ConnectorTypeList = Schema.Array(Schema.String);
export const TagKeyList = Schema.Array(Schema.String);
export const CancelFlowExecutionsRequest = Schema.Struct({flowName: Schema.String, executionIds: Schema.optional(ExecutionIds)});
export const DeleteConnectorProfileRequest = Schema.Struct({connectorProfileName: Schema.String, forceDelete: Schema.optional(Schema.Boolean)});
export const DeleteConnectorProfileResponse = Schema.Struct({});
export const DeleteFlowRequest = Schema.Struct({flowName: Schema.String, forceDelete: Schema.optional(Schema.Boolean)});
export const DeleteFlowResponse = Schema.Struct({});
export const DescribeConnectorRequest = Schema.Struct({connectorType: Schema.String, connectorLabel: Schema.optional(Schema.String)});
export const DescribeConnectorEntityRequest = Schema.Struct({connectorEntityName: Schema.String, connectorType: Schema.optional(Schema.String), connectorProfileName: Schema.optional(Schema.String), apiVersion: Schema.optional(Schema.String)});
export const DescribeConnectorProfilesRequest = Schema.Struct({connectorProfileNames: Schema.optional(ConnectorProfileNameList), connectorType: Schema.optional(Schema.String), connectorLabel: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const DescribeConnectorsRequest = Schema.Struct({connectorTypes: Schema.optional(ConnectorTypeList), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const DescribeFlowRequest = Schema.Struct({flowName: Schema.String});
export const DescribeFlowExecutionRecordsRequest = Schema.Struct({flowName: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListConnectorEntitiesRequest = Schema.Struct({connectorProfileName: Schema.optional(Schema.String), connectorType: Schema.optional(Schema.String), entitiesPath: Schema.optional(Schema.String), apiVersion: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListConnectorsRequest = Schema.Struct({maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListFlowsRequest = Schema.Struct({maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListTagsForResourceRequest = Schema.Struct({resourceArn: Schema.String});
export const ResetConnectorMetadataCacheRequest = Schema.Struct({connectorProfileName: Schema.optional(Schema.String), connectorType: Schema.optional(Schema.String), connectorEntityName: Schema.optional(Schema.String), entitiesPath: Schema.optional(Schema.String), apiVersion: Schema.optional(Schema.String)});
export const ResetConnectorMetadataCacheResponse = Schema.Struct({});
export const StartFlowRequest = Schema.Struct({flowName: Schema.String, clientToken: Schema.optional(Schema.String)});
export const StopFlowRequest = Schema.Struct({flowName: Schema.String});
export const TagMap = Schema.Record({key: Schema.String, value: Schema.String});
export const TagResourceRequest = Schema.Struct({resourceArn: Schema.String, tags: TagMap});
export const TagResourceResponse = Schema.Struct({});
export const UnregisterConnectorRequest = Schema.Struct({connectorLabel: Schema.String, forceDelete: Schema.optional(Schema.Boolean)});
export const UnregisterConnectorResponse = Schema.Struct({});
export const UntagResourceRequest = Schema.Struct({resourceArn: Schema.String, tagKeys: TagKeyList});
export const UntagResourceResponse = Schema.Struct({});
export const AmplitudeConnectorProfileProperties = Schema.Struct({});
export const DatadogConnectorProfileProperties = Schema.Struct({instanceUrl: Schema.String});
export const DynatraceConnectorProfileProperties = Schema.Struct({instanceUrl: Schema.String});
export const GoogleAnalyticsConnectorProfileProperties = Schema.Struct({});
export const HoneycodeConnectorProfileProperties = Schema.Struct({});
export const InforNexusConnectorProfileProperties = Schema.Struct({instanceUrl: Schema.String});
export const MarketoConnectorProfileProperties = Schema.Struct({instanceUrl: Schema.String});
export const RedshiftConnectorProfileProperties = Schema.Struct({databaseUrl: Schema.optional(Schema.String), bucketName: Schema.String, bucketPrefix: Schema.optional(Schema.String), roleArn: Schema.String, dataApiRoleArn: Schema.optional(Schema.String), isRedshiftServerless: Schema.optional(Schema.Boolean), clusterIdentifier: Schema.optional(Schema.String), workgroupName: Schema.optional(Schema.String), databaseName: Schema.optional(Schema.String)});
export const SalesforceConnectorProfileProperties = Schema.Struct({instanceUrl: Schema.optional(Schema.String), isSandboxEnvironment: Schema.optional(Schema.Boolean), usePrivateLinkForMetadataAndAuthorization: Schema.optional(Schema.Boolean)});
export const ServiceNowConnectorProfileProperties = Schema.Struct({instanceUrl: Schema.String});
export const SingularConnectorProfileProperties = Schema.Struct({});
export const SlackConnectorProfileProperties = Schema.Struct({instanceUrl: Schema.String});
export const SnowflakeConnectorProfileProperties = Schema.Struct({warehouse: Schema.String, stage: Schema.String, bucketName: Schema.String, bucketPrefix: Schema.optional(Schema.String), privateLinkServiceName: Schema.optional(Schema.String), accountName: Schema.optional(Schema.String), region: Schema.optional(Schema.String)});
export const TrendmicroConnectorProfileProperties = Schema.Struct({});
export const VeevaConnectorProfileProperties = Schema.Struct({instanceUrl: Schema.String});
export const ZendeskConnectorProfileProperties = Schema.Struct({instanceUrl: Schema.String});
export const OAuthScopeList = Schema.Array(Schema.String);
export const OAuthProperties = Schema.Struct({tokenUrl: Schema.String, authCodeUrl: Schema.String, oAuthScopes: OAuthScopeList});
export const SAPODataConnectorProfileProperties = Schema.Struct({applicationHostUrl: Schema.String, applicationServicePath: Schema.String, portNumber: Schema.Number, clientNumber: Schema.String, logonLanguage: Schema.optional(Schema.String), privateLinkServiceName: Schema.optional(Schema.String), oAuthProperties: Schema.optional(OAuthProperties), disableSSO: Schema.optional(Schema.Boolean)});
export const ProfilePropertiesMap = Schema.Record({key: Schema.String, value: Schema.String});
export const TokenUrlCustomProperties = Schema.Record({key: Schema.String, value: Schema.String});
export const OAuth2Properties = Schema.Struct({tokenUrl: Schema.String, oAuth2GrantType: Schema.String, tokenUrlCustomProperties: Schema.optional(TokenUrlCustomProperties)});
export const CustomConnectorProfileProperties = Schema.Struct({profileProperties: Schema.optional(ProfilePropertiesMap), oAuth2Properties: Schema.optional(OAuth2Properties)});
export const PardotConnectorProfileProperties = Schema.Struct({instanceUrl: Schema.optional(Schema.String), isSandboxEnvironment: Schema.optional(Schema.Boolean), businessUnitId: Schema.optional(Schema.String)});
export const ConnectorProfileProperties = Schema.Struct({Amplitude: Schema.optional(AmplitudeConnectorProfileProperties), Datadog: Schema.optional(DatadogConnectorProfileProperties), Dynatrace: Schema.optional(DynatraceConnectorProfileProperties), GoogleAnalytics: Schema.optional(GoogleAnalyticsConnectorProfileProperties), Honeycode: Schema.optional(HoneycodeConnectorProfileProperties), InforNexus: Schema.optional(InforNexusConnectorProfileProperties), Marketo: Schema.optional(MarketoConnectorProfileProperties), Redshift: Schema.optional(RedshiftConnectorProfileProperties), Salesforce: Schema.optional(SalesforceConnectorProfileProperties), ServiceNow: Schema.optional(ServiceNowConnectorProfileProperties), Singular: Schema.optional(SingularConnectorProfileProperties), Slack: Schema.optional(SlackConnectorProfileProperties), Snowflake: Schema.optional(SnowflakeConnectorProfileProperties), Trendmicro: Schema.optional(TrendmicroConnectorProfileProperties), Veeva: Schema.optional(VeevaConnectorProfileProperties), Zendesk: Schema.optional(ZendeskConnectorProfileProperties), SAPOData: Schema.optional(SAPODataConnectorProfileProperties), CustomConnector: Schema.optional(CustomConnectorProfileProperties), Pardot: Schema.optional(PardotConnectorProfileProperties)});
export const AmplitudeConnectorProfileCredentials = Schema.Struct({apiKey: Schema.String, secretKey: Schema.String});
export const DatadogConnectorProfileCredentials = Schema.Struct({apiKey: Schema.String, applicationKey: Schema.String});
export const DynatraceConnectorProfileCredentials = Schema.Struct({apiToken: Schema.String});
export const ConnectorOAuthRequest = Schema.Struct({authCode: Schema.optional(Schema.String), redirectUri: Schema.optional(Schema.String)});
export const GoogleAnalyticsConnectorProfileCredentials = Schema.Struct({clientId: Schema.String, clientSecret: Schema.String, accessToken: Schema.optional(Schema.String), refreshToken: Schema.optional(Schema.String), oAuthRequest: Schema.optional(ConnectorOAuthRequest)});
export const HoneycodeConnectorProfileCredentials = Schema.Struct({accessToken: Schema.optional(Schema.String), refreshToken: Schema.optional(Schema.String), oAuthRequest: Schema.optional(ConnectorOAuthRequest)});
export const InforNexusConnectorProfileCredentials = Schema.Struct({accessKeyId: Schema.String, userId: Schema.String, secretAccessKey: Schema.String, datakey: Schema.String});
export const MarketoConnectorProfileCredentials = Schema.Struct({clientId: Schema.String, clientSecret: Schema.String, accessToken: Schema.optional(Schema.String), oAuthRequest: Schema.optional(ConnectorOAuthRequest)});
export const RedshiftConnectorProfileCredentials = Schema.Struct({username: Schema.optional(Schema.String), password: Schema.optional(Schema.String)});
export const SalesforceConnectorProfileCredentials = Schema.Struct({accessToken: Schema.optional(Schema.String), refreshToken: Schema.optional(Schema.String), oAuthRequest: Schema.optional(ConnectorOAuthRequest), clientCredentialsArn: Schema.optional(Schema.String), oAuth2GrantType: Schema.optional(Schema.String), jwtToken: Schema.optional(Schema.String)});
export const OAuth2Credentials = Schema.Struct({clientId: Schema.optional(Schema.String), clientSecret: Schema.optional(Schema.String), accessToken: Schema.optional(Schema.String), refreshToken: Schema.optional(Schema.String), oAuthRequest: Schema.optional(ConnectorOAuthRequest)});
export const ServiceNowConnectorProfileCredentials = Schema.Struct({username: Schema.optional(Schema.String), password: Schema.optional(Schema.String), oAuth2Credentials: Schema.optional(OAuth2Credentials)});
export const SingularConnectorProfileCredentials = Schema.Struct({apiKey: Schema.String});
export const SlackConnectorProfileCredentials = Schema.Struct({clientId: Schema.String, clientSecret: Schema.String, accessToken: Schema.optional(Schema.String), oAuthRequest: Schema.optional(ConnectorOAuthRequest)});
export const SnowflakeConnectorProfileCredentials = Schema.Struct({username: Schema.String, password: Schema.String});
export const TrendmicroConnectorProfileCredentials = Schema.Struct({apiSecretKey: Schema.String});
export const VeevaConnectorProfileCredentials = Schema.Struct({username: Schema.String, password: Schema.String});
export const ZendeskConnectorProfileCredentials = Schema.Struct({clientId: Schema.String, clientSecret: Schema.String, accessToken: Schema.optional(Schema.String), oAuthRequest: Schema.optional(ConnectorOAuthRequest)});
export const BasicAuthCredentials = Schema.Struct({username: Schema.String, password: Schema.String});
export const OAuthCredentials = Schema.Struct({clientId: Schema.String, clientSecret: Schema.String, accessToken: Schema.optional(Schema.String), refreshToken: Schema.optional(Schema.String), oAuthRequest: Schema.optional(ConnectorOAuthRequest)});
export const SAPODataConnectorProfileCredentials = Schema.Struct({basicAuthCredentials: Schema.optional(BasicAuthCredentials), oAuthCredentials: Schema.optional(OAuthCredentials)});
export const ApiKeyCredentials = Schema.Struct({apiKey: Schema.String, apiSecretKey: Schema.optional(Schema.String)});
export const CredentialsMap = Schema.Record({key: Schema.String, value: Schema.String});
export const CustomAuthCredentials = Schema.Struct({customAuthenticationType: Schema.String, credentialsMap: Schema.optional(CredentialsMap)});
export const CustomConnectorProfileCredentials = Schema.Struct({authenticationType: Schema.String, basic: Schema.optional(BasicAuthCredentials), oauth2: Schema.optional(OAuth2Credentials), apiKey: Schema.optional(ApiKeyCredentials), custom: Schema.optional(CustomAuthCredentials)});
export const PardotConnectorProfileCredentials = Schema.Struct({accessToken: Schema.optional(Schema.String), refreshToken: Schema.optional(Schema.String), oAuthRequest: Schema.optional(ConnectorOAuthRequest), clientCredentialsArn: Schema.optional(Schema.String)});
export const ConnectorProfileCredentials = Schema.Struct({Amplitude: Schema.optional(AmplitudeConnectorProfileCredentials), Datadog: Schema.optional(DatadogConnectorProfileCredentials), Dynatrace: Schema.optional(DynatraceConnectorProfileCredentials), GoogleAnalytics: Schema.optional(GoogleAnalyticsConnectorProfileCredentials), Honeycode: Schema.optional(HoneycodeConnectorProfileCredentials), InforNexus: Schema.optional(InforNexusConnectorProfileCredentials), Marketo: Schema.optional(MarketoConnectorProfileCredentials), Redshift: Schema.optional(RedshiftConnectorProfileCredentials), Salesforce: Schema.optional(SalesforceConnectorProfileCredentials), ServiceNow: Schema.optional(ServiceNowConnectorProfileCredentials), Singular: Schema.optional(SingularConnectorProfileCredentials), Slack: Schema.optional(SlackConnectorProfileCredentials), Snowflake: Schema.optional(SnowflakeConnectorProfileCredentials), Trendmicro: Schema.optional(TrendmicroConnectorProfileCredentials), Veeva: Schema.optional(VeevaConnectorProfileCredentials), Zendesk: Schema.optional(ZendeskConnectorProfileCredentials), SAPOData: Schema.optional(SAPODataConnectorProfileCredentials), CustomConnector: Schema.optional(CustomConnectorProfileCredentials), Pardot: Schema.optional(PardotConnectorProfileCredentials)});
export const ConnectorProfileConfig = Schema.Struct({connectorProfileProperties: ConnectorProfileProperties, connectorProfileCredentials: Schema.optional(ConnectorProfileCredentials)});
export const UpdateConnectorProfileRequest = Schema.Struct({connectorProfileName: Schema.String, connectionMode: Schema.String, connectorProfileConfig: ConnectorProfileConfig, clientToken: Schema.optional(Schema.String)});
export const LambdaConnectorProvisioningConfig = Schema.Struct({lambdaArn: Schema.String});
export const ConnectorProvisioningConfig = Schema.Struct({lambda: Schema.optional(LambdaConnectorProvisioningConfig)});
export const UpdateConnectorRegistrationRequest = Schema.Struct({connectorLabel: Schema.String, description: Schema.optional(Schema.String), connectorProvisioningConfig: Schema.optional(ConnectorProvisioningConfig), clientToken: Schema.optional(Schema.String)});
export const ScheduledTriggerProperties = Schema.Struct({scheduleExpression: Schema.String, dataPullMode: Schema.optional(Schema.String), scheduleStartTime: Schema.optional(Schema.Date), scheduleEndTime: Schema.optional(Schema.Date), timezone: Schema.optional(Schema.String), scheduleOffset: Schema.optional(Schema.Number), firstExecutionFrom: Schema.optional(Schema.Date), flowErrorDeactivationThreshold: Schema.optional(Schema.Number)});
export const TriggerProperties = Schema.Struct({Scheduled: Schema.optional(ScheduledTriggerProperties)});
export const TriggerConfig = Schema.Struct({triggerType: Schema.String, triggerProperties: Schema.optional(TriggerProperties)});
export const AmplitudeSourceProperties = Schema.Struct({object: Schema.String});
export const DatadogSourceProperties = Schema.Struct({object: Schema.String});
export const DynatraceSourceProperties = Schema.Struct({object: Schema.String});
export const GoogleAnalyticsSourceProperties = Schema.Struct({object: Schema.String});
export const InforNexusSourceProperties = Schema.Struct({object: Schema.String});
export const MarketoSourceProperties = Schema.Struct({object: Schema.String});
export const S3InputFormatConfig = Schema.Struct({s3InputFileType: Schema.optional(Schema.String)});
export const S3SourceProperties = Schema.Struct({bucketName: Schema.String, bucketPrefix: Schema.optional(Schema.String), s3InputFormatConfig: Schema.optional(S3InputFormatConfig)});
export const SalesforceSourceProperties = Schema.Struct({object: Schema.String, enableDynamicFieldUpdate: Schema.optional(Schema.Boolean), includeDeletedRecords: Schema.optional(Schema.Boolean), dataTransferApi: Schema.optional(Schema.String)});
export const ServiceNowSourceProperties = Schema.Struct({object: Schema.String});
export const SingularSourceProperties = Schema.Struct({object: Schema.String});
export const SlackSourceProperties = Schema.Struct({object: Schema.String});
export const TrendmicroSourceProperties = Schema.Struct({object: Schema.String});
export const VeevaSourceProperties = Schema.Struct({object: Schema.String, documentType: Schema.optional(Schema.String), includeSourceFiles: Schema.optional(Schema.Boolean), includeRenditions: Schema.optional(Schema.Boolean), includeAllVersions: Schema.optional(Schema.Boolean)});
export const ZendeskSourceProperties = Schema.Struct({object: Schema.String});
export const SAPODataParallelismConfig = Schema.Struct({maxParallelism: Schema.Number});
export const SAPODataPaginationConfig = Schema.Struct({maxPageSize: Schema.Number});
export const SAPODataSourceProperties = Schema.Struct({objectPath: Schema.optional(Schema.String), parallelismConfig: Schema.optional(SAPODataParallelismConfig), paginationConfig: Schema.optional(SAPODataPaginationConfig)});
export const CustomProperties = Schema.Record({key: Schema.String, value: Schema.String});
export const DataTransferApi = Schema.Struct({Name: Schema.optional(Schema.String), Type: Schema.optional(Schema.String)});
export const CustomConnectorSourceProperties = Schema.Struct({entityName: Schema.String, customProperties: Schema.optional(CustomProperties), dataTransferApi: Schema.optional(DataTransferApi)});
export const PardotSourceProperties = Schema.Struct({object: Schema.String});
export const SourceConnectorProperties = Schema.Struct({Amplitude: Schema.optional(AmplitudeSourceProperties), Datadog: Schema.optional(DatadogSourceProperties), Dynatrace: Schema.optional(DynatraceSourceProperties), GoogleAnalytics: Schema.optional(GoogleAnalyticsSourceProperties), InforNexus: Schema.optional(InforNexusSourceProperties), Marketo: Schema.optional(MarketoSourceProperties), S3: Schema.optional(S3SourceProperties), Salesforce: Schema.optional(SalesforceSourceProperties), ServiceNow: Schema.optional(ServiceNowSourceProperties), Singular: Schema.optional(SingularSourceProperties), Slack: Schema.optional(SlackSourceProperties), Trendmicro: Schema.optional(TrendmicroSourceProperties), Veeva: Schema.optional(VeevaSourceProperties), Zendesk: Schema.optional(ZendeskSourceProperties), SAPOData: Schema.optional(SAPODataSourceProperties), CustomConnector: Schema.optional(CustomConnectorSourceProperties), Pardot: Schema.optional(PardotSourceProperties)});
export const IncrementalPullConfig = Schema.Struct({datetimeTypeFieldName: Schema.optional(Schema.String)});
export const SourceFlowConfig = Schema.Struct({connectorType: Schema.String, apiVersion: Schema.optional(Schema.String), connectorProfileName: Schema.optional(Schema.String), sourceConnectorProperties: SourceConnectorProperties, incrementalPullConfig: Schema.optional(IncrementalPullConfig)});
export const ErrorHandlingConfig = Schema.Struct({failOnFirstDestinationError: Schema.optional(Schema.Boolean), bucketPrefix: Schema.optional(Schema.String), bucketName: Schema.optional(Schema.String)});
export const RedshiftDestinationProperties = Schema.Struct({object: Schema.String, intermediateBucketName: Schema.String, bucketPrefix: Schema.optional(Schema.String), errorHandlingConfig: Schema.optional(ErrorHandlingConfig)});
export const PathPrefixHierarchy = Schema.Array(Schema.String);
export const PrefixConfig = Schema.Struct({prefixType: Schema.optional(Schema.String), prefixFormat: Schema.optional(Schema.String), pathPrefixHierarchy: Schema.optional(PathPrefixHierarchy)});
export const AggregationConfig = Schema.Struct({aggregationType: Schema.optional(Schema.String), targetFileSize: Schema.optional(Schema.Number)});
export const S3OutputFormatConfig = Schema.Struct({fileType: Schema.optional(Schema.String), prefixConfig: Schema.optional(PrefixConfig), aggregationConfig: Schema.optional(AggregationConfig), preserveSourceDataTyping: Schema.optional(Schema.Boolean)});
export const S3DestinationProperties = Schema.Struct({bucketName: Schema.String, bucketPrefix: Schema.optional(Schema.String), s3OutputFormatConfig: Schema.optional(S3OutputFormatConfig)});
export const IdFieldNameList = Schema.Array(Schema.String);
export const SalesforceDestinationProperties = Schema.Struct({object: Schema.String, idFieldNames: Schema.optional(IdFieldNameList), errorHandlingConfig: Schema.optional(ErrorHandlingConfig), writeOperationType: Schema.optional(Schema.String), dataTransferApi: Schema.optional(Schema.String)});
export const SnowflakeDestinationProperties = Schema.Struct({object: Schema.String, intermediateBucketName: Schema.String, bucketPrefix: Schema.optional(Schema.String), errorHandlingConfig: Schema.optional(ErrorHandlingConfig)});
export const EventBridgeDestinationProperties = Schema.Struct({object: Schema.String, errorHandlingConfig: Schema.optional(ErrorHandlingConfig)});
export const LookoutMetricsDestinationProperties = Schema.Struct({});
export const UpsolverS3OutputFormatConfig = Schema.Struct({fileType: Schema.optional(Schema.String), prefixConfig: PrefixConfig, aggregationConfig: Schema.optional(AggregationConfig)});
export const UpsolverDestinationProperties = Schema.Struct({bucketName: Schema.String, bucketPrefix: Schema.optional(Schema.String), s3OutputFormatConfig: UpsolverS3OutputFormatConfig});
export const HoneycodeDestinationProperties = Schema.Struct({object: Schema.String, errorHandlingConfig: Schema.optional(ErrorHandlingConfig)});
export const CustomerProfilesDestinationProperties = Schema.Struct({domainName: Schema.String, objectTypeName: Schema.optional(Schema.String)});
export const ZendeskDestinationProperties = Schema.Struct({object: Schema.String, idFieldNames: Schema.optional(IdFieldNameList), errorHandlingConfig: Schema.optional(ErrorHandlingConfig), writeOperationType: Schema.optional(Schema.String)});
export const MarketoDestinationProperties = Schema.Struct({object: Schema.String, errorHandlingConfig: Schema.optional(ErrorHandlingConfig)});
export const CustomConnectorDestinationProperties = Schema.Struct({entityName: Schema.String, errorHandlingConfig: Schema.optional(ErrorHandlingConfig), writeOperationType: Schema.optional(Schema.String), idFieldNames: Schema.optional(IdFieldNameList), customProperties: Schema.optional(CustomProperties)});
export const SuccessResponseHandlingConfig = Schema.Struct({bucketPrefix: Schema.optional(Schema.String), bucketName: Schema.optional(Schema.String)});
export const SAPODataDestinationProperties = Schema.Struct({objectPath: Schema.String, successResponseHandlingConfig: Schema.optional(SuccessResponseHandlingConfig), idFieldNames: Schema.optional(IdFieldNameList), errorHandlingConfig: Schema.optional(ErrorHandlingConfig), writeOperationType: Schema.optional(Schema.String)});
export const DestinationConnectorProperties = Schema.Struct({Redshift: Schema.optional(RedshiftDestinationProperties), S3: Schema.optional(S3DestinationProperties), Salesforce: Schema.optional(SalesforceDestinationProperties), Snowflake: Schema.optional(SnowflakeDestinationProperties), EventBridge: Schema.optional(EventBridgeDestinationProperties), LookoutMetrics: Schema.optional(LookoutMetricsDestinationProperties), Upsolver: Schema.optional(UpsolverDestinationProperties), Honeycode: Schema.optional(HoneycodeDestinationProperties), CustomerProfiles: Schema.optional(CustomerProfilesDestinationProperties), Zendesk: Schema.optional(ZendeskDestinationProperties), Marketo: Schema.optional(MarketoDestinationProperties), CustomConnector: Schema.optional(CustomConnectorDestinationProperties), SAPOData: Schema.optional(SAPODataDestinationProperties)});
export const DestinationFlowConfig = Schema.Struct({connectorType: Schema.String, apiVersion: Schema.optional(Schema.String), connectorProfileName: Schema.optional(Schema.String), destinationConnectorProperties: DestinationConnectorProperties});
export const DestinationFlowConfigList = Schema.Array(DestinationFlowConfig);
export const SourceFields = Schema.Array(Schema.String);
export const ConnectorOperator = Schema.Struct({Amplitude: Schema.optional(Schema.String), Datadog: Schema.optional(Schema.String), Dynatrace: Schema.optional(Schema.String), GoogleAnalytics: Schema.optional(Schema.String), InforNexus: Schema.optional(Schema.String), Marketo: Schema.optional(Schema.String), S3: Schema.optional(Schema.String), Salesforce: Schema.optional(Schema.String), ServiceNow: Schema.optional(Schema.String), Singular: Schema.optional(Schema.String), Slack: Schema.optional(Schema.String), Trendmicro: Schema.optional(Schema.String), Veeva: Schema.optional(Schema.String), Zendesk: Schema.optional(Schema.String), SAPOData: Schema.optional(Schema.String), CustomConnector: Schema.optional(Schema.String), Pardot: Schema.optional(Schema.String)});
export const TaskPropertiesMap = Schema.Record({key: Schema.String, value: Schema.String});
export const Task = Schema.Struct({sourceFields: SourceFields, connectorOperator: Schema.optional(ConnectorOperator), destinationField: Schema.optional(Schema.String), taskType: Schema.String, taskProperties: Schema.optional(TaskPropertiesMap)});
export const Tasks = Schema.Array(Task);
export const GlueDataCatalogConfig = Schema.Struct({roleArn: Schema.String, databaseName: Schema.String, tablePrefix: Schema.String});
export const MetadataCatalogConfig = Schema.Struct({glueDataCatalog: Schema.optional(GlueDataCatalogConfig)});
export const UpdateFlowRequest = Schema.Struct({flowName: Schema.String, description: Schema.optional(Schema.String), triggerConfig: TriggerConfig, sourceFlowConfig: SourceFlowConfig, destinationFlowConfigList: DestinationFlowConfigList, tasks: Tasks, metadataCatalogConfig: Schema.optional(MetadataCatalogConfig), clientToken: Schema.optional(Schema.String)});
export const CancelFlowExecutionsResponse = Schema.Struct({invalidExecutions: Schema.optional(ExecutionIds)});
export const ConflictException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InternalServerException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ConnectorModeList = Schema.Array(Schema.String);
export const SupportedDataTransferTypeList = Schema.Array(Schema.String);
export const ConnectorDetail = Schema.Struct({connectorDescription: Schema.optional(Schema.String), connectorName: Schema.optional(Schema.String), connectorOwner: Schema.optional(Schema.String), connectorVersion: Schema.optional(Schema.String), applicationType: Schema.optional(Schema.String), connectorType: Schema.optional(Schema.String), connectorLabel: Schema.optional(Schema.String), registeredAt: Schema.optional(Schema.Date), registeredBy: Schema.optional(Schema.String), connectorProvisioningType: Schema.optional(Schema.String), connectorModes: Schema.optional(ConnectorModeList), supportedDataTransferTypes: Schema.optional(SupportedDataTransferTypeList)});
export const ConnectorList = Schema.Array(ConnectorDetail);
export const ListConnectorsResponse = Schema.Struct({connectors: Schema.optional(ConnectorList), nextToken: Schema.optional(Schema.String)});
export const ListTagsForResourceResponse = Schema.Struct({tags: Schema.optional(TagMap)});
export const ResourceNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const StartFlowResponse = Schema.Struct({flowArn: Schema.optional(Schema.String), flowStatus: Schema.optional(Schema.String), executionId: Schema.optional(Schema.String)});
export const StopFlowResponse = Schema.Struct({flowArn: Schema.optional(Schema.String), flowStatus: Schema.optional(Schema.String)});
export const ValidationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdateConnectorProfileResponse = Schema.Struct({connectorProfileArn: Schema.optional(Schema.String)});
export const UpdateConnectorRegistrationResponse = Schema.Struct({connectorArn: Schema.optional(Schema.String)});
export const UpdateFlowResponse = Schema.Struct({flowStatus: Schema.optional(Schema.String)});
export const SchedulingFrequencyTypeList = Schema.Array(Schema.String);
export const TriggerTypeList = Schema.Array(Schema.String);
export const SupportedApiVersionList = Schema.Array(Schema.String);
export const SupportedOperatorList = Schema.Array(Schema.String);
export const SupportedWriteOperationList = Schema.Array(Schema.String);
export const AmplitudeMetadata = Schema.Struct({});
export const DatadogMetadata = Schema.Struct({});
export const DynatraceMetadata = Schema.Struct({});
export const GoogleAnalyticsMetadata = Schema.Struct({oAuthScopes: Schema.optional(OAuthScopeList)});
export const InforNexusMetadata = Schema.Struct({});
export const MarketoMetadata = Schema.Struct({});
export const RedshiftMetadata = Schema.Struct({});
export const S3Metadata = Schema.Struct({});
export const SalesforceDataTransferApiList = Schema.Array(Schema.String);
export const OAuth2GrantTypeSupportedList = Schema.Array(Schema.String);
export const SalesforceMetadata = Schema.Struct({oAuthScopes: Schema.optional(OAuthScopeList), dataTransferApis: Schema.optional(SalesforceDataTransferApiList), oauth2GrantTypesSupported: Schema.optional(OAuth2GrantTypeSupportedList)});
export const ServiceNowMetadata = Schema.Struct({});
export const SingularMetadata = Schema.Struct({});
export const SlackMetadata = Schema.Struct({oAuthScopes: Schema.optional(OAuthScopeList)});
export const RegionList = Schema.Array(Schema.String);
export const SnowflakeMetadata = Schema.Struct({supportedRegions: Schema.optional(RegionList)});
export const TrendmicroMetadata = Schema.Struct({});
export const VeevaMetadata = Schema.Struct({});
export const ZendeskMetadata = Schema.Struct({oAuthScopes: Schema.optional(OAuthScopeList)});
export const EventBridgeMetadata = Schema.Struct({});
export const UpsolverMetadata = Schema.Struct({});
export const CustomerProfilesMetadata = Schema.Struct({});
export const HoneycodeMetadata = Schema.Struct({oAuthScopes: Schema.optional(OAuthScopeList)});
export const SAPODataMetadata = Schema.Struct({});
export const PardotMetadata = Schema.Struct({});
export const ConnectorMetadata = Schema.Struct({Amplitude: Schema.optional(AmplitudeMetadata), Datadog: Schema.optional(DatadogMetadata), Dynatrace: Schema.optional(DynatraceMetadata), GoogleAnalytics: Schema.optional(GoogleAnalyticsMetadata), InforNexus: Schema.optional(InforNexusMetadata), Marketo: Schema.optional(MarketoMetadata), Redshift: Schema.optional(RedshiftMetadata), S3: Schema.optional(S3Metadata), Salesforce: Schema.optional(SalesforceMetadata), ServiceNow: Schema.optional(ServiceNowMetadata), Singular: Schema.optional(SingularMetadata), Slack: Schema.optional(SlackMetadata), Snowflake: Schema.optional(SnowflakeMetadata), Trendmicro: Schema.optional(TrendmicroMetadata), Veeva: Schema.optional(VeevaMetadata), Zendesk: Schema.optional(ZendeskMetadata), EventBridge: Schema.optional(EventBridgeMetadata), Upsolver: Schema.optional(UpsolverMetadata), CustomerProfiles: Schema.optional(CustomerProfilesMetadata), Honeycode: Schema.optional(HoneycodeMetadata), SAPOData: Schema.optional(SAPODataMetadata), Pardot: Schema.optional(PardotMetadata)});
export const TokenUrlList = Schema.Array(Schema.String);
export const AuthCodeUrlList = Schema.Array(Schema.String);
export const ConnectorSuppliedValueList = Schema.Array(Schema.String);
export const OAuth2CustomParameter = Schema.Struct({key: Schema.optional(Schema.String), isRequired: Schema.optional(Schema.Boolean), label: Schema.optional(Schema.String), description: Schema.optional(Schema.String), isSensitiveField: Schema.optional(Schema.Boolean), connectorSuppliedValues: Schema.optional(ConnectorSuppliedValueList), type: Schema.optional(Schema.String)});
export const OAuth2CustomPropertiesList = Schema.Array(OAuth2CustomParameter);
export const OAuth2Defaults = Schema.Struct({oauthScopes: Schema.optional(OAuthScopeList), tokenUrls: Schema.optional(TokenUrlList), authCodeUrls: Schema.optional(AuthCodeUrlList), oauth2GrantTypesSupported: Schema.optional(OAuth2GrantTypeSupportedList), oauth2CustomProperties: Schema.optional(OAuth2CustomPropertiesList)});
export const AuthParameter = Schema.Struct({key: Schema.optional(Schema.String), isRequired: Schema.optional(Schema.Boolean), label: Schema.optional(Schema.String), description: Schema.optional(Schema.String), isSensitiveField: Schema.optional(Schema.Boolean), connectorSuppliedValues: Schema.optional(ConnectorSuppliedValueList)});
export const AuthParameterList = Schema.Array(AuthParameter);
export const CustomAuthConfig = Schema.Struct({customAuthenticationType: Schema.optional(Schema.String), authParameters: Schema.optional(AuthParameterList)});
export const CustomAuthConfigList = Schema.Array(CustomAuthConfig);
export const AuthenticationConfig = Schema.Struct({isBasicAuthSupported: Schema.optional(Schema.Boolean), isApiKeyAuthSupported: Schema.optional(Schema.Boolean), isOAuth2Supported: Schema.optional(Schema.Boolean), isCustomAuthSupported: Schema.optional(Schema.Boolean), oAuth2Defaults: Schema.optional(OAuth2Defaults), customAuthConfigs: Schema.optional(CustomAuthConfigList)});
export const ConnectorSuppliedValueOptionList = Schema.Array(Schema.String);
export const ConnectorRuntimeSetting = Schema.Struct({key: Schema.optional(Schema.String), dataType: Schema.optional(Schema.String), isRequired: Schema.optional(Schema.Boolean), label: Schema.optional(Schema.String), description: Schema.optional(Schema.String), scope: Schema.optional(Schema.String), connectorSuppliedValueOptions: Schema.optional(ConnectorSuppliedValueOptionList)});
export const ConnectorRuntimeSettingList = Schema.Array(ConnectorRuntimeSetting);
export const SupportedDataTransferApis = Schema.Array(DataTransferApi);
export const ConnectorConfiguration = Schema.Struct({canUseAsSource: Schema.optional(Schema.Boolean), canUseAsDestination: Schema.optional(Schema.Boolean), supportedDestinationConnectors: Schema.optional(ConnectorTypeList), supportedSchedulingFrequencies: Schema.optional(SchedulingFrequencyTypeList), isPrivateLinkEnabled: Schema.optional(Schema.Boolean), isPrivateLinkEndpointUrlRequired: Schema.optional(Schema.Boolean), supportedTriggerTypes: Schema.optional(TriggerTypeList), connectorMetadata: Schema.optional(ConnectorMetadata), connectorType: Schema.optional(Schema.String), connectorLabel: Schema.optional(Schema.String), connectorDescription: Schema.optional(Schema.String), connectorOwner: Schema.optional(Schema.String), connectorName: Schema.optional(Schema.String), connectorVersion: Schema.optional(Schema.String), connectorArn: Schema.optional(Schema.String), connectorModes: Schema.optional(ConnectorModeList), authenticationConfig: Schema.optional(AuthenticationConfig), connectorRuntimeSettings: Schema.optional(ConnectorRuntimeSettingList), supportedApiVersions: Schema.optional(SupportedApiVersionList), supportedOperators: Schema.optional(SupportedOperatorList), supportedWriteOperations: Schema.optional(SupportedWriteOperationList), connectorProvisioningType: Schema.optional(Schema.String), connectorProvisioningConfig: Schema.optional(ConnectorProvisioningConfig), logoURL: Schema.optional(Schema.String), registeredAt: Schema.optional(Schema.Date), registeredBy: Schema.optional(Schema.String), supportedDataTransferTypes: Schema.optional(SupportedDataTransferTypeList), supportedDataTransferApis: Schema.optional(SupportedDataTransferApis)});
export const ConnectorConfigurationsMap = Schema.Record({key: Schema.String, value: ConnectorConfiguration});
export const ExecutionDetails = Schema.Struct({mostRecentExecutionMessage: Schema.optional(Schema.String), mostRecentExecutionTime: Schema.optional(Schema.Date), mostRecentExecutionStatus: Schema.optional(Schema.String)});
export const FlowDefinition = Schema.Struct({flowArn: Schema.optional(Schema.String), description: Schema.optional(Schema.String), flowName: Schema.optional(Schema.String), flowStatus: Schema.optional(Schema.String), sourceConnectorType: Schema.optional(Schema.String), sourceConnectorLabel: Schema.optional(Schema.String), destinationConnectorType: Schema.optional(Schema.String), destinationConnectorLabel: Schema.optional(Schema.String), triggerType: Schema.optional(Schema.String), createdAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), createdBy: Schema.optional(Schema.String), lastUpdatedBy: Schema.optional(Schema.String), tags: Schema.optional(TagMap), lastRunExecutionDetails: Schema.optional(ExecutionDetails)});
export const FlowList = Schema.Array(FlowDefinition);
export const AccessDeniedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeConnectorsResponse = Schema.Struct({connectorConfigurations: Schema.optional(ConnectorConfigurationsMap), connectors: Schema.optional(ConnectorList), nextToken: Schema.optional(Schema.String)});
export const ListFlowsResponse = Schema.Struct({flows: Schema.optional(FlowList), nextToken: Schema.optional(Schema.String)});
export const RegisterConnectorRequest = Schema.Struct({connectorLabel: Schema.optional(Schema.String), description: Schema.optional(Schema.String), connectorProvisioningType: Schema.optional(Schema.String), connectorProvisioningConfig: Schema.optional(ConnectorProvisioningConfig), clientToken: Schema.optional(Schema.String)});
export const ServiceQuotaExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UnsupportedOperationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ConnectorAuthenticationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ConnectorServerException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SourceFieldProperties = Schema.Struct({isRetrievable: Schema.optional(Schema.Boolean), isQueryable: Schema.optional(Schema.Boolean), isTimestampFieldForIncrementalQueries: Schema.optional(Schema.Boolean)});
export const DestinationFieldProperties = Schema.Struct({isCreatable: Schema.optional(Schema.Boolean), isNullable: Schema.optional(Schema.Boolean), isUpsertable: Schema.optional(Schema.Boolean), isUpdatable: Schema.optional(Schema.Boolean), isDefaultedOnCreate: Schema.optional(Schema.Boolean), supportedWriteOperations: Schema.optional(SupportedWriteOperationList)});
export const PrivateConnectionProvisioningState = Schema.Struct({status: Schema.optional(Schema.String), failureMessage: Schema.optional(Schema.String), failureCause: Schema.optional(Schema.String)});
export const RegistrationOutput = Schema.Struct({message: Schema.optional(Schema.String), result: Schema.optional(Schema.String), status: Schema.optional(Schema.String)});
export const ConnectorEntity = Schema.Struct({name: Schema.String, label: Schema.optional(Schema.String), hasNestedEntities: Schema.optional(Schema.Boolean)});
export const ConnectorEntityList = Schema.Array(ConnectorEntity);
export const FilterOperatorList = Schema.Array(Schema.String);
export const SupportedValueList = Schema.Array(Schema.String);
export const ConnectorProfile = Schema.Struct({connectorProfileArn: Schema.optional(Schema.String), connectorProfileName: Schema.optional(Schema.String), connectorType: Schema.optional(Schema.String), connectorLabel: Schema.optional(Schema.String), connectionMode: Schema.optional(Schema.String), credentialsArn: Schema.optional(Schema.String), connectorProfileProperties: Schema.optional(ConnectorProfileProperties), createdAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), privateConnectionProvisioningState: Schema.optional(PrivateConnectionProvisioningState)});
export const ConnectorProfileDetailList = Schema.Array(ConnectorProfile);
export const MetadataCatalogDetail = Schema.Struct({catalogType: Schema.optional(Schema.String), tableName: Schema.optional(Schema.String), tableRegistrationOutput: Schema.optional(RegistrationOutput), partitionRegistrationOutput: Schema.optional(RegistrationOutput)});
export const MetadataCatalogDetails = Schema.Array(MetadataCatalogDetail);
export const ConnectorEntityMap = Schema.Record({key: Schema.String, value: ConnectorEntityList});
export const ErrorInfo = Schema.Struct({putFailuresCount: Schema.optional(Schema.Number), executionMessage: Schema.optional(Schema.String)});
export const ThrottlingException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeConnectorProfilesResponse = Schema.Struct({connectorProfileDetails: Schema.optional(ConnectorProfileDetailList), nextToken: Schema.optional(Schema.String)});
export const DescribeFlowResponse = Schema.Struct({flowArn: Schema.optional(Schema.String), description: Schema.optional(Schema.String), flowName: Schema.optional(Schema.String), kmsArn: Schema.optional(Schema.String), flowStatus: Schema.optional(Schema.String), flowStatusMessage: Schema.optional(Schema.String), sourceFlowConfig: Schema.optional(SourceFlowConfig), destinationFlowConfigList: Schema.optional(DestinationFlowConfigList), lastRunExecutionDetails: Schema.optional(ExecutionDetails), triggerConfig: Schema.optional(TriggerConfig), tasks: Schema.optional(Tasks), createdAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), createdBy: Schema.optional(Schema.String), lastUpdatedBy: Schema.optional(Schema.String), tags: Schema.optional(TagMap), metadataCatalogConfig: Schema.optional(MetadataCatalogConfig), lastRunMetadataCatalogDetails: Schema.optional(MetadataCatalogDetails), schemaVersion: Schema.optional(Schema.Number)});
export const ListConnectorEntitiesResponse = Schema.Struct({connectorEntityMap: ConnectorEntityMap, nextToken: Schema.optional(Schema.String)});
export const RegisterConnectorResponse = Schema.Struct({connectorArn: Schema.optional(Schema.String)});
export const ExecutionResult = Schema.Struct({errorInfo: Schema.optional(ErrorInfo), bytesProcessed: Schema.optional(Schema.Number), bytesWritten: Schema.optional(Schema.Number), recordsProcessed: Schema.optional(Schema.Number), numParallelProcesses: Schema.optional(Schema.Number), maxPageSize: Schema.optional(Schema.Number)});
export const Range = Schema.Struct({maximum: Schema.optional(Schema.Number), minimum: Schema.optional(Schema.Number)});
export const ExecutionRecord = Schema.Struct({executionId: Schema.optional(Schema.String), executionStatus: Schema.optional(Schema.String), executionResult: Schema.optional(ExecutionResult), startedAt: Schema.optional(Schema.Date), lastUpdatedAt: Schema.optional(Schema.Date), dataPullStartTime: Schema.optional(Schema.Date), dataPullEndTime: Schema.optional(Schema.Date), metadataCatalogDetails: Schema.optional(MetadataCatalogDetails)});
export const FlowExecutionList = Schema.Array(ExecutionRecord);
export const FieldTypeDetails = Schema.Struct({fieldType: Schema.String, filterOperators: FilterOperatorList, supportedValues: Schema.optional(SupportedValueList), valueRegexPattern: Schema.optional(Schema.String), supportedDateFormat: Schema.optional(Schema.String), fieldValueRange: Schema.optional(Range), fieldLengthRange: Schema.optional(Range)});
export const DescribeFlowExecutionRecordsResponse = Schema.Struct({flowExecutions: Schema.optional(FlowExecutionList), nextToken: Schema.optional(Schema.String)});
export const SupportedFieldTypeDetails = Schema.Struct({v1: FieldTypeDetails});
export const ConnectorEntityField = Schema.Struct({identifier: Schema.String, parentIdentifier: Schema.optional(Schema.String), label: Schema.optional(Schema.String), isPrimaryKey: Schema.optional(Schema.Boolean), defaultValue: Schema.optional(Schema.String), isDeprecated: Schema.optional(Schema.Boolean), supportedFieldTypeDetails: Schema.optional(SupportedFieldTypeDetails), description: Schema.optional(Schema.String), sourceProperties: Schema.optional(SourceFieldProperties), destinationProperties: Schema.optional(DestinationFieldProperties), customProperties: Schema.optional(CustomProperties)});
export const ConnectorEntityFieldList = Schema.Array(ConnectorEntityField);
export const CreateConnectorProfileRequest = Schema.Struct({connectorProfileName: Schema.String, kmsArn: Schema.optional(Schema.String), connectorType: Schema.String, connectorLabel: Schema.optional(Schema.String), connectionMode: Schema.String, connectorProfileConfig: ConnectorProfileConfig, clientToken: Schema.optional(Schema.String)});
export const CreateFlowRequest = Schema.Struct({flowName: Schema.String, description: Schema.optional(Schema.String), kmsArn: Schema.optional(Schema.String), triggerConfig: TriggerConfig, sourceFlowConfig: SourceFlowConfig, destinationFlowConfigList: DestinationFlowConfigList, tasks: Tasks, tags: Schema.optional(TagMap), metadataCatalogConfig: Schema.optional(MetadataCatalogConfig), clientToken: Schema.optional(Schema.String)});
export const DescribeConnectorResponse = Schema.Struct({connectorConfiguration: Schema.optional(ConnectorConfiguration)});
export const DescribeConnectorEntityResponse = Schema.Struct({connectorEntityFields: ConnectorEntityFieldList});
export const CreateConnectorProfileResponse = Schema.Struct({connectorProfileArn: Schema.optional(Schema.String)});
export const CreateFlowResponse = Schema.Struct({flowArn: Schema.optional(Schema.String), flowStatus: Schema.optional(Schema.String)});

//# Errors
export class ConflictExceptionError extends Schema.TaggedError<ConflictExceptionError>()("ConflictException", ConflictException) {};
export class InternalServerExceptionError extends Schema.TaggedError<InternalServerExceptionError>()("InternalServerException", InternalServerException) {};
export class ResourceNotFoundExceptionError extends Schema.TaggedError<ResourceNotFoundExceptionError>()("ResourceNotFoundException", ResourceNotFoundException) {};
export class ValidationExceptionError extends Schema.TaggedError<ValidationExceptionError>()("ValidationException", ValidationException) {};
export class AccessDeniedExceptionError extends Schema.TaggedError<AccessDeniedExceptionError>()("AccessDeniedException", AccessDeniedException) {};
export class ConnectorAuthenticationExceptionError extends Schema.TaggedError<ConnectorAuthenticationExceptionError>()("ConnectorAuthenticationException", ConnectorAuthenticationException) {};
export class ConnectorServerExceptionError extends Schema.TaggedError<ConnectorServerExceptionError>()("ConnectorServerException", ConnectorServerException) {};
export class ServiceQuotaExceededExceptionError extends Schema.TaggedError<ServiceQuotaExceededExceptionError>()("ServiceQuotaExceededException", ServiceQuotaExceededException) {};
export class UnsupportedOperationExceptionError extends Schema.TaggedError<UnsupportedOperationExceptionError>()("UnsupportedOperationException", UnsupportedOperationException) {};
export class ThrottlingExceptionError extends Schema.TaggedError<ThrottlingExceptionError>()("ThrottlingException", ThrottlingException) {};

//# Operations
export const unregisterConnector = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/unregister-connector", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.UnregisterConnector" }, UnregisterConnectorRequest, UnregisterConnectorResponse, [ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const untagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/tags/{resourceArn}", method: "DELETE", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.UntagResource" }, UntagResourceRequest, UntagResourceResponse, [InternalServerExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteConnectorProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/delete-connector-profile", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.DeleteConnectorProfile" }, DeleteConnectorProfileRequest, DeleteConnectorProfileResponse, [ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteFlow = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/delete-flow", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.DeleteFlow" }, DeleteFlowRequest, DeleteFlowResponse, [ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listConnectors = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/list-connectors", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.ListConnectors" }, ListConnectorsRequest, ListConnectorsResponse, [InternalServerExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/tags/{resourceArn}", method: "GET", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, [InternalServerExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const resetConnectorMetadataCache = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/reset-connector-metadata-cache", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.ResetConnectorMetadataCache" }, ResetConnectorMetadataCacheRequest, ResetConnectorMetadataCacheResponse, [ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const tagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/tags/{resourceArn}", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.TagResource" }, TagResourceRequest, TagResourceResponse, [InternalServerExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateFlow = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/update-flow", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.UpdateFlow" }, UpdateFlowRequest, UpdateFlowResponse, [AccessDeniedExceptionError, ConflictExceptionError, ConnectorAuthenticationExceptionError, ConnectorServerExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeConnectors = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/describe-connectors", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.DescribeConnectors" }, DescribeConnectorsRequest, DescribeConnectorsResponse, [InternalServerExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listFlows = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/list-flows", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.ListFlows" }, ListFlowsRequest, ListFlowsResponse, [InternalServerExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const startFlow = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/start-flow", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.StartFlow" }, StartFlowRequest, StartFlowResponse, [ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const stopFlow = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/stop-flow", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.StopFlow" }, StopFlowRequest, StopFlowResponse, [ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, UnsupportedOperationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateConnectorProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/update-connector-profile", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.UpdateConnectorProfile" }, UpdateConnectorProfileRequest, UpdateConnectorProfileResponse, [ConflictExceptionError, ConnectorAuthenticationExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateConnectorRegistration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/update-connector-registration", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.UpdateConnectorRegistration" }, UpdateConnectorRegistrationRequest, UpdateConnectorRegistrationResponse, [AccessDeniedExceptionError, ConflictExceptionError, ConnectorAuthenticationExceptionError, ConnectorServerExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const cancelFlowExecutions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/cancel-flow-executions", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.CancelFlowExecutions" }, CancelFlowExecutionsRequest, CancelFlowExecutionsResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeConnectorProfiles = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/describe-connector-profiles", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.DescribeConnectorProfiles" }, DescribeConnectorProfilesRequest, DescribeConnectorProfilesResponse, [InternalServerExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeFlow = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/describe-flow", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.DescribeFlow" }, DescribeFlowRequest, DescribeFlowResponse, [InternalServerExceptionError, ResourceNotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listConnectorEntities = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/list-connector-entities", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.ListConnectorEntities" }, ListConnectorEntitiesRequest, ListConnectorEntitiesResponse, [ConnectorAuthenticationExceptionError, ConnectorServerExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const registerConnector = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/register-connector", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.RegisterConnector" }, RegisterConnectorRequest, RegisterConnectorResponse, [AccessDeniedExceptionError, ConflictExceptionError, ConnectorAuthenticationExceptionError, ConnectorServerExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeFlowExecutionRecords = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/describe-flow-execution-records", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.DescribeFlowExecutionRecords" }, DescribeFlowExecutionRecordsRequest, DescribeFlowExecutionRecordsResponse, [InternalServerExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeConnector = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/describe-connector", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.DescribeConnector" }, DescribeConnectorRequest, DescribeConnectorResponse, [InternalServerExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const describeConnectorEntity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/describe-connector-entity", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.DescribeConnectorEntity" }, DescribeConnectorEntityRequest, DescribeConnectorEntityResponse, [ConnectorAuthenticationExceptionError, ConnectorServerExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createConnectorProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/create-connector-profile", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.CreateConnectorProfile" }, CreateConnectorProfileRequest, CreateConnectorProfileResponse, [ConflictExceptionError, ConnectorAuthenticationExceptionError, InternalServerExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createFlow = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-08-23", uri: "/create-flow", method: "POST", sdkId: "Appflow", sigV4ServiceName: "appflow", name: "SandstoneConfigurationServiceLambda.CreateFlow" }, CreateFlowRequest, CreateFlowResponse, [AccessDeniedExceptionError, ConflictExceptionError, ConnectorAuthenticationExceptionError, ConnectorServerExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
