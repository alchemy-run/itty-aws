import { Schema} from "effect"
import { FormatXMLRequest,FormatXMLResponse,FormatAwsXMLError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const FieldList = Schema.Array(Schema.String);
export const AssociateAliasRequest = Schema.Struct({TargetDistributionId: Schema.String, Alias: Schema.String});
export const AssociateDistributionTenantWebACLRequest = Schema.Struct({Id: Schema.String, WebACLArn: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const AssociateDistributionWebACLRequest = Schema.Struct({Id: Schema.String, WebACLArn: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const CopyDistributionRequest = Schema.Struct({PrimaryDistributionId: Schema.String, Staging: Schema.optional(Header("Staging", Schema.Boolean)), IfMatch: Schema.optional(Header("If-Match")), CallerReference: Schema.String, Enabled: Schema.optional(Schema.Boolean)});
export const Tag = Schema.Struct({Key: Schema.String, Value: Schema.optional(Schema.String)});
export const TagList = Schema.Array(Tag);
export const Tags = Schema.Struct({Items: Schema.optional(TagList)});
export const CreateConnectionGroupRequest = Schema.Struct({Name: Schema.String, Ipv6Enabled: Schema.optional(Schema.Boolean), Tags: Schema.optional(Tags), AnycastIpListId: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean)});
export const PathList = Schema.Array(Schema.String);
export const Paths = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(PathList)});
export const InvalidationBatch = Schema.Struct({Paths: Paths, CallerReference: Schema.String});
export const CreateInvalidationForDistributionTenantRequest = Schema.Struct({Id: Schema.String, InvalidationBatch: Body("InvalidationBatch", InvalidationBatch)});
export const DeleteAnycastIpListRequest = Schema.Struct({Id: Schema.String, IfMatch: Header("If-Match")});
export const DeleteCachePolicyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteCloudFrontOriginAccessIdentityRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteConnectionGroupRequest = Schema.Struct({Id: Schema.String, IfMatch: Header("If-Match")});
export const DeleteContinuousDeploymentPolicyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteDistributionRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteDistributionTenantRequest = Schema.Struct({Id: Schema.String, IfMatch: Header("If-Match")});
export const DeleteFieldLevelEncryptionConfigRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteFieldLevelEncryptionProfileRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteFunctionRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match")});
export const DeleteKeyGroupRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteKeyValueStoreRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match")});
export const DeleteMonitoringSubscriptionRequest = Schema.Struct({DistributionId: Schema.String});
export const DeleteMonitoringSubscriptionResult = Schema.Struct({});
export const DeleteOriginAccessControlRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteOriginRequestPolicyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeletePublicKeyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteRealtimeLogConfigRequest = Schema.Struct({Name: Schema.optional(Schema.String), ARN: Schema.optional(Schema.String)});
export const DeleteResourcePolicyRequest = Schema.Struct({ResourceArn: Schema.String});
export const DeleteResponseHeadersPolicyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteStreamingDistributionRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteVpcOriginRequest = Schema.Struct({Id: Schema.String, IfMatch: Header("If-Match")});
export const DescribeFunctionRequest = Schema.Struct({Name: Schema.String, Stage: Schema.optional(Schema.String)});
export const DescribeKeyValueStoreRequest = Schema.Struct({Name: Schema.String});
export const DisassociateDistributionTenantWebACLRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DisassociateDistributionWebACLRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const GetAnycastIpListRequest = Schema.Struct({Id: Schema.String});
export const GetCachePolicyRequest = Schema.Struct({Id: Schema.String});
export const GetCachePolicyConfigRequest = Schema.Struct({Id: Schema.String});
export const GetCloudFrontOriginAccessIdentityRequest = Schema.Struct({Id: Schema.String});
export const GetCloudFrontOriginAccessIdentityConfigRequest = Schema.Struct({Id: Schema.String});
export const GetConnectionGroupRequest = Schema.Struct({Identifier: Schema.String});
export const GetConnectionGroupByRoutingEndpointRequest = Schema.Struct({RoutingEndpoint: Schema.String});
export const GetContinuousDeploymentPolicyRequest = Schema.Struct({Id: Schema.String});
export const GetContinuousDeploymentPolicyConfigRequest = Schema.Struct({Id: Schema.String});
export const GetDistributionRequest = Schema.Struct({Id: Schema.String});
export const GetDistributionConfigRequest = Schema.Struct({Id: Schema.String});
export const GetDistributionTenantRequest = Schema.Struct({Identifier: Schema.String});
export const GetDistributionTenantByDomainRequest = Schema.Struct({Domain: Schema.String});
export const GetFieldLevelEncryptionRequest = Schema.Struct({Id: Schema.String});
export const GetFieldLevelEncryptionConfigRequest = Schema.Struct({Id: Schema.String});
export const GetFieldLevelEncryptionProfileRequest = Schema.Struct({Id: Schema.String});
export const GetFieldLevelEncryptionProfileConfigRequest = Schema.Struct({Id: Schema.String});
export const GetFunctionRequest = Schema.Struct({Name: Schema.String, Stage: Schema.optional(Schema.String)});
export const GetInvalidationRequest = Schema.Struct({DistributionId: Schema.String, Id: Schema.String});
export const GetInvalidationForDistributionTenantRequest = Schema.Struct({DistributionTenantId: Schema.String, Id: Schema.String});
export const GetKeyGroupRequest = Schema.Struct({Id: Schema.String});
export const GetKeyGroupConfigRequest = Schema.Struct({Id: Schema.String});
export const GetManagedCertificateDetailsRequest = Schema.Struct({Identifier: Schema.String});
export const GetMonitoringSubscriptionRequest = Schema.Struct({DistributionId: Schema.String});
export const GetOriginAccessControlRequest = Schema.Struct({Id: Schema.String});
export const GetOriginAccessControlConfigRequest = Schema.Struct({Id: Schema.String});
export const GetOriginRequestPolicyRequest = Schema.Struct({Id: Schema.String});
export const GetOriginRequestPolicyConfigRequest = Schema.Struct({Id: Schema.String});
export const GetPublicKeyRequest = Schema.Struct({Id: Schema.String});
export const GetPublicKeyConfigRequest = Schema.Struct({Id: Schema.String});
export const GetRealtimeLogConfigRequest = Schema.Struct({Name: Schema.optional(Schema.String), ARN: Schema.optional(Schema.String)});
export const GetResourcePolicyRequest = Schema.Struct({ResourceArn: Schema.String});
export const GetResponseHeadersPolicyRequest = Schema.Struct({Id: Schema.String});
export const GetResponseHeadersPolicyConfigRequest = Schema.Struct({Id: Schema.String});
export const GetStreamingDistributionRequest = Schema.Struct({Id: Schema.String});
export const GetStreamingDistributionConfigRequest = Schema.Struct({Id: Schema.String});
export const GetVpcOriginRequest = Schema.Struct({Id: Schema.String});
export const ListAnycastIpListsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListCachePoliciesRequest = Schema.Struct({Type: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListCloudFrontOriginAccessIdentitiesRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListConflictingAliasesRequest = Schema.Struct({DistributionId: Schema.String, Alias: Schema.String, Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListContinuousDeploymentPoliciesRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListDistributionsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListDistributionsByAnycastIpListIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), AnycastIpListId: Schema.String});
export const ListDistributionsByCachePolicyIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), CachePolicyId: Schema.String});
export const ListDistributionsByConnectionModeRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), ConnectionMode: Schema.String});
export const ListDistributionsByKeyGroupRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), KeyGroupId: Schema.String});
export const ListDistributionsByOriginRequestPolicyIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), OriginRequestPolicyId: Schema.String});
export const ListDistributionsByOwnedResourceRequest = Schema.Struct({ResourceArn: Schema.String, Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListDistributionsByRealtimeLogConfigRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), RealtimeLogConfigName: Schema.optional(Schema.String), RealtimeLogConfigArn: Schema.optional(Schema.String)});
export const ListDistributionsByResponseHeadersPolicyIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), ResponseHeadersPolicyId: Schema.String});
export const ListDistributionsByVpcOriginIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), VpcOriginId: Schema.String});
export const ListDistributionsByWebACLIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), WebACLId: Schema.String});
export const ListDistributionTenantsByCustomizationRequest = Schema.Struct({WebACLArn: Schema.optional(Schema.String), CertificateArn: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListFieldLevelEncryptionConfigsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListFieldLevelEncryptionProfilesRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListFunctionsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), Stage: Schema.optional(Schema.String)});
export const ListInvalidationsRequest = Schema.Struct({DistributionId: Schema.String, Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListInvalidationsForDistributionTenantRequest = Schema.Struct({Id: Schema.String, Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListKeyGroupsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListKeyValueStoresRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), Status: Schema.optional(Schema.String)});
export const ListOriginAccessControlsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListOriginRequestPoliciesRequest = Schema.Struct({Type: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListPublicKeysRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListRealtimeLogConfigsRequest = Schema.Struct({MaxItems: Schema.optional(Schema.Number), Marker: Schema.optional(Schema.String)});
export const ListResponseHeadersPoliciesRequest = Schema.Struct({Type: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListStreamingDistributionsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListTagsForResourceRequest = Schema.Struct({Resource: Schema.String});
export const ListVpcOriginsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const PublishFunctionRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match")});
export const PutResourcePolicyRequest = Schema.Struct({ResourceArn: Schema.String, PolicyDocument: Schema.String});
export const TagResourceRequest = Schema.Struct({Resource: Schema.String, Tags: Body("Tags", Tags)});
export const TestFunctionRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match"), Stage: Schema.optional(Schema.String), EventObject: StreamBody()});
export const UpdateAnycastIpListRequest = Schema.Struct({Id: Schema.String, IpAddressType: Schema.optional(Schema.String), IfMatch: Header("If-Match")});
export const HeaderList = Schema.Array(Schema.String);
export const Headers = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(HeaderList)});
export const CachePolicyHeadersConfig = Schema.Struct({HeaderBehavior: Schema.String, Headers: Schema.optional(Headers)});
export const CookieNameList = Schema.Array(Schema.String);
export const CookieNames = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(CookieNameList)});
export const CachePolicyCookiesConfig = Schema.Struct({CookieBehavior: Schema.String, Cookies: Schema.optional(CookieNames)});
export const QueryStringNamesList = Schema.Array(Schema.String);
export const QueryStringNames = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(QueryStringNamesList)});
export const CachePolicyQueryStringsConfig = Schema.Struct({QueryStringBehavior: Schema.String, QueryStrings: Schema.optional(QueryStringNames)});
export const ParametersInCacheKeyAndForwardedToOrigin = Schema.Struct({EnableAcceptEncodingGzip: Schema.Boolean, EnableAcceptEncodingBrotli: Schema.optional(Schema.Boolean), HeadersConfig: CachePolicyHeadersConfig, CookiesConfig: CachePolicyCookiesConfig, QueryStringsConfig: CachePolicyQueryStringsConfig});
export const CachePolicyConfig = Schema.Struct({Comment: Schema.optional(Schema.String), Name: Schema.String, DefaultTTL: Schema.optional(Schema.Number), MaxTTL: Schema.optional(Schema.Number), MinTTL: Schema.Number, ParametersInCacheKeyAndForwardedToOrigin: Schema.optional(ParametersInCacheKeyAndForwardedToOrigin)});
export const UpdateCachePolicyRequest = Schema.Struct({CachePolicyConfig: Body("CachePolicyConfig", CachePolicyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const CloudFrontOriginAccessIdentityConfig = Schema.Struct({CallerReference: Schema.String, Comment: Schema.String});
export const UpdateCloudFrontOriginAccessIdentityRequest = Schema.Struct({CloudFrontOriginAccessIdentityConfig: Body("CloudFrontOriginAccessIdentityConfig", CloudFrontOriginAccessIdentityConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const UpdateConnectionGroupRequest = Schema.Struct({Id: Schema.String, Ipv6Enabled: Schema.optional(Schema.Boolean), IfMatch: Header("If-Match"), AnycastIpListId: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean)});
export const StagingDistributionDnsNameList = Schema.Array(Schema.String);
export const StagingDistributionDnsNames = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(StagingDistributionDnsNameList)});
export const SessionStickinessConfig = Schema.Struct({IdleTTL: Schema.Number, MaximumTTL: Schema.Number});
export const ContinuousDeploymentSingleWeightConfig = Schema.Struct({Weight: Schema.Number, SessionStickinessConfig: Schema.optional(SessionStickinessConfig)});
export const ContinuousDeploymentSingleHeaderConfig = Schema.Struct({Header: Schema.String, Value: Schema.String});
export const TrafficConfig = Schema.Struct({SingleWeightConfig: Schema.optional(ContinuousDeploymentSingleWeightConfig), SingleHeaderConfig: Schema.optional(ContinuousDeploymentSingleHeaderConfig), Type: Schema.String});
export const ContinuousDeploymentPolicyConfig = Schema.Struct({StagingDistributionDnsNames: StagingDistributionDnsNames, Enabled: Schema.Boolean, TrafficConfig: Schema.optional(TrafficConfig)});
export const UpdateContinuousDeploymentPolicyRequest = Schema.Struct({ContinuousDeploymentPolicyConfig: Body("ContinuousDeploymentPolicyConfig", ContinuousDeploymentPolicyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const AliasList = Schema.Array(Schema.String);
export const Aliases = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(AliasList)});
export const OriginCustomHeader = Schema.Struct({HeaderName: Schema.String, HeaderValue: Schema.String});
export const OriginCustomHeadersList = Schema.Array(OriginCustomHeader);
export const CustomHeaders = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(OriginCustomHeadersList)});
export const S3OriginConfig = Schema.Struct({OriginAccessIdentity: Schema.String, OriginReadTimeout: Schema.optional(Schema.Number)});
export const SslProtocolsList = Schema.Array(Schema.String);
export const OriginSslProtocols = Schema.Struct({Quantity: Schema.Number, Items: SslProtocolsList});
export const CustomOriginConfig = Schema.Struct({HTTPPort: Schema.Number, HTTPSPort: Schema.Number, OriginProtocolPolicy: Schema.String, OriginSslProtocols: Schema.optional(OriginSslProtocols), OriginReadTimeout: Schema.optional(Schema.Number), OriginKeepaliveTimeout: Schema.optional(Schema.Number), IpAddressType: Schema.optional(Schema.String)});
export const VpcOriginConfig = Schema.Struct({VpcOriginId: Schema.String, OwnerAccountId: Schema.optional(Schema.String), OriginReadTimeout: Schema.optional(Schema.Number), OriginKeepaliveTimeout: Schema.optional(Schema.Number)});
export const OriginShield = Schema.Struct({Enabled: Schema.Boolean, OriginShieldRegion: Schema.optional(Schema.String)});
export const Origin = Schema.Struct({Id: Schema.String, DomainName: Schema.String, OriginPath: Schema.optional(Schema.String), CustomHeaders: Schema.optional(CustomHeaders), S3OriginConfig: Schema.optional(S3OriginConfig), CustomOriginConfig: Schema.optional(CustomOriginConfig), VpcOriginConfig: Schema.optional(VpcOriginConfig), ConnectionAttempts: Schema.optional(Schema.Number), ConnectionTimeout: Schema.optional(Schema.Number), ResponseCompletionTimeout: Schema.optional(Schema.Number), OriginShield: Schema.optional(OriginShield), OriginAccessControlId: Schema.optional(Schema.String)});
export const OriginList = Schema.Array(Origin);
export const Origins = Schema.Struct({Quantity: Schema.Number, Items: OriginList});
export const StatusCodeList = Schema.Array(Schema.Number);
export const StatusCodes = Schema.Struct({Quantity: Schema.Number, Items: StatusCodeList});
export const OriginGroupFailoverCriteria = Schema.Struct({StatusCodes: StatusCodes});
export const OriginGroupMember = Schema.Struct({OriginId: Schema.String});
export const OriginGroupMemberList = Schema.Array(OriginGroupMember);
export const OriginGroupMembers = Schema.Struct({Quantity: Schema.Number, Items: OriginGroupMemberList});
export const OriginGroup = Schema.Struct({Id: Schema.String, FailoverCriteria: OriginGroupFailoverCriteria, Members: OriginGroupMembers, SelectionCriteria: Schema.optional(Schema.String)});
export const OriginGroupList = Schema.Array(OriginGroup);
export const OriginGroups = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(OriginGroupList)});
export const AwsAccountNumberList = Schema.Array(Schema.String);
export const TrustedSigners = Schema.Struct({Enabled: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(AwsAccountNumberList)});
export const TrustedKeyGroupIdList = Schema.Array(Schema.String);
export const TrustedKeyGroups = Schema.Struct({Enabled: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(TrustedKeyGroupIdList)});
export const MethodsList = Schema.Array(Schema.String);
export const CachedMethods = Schema.Struct({Quantity: Schema.Number, Items: MethodsList});
export const AllowedMethods = Schema.Struct({Quantity: Schema.Number, Items: MethodsList, CachedMethods: Schema.optional(CachedMethods)});
export const LambdaFunctionAssociation = Schema.Struct({LambdaFunctionARN: Schema.String, EventType: Schema.String, IncludeBody: Schema.optional(Schema.Boolean)});
export const LambdaFunctionAssociationList = Schema.Array(LambdaFunctionAssociation);
export const LambdaFunctionAssociations = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(LambdaFunctionAssociationList)});
export const FunctionAssociation = Schema.Struct({FunctionARN: Schema.String, EventType: Schema.String});
export const FunctionAssociationList = Schema.Array(FunctionAssociation);
export const FunctionAssociations = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(FunctionAssociationList)});
export const GrpcConfig = Schema.Struct({Enabled: Schema.Boolean});
export const CookiePreference = Schema.Struct({Forward: Schema.String, WhitelistedNames: Schema.optional(CookieNames)});
export const QueryStringCacheKeysList = Schema.Array(Schema.String);
export const QueryStringCacheKeys = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(QueryStringCacheKeysList)});
export const ForwardedValues = Schema.Struct({QueryString: Schema.Boolean, Cookies: CookiePreference, Headers: Schema.optional(Headers), QueryStringCacheKeys: Schema.optional(QueryStringCacheKeys)});
export const DefaultCacheBehavior = Schema.Struct({TargetOriginId: Schema.String, TrustedSigners: Schema.optional(TrustedSigners), TrustedKeyGroups: Schema.optional(TrustedKeyGroups), ViewerProtocolPolicy: Schema.String, AllowedMethods: Schema.optional(AllowedMethods), SmoothStreaming: Schema.optional(Schema.Boolean), Compress: Schema.optional(Schema.Boolean), LambdaFunctionAssociations: Schema.optional(LambdaFunctionAssociations), FunctionAssociations: Schema.optional(FunctionAssociations), FieldLevelEncryptionId: Schema.optional(Schema.String), RealtimeLogConfigArn: Schema.optional(Schema.String), CachePolicyId: Schema.optional(Schema.String), OriginRequestPolicyId: Schema.optional(Schema.String), ResponseHeadersPolicyId: Schema.optional(Schema.String), GrpcConfig: Schema.optional(GrpcConfig), ForwardedValues: Schema.optional(ForwardedValues), MinTTL: Schema.optional(Schema.Number), DefaultTTL: Schema.optional(Schema.Number), MaxTTL: Schema.optional(Schema.Number)});
export const CacheBehavior = Schema.Struct({PathPattern: Schema.String, TargetOriginId: Schema.String, TrustedSigners: Schema.optional(TrustedSigners), TrustedKeyGroups: Schema.optional(TrustedKeyGroups), ViewerProtocolPolicy: Schema.String, AllowedMethods: Schema.optional(AllowedMethods), SmoothStreaming: Schema.optional(Schema.Boolean), Compress: Schema.optional(Schema.Boolean), LambdaFunctionAssociations: Schema.optional(LambdaFunctionAssociations), FunctionAssociations: Schema.optional(FunctionAssociations), FieldLevelEncryptionId: Schema.optional(Schema.String), RealtimeLogConfigArn: Schema.optional(Schema.String), CachePolicyId: Schema.optional(Schema.String), OriginRequestPolicyId: Schema.optional(Schema.String), ResponseHeadersPolicyId: Schema.optional(Schema.String), GrpcConfig: Schema.optional(GrpcConfig), ForwardedValues: Schema.optional(ForwardedValues), MinTTL: Schema.optional(Schema.Number), DefaultTTL: Schema.optional(Schema.Number), MaxTTL: Schema.optional(Schema.Number)});
export const CacheBehaviorList = Schema.Array(CacheBehavior);
export const CacheBehaviors = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(CacheBehaviorList)});
export const CustomErrorResponse = Schema.Struct({ErrorCode: Schema.Number, ResponsePagePath: Schema.optional(Schema.String), ResponseCode: Schema.optional(Schema.String), ErrorCachingMinTTL: Schema.optional(Schema.Number)});
export const CustomErrorResponseList = Schema.Array(CustomErrorResponse);
export const CustomErrorResponses = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(CustomErrorResponseList)});
export const LoggingConfig = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), IncludeCookies: Schema.optional(Schema.Boolean), Bucket: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String)});
export const ViewerCertificate = Schema.Struct({CloudFrontDefaultCertificate: Schema.optional(Schema.Boolean), IAMCertificateId: Schema.optional(Schema.String), ACMCertificateArn: Schema.optional(Schema.String), SSLSupportMethod: Schema.optional(Schema.String), MinimumProtocolVersion: Schema.optional(Schema.String), Certificate: Schema.optional(Schema.String), CertificateSource: Schema.optional(Schema.String)});
export const LocationList = Schema.Array(Schema.String);
export const GeoRestriction = Schema.Struct({RestrictionType: Schema.String, Quantity: Schema.Number, Items: Schema.optional(LocationList)});
export const Restrictions = Schema.Struct({GeoRestriction: GeoRestriction});
export const StringSchemaConfig = Schema.Struct({Comment: Schema.optional(Schema.String), DefaultValue: Schema.optional(Schema.String), Required: Schema.Boolean});
export const ParameterDefinitionSchema = Schema.Struct({StringSchema: Schema.optional(StringSchemaConfig)});
export const ParameterDefinition = Schema.Struct({Name: Schema.String, Definition: ParameterDefinitionSchema});
export const ParameterDefinitions = Schema.Array(ParameterDefinition);
export const TenantConfig = Schema.Struct({ParameterDefinitions: Schema.optional(ParameterDefinitions)});
export const DistributionConfig = Schema.Struct({CallerReference: Schema.String, Aliases: Schema.optional(Aliases), DefaultRootObject: Schema.optional(Schema.String), Origins: Origins, OriginGroups: Schema.optional(OriginGroups), DefaultCacheBehavior: DefaultCacheBehavior, CacheBehaviors: Schema.optional(CacheBehaviors), CustomErrorResponses: Schema.optional(CustomErrorResponses), Comment: Schema.String, Logging: Schema.optional(LoggingConfig), PriceClass: Schema.optional(Schema.String), Enabled: Schema.Boolean, ViewerCertificate: Schema.optional(ViewerCertificate), Restrictions: Schema.optional(Restrictions), WebACLId: Schema.optional(Schema.String), HttpVersion: Schema.optional(Schema.String), IsIPV6Enabled: Schema.optional(Schema.Boolean), ContinuousDeploymentPolicyId: Schema.optional(Schema.String), Staging: Schema.optional(Schema.Boolean), AnycastIpListId: Schema.optional(Schema.String), TenantConfig: Schema.optional(TenantConfig), ConnectionMode: Schema.optional(Schema.String)});
export const UpdateDistributionRequest = Schema.Struct({DistributionConfig: Body("DistributionConfig", DistributionConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DomainItem = Schema.Struct({Domain: Schema.String});
export const DomainList = Schema.Array(DomainItem);
export const WebAclCustomization = Schema.Struct({Action: Schema.String, Arn: Schema.optional(Schema.String)});
export const Certificate = Schema.Struct({Arn: Schema.String});
export const GeoRestrictionCustomization = Schema.Struct({RestrictionType: Schema.String, Locations: Schema.optional(LocationList)});
export const Customizations = Schema.Struct({WebAcl: Schema.optional(WebAclCustomization), Certificate: Schema.optional(Certificate), GeoRestrictions: Schema.optional(GeoRestrictionCustomization)});
export const Parameter = Schema.Struct({Name: Schema.String, Value: Schema.String});
export const Parameters = Schema.Array(Parameter);
export const ManagedCertificateRequest = Schema.Struct({ValidationTokenHost: Schema.String, PrimaryDomainName: Schema.optional(Schema.String), CertificateTransparencyLoggingPreference: Schema.optional(Schema.String)});
export const UpdateDistributionTenantRequest = Schema.Struct({Id: Schema.String, DistributionId: Schema.optional(Schema.String), Domains: Schema.optional(DomainList), Customizations: Schema.optional(Customizations), Parameters: Schema.optional(Parameters), ConnectionGroupId: Schema.optional(Schema.String), IfMatch: Header("If-Match"), ManagedCertificateRequest: Schema.optional(ManagedCertificateRequest), Enabled: Schema.optional(Schema.Boolean)});
export const UpdateDistributionWithStagingConfigRequest = Schema.Struct({Id: Schema.String, StagingDistributionId: Schema.optional(Schema.String), IfMatch: Schema.optional(Header("If-Match"))});
export const DistributionResourceId = Schema.Struct({DistributionId: Schema.optional(Schema.String), DistributionTenantId: Schema.optional(Schema.String)});
export const UpdateDomainAssociationRequest = Schema.Struct({Domain: Schema.String, TargetResource: DistributionResourceId, IfMatch: Schema.optional(Header("If-Match"))});
export const QueryArgProfile = Schema.Struct({QueryArg: Schema.String, ProfileId: Schema.String});
export const QueryArgProfileList = Schema.Array(QueryArgProfile);
export const QueryArgProfiles = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(QueryArgProfileList)});
export const QueryArgProfileConfig = Schema.Struct({ForwardWhenQueryArgProfileIsUnknown: Schema.Boolean, QueryArgProfiles: Schema.optional(QueryArgProfiles)});
export const ContentTypeProfile = Schema.Struct({Format: Schema.String, ProfileId: Schema.optional(Schema.String), ContentType: Schema.String});
export const ContentTypeProfileList = Schema.Array(ContentTypeProfile);
export const ContentTypeProfiles = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(ContentTypeProfileList)});
export const ContentTypeProfileConfig = Schema.Struct({ForwardWhenContentTypeIsUnknown: Schema.Boolean, ContentTypeProfiles: Schema.optional(ContentTypeProfiles)});
export const FieldLevelEncryptionConfig = Schema.Struct({CallerReference: Schema.String, Comment: Schema.optional(Schema.String), QueryArgProfileConfig: Schema.optional(QueryArgProfileConfig), ContentTypeProfileConfig: Schema.optional(ContentTypeProfileConfig)});
export const UpdateFieldLevelEncryptionConfigRequest = Schema.Struct({FieldLevelEncryptionConfig: Body("FieldLevelEncryptionConfig", FieldLevelEncryptionConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const FieldPatternList = Schema.Array(Schema.String);
export const FieldPatterns = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(FieldPatternList)});
export const EncryptionEntity = Schema.Struct({PublicKeyId: Schema.String, ProviderId: Schema.String, FieldPatterns: FieldPatterns});
export const EncryptionEntityList = Schema.Array(EncryptionEntity);
export const EncryptionEntities = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(EncryptionEntityList)});
export const FieldLevelEncryptionProfileConfig = Schema.Struct({Name: Schema.String, CallerReference: Schema.String, Comment: Schema.optional(Schema.String), EncryptionEntities: EncryptionEntities});
export const UpdateFieldLevelEncryptionProfileRequest = Schema.Struct({FieldLevelEncryptionProfileConfig: Body("FieldLevelEncryptionProfileConfig", FieldLevelEncryptionProfileConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const KeyValueStoreAssociation = Schema.Struct({KeyValueStoreARN: Schema.String});
export const KeyValueStoreAssociationList = Schema.Array(KeyValueStoreAssociation);
export const KeyValueStoreAssociations = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(KeyValueStoreAssociationList)});
export const FunctionConfig = Schema.Struct({Comment: Schema.String, Runtime: Schema.String, KeyValueStoreAssociations: Schema.optional(KeyValueStoreAssociations)});
export const UpdateFunctionRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match"), FunctionConfig: FunctionConfig, FunctionCode: StreamBody()});
export const PublicKeyIdList = Schema.Array(Schema.String);
export const KeyGroupConfig = Schema.Struct({Name: Schema.String, Items: PublicKeyIdList, Comment: Schema.optional(Schema.String)});
export const UpdateKeyGroupRequest = Schema.Struct({KeyGroupConfig: Body("KeyGroupConfig", KeyGroupConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const UpdateKeyValueStoreRequest = Schema.Struct({Name: Schema.String, Comment: Schema.String, IfMatch: Header("If-Match")});
export const OriginAccessControlConfig = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), SigningProtocol: Schema.String, SigningBehavior: Schema.String, OriginAccessControlOriginType: Schema.String});
export const UpdateOriginAccessControlRequest = Schema.Struct({OriginAccessControlConfig: Body("OriginAccessControlConfig", OriginAccessControlConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const OriginRequestPolicyHeadersConfig = Schema.Struct({HeaderBehavior: Schema.String, Headers: Schema.optional(Headers)});
export const OriginRequestPolicyCookiesConfig = Schema.Struct({CookieBehavior: Schema.String, Cookies: Schema.optional(CookieNames)});
export const OriginRequestPolicyQueryStringsConfig = Schema.Struct({QueryStringBehavior: Schema.String, QueryStrings: Schema.optional(QueryStringNames)});
export const OriginRequestPolicyConfig = Schema.Struct({Comment: Schema.optional(Schema.String), Name: Schema.String, HeadersConfig: OriginRequestPolicyHeadersConfig, CookiesConfig: OriginRequestPolicyCookiesConfig, QueryStringsConfig: OriginRequestPolicyQueryStringsConfig});
export const UpdateOriginRequestPolicyRequest = Schema.Struct({OriginRequestPolicyConfig: Body("OriginRequestPolicyConfig", OriginRequestPolicyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const PublicKeyConfig = Schema.Struct({CallerReference: Schema.String, Name: Schema.String, EncodedKey: Schema.String, Comment: Schema.optional(Schema.String)});
export const UpdatePublicKeyRequest = Schema.Struct({PublicKeyConfig: Body("PublicKeyConfig", PublicKeyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const KinesisStreamConfig = Schema.Struct({RoleARN: Schema.String, StreamARN: Schema.String});
export const EndPoint = Schema.Struct({StreamType: Schema.String, KinesisStreamConfig: Schema.optional(KinesisStreamConfig)});
export const EndPointList = Schema.Array(EndPoint);
export const UpdateRealtimeLogConfigRequest = Schema.Struct({EndPoints: Schema.optional(EndPointList), Fields: Schema.optional(FieldList), Name: Schema.optional(Schema.String), ARN: Schema.optional(Schema.String), SamplingRate: Schema.optional(Schema.Number)});
export const AccessControlAllowOriginsList = Schema.Array(Schema.String);
export const ResponseHeadersPolicyAccessControlAllowOrigins = Schema.Struct({Quantity: Schema.Number, Items: AccessControlAllowOriginsList});
export const AccessControlAllowHeadersList = Schema.Array(Schema.String);
export const ResponseHeadersPolicyAccessControlAllowHeaders = Schema.Struct({Quantity: Schema.Number, Items: AccessControlAllowHeadersList});
export const AccessControlAllowMethodsList = Schema.Array(Schema.String);
export const ResponseHeadersPolicyAccessControlAllowMethods = Schema.Struct({Quantity: Schema.Number, Items: AccessControlAllowMethodsList});
export const AccessControlExposeHeadersList = Schema.Array(Schema.String);
export const ResponseHeadersPolicyAccessControlExposeHeaders = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(AccessControlExposeHeadersList)});
export const ResponseHeadersPolicyCorsConfig = Schema.Struct({AccessControlAllowOrigins: ResponseHeadersPolicyAccessControlAllowOrigins, AccessControlAllowHeaders: ResponseHeadersPolicyAccessControlAllowHeaders, AccessControlAllowMethods: ResponseHeadersPolicyAccessControlAllowMethods, AccessControlAllowCredentials: Schema.Boolean, AccessControlExposeHeaders: Schema.optional(ResponseHeadersPolicyAccessControlExposeHeaders), AccessControlMaxAgeSec: Schema.optional(Schema.Number), OriginOverride: Schema.Boolean});
export const ResponseHeadersPolicyXSSProtection = Schema.Struct({Override: Schema.Boolean, Protection: Schema.Boolean, ModeBlock: Schema.optional(Schema.Boolean), ReportUri: Schema.optional(Schema.String)});
export const ResponseHeadersPolicyFrameOptions = Schema.Struct({Override: Schema.Boolean, FrameOption: Schema.String});
export const ResponseHeadersPolicyReferrerPolicy = Schema.Struct({Override: Schema.Boolean, ReferrerPolicy: Schema.String});
export const ResponseHeadersPolicyContentSecurityPolicy = Schema.Struct({Override: Schema.Boolean, ContentSecurityPolicy: Schema.String});
export const ResponseHeadersPolicyContentTypeOptions = Schema.Struct({Override: Schema.Boolean});
export const ResponseHeadersPolicyStrictTransportSecurity = Schema.Struct({Override: Schema.Boolean, IncludeSubdomains: Schema.optional(Schema.Boolean), Preload: Schema.optional(Schema.Boolean), AccessControlMaxAgeSec: Schema.Number});
export const ResponseHeadersPolicySecurityHeadersConfig = Schema.Struct({XSSProtection: Schema.optional(ResponseHeadersPolicyXSSProtection), FrameOptions: Schema.optional(ResponseHeadersPolicyFrameOptions), ReferrerPolicy: Schema.optional(ResponseHeadersPolicyReferrerPolicy), ContentSecurityPolicy: Schema.optional(ResponseHeadersPolicyContentSecurityPolicy), ContentTypeOptions: Schema.optional(ResponseHeadersPolicyContentTypeOptions), StrictTransportSecurity: Schema.optional(ResponseHeadersPolicyStrictTransportSecurity)});
export const ResponseHeadersPolicyServerTimingHeadersConfig = Schema.Struct({Enabled: Schema.Boolean, SamplingRate: Schema.optional(Schema.Number)});
export const ResponseHeadersPolicyCustomHeader = Schema.Struct({Header: Schema.String, Value: Schema.String, Override: Schema.Boolean});
export const ResponseHeadersPolicyCustomHeaderList = Schema.Array(ResponseHeadersPolicyCustomHeader);
export const ResponseHeadersPolicyCustomHeadersConfig = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(ResponseHeadersPolicyCustomHeaderList)});
export const ResponseHeadersPolicyRemoveHeader = Schema.Struct({Header: Schema.String});
export const ResponseHeadersPolicyRemoveHeaderList = Schema.Array(ResponseHeadersPolicyRemoveHeader);
export const ResponseHeadersPolicyRemoveHeadersConfig = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(ResponseHeadersPolicyRemoveHeaderList)});
export const ResponseHeadersPolicyConfig = Schema.Struct({Comment: Schema.optional(Schema.String), Name: Schema.String, CorsConfig: Schema.optional(ResponseHeadersPolicyCorsConfig), SecurityHeadersConfig: Schema.optional(ResponseHeadersPolicySecurityHeadersConfig), ServerTimingHeadersConfig: Schema.optional(ResponseHeadersPolicyServerTimingHeadersConfig), CustomHeadersConfig: Schema.optional(ResponseHeadersPolicyCustomHeadersConfig), RemoveHeadersConfig: Schema.optional(ResponseHeadersPolicyRemoveHeadersConfig)});
export const UpdateResponseHeadersPolicyRequest = Schema.Struct({ResponseHeadersPolicyConfig: Body("ResponseHeadersPolicyConfig", ResponseHeadersPolicyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const S3Origin = Schema.Struct({DomainName: Schema.String, OriginAccessIdentity: Schema.String});
export const StreamingLoggingConfig = Schema.Struct({Enabled: Schema.Boolean, Bucket: Schema.String, Prefix: Schema.String});
export const StreamingDistributionConfig = Schema.Struct({CallerReference: Schema.String, S3Origin: S3Origin, Aliases: Schema.optional(Aliases), Comment: Schema.String, Logging: Schema.optional(StreamingLoggingConfig), TrustedSigners: TrustedSigners, PriceClass: Schema.optional(Schema.String), Enabled: Schema.Boolean});
export const UpdateStreamingDistributionRequest = Schema.Struct({StreamingDistributionConfig: Body("StreamingDistributionConfig", StreamingDistributionConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const VpcOriginEndpointConfig = Schema.Struct({Name: Schema.String, Arn: Schema.String, HTTPPort: Schema.Number, HTTPSPort: Schema.Number, OriginProtocolPolicy: Schema.String, OriginSslProtocols: Schema.optional(OriginSslProtocols)});
export const UpdateVpcOriginRequest = Schema.Struct({VpcOriginEndpointConfig: Body("VpcOriginEndpointConfig", VpcOriginEndpointConfig), Id: Schema.String, IfMatch: Header("If-Match")});
export const VerifyDnsConfigurationRequest = Schema.Struct({Domain: Schema.optional(Schema.String), Identifier: Schema.String});
export const TagKeyList = Schema.Array(Schema.String);
export const DistributionConfigWithTags = Schema.Struct({DistributionConfig: DistributionConfig, Tags: Tags});
export const ImportSource = Schema.Struct({SourceType: Schema.String, SourceARN: Schema.String});
export const StreamingDistributionConfigWithTags = Schema.Struct({StreamingDistributionConfig: StreamingDistributionConfig, Tags: Tags});
export const ConnectionGroupAssociationFilter = Schema.Struct({AnycastIpListId: Schema.optional(Schema.String)});
export const DistributionTenantAssociationFilter = Schema.Struct({DistributionId: Schema.optional(Schema.String), ConnectionGroupId: Schema.optional(Schema.String)});
export const TagKeys = Schema.Struct({Items: Schema.optional(TagKeyList)});
export const AccessDenied = Schema.Struct({Message: Schema.optional(Schema.String)});
export const AssociateDistributionTenantWebACLResult = Schema.Struct({Id: Schema.optional(Schema.String), WebACLArn: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))});
export const AssociateDistributionWebACLResult = Schema.Struct({Id: Schema.optional(Schema.String), WebACLArn: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))});
export const CreateCloudFrontOriginAccessIdentityRequest = Schema.Struct({CloudFrontOriginAccessIdentityConfig: Body("CloudFrontOriginAccessIdentityConfig", CloudFrontOriginAccessIdentityConfig)});
export const CreateDistributionWithTagsRequest = Schema.Struct({DistributionConfigWithTags: Body("DistributionConfigWithTags", DistributionConfigWithTags)});
export const CreateKeyGroupRequest = Schema.Struct({KeyGroupConfig: Body("KeyGroupConfig", KeyGroupConfig)});
export const CreateKeyValueStoreRequest = Schema.Struct({Name: Schema.String, Comment: Schema.optional(Schema.String), ImportSource: Schema.optional(ImportSource)});
export const CreateOriginAccessControlRequest = Schema.Struct({OriginAccessControlConfig: Body("OriginAccessControlConfig", OriginAccessControlConfig)});
export const CreatePublicKeyRequest = Schema.Struct({PublicKeyConfig: Body("PublicKeyConfig", PublicKeyConfig)});
export const CreateStreamingDistributionWithTagsRequest = Schema.Struct({StreamingDistributionConfigWithTags: Body("StreamingDistributionConfigWithTags", StreamingDistributionConfigWithTags)});
export const CannotDeleteEntityWhileInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CachePolicyInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CloudFrontOriginAccessIdentityInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const EntityNotFound = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ContinuousDeploymentPolicyInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DistributionNotDisabled = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidIfMatchVersion = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FieldLevelEncryptionConfigInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FieldLevelEncryptionProfileInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FunctionInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchResource = Schema.Struct({Message: Schema.optional(Schema.String)});
export const PreconditionFailed = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchDistribution = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchOriginAccessControl = Schema.Struct({Message: Schema.optional(Schema.String)});
export const IllegalDelete = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchPublicKey = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidArgument = Schema.Struct({Message: Schema.optional(Schema.String)});
export const UnsupportedOperation = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchStreamingDistribution = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DisassociateDistributionTenantWebACLResult = Schema.Struct({Id: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))});
export const DisassociateDistributionWebACLResult = Schema.Struct({Id: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))});
export const GetCachePolicyConfigResult = Schema.Struct({CachePolicyConfig: Schema.optional(Body("undefined", CachePolicyConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetCloudFrontOriginAccessIdentityConfigResult = Schema.Struct({CloudFrontOriginAccessIdentityConfig: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentityConfig)), ETag: Schema.optional(Header("ETag"))});
export const ConnectionGroup = Schema.Struct({Id: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), Arn: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.Date), LastModifiedTime: Schema.optional(Schema.Date), Tags: Schema.optional(Tags), Ipv6Enabled: Schema.optional(Schema.Boolean), RoutingEndpoint: Schema.optional(Schema.String), AnycastIpListId: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean), IsDefault: Schema.optional(Schema.Boolean)});
export const GetConnectionGroupResult = Schema.Struct({ConnectionGroup: Schema.optional(Body("undefined", ConnectionGroup)), ETag: Schema.optional(Header("ETag"))});
export const GetConnectionGroupByRoutingEndpointResult = Schema.Struct({ConnectionGroup: Schema.optional(Body("undefined", ConnectionGroup)), ETag: Schema.optional(Header("ETag"))});
export const GetContinuousDeploymentPolicyConfigResult = Schema.Struct({ContinuousDeploymentPolicyConfig: Schema.optional(Body("undefined", ContinuousDeploymentPolicyConfig)), ETag: Schema.optional(Header("ETag"))});
export const KeyPairIdList = Schema.Array(Schema.String);
export const KeyPairIds = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(KeyPairIdList)});
export const Signer = Schema.Struct({AwsAccountNumber: Schema.optional(Schema.String), KeyPairIds: Schema.optional(KeyPairIds)});
export const SignerList = Schema.Array(Signer);
export const ActiveTrustedSigners = Schema.Struct({Enabled: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(SignerList)});
export const KGKeyPairIds = Schema.Struct({KeyGroupId: Schema.optional(Schema.String), KeyPairIds: Schema.optional(KeyPairIds)});
export const KGKeyPairIdsList = Schema.Array(KGKeyPairIds);
export const ActiveTrustedKeyGroups = Schema.Struct({Enabled: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(KGKeyPairIdsList)});
export const AliasICPRecordal = Schema.Struct({CNAME: Schema.optional(Schema.String), ICPRecordalStatus: Schema.optional(Schema.String)});
export const AliasICPRecordals = Schema.Array(AliasICPRecordal);
export const Distribution = Schema.Struct({Id: Schema.String, ARN: Schema.String, Status: Schema.String, LastModifiedTime: Schema.Date, InProgressInvalidationBatches: Schema.Number, DomainName: Schema.String, ActiveTrustedSigners: Schema.optional(ActiveTrustedSigners), ActiveTrustedKeyGroups: Schema.optional(ActiveTrustedKeyGroups), DistributionConfig: DistributionConfig, AliasICPRecordals: Schema.optional(AliasICPRecordals)});
export const GetDistributionResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), ETag: Schema.optional(Header("ETag"))});
export const GetDistributionConfigResult = Schema.Struct({DistributionConfig: Schema.optional(Body("undefined", DistributionConfig)), ETag: Schema.optional(Header("ETag"))});
export const DomainResult = Schema.Struct({Domain: Schema.String, Status: Schema.optional(Schema.String)});
export const DomainResultList = Schema.Array(DomainResult);
export const DistributionTenant = Schema.Struct({Id: Schema.optional(Schema.String), DistributionId: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), Arn: Schema.optional(Schema.String), Domains: Schema.optional(DomainResultList), Tags: Schema.optional(Tags), Customizations: Schema.optional(Customizations), Parameters: Schema.optional(Parameters), ConnectionGroupId: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.Date), LastModifiedTime: Schema.optional(Schema.Date), Enabled: Schema.optional(Schema.Boolean), Status: Schema.optional(Schema.String)});
export const GetDistributionTenantByDomainResult = Schema.Struct({DistributionTenant: Schema.optional(Body("undefined", DistributionTenant)), ETag: Schema.optional(Header("ETag"))});
export const GetFieldLevelEncryptionConfigResult = Schema.Struct({FieldLevelEncryptionConfig: Schema.optional(Body("undefined", FieldLevelEncryptionConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetFieldLevelEncryptionProfileConfigResult = Schema.Struct({FieldLevelEncryptionProfileConfig: Schema.optional(Body("undefined", FieldLevelEncryptionProfileConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetFunctionResult = Schema.Struct({FunctionCode: Schema.optional(Body("undefined", StreamBody())), ETag: Schema.optional(Header("ETag")), ContentType: Schema.optional(Header("Content-Type"))});
export const Invalidation = Schema.Struct({Id: Schema.String, Status: Schema.String, CreateTime: Schema.Date, InvalidationBatch: InvalidationBatch});
export const GetInvalidationResult = Schema.Struct({Invalidation: Schema.optional(Body("undefined", Invalidation))});
export const GetInvalidationForDistributionTenantResult = Schema.Struct({Invalidation: Schema.optional(Body("undefined", Invalidation))});
export const GetKeyGroupConfigResult = Schema.Struct({KeyGroupConfig: Schema.optional(Body("undefined", KeyGroupConfig)), ETag: Schema.optional(Header("ETag"))});
export const RealtimeMetricsSubscriptionConfig = Schema.Struct({RealtimeMetricsSubscriptionStatus: Schema.String});
export const MonitoringSubscription = Schema.Struct({RealtimeMetricsSubscriptionConfig: Schema.optional(RealtimeMetricsSubscriptionConfig)});
export const GetMonitoringSubscriptionResult = Schema.Struct({MonitoringSubscription: Schema.optional(Body("undefined", MonitoringSubscription))});
export const GetOriginAccessControlConfigResult = Schema.Struct({OriginAccessControlConfig: Schema.optional(Body("undefined", OriginAccessControlConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetOriginRequestPolicyConfigResult = Schema.Struct({OriginRequestPolicyConfig: Schema.optional(Body("undefined", OriginRequestPolicyConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetPublicKeyConfigResult = Schema.Struct({PublicKeyConfig: Schema.optional(Body("undefined", PublicKeyConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetResourcePolicyResult = Schema.Struct({ResourceArn: Schema.optional(Schema.String), PolicyDocument: Schema.optional(Schema.String)});
export const GetResponseHeadersPolicyConfigResult = Schema.Struct({ResponseHeadersPolicyConfig: Schema.optional(Body("undefined", ResponseHeadersPolicyConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetStreamingDistributionConfigResult = Schema.Struct({StreamingDistributionConfig: Schema.optional(Body("undefined", StreamingDistributionConfig)), ETag: Schema.optional(Header("ETag"))});
export const VpcOrigin = Schema.Struct({Id: Schema.String, Arn: Schema.String, AccountId: Schema.optional(Schema.String), Status: Schema.String, CreatedTime: Schema.Date, LastModifiedTime: Schema.Date, VpcOriginEndpointConfig: VpcOriginEndpointConfig});
export const GetVpcOriginResult = Schema.Struct({VpcOrigin: Schema.optional(Body("undefined", VpcOrigin)), ETag: Schema.optional(Header("ETag"))});
export const ListConnectionGroupsRequest = Schema.Struct({AssociationFilter: Schema.optional(ConnectionGroupAssociationFilter), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const DistributionSummary = Schema.Struct({Id: Schema.String, ARN: Schema.String, ETag: Schema.optional(Schema.String), Status: Schema.String, LastModifiedTime: Schema.Date, DomainName: Schema.String, Aliases: Aliases, Origins: Origins, OriginGroups: Schema.optional(OriginGroups), DefaultCacheBehavior: DefaultCacheBehavior, CacheBehaviors: CacheBehaviors, CustomErrorResponses: CustomErrorResponses, Comment: Schema.String, PriceClass: Schema.String, Enabled: Schema.Boolean, ViewerCertificate: ViewerCertificate, Restrictions: Restrictions, WebACLId: Schema.String, HttpVersion: Schema.String, IsIPV6Enabled: Schema.Boolean, AliasICPRecordals: Schema.optional(AliasICPRecordals), Staging: Schema.Boolean, ConnectionMode: Schema.optional(Schema.String), AnycastIpListId: Schema.optional(Schema.String)});
export const DistributionSummaryList = Schema.Array(DistributionSummary);
export const DistributionList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(DistributionSummaryList)});
export const ListDistributionsByAnycastIpListIdResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))});
export const ListDistributionsByConnectionModeResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))});
export const DistributionIdListSummary = Schema.Array(Schema.String);
export const DistributionIdList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(DistributionIdListSummary)});
export const ListDistributionsByKeyGroupResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))});
export const ListDistributionsByOriginRequestPolicyIdResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))});
export const ListDistributionsByRealtimeLogConfigResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))});
export const ListDistributionsByResponseHeadersPolicyIdResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))});
export const ListDistributionsByVpcOriginIdResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))});
export const ListDistributionsByWebACLIdResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))});
export const ListDistributionTenantsRequest = Schema.Struct({AssociationFilter: Schema.optional(DistributionTenantAssociationFilter), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListDomainConflictsRequest = Schema.Struct({Domain: Schema.String, DomainControlValidationResource: DistributionResourceId, MaxItems: Schema.optional(Schema.Number), Marker: Schema.optional(Schema.String)});
export const InvalidationSummary = Schema.Struct({Id: Schema.String, CreateTime: Schema.Date, Status: Schema.String});
export const InvalidationSummaryList = Schema.Array(InvalidationSummary);
export const InvalidationList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(InvalidationSummaryList)});
export const ListInvalidationsForDistributionTenantResult = Schema.Struct({InvalidationList: Schema.optional(Body("undefined", InvalidationList))});
export const ListTagsForResourceResult = Schema.Struct({Tags: Body("undefined", Tags)});
export const FunctionMetadata = Schema.Struct({FunctionARN: Schema.String, Stage: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.Date), LastModifiedTime: Schema.Date});
export const FunctionSummary = Schema.Struct({Name: Schema.String, Status: Schema.optional(Schema.String), FunctionConfig: FunctionConfig, FunctionMetadata: FunctionMetadata});
export const PublishFunctionResult = Schema.Struct({FunctionSummary: Schema.optional(Body("undefined", FunctionSummary))});
export const PutResourcePolicyResult = Schema.Struct({ResourceArn: Schema.optional(Schema.String)});
export const InvalidTagging = Schema.Struct({Message: Schema.optional(Schema.String)});
export const UntagResourceRequest = Schema.Struct({Resource: Schema.String, TagKeys: Body("TagKeys", TagKeys)});
export const AnycastIps = Schema.Array(Schema.String);
export const AnycastIpList = Schema.Struct({Id: Schema.String, Name: Schema.String, Status: Schema.String, Arn: Schema.String, IpAddressType: Schema.optional(Schema.String), AnycastIps: AnycastIps, IpCount: Schema.Number, LastModifiedTime: Schema.Date});
export const UpdateAnycastIpListResult = Schema.Struct({AnycastIpList: Schema.optional(Body("undefined", AnycastIpList)), ETag: Schema.optional(Header("ETag"))});
export const CachePolicy = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, CachePolicyConfig: CachePolicyConfig});
export const UpdateCachePolicyResult = Schema.Struct({CachePolicy: Schema.optional(Body("undefined", CachePolicy)), ETag: Schema.optional(Header("ETag"))});
export const CloudFrontOriginAccessIdentity = Schema.Struct({Id: Schema.String, S3CanonicalUserId: Schema.String, CloudFrontOriginAccessIdentityConfig: Schema.optional(CloudFrontOriginAccessIdentityConfig)});
export const UpdateCloudFrontOriginAccessIdentityResult = Schema.Struct({CloudFrontOriginAccessIdentity: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentity)), ETag: Schema.optional(Header("ETag"))});
export const UpdateConnectionGroupResult = Schema.Struct({ConnectionGroup: Schema.optional(Body("undefined", ConnectionGroup)), ETag: Schema.optional(Header("ETag"))});
export const ContinuousDeploymentPolicy = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, ContinuousDeploymentPolicyConfig: ContinuousDeploymentPolicyConfig});
export const UpdateContinuousDeploymentPolicyResult = Schema.Struct({ContinuousDeploymentPolicy: Schema.optional(Body("undefined", ContinuousDeploymentPolicy)), ETag: Schema.optional(Header("ETag"))});
export const UpdateDistributionResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), ETag: Schema.optional(Header("ETag"))});
export const UpdateDistributionTenantResult = Schema.Struct({DistributionTenant: Schema.optional(Body("undefined", DistributionTenant)), ETag: Schema.optional(Header("ETag"))});
export const UpdateDistributionWithStagingConfigResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), ETag: Schema.optional(Header("ETag"))});
export const UpdateDomainAssociationResult = Schema.Struct({Domain: Schema.optional(Schema.String), ResourceId: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))});
export const FieldLevelEncryption = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, FieldLevelEncryptionConfig: FieldLevelEncryptionConfig});
export const UpdateFieldLevelEncryptionConfigResult = Schema.Struct({FieldLevelEncryption: Schema.optional(Body("undefined", FieldLevelEncryption)), ETag: Schema.optional(Header("ETag"))});
export const FieldLevelEncryptionProfile = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, FieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig});
export const UpdateFieldLevelEncryptionProfileResult = Schema.Struct({FieldLevelEncryptionProfile: Schema.optional(Body("undefined", FieldLevelEncryptionProfile)), ETag: Schema.optional(Header("ETag"))});
export const UpdateFunctionResult = Schema.Struct({FunctionSummary: Schema.optional(Body("undefined", FunctionSummary)), ETag: Schema.optional(Header("ETtag"))});
export const KeyGroup = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, KeyGroupConfig: KeyGroupConfig});
export const UpdateKeyGroupResult = Schema.Struct({KeyGroup: Schema.optional(Body("undefined", KeyGroup)), ETag: Schema.optional(Header("ETag"))});
export const KeyValueStore = Schema.Struct({Name: Schema.String, Id: Schema.String, Comment: Schema.String, ARN: Schema.String, Status: Schema.optional(Schema.String), LastModifiedTime: Schema.Date});
export const UpdateKeyValueStoreResult = Schema.Struct({KeyValueStore: Schema.optional(Body("undefined", KeyValueStore)), ETag: Schema.optional(Header("ETag"))});
export const OriginAccessControl = Schema.Struct({Id: Schema.String, OriginAccessControlConfig: Schema.optional(OriginAccessControlConfig)});
export const UpdateOriginAccessControlResult = Schema.Struct({OriginAccessControl: Schema.optional(Body("undefined", OriginAccessControl)), ETag: Schema.optional(Header("ETag"))});
export const OriginRequestPolicy = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, OriginRequestPolicyConfig: OriginRequestPolicyConfig});
export const UpdateOriginRequestPolicyResult = Schema.Struct({OriginRequestPolicy: Schema.optional(Body("undefined", OriginRequestPolicy)), ETag: Schema.optional(Header("ETag"))});
export const PublicKey = Schema.Struct({Id: Schema.String, CreatedTime: Schema.Date, PublicKeyConfig: PublicKeyConfig});
export const UpdatePublicKeyResult = Schema.Struct({PublicKey: Schema.optional(Body("undefined", PublicKey)), ETag: Schema.optional(Header("ETag"))});
export const RealtimeLogConfig = Schema.Struct({ARN: Schema.String, Name: Schema.String, SamplingRate: Schema.Number, EndPoints: EndPointList, Fields: FieldList});
export const UpdateRealtimeLogConfigResult = Schema.Struct({RealtimeLogConfig: Schema.optional(RealtimeLogConfig)});
export const ResponseHeadersPolicy = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, ResponseHeadersPolicyConfig: ResponseHeadersPolicyConfig});
export const UpdateResponseHeadersPolicyResult = Schema.Struct({ResponseHeadersPolicy: Schema.optional(Body("undefined", ResponseHeadersPolicy)), ETag: Schema.optional(Header("ETag"))});
export const StreamingDistribution = Schema.Struct({Id: Schema.String, ARN: Schema.String, Status: Schema.String, LastModifiedTime: Schema.optional(Schema.Date), DomainName: Schema.String, ActiveTrustedSigners: ActiveTrustedSigners, StreamingDistributionConfig: StreamingDistributionConfig});
export const UpdateStreamingDistributionResult = Schema.Struct({StreamingDistribution: Schema.optional(Body("undefined", StreamingDistribution)), ETag: Schema.optional(Header("ETag"))});
export const UpdateVpcOriginResult = Schema.Struct({VpcOrigin: Schema.optional(Body("undefined", VpcOrigin)), ETag: Schema.optional(Header("ETag"))});
export const FunctionSummaryList = Schema.Array(FunctionSummary);
export const KeyValueStoreSummaryList = Schema.Array(KeyValueStore);
export const RealtimeLogConfigList = Schema.Array(RealtimeLogConfig);
export const FunctionExecutionLogList = Schema.Array(Schema.String);
export const DistributionTenantSummary = Schema.Struct({Id: Schema.String, DistributionId: Schema.String, Name: Schema.String, Arn: Schema.String, Domains: DomainResultList, ConnectionGroupId: Schema.optional(Schema.String), Customizations: Schema.optional(Customizations), CreatedTime: Schema.Date, LastModifiedTime: Schema.Date, ETag: Schema.String, Enabled: Schema.optional(Schema.Boolean), Status: Schema.optional(Schema.String)});
export const DistributionTenantList = Schema.Array(DistributionTenantSummary);
export const FunctionList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(FunctionSummaryList)});
export const KeyValueStoreList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(KeyValueStoreSummaryList)});
export const RealtimeLogConfigs = Schema.Struct({MaxItems: Schema.Number, Items: Schema.optional(RealtimeLogConfigList), IsTruncated: Schema.Boolean, Marker: Schema.String, NextMarker: Schema.optional(Schema.String)});
export const TestResult = Schema.Struct({FunctionSummary: Schema.optional(FunctionSummary), ComputeUtilization: Schema.optional(Schema.String), FunctionExecutionLogs: Schema.optional(FunctionExecutionLogList), FunctionErrorMessage: Schema.optional(Schema.String), FunctionOutput: Schema.optional(Schema.String)});
export const DnsConfiguration = Schema.Struct({Domain: Schema.String, Status: Schema.String, Reason: Schema.optional(Schema.String)});
export const DnsConfigurationList = Schema.Array(DnsConfiguration);
export const IllegalUpdate = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateAnycastIpListRequest = Schema.Struct({Name: Schema.String, IpCount: Schema.Number, Tags: Schema.optional(Tags), IpAddressType: Schema.optional(Schema.String)});
export const CreateCloudFrontOriginAccessIdentityResult = Schema.Struct({CloudFrontOriginAccessIdentity: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentity)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateConnectionGroupResult = Schema.Struct({ConnectionGroup: Schema.optional(Body("undefined", ConnectionGroup)), ETag: Schema.optional(Header("ETag"))});
export const CreateDistributionTenantRequest = Schema.Struct({DistributionId: Schema.String, Name: Schema.String, Domains: DomainList, Tags: Schema.optional(Tags), Customizations: Schema.optional(Customizations), Parameters: Schema.optional(Parameters), ConnectionGroupId: Schema.optional(Schema.String), ManagedCertificateRequest: Schema.optional(ManagedCertificateRequest), Enabled: Schema.optional(Schema.Boolean)});
export const CreateDistributionWithTagsResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateInvalidationRequest = Schema.Struct({DistributionId: Schema.String, InvalidationBatch: Body("InvalidationBatch", InvalidationBatch)});
export const CreateInvalidationForDistributionTenantResult = Schema.Struct({Location: Schema.optional(Header("Location")), Invalidation: Schema.optional(Body("undefined", Invalidation))});
export const CreateKeyGroupResult = Schema.Struct({KeyGroup: Schema.optional(Body("undefined", KeyGroup)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateKeyValueStoreResult = Schema.Struct({KeyValueStore: Schema.optional(Body("undefined", KeyValueStore)), ETag: Schema.optional(Header("ETag")), Location: Schema.optional(Header("Location"))});
export const CreateMonitoringSubscriptionRequest = Schema.Struct({DistributionId: Schema.String, MonitoringSubscription: Body("MonitoringSubscription", MonitoringSubscription)});
export const CreateOriginAccessControlResult = Schema.Struct({OriginAccessControl: Schema.optional(Body("undefined", OriginAccessControl)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreatePublicKeyResult = Schema.Struct({PublicKey: Schema.optional(Body("undefined", PublicKey)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateRealtimeLogConfigRequest = Schema.Struct({EndPoints: EndPointList, Fields: FieldList, Name: Schema.String, SamplingRate: Schema.Number});
export const CreateStreamingDistributionRequest = Schema.Struct({StreamingDistributionConfig: Body("StreamingDistributionConfig", StreamingDistributionConfig)});
export const CreateStreamingDistributionWithTagsResult = Schema.Struct({StreamingDistribution: Schema.optional(Body("undefined", StreamingDistribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateVpcOriginRequest = Schema.Struct({VpcOriginEndpointConfig: VpcOriginEndpointConfig, Tags: Schema.optional(Tags)});
export const NoSuchCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchCloudFrontOriginAccessIdentity = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ResourceNotDisabled = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchContinuousDeploymentPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ResourceInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchFieldLevelEncryptionConfig = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchFieldLevelEncryptionProfile = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchFunctionExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchMonitoringSubscription = Schema.Struct({Message: Schema.optional(Schema.String)});
export const OriginAccessControlInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const PublicKeyInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchRealtimeLogConfig = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ResponseHeadersPolicyInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const StreamingDistributionNotDisabled = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DeleteVpcOriginResult = Schema.Struct({VpcOrigin: Schema.optional(Body("undefined", VpcOrigin)), ETag: Schema.optional(Header("ETag"))});
export const DescribeKeyValueStoreResult = Schema.Struct({KeyValueStore: Schema.optional(Body("undefined", KeyValueStore)), ETag: Schema.optional(Header("ETag"))});
export const GetAnycastIpListResult = Schema.Struct({AnycastIpList: Schema.optional(Body("undefined", AnycastIpList)), ETag: Schema.optional(Header("ETag"))});
export const GetCachePolicyResult = Schema.Struct({CachePolicy: Schema.optional(Body("undefined", CachePolicy)), ETag: Schema.optional(Header("ETag"))});
export const GetCloudFrontOriginAccessIdentityResult = Schema.Struct({CloudFrontOriginAccessIdentity: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentity)), ETag: Schema.optional(Header("ETag"))});
export const GetContinuousDeploymentPolicyResult = Schema.Struct({ContinuousDeploymentPolicy: Schema.optional(Body("undefined", ContinuousDeploymentPolicy)), ETag: Schema.optional(Header("ETag"))});
export const GetFieldLevelEncryptionResult = Schema.Struct({FieldLevelEncryption: Schema.optional(Body("undefined", FieldLevelEncryption)), ETag: Schema.optional(Header("ETag"))});
export const GetFieldLevelEncryptionProfileResult = Schema.Struct({FieldLevelEncryptionProfile: Schema.optional(Body("undefined", FieldLevelEncryptionProfile)), ETag: Schema.optional(Header("ETag"))});
export const NoSuchInvalidation = Schema.Struct({Message: Schema.optional(Schema.String)});
export const GetKeyGroupResult = Schema.Struct({KeyGroup: Schema.optional(Body("undefined", KeyGroup)), ETag: Schema.optional(Header("ETag"))});
export const GetOriginAccessControlResult = Schema.Struct({OriginAccessControl: Schema.optional(Body("undefined", OriginAccessControl)), ETag: Schema.optional(Header("ETag"))});
export const GetOriginRequestPolicyResult = Schema.Struct({OriginRequestPolicy: Schema.optional(Body("undefined", OriginRequestPolicy)), ETag: Schema.optional(Header("ETag"))});
export const GetPublicKeyResult = Schema.Struct({PublicKey: Schema.optional(Body("undefined", PublicKey)), ETag: Schema.optional(Header("ETag"))});
export const GetRealtimeLogConfigResult = Schema.Struct({RealtimeLogConfig: Schema.optional(RealtimeLogConfig)});
export const GetResponseHeadersPolicyResult = Schema.Struct({ResponseHeadersPolicy: Schema.optional(Body("undefined", ResponseHeadersPolicy)), ETag: Schema.optional(Header("ETag"))});
export const GetStreamingDistributionResult = Schema.Struct({StreamingDistribution: Schema.optional(Body("undefined", StreamingDistribution)), ETag: Schema.optional(Header("ETag"))});
export const ListDistributionsByCachePolicyIdResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))});
export const InvalidWebACLId = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ListDistributionTenantsResult = Schema.Struct({NextMarker: Schema.optional(Schema.String), DistributionTenantList: Schema.optional(DistributionTenantList)});
export const ListDistributionTenantsByCustomizationResult = Schema.Struct({NextMarker: Schema.optional(Schema.String), DistributionTenantList: Schema.optional(DistributionTenantList)});
export const ListFunctionsResult = Schema.Struct({FunctionList: Schema.optional(Body("undefined", FunctionList))});
export const ListKeyValueStoresResult = Schema.Struct({KeyValueStoreList: Schema.optional(Body("undefined", KeyValueStoreList))});
export const ListRealtimeLogConfigsResult = Schema.Struct({RealtimeLogConfigs: Schema.optional(Body("undefined", RealtimeLogConfigs))});
export const TestFunctionResult = Schema.Struct({TestResult: Schema.optional(Body("undefined", TestResult))});
export const CachePolicyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InconsistentQuantities = Schema.Struct({Message: Schema.optional(Schema.String)});
export const EntityAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const StagingDistributionInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CNAMEAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const EntityLimitExceeded = Schema.Struct({Message: Schema.optional(Schema.String)});
export const IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior = Schema.Struct({Message: Schema.optional(Schema.String)});
export const QueryArgProfileEmpty = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FieldLevelEncryptionProfileAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FunctionSizeLimitExceeded = Schema.Struct({Message: Schema.optional(Schema.String)});
export const KeyGroupAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const OriginAccessControlAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const OriginRequestPolicyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CannotChangeImmutablePublicKeyFields = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ResponseHeadersPolicyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidOriginAccessControl = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CannotUpdateEntityWhileInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const VerifyDnsConfigurationResult = Schema.Struct({DnsConfigurationList: Schema.optional(DnsConfigurationList)});
export const ValidationTokenDetail = Schema.Struct({Domain: Schema.String, RedirectTo: Schema.optional(Schema.String), RedirectFrom: Schema.optional(Schema.String)});
export const ValidationTokenDetailList = Schema.Array(ValidationTokenDetail);
export const AnycastIpListSummary = Schema.Struct({Id: Schema.String, Name: Schema.String, Status: Schema.String, Arn: Schema.String, IpCount: Schema.Number, LastModifiedTime: Schema.Date, IpAddressType: Schema.optional(Schema.String), ETag: Schema.optional(Schema.String)});
export const AnycastIpListSummaries = Schema.Array(AnycastIpListSummary);
export const CachePolicySummary = Schema.Struct({Type: Schema.String, CachePolicy: CachePolicy});
export const CachePolicySummaryList = Schema.Array(CachePolicySummary);
export const CloudFrontOriginAccessIdentitySummary = Schema.Struct({Id: Schema.String, S3CanonicalUserId: Schema.String, Comment: Schema.String});
export const CloudFrontOriginAccessIdentitySummaryList = Schema.Array(CloudFrontOriginAccessIdentitySummary);
export const ConflictingAlias = Schema.Struct({Alias: Schema.optional(Schema.String), DistributionId: Schema.optional(Schema.String), AccountId: Schema.optional(Schema.String)});
export const ConflictingAliases = Schema.Array(ConflictingAlias);
export const ContinuousDeploymentPolicySummary = Schema.Struct({ContinuousDeploymentPolicy: ContinuousDeploymentPolicy});
export const ContinuousDeploymentPolicySummaryList = Schema.Array(ContinuousDeploymentPolicySummary);
export const DistributionIdOwner = Schema.Struct({DistributionId: Schema.String, OwnerAccountId: Schema.String});
export const DistributionIdOwnerItemList = Schema.Array(DistributionIdOwner);
export const FieldLevelEncryptionSummary = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, Comment: Schema.optional(Schema.String), QueryArgProfileConfig: Schema.optional(QueryArgProfileConfig), ContentTypeProfileConfig: Schema.optional(ContentTypeProfileConfig)});
export const FieldLevelEncryptionSummaryList = Schema.Array(FieldLevelEncryptionSummary);
export const FieldLevelEncryptionProfileSummary = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, Name: Schema.String, EncryptionEntities: EncryptionEntities, Comment: Schema.optional(Schema.String)});
export const FieldLevelEncryptionProfileSummaryList = Schema.Array(FieldLevelEncryptionProfileSummary);
export const KeyGroupSummary = Schema.Struct({KeyGroup: KeyGroup});
export const KeyGroupSummaryList = Schema.Array(KeyGroupSummary);
export const OriginAccessControlSummary = Schema.Struct({Id: Schema.String, Description: Schema.String, Name: Schema.String, SigningProtocol: Schema.String, SigningBehavior: Schema.String, OriginAccessControlOriginType: Schema.String});
export const OriginAccessControlSummaryList = Schema.Array(OriginAccessControlSummary);
export const OriginRequestPolicySummary = Schema.Struct({Type: Schema.String, OriginRequestPolicy: OriginRequestPolicy});
export const OriginRequestPolicySummaryList = Schema.Array(OriginRequestPolicySummary);
export const PublicKeySummary = Schema.Struct({Id: Schema.String, Name: Schema.String, CreatedTime: Schema.Date, EncodedKey: Schema.String, Comment: Schema.optional(Schema.String)});
export const PublicKeySummaryList = Schema.Array(PublicKeySummary);
export const ResponseHeadersPolicySummary = Schema.Struct({Type: Schema.String, ResponseHeadersPolicy: ResponseHeadersPolicy});
export const ResponseHeadersPolicySummaryList = Schema.Array(ResponseHeadersPolicySummary);
export const StreamingDistributionSummary = Schema.Struct({Id: Schema.String, ARN: Schema.String, Status: Schema.String, LastModifiedTime: Schema.Date, DomainName: Schema.String, S3Origin: S3Origin, Aliases: Aliases, TrustedSigners: TrustedSigners, Comment: Schema.String, PriceClass: Schema.String, Enabled: Schema.Boolean});
export const StreamingDistributionSummaryList = Schema.Array(StreamingDistributionSummary);
export const VpcOriginSummary = Schema.Struct({Id: Schema.String, Name: Schema.String, Status: Schema.String, CreatedTime: Schema.Date, LastModifiedTime: Schema.Date, Arn: Schema.String, AccountId: Schema.optional(Schema.String), OriginEndpointArn: Schema.String});
export const VpcOriginSummaryList = Schema.Array(VpcOriginSummary);
export const ManagedCertificateDetails = Schema.Struct({CertificateArn: Schema.optional(Schema.String), CertificateStatus: Schema.optional(Schema.String), ValidationTokenHost: Schema.optional(Schema.String), ValidationTokenDetails: Schema.optional(ValidationTokenDetailList)});
export const AnycastIpListCollection = Schema.Struct({Items: Schema.optional(AnycastIpListSummaries), Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number});
export const CachePolicyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(CachePolicySummaryList)});
export const CloudFrontOriginAccessIdentityList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(CloudFrontOriginAccessIdentitySummaryList)});
export const ConflictingAliasesList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), Quantity: Schema.optional(Schema.Number), Items: Schema.optional(ConflictingAliases)});
export const ConnectionGroupSummary = Schema.Struct({Id: Schema.String, Name: Schema.String, Arn: Schema.String, RoutingEndpoint: Schema.String, CreatedTime: Schema.Date, LastModifiedTime: Schema.Date, ETag: Schema.String, AnycastIpListId: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean), Status: Schema.optional(Schema.String), IsDefault: Schema.optional(Schema.Boolean)});
export const ConnectionGroupSummaryList = Schema.Array(ConnectionGroupSummary);
export const ContinuousDeploymentPolicyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(ContinuousDeploymentPolicySummaryList)});
export const DistributionIdOwnerList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(DistributionIdOwnerItemList)});
export const DomainConflict = Schema.Struct({Domain: Schema.String, ResourceType: Schema.String, ResourceId: Schema.String, AccountId: Schema.String});
export const DomainConflictsList = Schema.Array(DomainConflict);
export const FieldLevelEncryptionList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(FieldLevelEncryptionSummaryList)});
export const FieldLevelEncryptionProfileList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(FieldLevelEncryptionProfileSummaryList)});
export const KeyGroupList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(KeyGroupSummaryList)});
export const OriginAccessControlList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(OriginAccessControlSummaryList)});
export const OriginRequestPolicyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(OriginRequestPolicySummaryList)});
export const PublicKeyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(PublicKeySummaryList)});
export const ResponseHeadersPolicyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(ResponseHeadersPolicySummaryList)});
export const StreamingDistributionList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(StreamingDistributionSummaryList)});
export const VpcOriginList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(VpcOriginSummaryList)});
export const TooManyDistributionCNAMEs = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateAnycastIpListResult = Schema.Struct({AnycastIpList: Schema.optional(Body("undefined", AnycastIpList)), ETag: Schema.optional(Header("ETag"))});
export const CreateCachePolicyRequest = Schema.Struct({CachePolicyConfig: Body("CachePolicyConfig", CachePolicyConfig)});
export const CloudFrontOriginAccessIdentityAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateDistributionTenantResult = Schema.Struct({DistributionTenant: Schema.optional(Body("undefined", DistributionTenant)), ETag: Schema.optional(Header("ETag"))});
export const DistributionAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateFunctionRequest = Schema.Struct({Name: Schema.String, FunctionConfig: FunctionConfig, FunctionCode: StreamBody()});
export const CreateInvalidationResult = Schema.Struct({Location: Schema.optional(Header("Location")), Invalidation: Schema.optional(Body("undefined", Invalidation))});
export const BatchTooLarge = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyKeyGroups = Schema.Struct({Message: Schema.optional(Schema.String)});
export const EntitySizeLimitExceeded = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateMonitoringSubscriptionResult = Schema.Struct({MonitoringSubscription: Schema.optional(Body("undefined", MonitoringSubscription))});
export const TooManyOriginAccessControls = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateOriginRequestPolicyRequest = Schema.Struct({OriginRequestPolicyConfig: Body("OriginRequestPolicyConfig", OriginRequestPolicyConfig)});
export const PublicKeyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateRealtimeLogConfigResult = Schema.Struct({RealtimeLogConfig: Schema.optional(RealtimeLogConfig)});
export const CreateResponseHeadersPolicyRequest = Schema.Struct({ResponseHeadersPolicyConfig: Body("ResponseHeadersPolicyConfig", ResponseHeadersPolicyConfig)});
export const CreateStreamingDistributionResult = Schema.Struct({StreamingDistribution: Schema.optional(Body("undefined", StreamingDistribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const InvalidOrigin = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateVpcOriginResult = Schema.Struct({VpcOrigin: Schema.optional(Body("undefined", VpcOrigin)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const OriginRequestPolicyInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const RealtimeLogConfigInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DescribeFunctionResult = Schema.Struct({FunctionSummary: Schema.optional(Body("undefined", FunctionSummary)), ETag: Schema.optional(Header("ETag"))});
export const GetDistributionTenantResult = Schema.Struct({DistributionTenant: Schema.optional(Body("undefined", DistributionTenant)), ETag: Schema.optional(Header("ETag"))});
export const GetManagedCertificateDetailsResult = Schema.Struct({ManagedCertificateDetails: Schema.optional(Body("undefined", ManagedCertificateDetails))});
export const ListAnycastIpListsResult = Schema.Struct({AnycastIpLists: Schema.optional(Body("AnycastIpListCollection", AnycastIpListCollection))});
export const ListCachePoliciesResult = Schema.Struct({CachePolicyList: Schema.optional(Body("undefined", CachePolicyList))});
export const ListCloudFrontOriginAccessIdentitiesResult = Schema.Struct({CloudFrontOriginAccessIdentityList: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentityList))});
export const ListConflictingAliasesResult = Schema.Struct({ConflictingAliasesList: Schema.optional(Body("undefined", ConflictingAliasesList))});
export const ListConnectionGroupsResult = Schema.Struct({NextMarker: Schema.optional(Schema.String), ConnectionGroups: Schema.optional(ConnectionGroupSummaryList)});
export const ListContinuousDeploymentPoliciesResult = Schema.Struct({ContinuousDeploymentPolicyList: Schema.optional(Body("undefined", ContinuousDeploymentPolicyList))});
export const ListDistributionsResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))});
export const ListDistributionsByOwnedResourceResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionIdOwnerList))});
export const ListDomainConflictsResult = Schema.Struct({DomainConflicts: Schema.optional(DomainConflictsList), NextMarker: Schema.optional(Schema.String)});
export const ListFieldLevelEncryptionConfigsResult = Schema.Struct({FieldLevelEncryptionList: Schema.optional(Body("undefined", FieldLevelEncryptionList))});
export const ListFieldLevelEncryptionProfilesResult = Schema.Struct({FieldLevelEncryptionProfileList: Schema.optional(Body("undefined", FieldLevelEncryptionProfileList))});
export const ListInvalidationsResult = Schema.Struct({InvalidationList: Schema.optional(Body("undefined", InvalidationList))});
export const ListKeyGroupsResult = Schema.Struct({KeyGroupList: Schema.optional(Body("undefined", KeyGroupList))});
export const ListOriginAccessControlsResult = Schema.Struct({OriginAccessControlList: Schema.optional(Body("undefined", OriginAccessControlList))});
export const ListOriginRequestPoliciesResult = Schema.Struct({OriginRequestPolicyList: Schema.optional(Body("undefined", OriginRequestPolicyList))});
export const ListPublicKeysResult = Schema.Struct({PublicKeyList: Schema.optional(Body("undefined", PublicKeyList))});
export const ListResponseHeadersPoliciesResult = Schema.Struct({ResponseHeadersPolicyList: Schema.optional(Body("undefined", ResponseHeadersPolicyList))});
export const ListStreamingDistributionsResult = Schema.Struct({StreamingDistributionList: Schema.optional(Body("undefined", StreamingDistributionList))});
export const ListVpcOriginsResult = Schema.Struct({VpcOriginList: Schema.optional(Body("undefined", VpcOriginList))});
export const TestFunctionFailed = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyCookiesInCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const MissingBody = Schema.Struct({Message: Schema.optional(Schema.String)});
export const IllegalOriginAccessConfiguration = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidAssociation = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidDefaultRootObject = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFieldLevelEncryptionContentTypeProfiles = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FieldLevelEncryptionProfileSizeExceeded = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyPublicKeysInKeyGroup = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyCookiesInOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooLongCSPInResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidOriginAccessIdentity = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateCachePolicyResult = Schema.Struct({CachePolicy: Schema.optional(Body("undefined", CachePolicy)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const TooManyCloudFrontOriginAccessIdentities = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateContinuousDeploymentPolicyRequest = Schema.Struct({ContinuousDeploymentPolicyConfig: Body("ContinuousDeploymentPolicyConfig", ContinuousDeploymentPolicyConfig)});
export const InvalidDomainNameForOriginAccessControl = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateFieldLevelEncryptionConfigRequest = Schema.Struct({FieldLevelEncryptionConfig: Body("FieldLevelEncryptionConfig", FieldLevelEncryptionConfig)});
export const CreateFieldLevelEncryptionProfileRequest = Schema.Struct({FieldLevelEncryptionProfileConfig: Body("FieldLevelEncryptionProfileConfig", FieldLevelEncryptionProfileConfig)});
export const CreateFunctionResult = Schema.Struct({FunctionSummary: Schema.optional(Body("undefined", FunctionSummary)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const TooManyInvalidationsInProgress = Schema.Struct({Message: Schema.optional(Schema.String)});
export const MonitoringSubscriptionAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateOriginRequestPolicyResult = Schema.Struct({OriginRequestPolicy: Schema.optional(Body("undefined", OriginRequestPolicy)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const TooManyPublicKeys = Schema.Struct({Message: Schema.optional(Schema.String)});
export const RealtimeLogConfigAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateResponseHeadersPolicyResult = Schema.Struct({ResponseHeadersPolicy: Schema.optional(Body("undefined", ResponseHeadersPolicy)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const StreamingDistributionAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyStreamingDistributionCNAMEs = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyHeadersInCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidErrorCode = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidForwardCookies = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFieldLevelEncryptionQueryArgProfiles = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFieldLevelEncryptionEncryptionEntities = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyHeadersInOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyCustomHeadersInResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyTrustedSigners = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CopyDistributionResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const TooManyCachePolicies = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateContinuousDeploymentPolicyResult = Schema.Struct({ContinuousDeploymentPolicy: Schema.optional(Body("undefined", ContinuousDeploymentPolicy)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateDistributionRequest = Schema.Struct({DistributionConfig: Body("DistributionConfig", DistributionConfig)});
export const InvalidFunctionAssociation = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateFieldLevelEncryptionConfigResult = Schema.Struct({FieldLevelEncryption: Schema.optional(Body("undefined", FieldLevelEncryption)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateFieldLevelEncryptionProfileResult = Schema.Struct({FieldLevelEncryptionProfile: Schema.optional(Body("undefined", FieldLevelEncryptionProfile)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const FunctionAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyOriginRequestPolicies = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyRealtimeLogConfigs = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyRemoveHeadersInResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyStreamingDistributions = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TrustedSignerDoesNotExist = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyQueryStringsInCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidGeoRestrictionParameter = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidHeadersForS3Origin = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFieldLevelEncryptionFieldPatterns = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyQueryStringsInOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidLambdaFunctionAssociation = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ContinuousDeploymentPolicyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateDistributionResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const InvalidLocationCode = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FieldLevelEncryptionConfigAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFieldLevelEncryptionProfiles = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFunctions = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyResponseHeadersPolicies = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidMinimumProtocolVersion = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidOriginKeepaliveTimeout = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidOriginReadTimeout = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyContinuousDeploymentPolicies = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidProtocolSettings = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidQueryStringParameters = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFieldLevelEncryptionConfigs = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidRelativePath = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidRequiredProtocol = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidResponseCode = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidTTLOrder = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidViewerCertificate = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchOrigin = Schema.Struct({Message: Schema.optional(Schema.String)});
export const RealtimeLogConfigOwnerMismatch = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyCacheBehaviors = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyCertificates = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyCookieNamesInWhiteList = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsAssociatedToCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsAssociatedToFieldLevelEncryptionConfig = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributions = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsAssociatedToKeyGroup = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsAssociatedToOriginAccessControl = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsAssociatedToOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsAssociatedToResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsWithFunctionAssociations = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsWithLambdaAssociations = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsWithSingleFunctionARN = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFunctionAssociations = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyHeadersInForwardedValues = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyKeyGroupsAssociatedToDistribution = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyLambdaFunctionAssociations = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyOriginCustomHeaders = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyOriginGroupsPerDistribution = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyOrigins = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyQueryStringParameters = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TrustedKeyGroupDoesNotExist = Schema.Struct({Message: Schema.optional(Schema.String)});

//# Errors
export class AccessDeniedError extends Schema.TaggedError<AccessDeniedError>()("AccessDenied", AccessDenied) {};
export class CannotDeleteEntityWhileInUseError extends Schema.TaggedError<CannotDeleteEntityWhileInUseError>()("CannotDeleteEntityWhileInUse", CannotDeleteEntityWhileInUse) {};
export class EntityNotFoundError extends Schema.TaggedError<EntityNotFoundError>()("EntityNotFound", EntityNotFound) {};
export class InvalidIfMatchVersionError extends Schema.TaggedError<InvalidIfMatchVersionError>()("InvalidIfMatchVersion", InvalidIfMatchVersion) {};
export class IllegalDeleteError extends Schema.TaggedError<IllegalDeleteError>()("IllegalDelete", IllegalDelete) {};
export class InvalidArgumentError extends Schema.TaggedError<InvalidArgumentError>()("InvalidArgument", InvalidArgument) {};
export class PreconditionFailedError extends Schema.TaggedError<PreconditionFailedError>()("PreconditionFailed", PreconditionFailed) {};
export class UnsupportedOperationError extends Schema.TaggedError<UnsupportedOperationError>()("UnsupportedOperation", UnsupportedOperation) {};
export class CachePolicyInUseError extends Schema.TaggedError<CachePolicyInUseError>()("CachePolicyInUse", CachePolicyInUse) {};
export class CloudFrontOriginAccessIdentityInUseError extends Schema.TaggedError<CloudFrontOriginAccessIdentityInUseError>()("CloudFrontOriginAccessIdentityInUse", CloudFrontOriginAccessIdentityInUse) {};
export class ContinuousDeploymentPolicyInUseError extends Schema.TaggedError<ContinuousDeploymentPolicyInUseError>()("ContinuousDeploymentPolicyInUse", ContinuousDeploymentPolicyInUse) {};
export class DistributionNotDisabledError extends Schema.TaggedError<DistributionNotDisabledError>()("DistributionNotDisabled", DistributionNotDisabled) {};
export class NoSuchDistributionError extends Schema.TaggedError<NoSuchDistributionError>()("NoSuchDistribution", NoSuchDistribution) {};
export class ResourceNotDisabledError extends Schema.TaggedError<ResourceNotDisabledError>()("ResourceNotDisabled", ResourceNotDisabled) {};
export class FieldLevelEncryptionConfigInUseError extends Schema.TaggedError<FieldLevelEncryptionConfigInUseError>()("FieldLevelEncryptionConfigInUse", FieldLevelEncryptionConfigInUse) {};
export class FieldLevelEncryptionProfileInUseError extends Schema.TaggedError<FieldLevelEncryptionProfileInUseError>()("FieldLevelEncryptionProfileInUse", FieldLevelEncryptionProfileInUse) {};
export class FunctionInUseError extends Schema.TaggedError<FunctionInUseError>()("FunctionInUse", FunctionInUse) {};
export class NoSuchResourceError extends Schema.TaggedError<NoSuchResourceError>()("NoSuchResource", NoSuchResource) {};
export class ResourceInUseError extends Schema.TaggedError<ResourceInUseError>()("ResourceInUse", ResourceInUse) {};
export class NoSuchOriginAccessControlError extends Schema.TaggedError<NoSuchOriginAccessControlError>()("NoSuchOriginAccessControl", NoSuchOriginAccessControl) {};
export class NoSuchPublicKeyError extends Schema.TaggedError<NoSuchPublicKeyError>()("NoSuchPublicKey", NoSuchPublicKey) {};
export class NoSuchResponseHeadersPolicyError extends Schema.TaggedError<NoSuchResponseHeadersPolicyError>()("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy) {};
export class NoSuchStreamingDistributionError extends Schema.TaggedError<NoSuchStreamingDistributionError>()("NoSuchStreamingDistribution", NoSuchStreamingDistribution) {};
export class NoSuchCachePolicyError extends Schema.TaggedError<NoSuchCachePolicyError>()("NoSuchCachePolicy", NoSuchCachePolicy) {};
export class NoSuchCloudFrontOriginAccessIdentityError extends Schema.TaggedError<NoSuchCloudFrontOriginAccessIdentityError>()("NoSuchCloudFrontOriginAccessIdentity", NoSuchCloudFrontOriginAccessIdentity) {};
export class NoSuchContinuousDeploymentPolicyError extends Schema.TaggedError<NoSuchContinuousDeploymentPolicyError>()("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy) {};
export class NoSuchFieldLevelEncryptionConfigError extends Schema.TaggedError<NoSuchFieldLevelEncryptionConfigError>()("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig) {};
export class NoSuchFieldLevelEncryptionProfileError extends Schema.TaggedError<NoSuchFieldLevelEncryptionProfileError>()("NoSuchFieldLevelEncryptionProfile", NoSuchFieldLevelEncryptionProfile) {};
export class NoSuchFunctionExistsError extends Schema.TaggedError<NoSuchFunctionExistsError>()("NoSuchFunctionExists", NoSuchFunctionExists) {};
export class NoSuchInvalidationError extends Schema.TaggedError<NoSuchInvalidationError>()("NoSuchInvalidation", NoSuchInvalidation) {};
export class NoSuchMonitoringSubscriptionError extends Schema.TaggedError<NoSuchMonitoringSubscriptionError>()("NoSuchMonitoringSubscription", NoSuchMonitoringSubscription) {};
export class NoSuchOriginRequestPolicyError extends Schema.TaggedError<NoSuchOriginRequestPolicyError>()("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy) {};
export class InvalidTaggingError extends Schema.TaggedError<InvalidTaggingError>()("InvalidTagging", InvalidTagging) {};
export class IllegalUpdateError extends Schema.TaggedError<IllegalUpdateError>()("IllegalUpdate", IllegalUpdate) {};
export class InconsistentQuantitiesError extends Schema.TaggedError<InconsistentQuantitiesError>()("InconsistentQuantities", InconsistentQuantities) {};
export class CNAMEAlreadyExistsError extends Schema.TaggedError<CNAMEAlreadyExistsError>()("CNAMEAlreadyExists", CNAMEAlreadyExists) {};
export class EntityAlreadyExistsError extends Schema.TaggedError<EntityAlreadyExistsError>()("EntityAlreadyExists", EntityAlreadyExists) {};
export class NoSuchRealtimeLogConfigError extends Schema.TaggedError<NoSuchRealtimeLogConfigError>()("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig) {};
export class EntityLimitExceededError extends Schema.TaggedError<EntityLimitExceededError>()("EntityLimitExceeded", EntityLimitExceeded) {};
export class KeyGroupAlreadyExistsError extends Schema.TaggedError<KeyGroupAlreadyExistsError>()("KeyGroupAlreadyExists", KeyGroupAlreadyExists) {};
export class OriginAccessControlAlreadyExistsError extends Schema.TaggedError<OriginAccessControlAlreadyExistsError>()("OriginAccessControlAlreadyExists", OriginAccessControlAlreadyExists) {};
export class OriginAccessControlInUseError extends Schema.TaggedError<OriginAccessControlInUseError>()("OriginAccessControlInUse", OriginAccessControlInUse) {};
export class PublicKeyInUseError extends Schema.TaggedError<PublicKeyInUseError>()("PublicKeyInUse", PublicKeyInUse) {};
export class ResponseHeadersPolicyInUseError extends Schema.TaggedError<ResponseHeadersPolicyInUseError>()("ResponseHeadersPolicyInUse", ResponseHeadersPolicyInUse) {};
export class StreamingDistributionNotDisabledError extends Schema.TaggedError<StreamingDistributionNotDisabledError>()("StreamingDistributionNotDisabled", StreamingDistributionNotDisabled) {};
export class InvalidWebACLIdError extends Schema.TaggedError<InvalidWebACLIdError>()("InvalidWebACLId", InvalidWebACLId) {};
export class CachePolicyAlreadyExistsError extends Schema.TaggedError<CachePolicyAlreadyExistsError>()("CachePolicyAlreadyExists", CachePolicyAlreadyExists) {};
export class StagingDistributionInUseError extends Schema.TaggedError<StagingDistributionInUseError>()("StagingDistributionInUse", StagingDistributionInUse) {};
export class IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorError extends Schema.TaggedError<IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorError>()("IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior", IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior) {};
export class QueryArgProfileEmptyError extends Schema.TaggedError<QueryArgProfileEmptyError>()("QueryArgProfileEmpty", QueryArgProfileEmpty) {};
export class FieldLevelEncryptionProfileAlreadyExistsError extends Schema.TaggedError<FieldLevelEncryptionProfileAlreadyExistsError>()("FieldLevelEncryptionProfileAlreadyExists", FieldLevelEncryptionProfileAlreadyExists) {};
export class FunctionSizeLimitExceededError extends Schema.TaggedError<FunctionSizeLimitExceededError>()("FunctionSizeLimitExceeded", FunctionSizeLimitExceeded) {};
export class OriginRequestPolicyAlreadyExistsError extends Schema.TaggedError<OriginRequestPolicyAlreadyExistsError>()("OriginRequestPolicyAlreadyExists", OriginRequestPolicyAlreadyExists) {};
export class CannotChangeImmutablePublicKeyFieldsError extends Schema.TaggedError<CannotChangeImmutablePublicKeyFieldsError>()("CannotChangeImmutablePublicKeyFields", CannotChangeImmutablePublicKeyFields) {};
export class ResponseHeadersPolicyAlreadyExistsError extends Schema.TaggedError<ResponseHeadersPolicyAlreadyExistsError>()("ResponseHeadersPolicyAlreadyExists", ResponseHeadersPolicyAlreadyExists) {};
export class InvalidOriginAccessControlError extends Schema.TaggedError<InvalidOriginAccessControlError>()("InvalidOriginAccessControl", InvalidOriginAccessControl) {};
export class CannotUpdateEntityWhileInUseError extends Schema.TaggedError<CannotUpdateEntityWhileInUseError>()("CannotUpdateEntityWhileInUse", CannotUpdateEntityWhileInUse) {};
export class TooManyDistributionCNAMEsError extends Schema.TaggedError<TooManyDistributionCNAMEsError>()("TooManyDistributionCNAMEs", TooManyDistributionCNAMEs) {};
export class CloudFrontOriginAccessIdentityAlreadyExistsError extends Schema.TaggedError<CloudFrontOriginAccessIdentityAlreadyExistsError>()("CloudFrontOriginAccessIdentityAlreadyExists", CloudFrontOriginAccessIdentityAlreadyExists) {};
export class MissingBodyError extends Schema.TaggedError<MissingBodyError>()("MissingBody", MissingBody) {};
export class InvalidAssociationError extends Schema.TaggedError<InvalidAssociationError>()("InvalidAssociation", InvalidAssociation) {};
export class DistributionAlreadyExistsError extends Schema.TaggedError<DistributionAlreadyExistsError>()("DistributionAlreadyExists", DistributionAlreadyExists) {};
export class IllegalOriginAccessConfigurationError extends Schema.TaggedError<IllegalOriginAccessConfigurationError>()("IllegalOriginAccessConfiguration", IllegalOriginAccessConfiguration) {};
export class InvalidDefaultRootObjectError extends Schema.TaggedError<InvalidDefaultRootObjectError>()("InvalidDefaultRootObject", InvalidDefaultRootObject) {};
export class BatchTooLargeError extends Schema.TaggedError<BatchTooLargeError>()("BatchTooLarge", BatchTooLarge) {};
export class TooManyInvalidationsInProgressError extends Schema.TaggedError<TooManyInvalidationsInProgressError>()("TooManyInvalidationsInProgress", TooManyInvalidationsInProgress) {};
export class TooManyKeyGroupsError extends Schema.TaggedError<TooManyKeyGroupsError>()("TooManyKeyGroups", TooManyKeyGroups) {};
export class TooManyPublicKeysInKeyGroupError extends Schema.TaggedError<TooManyPublicKeysInKeyGroupError>()("TooManyPublicKeysInKeyGroup", TooManyPublicKeysInKeyGroup) {};
export class EntitySizeLimitExceededError extends Schema.TaggedError<EntitySizeLimitExceededError>()("EntitySizeLimitExceeded", EntitySizeLimitExceeded) {};
export class TooManyOriginAccessControlsError extends Schema.TaggedError<TooManyOriginAccessControlsError>()("TooManyOriginAccessControls", TooManyOriginAccessControls) {};
export class PublicKeyAlreadyExistsError extends Schema.TaggedError<PublicKeyAlreadyExistsError>()("PublicKeyAlreadyExists", PublicKeyAlreadyExists) {};
export class InvalidOriginError extends Schema.TaggedError<InvalidOriginError>()("InvalidOrigin", InvalidOrigin) {};
export class InvalidOriginAccessIdentityError extends Schema.TaggedError<InvalidOriginAccessIdentityError>()("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity) {};
export class StreamingDistributionAlreadyExistsError extends Schema.TaggedError<StreamingDistributionAlreadyExistsError>()("StreamingDistributionAlreadyExists", StreamingDistributionAlreadyExists) {};
export class OriginRequestPolicyInUseError extends Schema.TaggedError<OriginRequestPolicyInUseError>()("OriginRequestPolicyInUse", OriginRequestPolicyInUse) {};
export class RealtimeLogConfigInUseError extends Schema.TaggedError<RealtimeLogConfigInUseError>()("RealtimeLogConfigInUse", RealtimeLogConfigInUse) {};
export class TestFunctionFailedError extends Schema.TaggedError<TestFunctionFailedError>()("TestFunctionFailed", TestFunctionFailed) {};
export class TooManyCookiesInCachePolicyError extends Schema.TaggedError<TooManyCookiesInCachePolicyError>()("TooManyCookiesInCachePolicy", TooManyCookiesInCachePolicy) {};
export class InvalidDomainNameForOriginAccessControlError extends Schema.TaggedError<InvalidDomainNameForOriginAccessControlError>()("InvalidDomainNameForOriginAccessControl", InvalidDomainNameForOriginAccessControl) {};
export class InvalidErrorCodeError extends Schema.TaggedError<InvalidErrorCodeError>()("InvalidErrorCode", InvalidErrorCode) {};
export class TooManyFieldLevelEncryptionContentTypeProfilesError extends Schema.TaggedError<TooManyFieldLevelEncryptionContentTypeProfilesError>()("TooManyFieldLevelEncryptionContentTypeProfiles", TooManyFieldLevelEncryptionContentTypeProfiles) {};
export class FieldLevelEncryptionProfileSizeExceededError extends Schema.TaggedError<FieldLevelEncryptionProfileSizeExceededError>()("FieldLevelEncryptionProfileSizeExceeded", FieldLevelEncryptionProfileSizeExceeded) {};
export class TooManyCookiesInOriginRequestPolicyError extends Schema.TaggedError<TooManyCookiesInOriginRequestPolicyError>()("TooManyCookiesInOriginRequestPolicy", TooManyCookiesInOriginRequestPolicy) {};
export class TooLongCSPInResponseHeadersPolicyError extends Schema.TaggedError<TooLongCSPInResponseHeadersPolicyError>()("TooLongCSPInResponseHeadersPolicy", TooLongCSPInResponseHeadersPolicy) {};
export class TooManyStreamingDistributionCNAMEsError extends Schema.TaggedError<TooManyStreamingDistributionCNAMEsError>()("TooManyStreamingDistributionCNAMEs", TooManyStreamingDistributionCNAMEs) {};
export class TooManyCloudFrontOriginAccessIdentitiesError extends Schema.TaggedError<TooManyCloudFrontOriginAccessIdentitiesError>()("TooManyCloudFrontOriginAccessIdentities", TooManyCloudFrontOriginAccessIdentities) {};
export class InvalidForwardCookiesError extends Schema.TaggedError<InvalidForwardCookiesError>()("InvalidForwardCookies", InvalidForwardCookies) {};
export class MonitoringSubscriptionAlreadyExistsError extends Schema.TaggedError<MonitoringSubscriptionAlreadyExistsError>()("MonitoringSubscriptionAlreadyExists", MonitoringSubscriptionAlreadyExists) {};
export class TooManyHeadersInOriginRequestPolicyError extends Schema.TaggedError<TooManyHeadersInOriginRequestPolicyError>()("TooManyHeadersInOriginRequestPolicy", TooManyHeadersInOriginRequestPolicy) {};
export class TooManyPublicKeysError extends Schema.TaggedError<TooManyPublicKeysError>()("TooManyPublicKeys", TooManyPublicKeys) {};
export class RealtimeLogConfigAlreadyExistsError extends Schema.TaggedError<RealtimeLogConfigAlreadyExistsError>()("RealtimeLogConfigAlreadyExists", RealtimeLogConfigAlreadyExists) {};
export class TooManyCustomHeadersInResponseHeadersPolicyError extends Schema.TaggedError<TooManyCustomHeadersInResponseHeadersPolicyError>()("TooManyCustomHeadersInResponseHeadersPolicy", TooManyCustomHeadersInResponseHeadersPolicy) {};
export class TooManyStreamingDistributionsError extends Schema.TaggedError<TooManyStreamingDistributionsError>()("TooManyStreamingDistributions", TooManyStreamingDistributions) {};
export class TooManyTrustedSignersError extends Schema.TaggedError<TooManyTrustedSignersError>()("TooManyTrustedSigners", TooManyTrustedSigners) {};
export class TooManyHeadersInCachePolicyError extends Schema.TaggedError<TooManyHeadersInCachePolicyError>()("TooManyHeadersInCachePolicy", TooManyHeadersInCachePolicy) {};
export class InvalidFunctionAssociationError extends Schema.TaggedError<InvalidFunctionAssociationError>()("InvalidFunctionAssociation", InvalidFunctionAssociation) {};
export class InvalidGeoRestrictionParameterError extends Schema.TaggedError<InvalidGeoRestrictionParameterError>()("InvalidGeoRestrictionParameter", InvalidGeoRestrictionParameter) {};
export class TooManyFieldLevelEncryptionQueryArgProfilesError extends Schema.TaggedError<TooManyFieldLevelEncryptionQueryArgProfilesError>()("TooManyFieldLevelEncryptionQueryArgProfiles", TooManyFieldLevelEncryptionQueryArgProfiles) {};
export class TooManyFieldLevelEncryptionEncryptionEntitiesError extends Schema.TaggedError<TooManyFieldLevelEncryptionEncryptionEntitiesError>()("TooManyFieldLevelEncryptionEncryptionEntities", TooManyFieldLevelEncryptionEncryptionEntities) {};
export class TooManyRemoveHeadersInResponseHeadersPolicyError extends Schema.TaggedError<TooManyRemoveHeadersInResponseHeadersPolicyError>()("TooManyRemoveHeadersInResponseHeadersPolicy", TooManyRemoveHeadersInResponseHeadersPolicy) {};
export class TrustedSignerDoesNotExistError extends Schema.TaggedError<TrustedSignerDoesNotExistError>()("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist) {};
export class InvalidHeadersForS3OriginError extends Schema.TaggedError<InvalidHeadersForS3OriginError>()("InvalidHeadersForS3Origin", InvalidHeadersForS3Origin) {};
export class TooManyCachePoliciesError extends Schema.TaggedError<TooManyCachePoliciesError>()("TooManyCachePolicies", TooManyCachePolicies) {};
export class TooManyQueryStringsInCachePolicyError extends Schema.TaggedError<TooManyQueryStringsInCachePolicyError>()("TooManyQueryStringsInCachePolicy", TooManyQueryStringsInCachePolicy) {};
export class InvalidLambdaFunctionAssociationError extends Schema.TaggedError<InvalidLambdaFunctionAssociationError>()("InvalidLambdaFunctionAssociation", InvalidLambdaFunctionAssociation) {};
export class TooManyFieldLevelEncryptionFieldPatternsError extends Schema.TaggedError<TooManyFieldLevelEncryptionFieldPatternsError>()("TooManyFieldLevelEncryptionFieldPatterns", TooManyFieldLevelEncryptionFieldPatterns) {};
export class FunctionAlreadyExistsError extends Schema.TaggedError<FunctionAlreadyExistsError>()("FunctionAlreadyExists", FunctionAlreadyExists) {};
export class TooManyOriginRequestPoliciesError extends Schema.TaggedError<TooManyOriginRequestPoliciesError>()("TooManyOriginRequestPolicies", TooManyOriginRequestPolicies) {};
export class TooManyQueryStringsInOriginRequestPolicyError extends Schema.TaggedError<TooManyQueryStringsInOriginRequestPolicyError>()("TooManyQueryStringsInOriginRequestPolicy", TooManyQueryStringsInOriginRequestPolicy) {};
export class TooManyRealtimeLogConfigsError extends Schema.TaggedError<TooManyRealtimeLogConfigsError>()("TooManyRealtimeLogConfigs", TooManyRealtimeLogConfigs) {};
export class InvalidLocationCodeError extends Schema.TaggedError<InvalidLocationCodeError>()("InvalidLocationCode", InvalidLocationCode) {};
export class InvalidMinimumProtocolVersionError extends Schema.TaggedError<InvalidMinimumProtocolVersionError>()("InvalidMinimumProtocolVersion", InvalidMinimumProtocolVersion) {};
export class InvalidOriginKeepaliveTimeoutError extends Schema.TaggedError<InvalidOriginKeepaliveTimeoutError>()("InvalidOriginKeepaliveTimeout", InvalidOriginKeepaliveTimeout) {};
export class ContinuousDeploymentPolicyAlreadyExistsError extends Schema.TaggedError<ContinuousDeploymentPolicyAlreadyExistsError>()("ContinuousDeploymentPolicyAlreadyExists", ContinuousDeploymentPolicyAlreadyExists) {};
export class InvalidOriginReadTimeoutError extends Schema.TaggedError<InvalidOriginReadTimeoutError>()("InvalidOriginReadTimeout", InvalidOriginReadTimeout) {};
export class InvalidProtocolSettingsError extends Schema.TaggedError<InvalidProtocolSettingsError>()("InvalidProtocolSettings", InvalidProtocolSettings) {};
export class FieldLevelEncryptionConfigAlreadyExistsError extends Schema.TaggedError<FieldLevelEncryptionConfigAlreadyExistsError>()("FieldLevelEncryptionConfigAlreadyExists", FieldLevelEncryptionConfigAlreadyExists) {};
export class TooManyFieldLevelEncryptionProfilesError extends Schema.TaggedError<TooManyFieldLevelEncryptionProfilesError>()("TooManyFieldLevelEncryptionProfiles", TooManyFieldLevelEncryptionProfiles) {};
export class TooManyFunctionsError extends Schema.TaggedError<TooManyFunctionsError>()("TooManyFunctions", TooManyFunctions) {};
export class TooManyResponseHeadersPoliciesError extends Schema.TaggedError<TooManyResponseHeadersPoliciesError>()("TooManyResponseHeadersPolicies", TooManyResponseHeadersPolicies) {};
export class InvalidQueryStringParametersError extends Schema.TaggedError<InvalidQueryStringParametersError>()("InvalidQueryStringParameters", InvalidQueryStringParameters) {};
export class InvalidRelativePathError extends Schema.TaggedError<InvalidRelativePathError>()("InvalidRelativePath", InvalidRelativePath) {};
export class InvalidRequiredProtocolError extends Schema.TaggedError<InvalidRequiredProtocolError>()("InvalidRequiredProtocol", InvalidRequiredProtocol) {};
export class TooManyContinuousDeploymentPoliciesError extends Schema.TaggedError<TooManyContinuousDeploymentPoliciesError>()("TooManyContinuousDeploymentPolicies", TooManyContinuousDeploymentPolicies) {};
export class InvalidResponseCodeError extends Schema.TaggedError<InvalidResponseCodeError>()("InvalidResponseCode", InvalidResponseCode) {};
export class InvalidTTLOrderError extends Schema.TaggedError<InvalidTTLOrderError>()("InvalidTTLOrder", InvalidTTLOrder) {};
export class TooManyFieldLevelEncryptionConfigsError extends Schema.TaggedError<TooManyFieldLevelEncryptionConfigsError>()("TooManyFieldLevelEncryptionConfigs", TooManyFieldLevelEncryptionConfigs) {};
export class InvalidViewerCertificateError extends Schema.TaggedError<InvalidViewerCertificateError>()("InvalidViewerCertificate", InvalidViewerCertificate) {};
export class NoSuchOriginError extends Schema.TaggedError<NoSuchOriginError>()("NoSuchOrigin", NoSuchOrigin) {};
export class RealtimeLogConfigOwnerMismatchError extends Schema.TaggedError<RealtimeLogConfigOwnerMismatchError>()("RealtimeLogConfigOwnerMismatch", RealtimeLogConfigOwnerMismatch) {};
export class TooManyCacheBehaviorsError extends Schema.TaggedError<TooManyCacheBehaviorsError>()("TooManyCacheBehaviors", TooManyCacheBehaviors) {};
export class TooManyCertificatesError extends Schema.TaggedError<TooManyCertificatesError>()("TooManyCertificates", TooManyCertificates) {};
export class TooManyCookieNamesInWhiteListError extends Schema.TaggedError<TooManyCookieNamesInWhiteListError>()("TooManyCookieNamesInWhiteList", TooManyCookieNamesInWhiteList) {};
export class TooManyDistributionsAssociatedToCachePolicyError extends Schema.TaggedError<TooManyDistributionsAssociatedToCachePolicyError>()("TooManyDistributionsAssociatedToCachePolicy", TooManyDistributionsAssociatedToCachePolicy) {};
export class TooManyDistributionsError extends Schema.TaggedError<TooManyDistributionsError>()("TooManyDistributions", TooManyDistributions) {};
export class TooManyDistributionsAssociatedToFieldLevelEncryptionConfigError extends Schema.TaggedError<TooManyDistributionsAssociatedToFieldLevelEncryptionConfigError>()("TooManyDistributionsAssociatedToFieldLevelEncryptionConfig", TooManyDistributionsAssociatedToFieldLevelEncryptionConfig) {};
export class TooManyDistributionsAssociatedToKeyGroupError extends Schema.TaggedError<TooManyDistributionsAssociatedToKeyGroupError>()("TooManyDistributionsAssociatedToKeyGroup", TooManyDistributionsAssociatedToKeyGroup) {};
export class TooManyDistributionsAssociatedToOriginAccessControlError extends Schema.TaggedError<TooManyDistributionsAssociatedToOriginAccessControlError>()("TooManyDistributionsAssociatedToOriginAccessControl", TooManyDistributionsAssociatedToOriginAccessControl) {};
export class TooManyDistributionsAssociatedToOriginRequestPolicyError extends Schema.TaggedError<TooManyDistributionsAssociatedToOriginRequestPolicyError>()("TooManyDistributionsAssociatedToOriginRequestPolicy", TooManyDistributionsAssociatedToOriginRequestPolicy) {};
export class TooManyDistributionsAssociatedToResponseHeadersPolicyError extends Schema.TaggedError<TooManyDistributionsAssociatedToResponseHeadersPolicyError>()("TooManyDistributionsAssociatedToResponseHeadersPolicy", TooManyDistributionsAssociatedToResponseHeadersPolicy) {};
export class TooManyDistributionsWithFunctionAssociationsError extends Schema.TaggedError<TooManyDistributionsWithFunctionAssociationsError>()("TooManyDistributionsWithFunctionAssociations", TooManyDistributionsWithFunctionAssociations) {};
export class TooManyDistributionsWithLambdaAssociationsError extends Schema.TaggedError<TooManyDistributionsWithLambdaAssociationsError>()("TooManyDistributionsWithLambdaAssociations", TooManyDistributionsWithLambdaAssociations) {};
export class TooManyDistributionsWithSingleFunctionARNError extends Schema.TaggedError<TooManyDistributionsWithSingleFunctionARNError>()("TooManyDistributionsWithSingleFunctionARN", TooManyDistributionsWithSingleFunctionARN) {};
export class TooManyFunctionAssociationsError extends Schema.TaggedError<TooManyFunctionAssociationsError>()("TooManyFunctionAssociations", TooManyFunctionAssociations) {};
export class TooManyHeadersInForwardedValuesError extends Schema.TaggedError<TooManyHeadersInForwardedValuesError>()("TooManyHeadersInForwardedValues", TooManyHeadersInForwardedValues) {};
export class TooManyKeyGroupsAssociatedToDistributionError extends Schema.TaggedError<TooManyKeyGroupsAssociatedToDistributionError>()("TooManyKeyGroupsAssociatedToDistribution", TooManyKeyGroupsAssociatedToDistribution) {};
export class TooManyLambdaFunctionAssociationsError extends Schema.TaggedError<TooManyLambdaFunctionAssociationsError>()("TooManyLambdaFunctionAssociations", TooManyLambdaFunctionAssociations) {};
export class TooManyOriginCustomHeadersError extends Schema.TaggedError<TooManyOriginCustomHeadersError>()("TooManyOriginCustomHeaders", TooManyOriginCustomHeaders) {};
export class TooManyOriginGroupsPerDistributionError extends Schema.TaggedError<TooManyOriginGroupsPerDistributionError>()("TooManyOriginGroupsPerDistribution", TooManyOriginGroupsPerDistribution) {};
export class TooManyOriginsError extends Schema.TaggedError<TooManyOriginsError>()("TooManyOrigins", TooManyOrigins) {};
export class TooManyQueryStringParametersError extends Schema.TaggedError<TooManyQueryStringParametersError>()("TooManyQueryStringParameters", TooManyQueryStringParameters) {};
export class TrustedKeyGroupDoesNotExistError extends Schema.TaggedError<TrustedKeyGroupDoesNotExistError>()("TrustedKeyGroupDoesNotExist", TrustedKeyGroupDoesNotExist) {};

//# Operations
export const associateDistributionTenantWebACL = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Id}/associate-web-acl", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.AssociateDistributionTenantWebACL" }, AssociateDistributionTenantWebACLRequest, AssociateDistributionTenantWebACLResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, InvalidIfMatchVersionError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const associateDistributionWebACL = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}/associate-web-acl", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.AssociateDistributionWebACL" }, AssociateDistributionWebACLRequest, AssociateDistributionWebACLResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, InvalidIfMatchVersionError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteAnycastIpList = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/anycast-ip-list/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteAnycastIpList" }, DeleteAnycastIpListRequest, Schema.Struct({}), [AccessDeniedError, CannotDeleteEntityWhileInUseError, EntityNotFoundError, IllegalDeleteError, InvalidArgumentError, InvalidIfMatchVersionError, PreconditionFailedError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteDistributionTenant" }, DeleteDistributionTenantRequest, Schema.Struct({}), [AccessDeniedError, EntityNotFoundError, InvalidIfMatchVersionError, PreconditionFailedError, ResourceNotDisabledError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-group/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteKeyGroup" }, DeleteKeyGroupRequest, Schema.Struct({}), [InvalidIfMatchVersionError, NoSuchResourceError, PreconditionFailedError, ResourceInUseError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteKeyValueStore = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-value-store/{Name}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteKeyValueStore" }, DeleteKeyValueStoreRequest, Schema.Struct({}), [AccessDeniedError, CannotDeleteEntityWhileInUseError, EntityNotFoundError, InvalidIfMatchVersionError, PreconditionFailedError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/delete-resource-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteResourcePolicy" }, DeleteResourcePolicyRequest, Schema.Struct({}), [AccessDeniedError, EntityNotFoundError, IllegalDeleteError, InvalidArgumentError, PreconditionFailedError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const disassociateDistributionTenantWebACL = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Id}/disassociate-web-acl", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DisassociateDistributionTenantWebACL" }, DisassociateDistributionTenantWebACLRequest, DisassociateDistributionTenantWebACLResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, InvalidIfMatchVersionError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const disassociateDistributionWebACL = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}/disassociate-web-acl", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DisassociateDistributionWebACL" }, DisassociateDistributionWebACLRequest, DisassociateDistributionWebACLResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, InvalidIfMatchVersionError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getCachePolicyConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/cache-policy/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetCachePolicyConfig" }, GetCachePolicyConfigRequest, GetCachePolicyConfigResult, [AccessDeniedError, NoSuchCachePolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getCloudFrontOriginAccessIdentityConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-identity/cloudfront/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetCloudFrontOriginAccessIdentityConfig" }, GetCloudFrontOriginAccessIdentityConfigRequest, GetCloudFrontOriginAccessIdentityConfigResult, [AccessDeniedError, NoSuchCloudFrontOriginAccessIdentityError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getConnectionGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/connection-group/{Identifier}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetConnectionGroup" }, GetConnectionGroupRequest, GetConnectionGroupResult, [AccessDeniedError, EntityNotFoundError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getConnectionGroupByRoutingEndpoint = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/connection-group", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetConnectionGroupByRoutingEndpoint" }, GetConnectionGroupByRoutingEndpointRequest, GetConnectionGroupByRoutingEndpointResult, [AccessDeniedError, EntityNotFoundError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getContinuousDeploymentPolicyConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/continuous-deployment-policy/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetContinuousDeploymentPolicyConfig" }, GetContinuousDeploymentPolicyConfigRequest, GetContinuousDeploymentPolicyConfigResult, [AccessDeniedError, NoSuchContinuousDeploymentPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetDistribution" }, GetDistributionRequest, GetDistributionResult, [AccessDeniedError, NoSuchDistributionError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getDistributionConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetDistributionConfig" }, GetDistributionConfigRequest, GetDistributionConfigResult, [AccessDeniedError, NoSuchDistributionError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getDistributionTenantByDomain = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetDistributionTenantByDomain" }, GetDistributionTenantByDomainRequest, GetDistributionTenantByDomainResult, [AccessDeniedError, EntityNotFoundError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getFieldLevelEncryptionConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetFieldLevelEncryptionConfig" }, GetFieldLevelEncryptionConfigRequest, GetFieldLevelEncryptionConfigResult, [AccessDeniedError, NoSuchFieldLevelEncryptionConfigError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getFieldLevelEncryptionProfileConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption-profile/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetFieldLevelEncryptionProfileConfig" }, GetFieldLevelEncryptionProfileConfigRequest, GetFieldLevelEncryptionProfileConfigResult, [AccessDeniedError, NoSuchFieldLevelEncryptionProfileError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function/{Name}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetFunction" }, GetFunctionRequest, GetFunctionResult, [NoSuchFunctionExistsError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getInvalidationForDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{DistributionTenantId}/invalidation/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetInvalidationForDistributionTenant" }, GetInvalidationForDistributionTenantRequest, GetInvalidationForDistributionTenantResult, [AccessDeniedError, EntityNotFoundError, NoSuchInvalidationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getKeyGroupConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-group/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetKeyGroupConfig" }, GetKeyGroupConfigRequest, GetKeyGroupConfigResult, [NoSuchResourceError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getMonitoringSubscription = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributions/{DistributionId}/monitoring-subscription", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetMonitoringSubscription" }, GetMonitoringSubscriptionRequest, GetMonitoringSubscriptionResult, [AccessDeniedError, NoSuchDistributionError, NoSuchMonitoringSubscriptionError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getOriginAccessControlConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-control/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetOriginAccessControlConfig" }, GetOriginAccessControlConfigRequest, GetOriginAccessControlConfigResult, [AccessDeniedError, NoSuchOriginAccessControlError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getOriginRequestPolicyConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-request-policy/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetOriginRequestPolicyConfig" }, GetOriginRequestPolicyConfigRequest, GetOriginRequestPolicyConfigResult, [AccessDeniedError, NoSuchOriginRequestPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getPublicKeyConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/public-key/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetPublicKeyConfig" }, GetPublicKeyConfigRequest, GetPublicKeyConfigResult, [AccessDeniedError, NoSuchPublicKeyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/get-resource-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetResourcePolicy" }, GetResourcePolicyRequest, GetResourcePolicyResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getResponseHeadersPolicyConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/response-headers-policy/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetResponseHeadersPolicyConfig" }, GetResponseHeadersPolicyConfigRequest, GetResponseHeadersPolicyConfigResult, [AccessDeniedError, NoSuchResponseHeadersPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getStreamingDistributionConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetStreamingDistributionConfig" }, GetStreamingDistributionConfigRequest, GetStreamingDistributionConfigResult, [AccessDeniedError, NoSuchStreamingDistributionError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getVpcOrigin = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/vpc-origin/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetVpcOrigin" }, GetVpcOriginRequest, GetVpcOriginResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDistributionsByAnycastIpListId = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByAnycastIpListId/{AnycastIpListId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByAnycastIpListId" }, ListDistributionsByAnycastIpListIdRequest, ListDistributionsByAnycastIpListIdResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDistributionsByConnectionMode = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByConnectionMode/{ConnectionMode}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByConnectionMode" }, ListDistributionsByConnectionModeRequest, ListDistributionsByConnectionModeResult, [AccessDeniedError, InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDistributionsByKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByKeyGroupId/{KeyGroupId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByKeyGroup" }, ListDistributionsByKeyGroupRequest, ListDistributionsByKeyGroupResult, [InvalidArgumentError, NoSuchResourceError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDistributionsByOriginRequestPolicyId = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByOriginRequestPolicyId/{OriginRequestPolicyId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByOriginRequestPolicyId" }, ListDistributionsByOriginRequestPolicyIdRequest, ListDistributionsByOriginRequestPolicyIdResult, [AccessDeniedError, InvalidArgumentError, NoSuchOriginRequestPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDistributionsByRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByRealtimeLogConfig", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByRealtimeLogConfig" }, ListDistributionsByRealtimeLogConfigRequest, ListDistributionsByRealtimeLogConfigResult, [InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDistributionsByResponseHeadersPolicyId = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByResponseHeadersPolicyId/{ResponseHeadersPolicyId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByResponseHeadersPolicyId" }, ListDistributionsByResponseHeadersPolicyIdRequest, ListDistributionsByResponseHeadersPolicyIdResult, [AccessDeniedError, InvalidArgumentError, NoSuchResponseHeadersPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDistributionsByVpcOriginId = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByVpcOriginId/{VpcOriginId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByVpcOriginId" }, ListDistributionsByVpcOriginIdRequest, ListDistributionsByVpcOriginIdResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listInvalidationsForDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Id}/invalidation", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListInvalidationsForDistributionTenant" }, ListInvalidationsForDistributionTenantRequest, ListInvalidationsForDistributionTenantResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/tagging", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResult, [AccessDeniedError, InvalidArgumentError, InvalidTaggingError, NoSuchResourceError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const publishFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function/{Name}/publish", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.PublishFunction" }, PublishFunctionRequest, PublishFunctionResult, [InvalidArgumentError, InvalidIfMatchVersionError, NoSuchFunctionExistsError, PreconditionFailedError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const putResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/put-resource-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.PutResourcePolicy" }, PutResourcePolicyRequest, PutResourcePolicyResult, [AccessDeniedError, EntityNotFoundError, IllegalUpdateError, InvalidArgumentError, PreconditionFailedError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const tagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/tagging?Operation=Tag", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.TagResource" }, TagResourceRequest, Schema.Struct({}), [AccessDeniedError, InvalidArgumentError, InvalidTaggingError, NoSuchResourceError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const untagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/tagging?Operation=Untag", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UntagResource" }, UntagResourceRequest, Schema.Struct({}), [AccessDeniedError, InvalidArgumentError, InvalidTaggingError, NoSuchResourceError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateAnycastIpList = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/anycast-ip-list/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateAnycastIpList" }, UpdateAnycastIpListRequest, UpdateAnycastIpListResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, InvalidIfMatchVersionError, PreconditionFailedError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateDomainAssociation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/domain-association", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateDomainAssociation" }, UpdateDomainAssociationRequest, UpdateDomainAssociationResult, [AccessDeniedError, EntityNotFoundError, IllegalUpdateError, InvalidArgumentError, InvalidIfMatchVersionError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateKeyValueStore = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-value-store/{Name}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateKeyValueStore" }, UpdateKeyValueStoreRequest, UpdateKeyValueStoreResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, InvalidIfMatchVersionError, PreconditionFailedError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/realtime-log-config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateRealtimeLogConfig" }, UpdateRealtimeLogConfigRequest, UpdateRealtimeLogConfigResult, [AccessDeniedError, InvalidArgumentError, NoSuchRealtimeLogConfigError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createConnectionGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/connection-group", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateConnectionGroup" }, CreateConnectionGroupRequest, CreateConnectionGroupResult, [AccessDeniedError, EntityAlreadyExistsError, EntityLimitExceededError, EntityNotFoundError, InvalidArgumentError, InvalidTaggingError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteCachePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/cache-policy/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteCachePolicy" }, DeleteCachePolicyRequest, Schema.Struct({}), [AccessDeniedError, CachePolicyInUseError, IllegalDeleteError, InvalidIfMatchVersionError, NoSuchCachePolicyError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteCloudFrontOriginAccessIdentity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-identity/cloudfront/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteCloudFrontOriginAccessIdentity" }, DeleteCloudFrontOriginAccessIdentityRequest, Schema.Struct({}), [AccessDeniedError, CloudFrontOriginAccessIdentityInUseError, InvalidIfMatchVersionError, NoSuchCloudFrontOriginAccessIdentityError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteConnectionGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/connection-group/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteConnectionGroup" }, DeleteConnectionGroupRequest, Schema.Struct({}), [AccessDeniedError, CannotDeleteEntityWhileInUseError, EntityNotFoundError, InvalidIfMatchVersionError, PreconditionFailedError, ResourceNotDisabledError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteContinuousDeploymentPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/continuous-deployment-policy/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteContinuousDeploymentPolicy" }, DeleteContinuousDeploymentPolicyRequest, Schema.Struct({}), [AccessDeniedError, ContinuousDeploymentPolicyInUseError, InvalidArgumentError, InvalidIfMatchVersionError, NoSuchContinuousDeploymentPolicyError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteDistribution" }, DeleteDistributionRequest, Schema.Struct({}), [AccessDeniedError, DistributionNotDisabledError, InvalidIfMatchVersionError, NoSuchDistributionError, PreconditionFailedError, ResourceInUseError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteFieldLevelEncryptionConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteFieldLevelEncryptionConfig" }, DeleteFieldLevelEncryptionConfigRequest, Schema.Struct({}), [AccessDeniedError, FieldLevelEncryptionConfigInUseError, InvalidIfMatchVersionError, NoSuchFieldLevelEncryptionConfigError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteFieldLevelEncryptionProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption-profile/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteFieldLevelEncryptionProfile" }, DeleteFieldLevelEncryptionProfileRequest, Schema.Struct({}), [AccessDeniedError, FieldLevelEncryptionProfileInUseError, InvalidIfMatchVersionError, NoSuchFieldLevelEncryptionProfileError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function/{Name}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteFunction" }, DeleteFunctionRequest, Schema.Struct({}), [FunctionInUseError, InvalidIfMatchVersionError, NoSuchFunctionExistsError, PreconditionFailedError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteMonitoringSubscription = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributions/{DistributionId}/monitoring-subscription", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteMonitoringSubscription" }, DeleteMonitoringSubscriptionRequest, DeleteMonitoringSubscriptionResult, [AccessDeniedError, NoSuchDistributionError, NoSuchMonitoringSubscriptionError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteOriginAccessControl = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-control/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteOriginAccessControl" }, DeleteOriginAccessControlRequest, Schema.Struct({}), [AccessDeniedError, InvalidIfMatchVersionError, NoSuchOriginAccessControlError, OriginAccessControlInUseError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deletePublicKey = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/public-key/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeletePublicKey" }, DeletePublicKeyRequest, Schema.Struct({}), [AccessDeniedError, InvalidIfMatchVersionError, NoSuchPublicKeyError, PreconditionFailedError, PublicKeyInUseError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteResponseHeadersPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/response-headers-policy/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteResponseHeadersPolicy" }, DeleteResponseHeadersPolicyRequest, Schema.Struct({}), [AccessDeniedError, IllegalDeleteError, InvalidIfMatchVersionError, NoSuchResponseHeadersPolicyError, PreconditionFailedError, ResponseHeadersPolicyInUseError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteStreamingDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteStreamingDistribution" }, DeleteStreamingDistributionRequest, Schema.Struct({}), [AccessDeniedError, InvalidIfMatchVersionError, NoSuchStreamingDistributionError, PreconditionFailedError, StreamingDistributionNotDisabledError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteVpcOrigin = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/vpc-origin/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteVpcOrigin" }, DeleteVpcOriginRequest, DeleteVpcOriginResult, [AccessDeniedError, CannotDeleteEntityWhileInUseError, EntityNotFoundError, IllegalDeleteError, InvalidArgumentError, InvalidIfMatchVersionError, PreconditionFailedError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const describeKeyValueStore = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-value-store/{Name}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DescribeKeyValueStore" }, DescribeKeyValueStoreRequest, DescribeKeyValueStoreResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getAnycastIpList = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/anycast-ip-list/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetAnycastIpList" }, GetAnycastIpListRequest, GetAnycastIpListResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getCachePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/cache-policy/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetCachePolicy" }, GetCachePolicyRequest, GetCachePolicyResult, [AccessDeniedError, NoSuchCachePolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getCloudFrontOriginAccessIdentity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-identity/cloudfront/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetCloudFrontOriginAccessIdentity" }, GetCloudFrontOriginAccessIdentityRequest, GetCloudFrontOriginAccessIdentityResult, [AccessDeniedError, NoSuchCloudFrontOriginAccessIdentityError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getContinuousDeploymentPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/continuous-deployment-policy/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetContinuousDeploymentPolicy" }, GetContinuousDeploymentPolicyRequest, GetContinuousDeploymentPolicyResult, [AccessDeniedError, NoSuchContinuousDeploymentPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getFieldLevelEncryption = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetFieldLevelEncryption" }, GetFieldLevelEncryptionRequest, GetFieldLevelEncryptionResult, [AccessDeniedError, NoSuchFieldLevelEncryptionConfigError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getFieldLevelEncryptionProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption-profile/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetFieldLevelEncryptionProfile" }, GetFieldLevelEncryptionProfileRequest, GetFieldLevelEncryptionProfileResult, [AccessDeniedError, NoSuchFieldLevelEncryptionProfileError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getInvalidation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{DistributionId}/invalidation/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetInvalidation" }, GetInvalidationRequest, GetInvalidationResult, [AccessDeniedError, NoSuchDistributionError, NoSuchInvalidationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-group/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetKeyGroup" }, GetKeyGroupRequest, GetKeyGroupResult, [NoSuchResourceError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getOriginAccessControl = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-control/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetOriginAccessControl" }, GetOriginAccessControlRequest, GetOriginAccessControlResult, [AccessDeniedError, NoSuchOriginAccessControlError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getOriginRequestPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-request-policy/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetOriginRequestPolicy" }, GetOriginRequestPolicyRequest, GetOriginRequestPolicyResult, [AccessDeniedError, NoSuchOriginRequestPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getPublicKey = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/public-key/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetPublicKey" }, GetPublicKeyRequest, GetPublicKeyResult, [AccessDeniedError, NoSuchPublicKeyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/get-realtime-log-config", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetRealtimeLogConfig" }, GetRealtimeLogConfigRequest, GetRealtimeLogConfigResult, [AccessDeniedError, InvalidArgumentError, NoSuchRealtimeLogConfigError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getResponseHeadersPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/response-headers-policy/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetResponseHeadersPolicy" }, GetResponseHeadersPolicyRequest, GetResponseHeadersPolicyResult, [AccessDeniedError, NoSuchResponseHeadersPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getStreamingDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetStreamingDistribution" }, GetStreamingDistributionRequest, GetStreamingDistributionResult, [AccessDeniedError, NoSuchStreamingDistributionError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDistributionsByCachePolicyId = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByCachePolicyId/{CachePolicyId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByCachePolicyId" }, ListDistributionsByCachePolicyIdRequest, ListDistributionsByCachePolicyIdResult, [AccessDeniedError, InvalidArgumentError, NoSuchCachePolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDistributionsByWebACLId = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByWebACLId/{WebACLId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByWebACLId" }, ListDistributionsByWebACLIdRequest, ListDistributionsByWebACLIdResult, [InvalidArgumentError, InvalidWebACLIdError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDistributionTenants = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenants", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionTenants" }, ListDistributionTenantsRequest, ListDistributionTenantsResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDistributionTenantsByCustomization = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenants-by-customization", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionTenantsByCustomization" }, ListDistributionTenantsByCustomizationRequest, ListDistributionTenantsByCustomizationResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listFunctions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListFunctions" }, ListFunctionsRequest, ListFunctionsResult, [InvalidArgumentError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listKeyValueStores = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-value-store", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListKeyValueStores" }, ListKeyValueStoresRequest, ListKeyValueStoresResult, [AccessDeniedError, InvalidArgumentError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listRealtimeLogConfigs = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/realtime-log-config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListRealtimeLogConfigs" }, ListRealtimeLogConfigsRequest, ListRealtimeLogConfigsResult, [AccessDeniedError, InvalidArgumentError, NoSuchRealtimeLogConfigError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateConnectionGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/connection-group/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateConnectionGroup" }, UpdateConnectionGroupRequest, UpdateConnectionGroupResult, [AccessDeniedError, EntityAlreadyExistsError, EntityLimitExceededError, EntityNotFoundError, InvalidArgumentError, InvalidIfMatchVersionError, PreconditionFailedError, ResourceInUseError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateContinuousDeploymentPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/continuous-deployment-policy/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateContinuousDeploymentPolicy" }, UpdateContinuousDeploymentPolicyRequest, UpdateContinuousDeploymentPolicyResult, [AccessDeniedError, InconsistentQuantitiesError, InvalidArgumentError, InvalidIfMatchVersionError, NoSuchContinuousDeploymentPolicyError, PreconditionFailedError, StagingDistributionInUseError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function/{Name}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateFunction" }, UpdateFunctionRequest, UpdateFunctionResult, [FunctionSizeLimitExceededError, InvalidArgumentError, InvalidIfMatchVersionError, NoSuchFunctionExistsError, PreconditionFailedError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateOriginAccessControl = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-control/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateOriginAccessControl" }, UpdateOriginAccessControlRequest, UpdateOriginAccessControlResult, [AccessDeniedError, IllegalUpdateError, InvalidArgumentError, InvalidIfMatchVersionError, NoSuchOriginAccessControlError, OriginAccessControlAlreadyExistsError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updatePublicKey = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/public-key/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdatePublicKey" }, UpdatePublicKeyRequest, UpdatePublicKeyResult, [AccessDeniedError, CannotChangeImmutablePublicKeyFieldsError, IllegalUpdateError, InvalidArgumentError, InvalidIfMatchVersionError, NoSuchPublicKeyError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateVpcOrigin = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/vpc-origin/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateVpcOrigin" }, UpdateVpcOriginRequest, UpdateVpcOriginResult, [AccessDeniedError, CannotUpdateEntityWhileInUseError, EntityAlreadyExistsError, EntityLimitExceededError, EntityNotFoundError, IllegalUpdateError, InconsistentQuantitiesError, InvalidArgumentError, InvalidIfMatchVersionError, PreconditionFailedError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const verifyDnsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/verify-dns-configuration", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.VerifyDnsConfiguration" }, VerifyDnsConfigurationRequest, VerifyDnsConfigurationResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const associateAlias = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{TargetDistributionId}/associate-alias", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.AssociateAlias" }, AssociateAliasRequest, Schema.Struct({}), [AccessDeniedError, IllegalUpdateError, InvalidArgumentError, NoSuchDistributionError, TooManyDistributionCNAMEsError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createAnycastIpList = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/anycast-ip-list", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateAnycastIpList" }, CreateAnycastIpListRequest, CreateAnycastIpListResult, [AccessDeniedError, EntityAlreadyExistsError, EntityLimitExceededError, InvalidArgumentError, InvalidTaggingError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateDistributionTenant" }, CreateDistributionTenantRequest, CreateDistributionTenantResult, [AccessDeniedError, CNAMEAlreadyExistsError, EntityAlreadyExistsError, EntityLimitExceededError, EntityNotFoundError, InvalidArgumentError, InvalidAssociationError, InvalidTaggingError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createInvalidationForDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Id}/invalidation", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateInvalidationForDistributionTenant" }, CreateInvalidationForDistributionTenantRequest, CreateInvalidationForDistributionTenantResult, [AccessDeniedError, BatchTooLargeError, EntityNotFoundError, InconsistentQuantitiesError, InvalidArgumentError, MissingBodyError, TooManyInvalidationsInProgressError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-group", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateKeyGroup" }, CreateKeyGroupRequest, CreateKeyGroupResult, [InvalidArgumentError, KeyGroupAlreadyExistsError, TooManyKeyGroupsError, TooManyPublicKeysInKeyGroupError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createKeyValueStore = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-value-store", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateKeyValueStore" }, CreateKeyValueStoreRequest, CreateKeyValueStoreResult, [AccessDeniedError, EntityAlreadyExistsError, EntityLimitExceededError, EntitySizeLimitExceededError, InvalidArgumentError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createOriginAccessControl = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-control", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateOriginAccessControl" }, CreateOriginAccessControlRequest, CreateOriginAccessControlResult, [InvalidArgumentError, OriginAccessControlAlreadyExistsError, TooManyOriginAccessControlsError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createVpcOrigin = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/vpc-origin", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateVpcOrigin" }, CreateVpcOriginRequest, CreateVpcOriginResult, [AccessDeniedError, EntityAlreadyExistsError, EntityLimitExceededError, InconsistentQuantitiesError, InvalidArgumentError, InvalidTaggingError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteOriginRequestPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-request-policy/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteOriginRequestPolicy" }, DeleteOriginRequestPolicyRequest, Schema.Struct({}), [AccessDeniedError, IllegalDeleteError, InvalidIfMatchVersionError, NoSuchOriginRequestPolicyError, OriginRequestPolicyInUseError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const deleteRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/delete-realtime-log-config", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteRealtimeLogConfig" }, DeleteRealtimeLogConfigRequest, Schema.Struct({}), [AccessDeniedError, InvalidArgumentError, NoSuchRealtimeLogConfigError, RealtimeLogConfigInUseError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const describeFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function/{Name}/describe", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DescribeFunction" }, DescribeFunctionRequest, DescribeFunctionResult, [NoSuchFunctionExistsError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Identifier}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetDistributionTenant" }, GetDistributionTenantRequest, GetDistributionTenantResult, [AccessDeniedError, EntityNotFoundError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const getManagedCertificateDetails = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/managed-certificate/{Identifier}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetManagedCertificateDetails" }, GetManagedCertificateDetailsRequest, GetManagedCertificateDetailsResult, [AccessDeniedError, EntityNotFoundError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listAnycastIpLists = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/anycast-ip-list", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListAnycastIpLists" }, ListAnycastIpListsRequest, ListAnycastIpListsResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listCachePolicies = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/cache-policy", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListCachePolicies" }, ListCachePoliciesRequest, ListCachePoliciesResult, [AccessDeniedError, InvalidArgumentError, NoSuchCachePolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listCloudFrontOriginAccessIdentities = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-identity/cloudfront", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListCloudFrontOriginAccessIdentities" }, ListCloudFrontOriginAccessIdentitiesRequest, ListCloudFrontOriginAccessIdentitiesResult, [InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listConflictingAliases = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/conflicting-alias", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListConflictingAliases" }, ListConflictingAliasesRequest, ListConflictingAliasesResult, [InvalidArgumentError, NoSuchDistributionError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listConnectionGroups = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/connection-groups", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListConnectionGroups" }, ListConnectionGroupsRequest, ListConnectionGroupsResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listContinuousDeploymentPolicies = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/continuous-deployment-policy", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListContinuousDeploymentPolicies" }, ListContinuousDeploymentPoliciesRequest, ListContinuousDeploymentPoliciesResult, [AccessDeniedError, InvalidArgumentError, NoSuchContinuousDeploymentPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDistributions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributions" }, ListDistributionsRequest, ListDistributionsResult, [InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDistributionsByOwnedResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByOwnedResource/{ResourceArn}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByOwnedResource" }, ListDistributionsByOwnedResourceRequest, ListDistributionsByOwnedResourceResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listDomainConflicts = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/domain-conflicts", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDomainConflicts" }, ListDomainConflictsRequest, ListDomainConflictsResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listFieldLevelEncryptionConfigs = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListFieldLevelEncryptionConfigs" }, ListFieldLevelEncryptionConfigsRequest, ListFieldLevelEncryptionConfigsResult, [InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listFieldLevelEncryptionProfiles = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption-profile", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListFieldLevelEncryptionProfiles" }, ListFieldLevelEncryptionProfilesRequest, ListFieldLevelEncryptionProfilesResult, [InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listInvalidations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{DistributionId}/invalidation", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListInvalidations" }, ListInvalidationsRequest, ListInvalidationsResult, [AccessDeniedError, InvalidArgumentError, NoSuchDistributionError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listKeyGroups = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-group", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListKeyGroups" }, ListKeyGroupsRequest, ListKeyGroupsResult, [InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listOriginAccessControls = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-control", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListOriginAccessControls" }, ListOriginAccessControlsRequest, ListOriginAccessControlsResult, [InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listOriginRequestPolicies = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-request-policy", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListOriginRequestPolicies" }, ListOriginRequestPoliciesRequest, ListOriginRequestPoliciesResult, [AccessDeniedError, InvalidArgumentError, NoSuchOriginRequestPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listPublicKeys = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/public-key", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListPublicKeys" }, ListPublicKeysRequest, ListPublicKeysResult, [InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listResponseHeadersPolicies = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/response-headers-policy", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListResponseHeadersPolicies" }, ListResponseHeadersPoliciesRequest, ListResponseHeadersPoliciesResult, [AccessDeniedError, InvalidArgumentError, NoSuchResponseHeadersPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listStreamingDistributions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListStreamingDistributions" }, ListStreamingDistributionsRequest, ListStreamingDistributionsResult, [InvalidArgumentError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const listVpcOrigins = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/vpc-origin", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListVpcOrigins" }, ListVpcOriginsRequest, ListVpcOriginsResult, [AccessDeniedError, EntityNotFoundError, InvalidArgumentError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const testFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function/{Name}/test", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.TestFunction" }, TestFunctionRequest, TestFunctionResult, [InvalidArgumentError, InvalidIfMatchVersionError, NoSuchFunctionExistsError, TestFunctionFailedError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateCloudFrontOriginAccessIdentity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-identity/cloudfront/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateCloudFrontOriginAccessIdentity" }, UpdateCloudFrontOriginAccessIdentityRequest, UpdateCloudFrontOriginAccessIdentityResult, [AccessDeniedError, IllegalUpdateError, InconsistentQuantitiesError, InvalidArgumentError, InvalidIfMatchVersionError, MissingBodyError, NoSuchCloudFrontOriginAccessIdentityError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateDistributionTenant" }, UpdateDistributionTenantRequest, UpdateDistributionTenantResult, [AccessDeniedError, CNAMEAlreadyExistsError, EntityAlreadyExistsError, EntityLimitExceededError, EntityNotFoundError, InvalidArgumentError, InvalidAssociationError, InvalidIfMatchVersionError, PreconditionFailedError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-group/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateKeyGroup" }, UpdateKeyGroupRequest, UpdateKeyGroupResult, [InvalidArgumentError, InvalidIfMatchVersionError, KeyGroupAlreadyExistsError, NoSuchResourceError, PreconditionFailedError, TooManyPublicKeysInKeyGroupError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createCloudFrontOriginAccessIdentity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-identity/cloudfront", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateCloudFrontOriginAccessIdentity" }, CreateCloudFrontOriginAccessIdentityRequest, CreateCloudFrontOriginAccessIdentityResult, [CloudFrontOriginAccessIdentityAlreadyExistsError, InconsistentQuantitiesError, InvalidArgumentError, MissingBodyError, TooManyCloudFrontOriginAccessIdentitiesError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createInvalidation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{DistributionId}/invalidation", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateInvalidation" }, CreateInvalidationRequest, CreateInvalidationResult, [AccessDeniedError, BatchTooLargeError, InconsistentQuantitiesError, InvalidArgumentError, MissingBodyError, NoSuchDistributionError, TooManyInvalidationsInProgressError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createMonitoringSubscription = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributions/{DistributionId}/monitoring-subscription", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateMonitoringSubscription" }, CreateMonitoringSubscriptionRequest, CreateMonitoringSubscriptionResult, [AccessDeniedError, MonitoringSubscriptionAlreadyExistsError, NoSuchDistributionError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createPublicKey = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/public-key", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreatePublicKey" }, CreatePublicKeyRequest, CreatePublicKeyResult, [InvalidArgumentError, PublicKeyAlreadyExistsError, TooManyPublicKeysError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateFieldLevelEncryptionConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateFieldLevelEncryptionConfig" }, UpdateFieldLevelEncryptionConfigRequest, UpdateFieldLevelEncryptionConfigResult, [AccessDeniedError, IllegalUpdateError, InconsistentQuantitiesError, InvalidArgumentError, InvalidIfMatchVersionError, NoSuchFieldLevelEncryptionConfigError, NoSuchFieldLevelEncryptionProfileError, PreconditionFailedError, QueryArgProfileEmptyError, TooManyFieldLevelEncryptionContentTypeProfilesError, TooManyFieldLevelEncryptionQueryArgProfilesError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateResponseHeadersPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/response-headers-policy/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateResponseHeadersPolicy" }, UpdateResponseHeadersPolicyRequest, UpdateResponseHeadersPolicyResult, [AccessDeniedError, IllegalUpdateError, InconsistentQuantitiesError, InvalidArgumentError, InvalidIfMatchVersionError, NoSuchResponseHeadersPolicyError, PreconditionFailedError, ResponseHeadersPolicyAlreadyExistsError, TooLongCSPInResponseHeadersPolicyError, TooManyCustomHeadersInResponseHeadersPolicyError, TooManyRemoveHeadersInResponseHeadersPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateStreamingDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateStreamingDistribution" }, UpdateStreamingDistributionRequest, UpdateStreamingDistributionResult, [AccessDeniedError, CNAMEAlreadyExistsError, IllegalUpdateError, InconsistentQuantitiesError, InvalidArgumentError, InvalidIfMatchVersionError, InvalidOriginAccessControlError, InvalidOriginAccessIdentityError, MissingBodyError, NoSuchStreamingDistributionError, PreconditionFailedError, TooManyStreamingDistributionCNAMEsError, TooManyTrustedSignersError, TrustedSignerDoesNotExistError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createCachePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/cache-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateCachePolicy" }, CreateCachePolicyRequest, CreateCachePolicyResult, [AccessDeniedError, CachePolicyAlreadyExistsError, InconsistentQuantitiesError, InvalidArgumentError, TooManyCachePoliciesError, TooManyCookiesInCachePolicyError, TooManyHeadersInCachePolicyError, TooManyQueryStringsInCachePolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createOriginRequestPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-request-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateOriginRequestPolicy" }, CreateOriginRequestPolicyRequest, CreateOriginRequestPolicyResult, [AccessDeniedError, InconsistentQuantitiesError, InvalidArgumentError, OriginRequestPolicyAlreadyExistsError, TooManyCookiesInOriginRequestPolicyError, TooManyHeadersInOriginRequestPolicyError, TooManyOriginRequestPoliciesError, TooManyQueryStringsInOriginRequestPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/realtime-log-config", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateRealtimeLogConfig" }, CreateRealtimeLogConfigRequest, CreateRealtimeLogConfigResult, [AccessDeniedError, InvalidArgumentError, RealtimeLogConfigAlreadyExistsError, TooManyRealtimeLogConfigsError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createStreamingDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateStreamingDistribution" }, CreateStreamingDistributionRequest, CreateStreamingDistributionResult, [AccessDeniedError, CNAMEAlreadyExistsError, InconsistentQuantitiesError, InvalidArgumentError, InvalidOriginError, InvalidOriginAccessControlError, InvalidOriginAccessIdentityError, MissingBodyError, StreamingDistributionAlreadyExistsError, TooManyStreamingDistributionCNAMEsError, TooManyStreamingDistributionsError, TooManyTrustedSignersError, TrustedSignerDoesNotExistError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createStreamingDistributionWithTags = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution?WithTags", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateStreamingDistributionWithTags" }, CreateStreamingDistributionWithTagsRequest, CreateStreamingDistributionWithTagsResult, [AccessDeniedError, CNAMEAlreadyExistsError, InconsistentQuantitiesError, InvalidArgumentError, InvalidOriginError, InvalidOriginAccessControlError, InvalidOriginAccessIdentityError, InvalidTaggingError, MissingBodyError, StreamingDistributionAlreadyExistsError, TooManyStreamingDistributionCNAMEsError, TooManyStreamingDistributionsError, TooManyTrustedSignersError, TrustedSignerDoesNotExistError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateCachePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/cache-policy/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateCachePolicy" }, UpdateCachePolicyRequest, UpdateCachePolicyResult, [AccessDeniedError, CachePolicyAlreadyExistsError, IllegalUpdateError, InconsistentQuantitiesError, InvalidArgumentError, InvalidIfMatchVersionError, NoSuchCachePolicyError, PreconditionFailedError, TooManyCookiesInCachePolicyError, TooManyHeadersInCachePolicyError, TooManyQueryStringsInCachePolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateFieldLevelEncryptionProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption-profile/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateFieldLevelEncryptionProfile" }, UpdateFieldLevelEncryptionProfileRequest, UpdateFieldLevelEncryptionProfileResult, [AccessDeniedError, FieldLevelEncryptionProfileAlreadyExistsError, FieldLevelEncryptionProfileSizeExceededError, IllegalUpdateError, InconsistentQuantitiesError, InvalidArgumentError, InvalidIfMatchVersionError, NoSuchFieldLevelEncryptionProfileError, NoSuchPublicKeyError, PreconditionFailedError, TooManyFieldLevelEncryptionEncryptionEntitiesError, TooManyFieldLevelEncryptionFieldPatternsError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateOriginRequestPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-request-policy/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateOriginRequestPolicy" }, UpdateOriginRequestPolicyRequest, UpdateOriginRequestPolicyResult, [AccessDeniedError, IllegalUpdateError, InconsistentQuantitiesError, InvalidArgumentError, InvalidIfMatchVersionError, NoSuchOriginRequestPolicyError, OriginRequestPolicyAlreadyExistsError, PreconditionFailedError, TooManyCookiesInOriginRequestPolicyError, TooManyHeadersInOriginRequestPolicyError, TooManyQueryStringsInOriginRequestPolicyError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createFieldLevelEncryptionProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption-profile", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateFieldLevelEncryptionProfile" }, CreateFieldLevelEncryptionProfileRequest, CreateFieldLevelEncryptionProfileResult, [FieldLevelEncryptionProfileAlreadyExistsError, FieldLevelEncryptionProfileSizeExceededError, InconsistentQuantitiesError, InvalidArgumentError, NoSuchPublicKeyError, TooManyFieldLevelEncryptionEncryptionEntitiesError, TooManyFieldLevelEncryptionFieldPatternsError, TooManyFieldLevelEncryptionProfilesError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateFunction" }, CreateFunctionRequest, CreateFunctionResult, [FunctionAlreadyExistsError, FunctionSizeLimitExceededError, InvalidArgumentError, TooManyFunctionsError, UnsupportedOperationError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createResponseHeadersPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/response-headers-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateResponseHeadersPolicy" }, CreateResponseHeadersPolicyRequest, CreateResponseHeadersPolicyResult, [AccessDeniedError, InconsistentQuantitiesError, InvalidArgumentError, ResponseHeadersPolicyAlreadyExistsError, TooLongCSPInResponseHeadersPolicyError, TooManyCustomHeadersInResponseHeadersPolicyError, TooManyRemoveHeadersInResponseHeadersPolicyError, TooManyResponseHeadersPoliciesError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createContinuousDeploymentPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/continuous-deployment-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateContinuousDeploymentPolicy" }, CreateContinuousDeploymentPolicyRequest, CreateContinuousDeploymentPolicyResult, [AccessDeniedError, ContinuousDeploymentPolicyAlreadyExistsError, InconsistentQuantitiesError, InvalidArgumentError, StagingDistributionInUseError, TooManyContinuousDeploymentPoliciesError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createFieldLevelEncryptionConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateFieldLevelEncryptionConfig" }, CreateFieldLevelEncryptionConfigRequest, CreateFieldLevelEncryptionConfigResult, [FieldLevelEncryptionConfigAlreadyExistsError, InconsistentQuantitiesError, InvalidArgumentError, NoSuchFieldLevelEncryptionProfileError, QueryArgProfileEmptyError, TooManyFieldLevelEncryptionConfigsError, TooManyFieldLevelEncryptionContentTypeProfilesError, TooManyFieldLevelEncryptionQueryArgProfilesError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createDistributionWithTags = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution?WithTags", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateDistributionWithTags" }, CreateDistributionWithTagsRequest, CreateDistributionWithTagsResult, [AccessDeniedError, CNAMEAlreadyExistsError, ContinuousDeploymentPolicyInUseError, DistributionAlreadyExistsError, EntityNotFoundError, IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorError, IllegalOriginAccessConfigurationError, InconsistentQuantitiesError, InvalidArgumentError, InvalidDefaultRootObjectError, InvalidDomainNameForOriginAccessControlError, InvalidErrorCodeError, InvalidForwardCookiesError, InvalidFunctionAssociationError, InvalidGeoRestrictionParameterError, InvalidHeadersForS3OriginError, InvalidLambdaFunctionAssociationError, InvalidLocationCodeError, InvalidMinimumProtocolVersionError, InvalidOriginError, InvalidOriginAccessControlError, InvalidOriginAccessIdentityError, InvalidOriginKeepaliveTimeoutError, InvalidOriginReadTimeoutError, InvalidProtocolSettingsError, InvalidQueryStringParametersError, InvalidRelativePathError, InvalidRequiredProtocolError, InvalidResponseCodeError, InvalidTaggingError, InvalidTTLOrderError, InvalidViewerCertificateError, InvalidWebACLIdError, MissingBodyError, NoSuchCachePolicyError, NoSuchContinuousDeploymentPolicyError, NoSuchFieldLevelEncryptionConfigError, NoSuchOriginError, NoSuchOriginRequestPolicyError, NoSuchRealtimeLogConfigError, NoSuchResponseHeadersPolicyError, RealtimeLogConfigOwnerMismatchError, TooManyCacheBehaviorsError, TooManyCertificatesError, TooManyCookieNamesInWhiteListError, TooManyDistributionCNAMEsError, TooManyDistributionsError, TooManyDistributionsAssociatedToCachePolicyError, TooManyDistributionsAssociatedToFieldLevelEncryptionConfigError, TooManyDistributionsAssociatedToKeyGroupError, TooManyDistributionsAssociatedToOriginAccessControlError, TooManyDistributionsAssociatedToOriginRequestPolicyError, TooManyDistributionsAssociatedToResponseHeadersPolicyError, TooManyDistributionsWithFunctionAssociationsError, TooManyDistributionsWithLambdaAssociationsError, TooManyDistributionsWithSingleFunctionARNError, TooManyFunctionAssociationsError, TooManyHeadersInForwardedValuesError, TooManyKeyGroupsAssociatedToDistributionError, TooManyLambdaFunctionAssociationsError, TooManyOriginCustomHeadersError, TooManyOriginGroupsPerDistributionError, TooManyOriginsError, TooManyQueryStringParametersError, TooManyTrustedSignersError, TrustedKeyGroupDoesNotExistError, TrustedSignerDoesNotExistError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateDistribution" }, UpdateDistributionRequest, UpdateDistributionResult, [AccessDeniedError, CNAMEAlreadyExistsError, ContinuousDeploymentPolicyInUseError, EntityNotFoundError, IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorError, IllegalOriginAccessConfigurationError, IllegalUpdateError, InconsistentQuantitiesError, InvalidArgumentError, InvalidDefaultRootObjectError, InvalidDomainNameForOriginAccessControlError, InvalidErrorCodeError, InvalidForwardCookiesError, InvalidFunctionAssociationError, InvalidGeoRestrictionParameterError, InvalidHeadersForS3OriginError, InvalidIfMatchVersionError, InvalidLambdaFunctionAssociationError, InvalidLocationCodeError, InvalidMinimumProtocolVersionError, InvalidOriginAccessControlError, InvalidOriginAccessIdentityError, InvalidOriginKeepaliveTimeoutError, InvalidOriginReadTimeoutError, InvalidQueryStringParametersError, InvalidRelativePathError, InvalidRequiredProtocolError, InvalidResponseCodeError, InvalidTTLOrderError, InvalidViewerCertificateError, InvalidWebACLIdError, MissingBodyError, NoSuchCachePolicyError, NoSuchContinuousDeploymentPolicyError, NoSuchDistributionError, NoSuchFieldLevelEncryptionConfigError, NoSuchOriginError, NoSuchOriginRequestPolicyError, NoSuchRealtimeLogConfigError, NoSuchResponseHeadersPolicyError, PreconditionFailedError, RealtimeLogConfigOwnerMismatchError, StagingDistributionInUseError, TooManyCacheBehaviorsError, TooManyCertificatesError, TooManyCookieNamesInWhiteListError, TooManyDistributionCNAMEsError, TooManyDistributionsAssociatedToCachePolicyError, TooManyDistributionsAssociatedToFieldLevelEncryptionConfigError, TooManyDistributionsAssociatedToKeyGroupError, TooManyDistributionsAssociatedToOriginAccessControlError, TooManyDistributionsAssociatedToOriginRequestPolicyError, TooManyDistributionsAssociatedToResponseHeadersPolicyError, TooManyDistributionsWithFunctionAssociationsError, TooManyDistributionsWithLambdaAssociationsError, TooManyDistributionsWithSingleFunctionARNError, TooManyFunctionAssociationsError, TooManyHeadersInForwardedValuesError, TooManyKeyGroupsAssociatedToDistributionError, TooManyLambdaFunctionAssociationsError, TooManyOriginCustomHeadersError, TooManyOriginGroupsPerDistributionError, TooManyOriginsError, TooManyQueryStringParametersError, TooManyTrustedSignersError, TrustedKeyGroupDoesNotExistError, TrustedSignerDoesNotExistError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const updateDistributionWithStagingConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}/promote-staging-config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateDistributionWithStagingConfig" }, UpdateDistributionWithStagingConfigRequest, UpdateDistributionWithStagingConfigResult, [AccessDeniedError, CNAMEAlreadyExistsError, EntityNotFoundError, IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorError, IllegalUpdateError, InconsistentQuantitiesError, InvalidArgumentError, InvalidDefaultRootObjectError, InvalidErrorCodeError, InvalidForwardCookiesError, InvalidFunctionAssociationError, InvalidGeoRestrictionParameterError, InvalidHeadersForS3OriginError, InvalidIfMatchVersionError, InvalidLambdaFunctionAssociationError, InvalidLocationCodeError, InvalidMinimumProtocolVersionError, InvalidOriginAccessControlError, InvalidOriginAccessIdentityError, InvalidOriginKeepaliveTimeoutError, InvalidOriginReadTimeoutError, InvalidQueryStringParametersError, InvalidRelativePathError, InvalidRequiredProtocolError, InvalidResponseCodeError, InvalidTTLOrderError, InvalidViewerCertificateError, InvalidWebACLIdError, MissingBodyError, NoSuchCachePolicyError, NoSuchDistributionError, NoSuchFieldLevelEncryptionConfigError, NoSuchOriginError, NoSuchOriginRequestPolicyError, NoSuchRealtimeLogConfigError, NoSuchResponseHeadersPolicyError, PreconditionFailedError, RealtimeLogConfigOwnerMismatchError, TooManyCacheBehaviorsError, TooManyCertificatesError, TooManyCookieNamesInWhiteListError, TooManyDistributionCNAMEsError, TooManyDistributionsAssociatedToCachePolicyError, TooManyDistributionsAssociatedToFieldLevelEncryptionConfigError, TooManyDistributionsAssociatedToKeyGroupError, TooManyDistributionsAssociatedToOriginAccessControlError, TooManyDistributionsAssociatedToOriginRequestPolicyError, TooManyDistributionsAssociatedToResponseHeadersPolicyError, TooManyDistributionsWithFunctionAssociationsError, TooManyDistributionsWithLambdaAssociationsError, TooManyDistributionsWithSingleFunctionARNError, TooManyFunctionAssociationsError, TooManyHeadersInForwardedValuesError, TooManyKeyGroupsAssociatedToDistributionError, TooManyLambdaFunctionAssociationsError, TooManyOriginCustomHeadersError, TooManyOriginGroupsPerDistributionError, TooManyOriginsError, TooManyQueryStringParametersError, TooManyTrustedSignersError, TrustedKeyGroupDoesNotExistError, TrustedSignerDoesNotExistError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const copyDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{PrimaryDistributionId}/copy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CopyDistribution" }, CopyDistributionRequest, CopyDistributionResult, [AccessDeniedError, CNAMEAlreadyExistsError, DistributionAlreadyExistsError, IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorError, InconsistentQuantitiesError, InvalidArgumentError, InvalidDefaultRootObjectError, InvalidErrorCodeError, InvalidForwardCookiesError, InvalidFunctionAssociationError, InvalidGeoRestrictionParameterError, InvalidHeadersForS3OriginError, InvalidIfMatchVersionError, InvalidLambdaFunctionAssociationError, InvalidLocationCodeError, InvalidMinimumProtocolVersionError, InvalidOriginError, InvalidOriginAccessControlError, InvalidOriginAccessIdentityError, InvalidOriginKeepaliveTimeoutError, InvalidOriginReadTimeoutError, InvalidProtocolSettingsError, InvalidQueryStringParametersError, InvalidRelativePathError, InvalidRequiredProtocolError, InvalidResponseCodeError, InvalidTTLOrderError, InvalidViewerCertificateError, InvalidWebACLIdError, MissingBodyError, NoSuchCachePolicyError, NoSuchDistributionError, NoSuchFieldLevelEncryptionConfigError, NoSuchOriginError, NoSuchOriginRequestPolicyError, NoSuchRealtimeLogConfigError, NoSuchResponseHeadersPolicyError, PreconditionFailedError, RealtimeLogConfigOwnerMismatchError, TooManyCacheBehaviorsError, TooManyCertificatesError, TooManyCookieNamesInWhiteListError, TooManyDistributionCNAMEsError, TooManyDistributionsError, TooManyDistributionsAssociatedToCachePolicyError, TooManyDistributionsAssociatedToFieldLevelEncryptionConfigError, TooManyDistributionsAssociatedToKeyGroupError, TooManyDistributionsAssociatedToOriginAccessControlError, TooManyDistributionsAssociatedToOriginRequestPolicyError, TooManyDistributionsAssociatedToResponseHeadersPolicyError, TooManyDistributionsWithFunctionAssociationsError, TooManyDistributionsWithLambdaAssociationsError, TooManyDistributionsWithSingleFunctionARNError, TooManyFunctionAssociationsError, TooManyHeadersInForwardedValuesError, TooManyKeyGroupsAssociatedToDistributionError, TooManyLambdaFunctionAssociationsError, TooManyOriginCustomHeadersError, TooManyOriginGroupsPerDistributionError, TooManyOriginsError, TooManyQueryStringParametersError, TooManyTrustedSignersError, TrustedKeyGroupDoesNotExistError, TrustedSignerDoesNotExistError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const createDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateDistribution" }, CreateDistributionRequest, CreateDistributionResult, [AccessDeniedError, CNAMEAlreadyExistsError, ContinuousDeploymentPolicyInUseError, DistributionAlreadyExistsError, EntityLimitExceededError, EntityNotFoundError, IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorError, IllegalOriginAccessConfigurationError, InconsistentQuantitiesError, InvalidArgumentError, InvalidDefaultRootObjectError, InvalidDomainNameForOriginAccessControlError, InvalidErrorCodeError, InvalidForwardCookiesError, InvalidFunctionAssociationError, InvalidGeoRestrictionParameterError, InvalidHeadersForS3OriginError, InvalidLambdaFunctionAssociationError, InvalidLocationCodeError, InvalidMinimumProtocolVersionError, InvalidOriginError, InvalidOriginAccessControlError, InvalidOriginAccessIdentityError, InvalidOriginKeepaliveTimeoutError, InvalidOriginReadTimeoutError, InvalidProtocolSettingsError, InvalidQueryStringParametersError, InvalidRelativePathError, InvalidRequiredProtocolError, InvalidResponseCodeError, InvalidTTLOrderError, InvalidViewerCertificateError, InvalidWebACLIdError, MissingBodyError, NoSuchCachePolicyError, NoSuchContinuousDeploymentPolicyError, NoSuchFieldLevelEncryptionConfigError, NoSuchOriginError, NoSuchOriginRequestPolicyError, NoSuchRealtimeLogConfigError, NoSuchResponseHeadersPolicyError, RealtimeLogConfigOwnerMismatchError, TooManyCacheBehaviorsError, TooManyCertificatesError, TooManyCookieNamesInWhiteListError, TooManyDistributionCNAMEsError, TooManyDistributionsError, TooManyDistributionsAssociatedToCachePolicyError, TooManyDistributionsAssociatedToFieldLevelEncryptionConfigError, TooManyDistributionsAssociatedToKeyGroupError, TooManyDistributionsAssociatedToOriginAccessControlError, TooManyDistributionsAssociatedToOriginRequestPolicyError, TooManyDistributionsAssociatedToResponseHeadersPolicyError, TooManyDistributionsWithFunctionAssociationsError, TooManyDistributionsWithLambdaAssociationsError, TooManyDistributionsWithSingleFunctionARNError, TooManyFunctionAssociationsError, TooManyHeadersInForwardedValuesError, TooManyKeyGroupsAssociatedToDistributionError, TooManyLambdaFunctionAssociationsError, TooManyOriginCustomHeadersError, TooManyOriginGroupsPerDistributionError, TooManyOriginsError, TooManyQueryStringParametersError, TooManyTrustedSignersError, TrustedKeyGroupDoesNotExistError, TrustedSignerDoesNotExistError]), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
