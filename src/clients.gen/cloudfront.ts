import { Schema} from "effect"
import { FormatXMLRequest,FormatXMLResponse,FormatAwsXMLError, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
export const FieldList = Schema.Array(Schema.String);
export const AssociateAliasRequest = Schema.Struct({TargetDistributionId: Schema.String, Alias: Schema.String});
export const AssociateDistributionTenantWebACLRequest = Schema.Struct({Id: Schema.String, WebACLArn: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const AssociateDistributionWebACLRequest = Schema.Struct({Id: Schema.String, WebACLArn: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const CopyDistributionRequest = Schema.Struct({PrimaryDistributionId: Schema.String, Staging: Schema.optional(Header("Staging", Schema.Boolean)), IfMatch: Schema.optional(Header("If-Match")), CallerReference: Schema.String, Enabled: Schema.optional(Schema.Boolean)});
export const Tag = Schema.Struct({Key: Schema.String, Value: Schema.optional(Schema.String)});
export const TagList = Schema.Array(Tag);
export const Tags = Schema.Struct({Items: Schema.optional(TagList)});
export const CreateConnectionGroupRequest = Schema.Struct({Name: Schema.String, Ipv6Enabled: Schema.optional(Schema.Boolean), Tags: Schema.optional(Tags), AnycastIpListId: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean)});
export const PathList = Schema.Array(Schema.String);
export const Paths = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(PathList)});
export const InvalidationBatch = Schema.Struct({Paths: Paths, CallerReference: Schema.String});
export const CreateInvalidationForDistributionTenantRequest = Schema.Struct({Id: Schema.String, InvalidationBatch: Body("InvalidationBatch", InvalidationBatch)});
export const DeleteAnycastIpListRequest = Schema.Struct({Id: Schema.String, IfMatch: Header("If-Match")});
export const DeleteCachePolicyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteCloudFrontOriginAccessIdentityRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteConnectionGroupRequest = Schema.Struct({Id: Schema.String, IfMatch: Header("If-Match")});
export const DeleteContinuousDeploymentPolicyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteDistributionRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteDistributionTenantRequest = Schema.Struct({Id: Schema.String, IfMatch: Header("If-Match")});
export const DeleteFieldLevelEncryptionConfigRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteFieldLevelEncryptionProfileRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteFunctionRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match")});
export const DeleteKeyGroupRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteKeyValueStoreRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match")});
export const DeleteMonitoringSubscriptionRequest = Schema.Struct({DistributionId: Schema.String});
export const DeleteMonitoringSubscriptionResult = Schema.Struct({});
export const DeleteOriginAccessControlRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteOriginRequestPolicyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeletePublicKeyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteRealtimeLogConfigRequest = Schema.Struct({Name: Schema.optional(Schema.String), ARN: Schema.optional(Schema.String)});
export const DeleteResourcePolicyRequest = Schema.Struct({ResourceArn: Schema.String});
export const DeleteResponseHeadersPolicyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteStreamingDistributionRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DeleteVpcOriginRequest = Schema.Struct({Id: Schema.String, IfMatch: Header("If-Match")});
export const DescribeFunctionRequest = Schema.Struct({Name: Schema.String, Stage: Schema.optional(Schema.String)});
export const DescribeKeyValueStoreRequest = Schema.Struct({Name: Schema.String});
export const DisassociateDistributionTenantWebACLRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DisassociateDistributionWebACLRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const GetAnycastIpListRequest = Schema.Struct({Id: Schema.String});
export const GetCachePolicyRequest = Schema.Struct({Id: Schema.String});
export const GetCachePolicyConfigRequest = Schema.Struct({Id: Schema.String});
export const GetCloudFrontOriginAccessIdentityRequest = Schema.Struct({Id: Schema.String});
export const GetCloudFrontOriginAccessIdentityConfigRequest = Schema.Struct({Id: Schema.String});
export const GetConnectionGroupRequest = Schema.Struct({Identifier: Schema.String});
export const GetConnectionGroupByRoutingEndpointRequest = Schema.Struct({RoutingEndpoint: Schema.String});
export const GetContinuousDeploymentPolicyRequest = Schema.Struct({Id: Schema.String});
export const GetContinuousDeploymentPolicyConfigRequest = Schema.Struct({Id: Schema.String});
export const GetDistributionRequest = Schema.Struct({Id: Schema.String});
export const GetDistributionConfigRequest = Schema.Struct({Id: Schema.String});
export const GetDistributionTenantRequest = Schema.Struct({Identifier: Schema.String});
export const GetDistributionTenantByDomainRequest = Schema.Struct({Domain: Schema.String});
export const GetFieldLevelEncryptionRequest = Schema.Struct({Id: Schema.String});
export const GetFieldLevelEncryptionConfigRequest = Schema.Struct({Id: Schema.String});
export const GetFieldLevelEncryptionProfileRequest = Schema.Struct({Id: Schema.String});
export const GetFieldLevelEncryptionProfileConfigRequest = Schema.Struct({Id: Schema.String});
export const GetFunctionRequest = Schema.Struct({Name: Schema.String, Stage: Schema.optional(Schema.String)});
export const GetInvalidationRequest = Schema.Struct({DistributionId: Schema.String, Id: Schema.String});
export const GetInvalidationForDistributionTenantRequest = Schema.Struct({DistributionTenantId: Schema.String, Id: Schema.String});
export const GetKeyGroupRequest = Schema.Struct({Id: Schema.String});
export const GetKeyGroupConfigRequest = Schema.Struct({Id: Schema.String});
export const GetManagedCertificateDetailsRequest = Schema.Struct({Identifier: Schema.String});
export const GetMonitoringSubscriptionRequest = Schema.Struct({DistributionId: Schema.String});
export const GetOriginAccessControlRequest = Schema.Struct({Id: Schema.String});
export const GetOriginAccessControlConfigRequest = Schema.Struct({Id: Schema.String});
export const GetOriginRequestPolicyRequest = Schema.Struct({Id: Schema.String});
export const GetOriginRequestPolicyConfigRequest = Schema.Struct({Id: Schema.String});
export const GetPublicKeyRequest = Schema.Struct({Id: Schema.String});
export const GetPublicKeyConfigRequest = Schema.Struct({Id: Schema.String});
export const GetRealtimeLogConfigRequest = Schema.Struct({Name: Schema.optional(Schema.String), ARN: Schema.optional(Schema.String)});
export const GetResourcePolicyRequest = Schema.Struct({ResourceArn: Schema.String});
export const GetResponseHeadersPolicyRequest = Schema.Struct({Id: Schema.String});
export const GetResponseHeadersPolicyConfigRequest = Schema.Struct({Id: Schema.String});
export const GetStreamingDistributionRequest = Schema.Struct({Id: Schema.String});
export const GetStreamingDistributionConfigRequest = Schema.Struct({Id: Schema.String});
export const GetVpcOriginRequest = Schema.Struct({Id: Schema.String});
export const ListAnycastIpListsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListCachePoliciesRequest = Schema.Struct({Type: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListCloudFrontOriginAccessIdentitiesRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListConflictingAliasesRequest = Schema.Struct({DistributionId: Schema.String, Alias: Schema.String, Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListContinuousDeploymentPoliciesRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListDistributionsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListDistributionsByAnycastIpListIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), AnycastIpListId: Schema.String});
export const ListDistributionsByCachePolicyIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), CachePolicyId: Schema.String});
export const ListDistributionsByConnectionModeRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), ConnectionMode: Schema.String});
export const ListDistributionsByKeyGroupRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), KeyGroupId: Schema.String});
export const ListDistributionsByOriginRequestPolicyIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), OriginRequestPolicyId: Schema.String});
export const ListDistributionsByOwnedResourceRequest = Schema.Struct({ResourceArn: Schema.String, Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListDistributionsByRealtimeLogConfigRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), RealtimeLogConfigName: Schema.optional(Schema.String), RealtimeLogConfigArn: Schema.optional(Schema.String)});
export const ListDistributionsByResponseHeadersPolicyIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), ResponseHeadersPolicyId: Schema.String});
export const ListDistributionsByVpcOriginIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), VpcOriginId: Schema.String});
export const ListDistributionsByWebACLIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), WebACLId: Schema.String});
export const ListDistributionTenantsByCustomizationRequest = Schema.Struct({WebACLArn: Schema.optional(Schema.String), CertificateArn: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListFieldLevelEncryptionConfigsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListFieldLevelEncryptionProfilesRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListFunctionsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), Stage: Schema.optional(Schema.String)});
export const ListInvalidationsRequest = Schema.Struct({DistributionId: Schema.String, Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListInvalidationsForDistributionTenantRequest = Schema.Struct({Id: Schema.String, Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListKeyGroupsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListKeyValueStoresRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), Status: Schema.optional(Schema.String)});
export const ListOriginAccessControlsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListOriginRequestPoliciesRequest = Schema.Struct({Type: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListPublicKeysRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListRealtimeLogConfigsRequest = Schema.Struct({MaxItems: Schema.optional(Schema.Number), Marker: Schema.optional(Schema.String)});
export const ListResponseHeadersPoliciesRequest = Schema.Struct({Type: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListStreamingDistributionsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListTagsForResourceRequest = Schema.Struct({Resource: Schema.String});
export const ListVpcOriginsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const PublishFunctionRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match")});
export const PutResourcePolicyRequest = Schema.Struct({ResourceArn: Schema.String, PolicyDocument: Schema.String});
export const TagResourceRequest = Schema.Struct({Resource: Schema.String, Tags: Body("Tags", Tags)});
export const TestFunctionRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match"), Stage: Schema.optional(Schema.String), EventObject: StreamBody()});
export const UpdateAnycastIpListRequest = Schema.Struct({Id: Schema.String, IpAddressType: Schema.optional(Schema.String), IfMatch: Header("If-Match")});
export const HeaderList = Schema.Array(Schema.String);
export const Headers = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(HeaderList)});
export const CachePolicyHeadersConfig = Schema.Struct({HeaderBehavior: Schema.String, Headers: Schema.optional(Headers)});
export const CookieNameList = Schema.Array(Schema.String);
export const CookieNames = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(CookieNameList)});
export const CachePolicyCookiesConfig = Schema.Struct({CookieBehavior: Schema.String, Cookies: Schema.optional(CookieNames)});
export const QueryStringNamesList = Schema.Array(Schema.String);
export const QueryStringNames = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(QueryStringNamesList)});
export const CachePolicyQueryStringsConfig = Schema.Struct({QueryStringBehavior: Schema.String, QueryStrings: Schema.optional(QueryStringNames)});
export const ParametersInCacheKeyAndForwardedToOrigin = Schema.Struct({EnableAcceptEncodingGzip: Schema.Boolean, EnableAcceptEncodingBrotli: Schema.optional(Schema.Boolean), HeadersConfig: CachePolicyHeadersConfig, CookiesConfig: CachePolicyCookiesConfig, QueryStringsConfig: CachePolicyQueryStringsConfig});
export const CachePolicyConfig = Schema.Struct({Comment: Schema.optional(Schema.String), Name: Schema.String, DefaultTTL: Schema.optional(Schema.Number), MaxTTL: Schema.optional(Schema.Number), MinTTL: Schema.Number, ParametersInCacheKeyAndForwardedToOrigin: Schema.optional(ParametersInCacheKeyAndForwardedToOrigin)});
export const UpdateCachePolicyRequest = Schema.Struct({CachePolicyConfig: Body("CachePolicyConfig", CachePolicyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const CloudFrontOriginAccessIdentityConfig = Schema.Struct({CallerReference: Schema.String, Comment: Schema.String});
export const UpdateCloudFrontOriginAccessIdentityRequest = Schema.Struct({CloudFrontOriginAccessIdentityConfig: Body("CloudFrontOriginAccessIdentityConfig", CloudFrontOriginAccessIdentityConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const UpdateConnectionGroupRequest = Schema.Struct({Id: Schema.String, Ipv6Enabled: Schema.optional(Schema.Boolean), IfMatch: Header("If-Match"), AnycastIpListId: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean)});
export const StagingDistributionDnsNameList = Schema.Array(Schema.String);
export const StagingDistributionDnsNames = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(StagingDistributionDnsNameList)});
export const SessionStickinessConfig = Schema.Struct({IdleTTL: Schema.Number, MaximumTTL: Schema.Number});
export const ContinuousDeploymentSingleWeightConfig = Schema.Struct({Weight: Schema.Number, SessionStickinessConfig: Schema.optional(SessionStickinessConfig)});
export const ContinuousDeploymentSingleHeaderConfig = Schema.Struct({Header: Schema.String, Value: Schema.String});
export const TrafficConfig = Schema.Struct({SingleWeightConfig: Schema.optional(ContinuousDeploymentSingleWeightConfig), SingleHeaderConfig: Schema.optional(ContinuousDeploymentSingleHeaderConfig), Type: Schema.String});
export const ContinuousDeploymentPolicyConfig = Schema.Struct({StagingDistributionDnsNames: StagingDistributionDnsNames, Enabled: Schema.Boolean, TrafficConfig: Schema.optional(TrafficConfig)});
export const UpdateContinuousDeploymentPolicyRequest = Schema.Struct({ContinuousDeploymentPolicyConfig: Body("ContinuousDeploymentPolicyConfig", ContinuousDeploymentPolicyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const AliasList = Schema.Array(Schema.String);
export const Aliases = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(AliasList)});
export const OriginCustomHeader = Schema.Struct({HeaderName: Schema.String, HeaderValue: Schema.String});
export const OriginCustomHeadersList = Schema.Array(OriginCustomHeader);
export const CustomHeaders = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(OriginCustomHeadersList)});
export const S3OriginConfig = Schema.Struct({OriginAccessIdentity: Schema.String, OriginReadTimeout: Schema.optional(Schema.Number)});
export const SslProtocolsList = Schema.Array(Schema.String);
export const OriginSslProtocols = Schema.Struct({Quantity: Schema.Number, Items: SslProtocolsList});
export const CustomOriginConfig = Schema.Struct({HTTPPort: Schema.Number, HTTPSPort: Schema.Number, OriginProtocolPolicy: Schema.String, OriginSslProtocols: Schema.optional(OriginSslProtocols), OriginReadTimeout: Schema.optional(Schema.Number), OriginKeepaliveTimeout: Schema.optional(Schema.Number), IpAddressType: Schema.optional(Schema.String)});
export const VpcOriginConfig = Schema.Struct({VpcOriginId: Schema.String, OwnerAccountId: Schema.optional(Schema.String), OriginReadTimeout: Schema.optional(Schema.Number), OriginKeepaliveTimeout: Schema.optional(Schema.Number)});
export const OriginShield = Schema.Struct({Enabled: Schema.Boolean, OriginShieldRegion: Schema.optional(Schema.String)});
export const Origin = Schema.Struct({Id: Schema.String, DomainName: Schema.String, OriginPath: Schema.optional(Schema.String), CustomHeaders: Schema.optional(CustomHeaders), S3OriginConfig: Schema.optional(S3OriginConfig), CustomOriginConfig: Schema.optional(CustomOriginConfig), VpcOriginConfig: Schema.optional(VpcOriginConfig), ConnectionAttempts: Schema.optional(Schema.Number), ConnectionTimeout: Schema.optional(Schema.Number), ResponseCompletionTimeout: Schema.optional(Schema.Number), OriginShield: Schema.optional(OriginShield), OriginAccessControlId: Schema.optional(Schema.String)});
export const OriginList = Schema.Array(Origin);
export const Origins = Schema.Struct({Quantity: Schema.Number, Items: OriginList});
export const StatusCodeList = Schema.Array(Schema.Number);
export const StatusCodes = Schema.Struct({Quantity: Schema.Number, Items: StatusCodeList});
export const OriginGroupFailoverCriteria = Schema.Struct({StatusCodes: StatusCodes});
export const OriginGroupMember = Schema.Struct({OriginId: Schema.String});
export const OriginGroupMemberList = Schema.Array(OriginGroupMember);
export const OriginGroupMembers = Schema.Struct({Quantity: Schema.Number, Items: OriginGroupMemberList});
export const OriginGroup = Schema.Struct({Id: Schema.String, FailoverCriteria: OriginGroupFailoverCriteria, Members: OriginGroupMembers, SelectionCriteria: Schema.optional(Schema.String)});
export const OriginGroupList = Schema.Array(OriginGroup);
export const OriginGroups = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(OriginGroupList)});
export const AwsAccountNumberList = Schema.Array(Schema.String);
export const TrustedSigners = Schema.Struct({Enabled: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(AwsAccountNumberList)});
export const TrustedKeyGroupIdList = Schema.Array(Schema.String);
export const TrustedKeyGroups = Schema.Struct({Enabled: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(TrustedKeyGroupIdList)});
export const MethodsList = Schema.Array(Schema.String);
export const CachedMethods = Schema.Struct({Quantity: Schema.Number, Items: MethodsList});
export const AllowedMethods = Schema.Struct({Quantity: Schema.Number, Items: MethodsList, CachedMethods: Schema.optional(CachedMethods)});
export const LambdaFunctionAssociation = Schema.Struct({LambdaFunctionARN: Schema.String, EventType: Schema.String, IncludeBody: Schema.optional(Schema.Boolean)});
export const LambdaFunctionAssociationList = Schema.Array(LambdaFunctionAssociation);
export const LambdaFunctionAssociations = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(LambdaFunctionAssociationList)});
export const FunctionAssociation = Schema.Struct({FunctionARN: Schema.String, EventType: Schema.String});
export const FunctionAssociationList = Schema.Array(FunctionAssociation);
export const FunctionAssociations = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(FunctionAssociationList)});
export const GrpcConfig = Schema.Struct({Enabled: Schema.Boolean});
export const CookiePreference = Schema.Struct({Forward: Schema.String, WhitelistedNames: Schema.optional(CookieNames)});
export const QueryStringCacheKeysList = Schema.Array(Schema.String);
export const QueryStringCacheKeys = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(QueryStringCacheKeysList)});
export const ForwardedValues = Schema.Struct({QueryString: Schema.Boolean, Cookies: CookiePreference, Headers: Schema.optional(Headers), QueryStringCacheKeys: Schema.optional(QueryStringCacheKeys)});
export const DefaultCacheBehavior = Schema.Struct({TargetOriginId: Schema.String, TrustedSigners: Schema.optional(TrustedSigners), TrustedKeyGroups: Schema.optional(TrustedKeyGroups), ViewerProtocolPolicy: Schema.String, AllowedMethods: Schema.optional(AllowedMethods), SmoothStreaming: Schema.optional(Schema.Boolean), Compress: Schema.optional(Schema.Boolean), LambdaFunctionAssociations: Schema.optional(LambdaFunctionAssociations), FunctionAssociations: Schema.optional(FunctionAssociations), FieldLevelEncryptionId: Schema.optional(Schema.String), RealtimeLogConfigArn: Schema.optional(Schema.String), CachePolicyId: Schema.optional(Schema.String), OriginRequestPolicyId: Schema.optional(Schema.String), ResponseHeadersPolicyId: Schema.optional(Schema.String), GrpcConfig: Schema.optional(GrpcConfig), ForwardedValues: Schema.optional(ForwardedValues), MinTTL: Schema.optional(Schema.Number), DefaultTTL: Schema.optional(Schema.Number), MaxTTL: Schema.optional(Schema.Number)});
export const CacheBehavior = Schema.Struct({PathPattern: Schema.String, TargetOriginId: Schema.String, TrustedSigners: Schema.optional(TrustedSigners), TrustedKeyGroups: Schema.optional(TrustedKeyGroups), ViewerProtocolPolicy: Schema.String, AllowedMethods: Schema.optional(AllowedMethods), SmoothStreaming: Schema.optional(Schema.Boolean), Compress: Schema.optional(Schema.Boolean), LambdaFunctionAssociations: Schema.optional(LambdaFunctionAssociations), FunctionAssociations: Schema.optional(FunctionAssociations), FieldLevelEncryptionId: Schema.optional(Schema.String), RealtimeLogConfigArn: Schema.optional(Schema.String), CachePolicyId: Schema.optional(Schema.String), OriginRequestPolicyId: Schema.optional(Schema.String), ResponseHeadersPolicyId: Schema.optional(Schema.String), GrpcConfig: Schema.optional(GrpcConfig), ForwardedValues: Schema.optional(ForwardedValues), MinTTL: Schema.optional(Schema.Number), DefaultTTL: Schema.optional(Schema.Number), MaxTTL: Schema.optional(Schema.Number)});
export const CacheBehaviorList = Schema.Array(CacheBehavior);
export const CacheBehaviors = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(CacheBehaviorList)});
export const CustomErrorResponse = Schema.Struct({ErrorCode: Schema.Number, ResponsePagePath: Schema.optional(Schema.String), ResponseCode: Schema.optional(Schema.String), ErrorCachingMinTTL: Schema.optional(Schema.Number)});
export const CustomErrorResponseList = Schema.Array(CustomErrorResponse);
export const CustomErrorResponses = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(CustomErrorResponseList)});
export const LoggingConfig = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), IncludeCookies: Schema.optional(Schema.Boolean), Bucket: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String)});
export const ViewerCertificate = Schema.Struct({CloudFrontDefaultCertificate: Schema.optional(Schema.Boolean), IAMCertificateId: Schema.optional(Schema.String), ACMCertificateArn: Schema.optional(Schema.String), SSLSupportMethod: Schema.optional(Schema.String), MinimumProtocolVersion: Schema.optional(Schema.String), Certificate: Schema.optional(Schema.String), CertificateSource: Schema.optional(Schema.String)});
export const LocationList = Schema.Array(Schema.String);
export const GeoRestriction = Schema.Struct({RestrictionType: Schema.String, Quantity: Schema.Number, Items: Schema.optional(LocationList)});
export const Restrictions = Schema.Struct({GeoRestriction: GeoRestriction});
export const StringSchemaConfig = Schema.Struct({Comment: Schema.optional(Schema.String), DefaultValue: Schema.optional(Schema.String), Required: Schema.Boolean});
export const ParameterDefinitionSchema = Schema.Struct({StringSchema: Schema.optional(StringSchemaConfig)});
export const ParameterDefinition = Schema.Struct({Name: Schema.String, Definition: ParameterDefinitionSchema});
export const ParameterDefinitions = Schema.Array(ParameterDefinition);
export const TenantConfig = Schema.Struct({ParameterDefinitions: Schema.optional(ParameterDefinitions)});
export const DistributionConfig = Schema.Struct({CallerReference: Schema.String, Aliases: Schema.optional(Aliases), DefaultRootObject: Schema.optional(Schema.String), Origins: Origins, OriginGroups: Schema.optional(OriginGroups), DefaultCacheBehavior: DefaultCacheBehavior, CacheBehaviors: Schema.optional(CacheBehaviors), CustomErrorResponses: Schema.optional(CustomErrorResponses), Comment: Schema.String, Logging: Schema.optional(LoggingConfig), PriceClass: Schema.optional(Schema.String), Enabled: Schema.Boolean, ViewerCertificate: Schema.optional(ViewerCertificate), Restrictions: Schema.optional(Restrictions), WebACLId: Schema.optional(Schema.String), HttpVersion: Schema.optional(Schema.String), IsIPV6Enabled: Schema.optional(Schema.Boolean), ContinuousDeploymentPolicyId: Schema.optional(Schema.String), Staging: Schema.optional(Schema.Boolean), AnycastIpListId: Schema.optional(Schema.String), TenantConfig: Schema.optional(TenantConfig), ConnectionMode: Schema.optional(Schema.String)});
export const UpdateDistributionRequest = Schema.Struct({DistributionConfig: Body("DistributionConfig", DistributionConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const DomainItem = Schema.Struct({Domain: Schema.String});
export const DomainList = Schema.Array(DomainItem);
export const WebAclCustomization = Schema.Struct({Action: Schema.String, Arn: Schema.optional(Schema.String)});
export const Certificate = Schema.Struct({Arn: Schema.String});
export const GeoRestrictionCustomization = Schema.Struct({RestrictionType: Schema.String, Locations: Schema.optional(LocationList)});
export const Customizations = Schema.Struct({WebAcl: Schema.optional(WebAclCustomization), Certificate: Schema.optional(Certificate), GeoRestrictions: Schema.optional(GeoRestrictionCustomization)});
export const Parameter = Schema.Struct({Name: Schema.String, Value: Schema.String});
export const Parameters = Schema.Array(Parameter);
export const ManagedCertificateRequest = Schema.Struct({ValidationTokenHost: Schema.String, PrimaryDomainName: Schema.optional(Schema.String), CertificateTransparencyLoggingPreference: Schema.optional(Schema.String)});
export const UpdateDistributionTenantRequest = Schema.Struct({Id: Schema.String, DistributionId: Schema.optional(Schema.String), Domains: Schema.optional(DomainList), Customizations: Schema.optional(Customizations), Parameters: Schema.optional(Parameters), ConnectionGroupId: Schema.optional(Schema.String), IfMatch: Header("If-Match"), ManagedCertificateRequest: Schema.optional(ManagedCertificateRequest), Enabled: Schema.optional(Schema.Boolean)});
export const UpdateDistributionWithStagingConfigRequest = Schema.Struct({Id: Schema.String, StagingDistributionId: Schema.optional(Schema.String), IfMatch: Schema.optional(Header("If-Match"))});
export const DistributionResourceId = Schema.Struct({DistributionId: Schema.optional(Schema.String), DistributionTenantId: Schema.optional(Schema.String)});
export const UpdateDomainAssociationRequest = Schema.Struct({Domain: Schema.String, TargetResource: DistributionResourceId, IfMatch: Schema.optional(Header("If-Match"))});
export const QueryArgProfile = Schema.Struct({QueryArg: Schema.String, ProfileId: Schema.String});
export const QueryArgProfileList = Schema.Array(QueryArgProfile);
export const QueryArgProfiles = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(QueryArgProfileList)});
export const QueryArgProfileConfig = Schema.Struct({ForwardWhenQueryArgProfileIsUnknown: Schema.Boolean, QueryArgProfiles: Schema.optional(QueryArgProfiles)});
export const ContentTypeProfile = Schema.Struct({Format: Schema.String, ProfileId: Schema.optional(Schema.String), ContentType: Schema.String});
export const ContentTypeProfileList = Schema.Array(ContentTypeProfile);
export const ContentTypeProfiles = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(ContentTypeProfileList)});
export const ContentTypeProfileConfig = Schema.Struct({ForwardWhenContentTypeIsUnknown: Schema.Boolean, ContentTypeProfiles: Schema.optional(ContentTypeProfiles)});
export const FieldLevelEncryptionConfig = Schema.Struct({CallerReference: Schema.String, Comment: Schema.optional(Schema.String), QueryArgProfileConfig: Schema.optional(QueryArgProfileConfig), ContentTypeProfileConfig: Schema.optional(ContentTypeProfileConfig)});
export const UpdateFieldLevelEncryptionConfigRequest = Schema.Struct({FieldLevelEncryptionConfig: Body("FieldLevelEncryptionConfig", FieldLevelEncryptionConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const FieldPatternList = Schema.Array(Schema.String);
export const FieldPatterns = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(FieldPatternList)});
export const EncryptionEntity = Schema.Struct({PublicKeyId: Schema.String, ProviderId: Schema.String, FieldPatterns: FieldPatterns});
export const EncryptionEntityList = Schema.Array(EncryptionEntity);
export const EncryptionEntities = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(EncryptionEntityList)});
export const FieldLevelEncryptionProfileConfig = Schema.Struct({Name: Schema.String, CallerReference: Schema.String, Comment: Schema.optional(Schema.String), EncryptionEntities: EncryptionEntities});
export const UpdateFieldLevelEncryptionProfileRequest = Schema.Struct({FieldLevelEncryptionProfileConfig: Body("FieldLevelEncryptionProfileConfig", FieldLevelEncryptionProfileConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const KeyValueStoreAssociation = Schema.Struct({KeyValueStoreARN: Schema.String});
export const KeyValueStoreAssociationList = Schema.Array(KeyValueStoreAssociation);
export const KeyValueStoreAssociations = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(KeyValueStoreAssociationList)});
export const FunctionConfig = Schema.Struct({Comment: Schema.String, Runtime: Schema.String, KeyValueStoreAssociations: Schema.optional(KeyValueStoreAssociations)});
export const UpdateFunctionRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match"), FunctionConfig: FunctionConfig, FunctionCode: StreamBody()});
export const PublicKeyIdList = Schema.Array(Schema.String);
export const KeyGroupConfig = Schema.Struct({Name: Schema.String, Items: PublicKeyIdList, Comment: Schema.optional(Schema.String)});
export const UpdateKeyGroupRequest = Schema.Struct({KeyGroupConfig: Body("KeyGroupConfig", KeyGroupConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const UpdateKeyValueStoreRequest = Schema.Struct({Name: Schema.String, Comment: Schema.String, IfMatch: Header("If-Match")});
export const OriginAccessControlConfig = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), SigningProtocol: Schema.String, SigningBehavior: Schema.String, OriginAccessControlOriginType: Schema.String});
export const UpdateOriginAccessControlRequest = Schema.Struct({OriginAccessControlConfig: Body("OriginAccessControlConfig", OriginAccessControlConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const OriginRequestPolicyHeadersConfig = Schema.Struct({HeaderBehavior: Schema.String, Headers: Schema.optional(Headers)});
export const OriginRequestPolicyCookiesConfig = Schema.Struct({CookieBehavior: Schema.String, Cookies: Schema.optional(CookieNames)});
export const OriginRequestPolicyQueryStringsConfig = Schema.Struct({QueryStringBehavior: Schema.String, QueryStrings: Schema.optional(QueryStringNames)});
export const OriginRequestPolicyConfig = Schema.Struct({Comment: Schema.optional(Schema.String), Name: Schema.String, HeadersConfig: OriginRequestPolicyHeadersConfig, CookiesConfig: OriginRequestPolicyCookiesConfig, QueryStringsConfig: OriginRequestPolicyQueryStringsConfig});
export const UpdateOriginRequestPolicyRequest = Schema.Struct({OriginRequestPolicyConfig: Body("OriginRequestPolicyConfig", OriginRequestPolicyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const PublicKeyConfig = Schema.Struct({CallerReference: Schema.String, Name: Schema.String, EncodedKey: Schema.String, Comment: Schema.optional(Schema.String)});
export const UpdatePublicKeyRequest = Schema.Struct({PublicKeyConfig: Body("PublicKeyConfig", PublicKeyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const KinesisStreamConfig = Schema.Struct({RoleARN: Schema.String, StreamARN: Schema.String});
export const EndPoint = Schema.Struct({StreamType: Schema.String, KinesisStreamConfig: Schema.optional(KinesisStreamConfig)});
export const EndPointList = Schema.Array(EndPoint);
export const UpdateRealtimeLogConfigRequest = Schema.Struct({EndPoints: Schema.optional(EndPointList), Fields: Schema.optional(FieldList), Name: Schema.optional(Schema.String), ARN: Schema.optional(Schema.String), SamplingRate: Schema.optional(Schema.Number)});
export const AccessControlAllowOriginsList = Schema.Array(Schema.String);
export const ResponseHeadersPolicyAccessControlAllowOrigins = Schema.Struct({Quantity: Schema.Number, Items: AccessControlAllowOriginsList});
export const AccessControlAllowHeadersList = Schema.Array(Schema.String);
export const ResponseHeadersPolicyAccessControlAllowHeaders = Schema.Struct({Quantity: Schema.Number, Items: AccessControlAllowHeadersList});
export const AccessControlAllowMethodsList = Schema.Array(Schema.String);
export const ResponseHeadersPolicyAccessControlAllowMethods = Schema.Struct({Quantity: Schema.Number, Items: AccessControlAllowMethodsList});
export const AccessControlExposeHeadersList = Schema.Array(Schema.String);
export const ResponseHeadersPolicyAccessControlExposeHeaders = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(AccessControlExposeHeadersList)});
export const ResponseHeadersPolicyCorsConfig = Schema.Struct({AccessControlAllowOrigins: ResponseHeadersPolicyAccessControlAllowOrigins, AccessControlAllowHeaders: ResponseHeadersPolicyAccessControlAllowHeaders, AccessControlAllowMethods: ResponseHeadersPolicyAccessControlAllowMethods, AccessControlAllowCredentials: Schema.Boolean, AccessControlExposeHeaders: Schema.optional(ResponseHeadersPolicyAccessControlExposeHeaders), AccessControlMaxAgeSec: Schema.optional(Schema.Number), OriginOverride: Schema.Boolean});
export const ResponseHeadersPolicyXSSProtection = Schema.Struct({Override: Schema.Boolean, Protection: Schema.Boolean, ModeBlock: Schema.optional(Schema.Boolean), ReportUri: Schema.optional(Schema.String)});
export const ResponseHeadersPolicyFrameOptions = Schema.Struct({Override: Schema.Boolean, FrameOption: Schema.String});
export const ResponseHeadersPolicyReferrerPolicy = Schema.Struct({Override: Schema.Boolean, ReferrerPolicy: Schema.String});
export const ResponseHeadersPolicyContentSecurityPolicy = Schema.Struct({Override: Schema.Boolean, ContentSecurityPolicy: Schema.String});
export const ResponseHeadersPolicyContentTypeOptions = Schema.Struct({Override: Schema.Boolean});
export const ResponseHeadersPolicyStrictTransportSecurity = Schema.Struct({Override: Schema.Boolean, IncludeSubdomains: Schema.optional(Schema.Boolean), Preload: Schema.optional(Schema.Boolean), AccessControlMaxAgeSec: Schema.Number});
export const ResponseHeadersPolicySecurityHeadersConfig = Schema.Struct({XSSProtection: Schema.optional(ResponseHeadersPolicyXSSProtection), FrameOptions: Schema.optional(ResponseHeadersPolicyFrameOptions), ReferrerPolicy: Schema.optional(ResponseHeadersPolicyReferrerPolicy), ContentSecurityPolicy: Schema.optional(ResponseHeadersPolicyContentSecurityPolicy), ContentTypeOptions: Schema.optional(ResponseHeadersPolicyContentTypeOptions), StrictTransportSecurity: Schema.optional(ResponseHeadersPolicyStrictTransportSecurity)});
export const ResponseHeadersPolicyServerTimingHeadersConfig = Schema.Struct({Enabled: Schema.Boolean, SamplingRate: Schema.optional(Schema.Number)});
export const ResponseHeadersPolicyCustomHeader = Schema.Struct({Header: Schema.String, Value: Schema.String, Override: Schema.Boolean});
export const ResponseHeadersPolicyCustomHeaderList = Schema.Array(ResponseHeadersPolicyCustomHeader);
export const ResponseHeadersPolicyCustomHeadersConfig = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(ResponseHeadersPolicyCustomHeaderList)});
export const ResponseHeadersPolicyRemoveHeader = Schema.Struct({Header: Schema.String});
export const ResponseHeadersPolicyRemoveHeaderList = Schema.Array(ResponseHeadersPolicyRemoveHeader);
export const ResponseHeadersPolicyRemoveHeadersConfig = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(ResponseHeadersPolicyRemoveHeaderList)});
export const ResponseHeadersPolicyConfig = Schema.Struct({Comment: Schema.optional(Schema.String), Name: Schema.String, CorsConfig: Schema.optional(ResponseHeadersPolicyCorsConfig), SecurityHeadersConfig: Schema.optional(ResponseHeadersPolicySecurityHeadersConfig), ServerTimingHeadersConfig: Schema.optional(ResponseHeadersPolicyServerTimingHeadersConfig), CustomHeadersConfig: Schema.optional(ResponseHeadersPolicyCustomHeadersConfig), RemoveHeadersConfig: Schema.optional(ResponseHeadersPolicyRemoveHeadersConfig)});
export const UpdateResponseHeadersPolicyRequest = Schema.Struct({ResponseHeadersPolicyConfig: Body("ResponseHeadersPolicyConfig", ResponseHeadersPolicyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const S3Origin = Schema.Struct({DomainName: Schema.String, OriginAccessIdentity: Schema.String});
export const StreamingLoggingConfig = Schema.Struct({Enabled: Schema.Boolean, Bucket: Schema.String, Prefix: Schema.String});
export const StreamingDistributionConfig = Schema.Struct({CallerReference: Schema.String, S3Origin: S3Origin, Aliases: Schema.optional(Aliases), Comment: Schema.String, Logging: Schema.optional(StreamingLoggingConfig), TrustedSigners: TrustedSigners, PriceClass: Schema.optional(Schema.String), Enabled: Schema.Boolean});
export const UpdateStreamingDistributionRequest = Schema.Struct({StreamingDistributionConfig: Body("StreamingDistributionConfig", StreamingDistributionConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))});
export const VpcOriginEndpointConfig = Schema.Struct({Name: Schema.String, Arn: Schema.String, HTTPPort: Schema.Number, HTTPSPort: Schema.Number, OriginProtocolPolicy: Schema.String, OriginSslProtocols: Schema.optional(OriginSslProtocols)});
export const UpdateVpcOriginRequest = Schema.Struct({VpcOriginEndpointConfig: Body("VpcOriginEndpointConfig", VpcOriginEndpointConfig), Id: Schema.String, IfMatch: Header("If-Match")});
export const VerifyDnsConfigurationRequest = Schema.Struct({Domain: Schema.optional(Schema.String), Identifier: Schema.String});
export const TagKeyList = Schema.Array(Schema.String);
export const DistributionConfigWithTags = Schema.Struct({DistributionConfig: DistributionConfig, Tags: Tags});
export const ImportSource = Schema.Struct({SourceType: Schema.String, SourceARN: Schema.String});
export const StreamingDistributionConfigWithTags = Schema.Struct({StreamingDistributionConfig: StreamingDistributionConfig, Tags: Tags});
export const ConnectionGroupAssociationFilter = Schema.Struct({AnycastIpListId: Schema.optional(Schema.String)});
export const DistributionTenantAssociationFilter = Schema.Struct({DistributionId: Schema.optional(Schema.String), ConnectionGroupId: Schema.optional(Schema.String)});
export const TagKeys = Schema.Struct({Items: Schema.optional(TagKeyList)});
export const AccessDenied = Schema.Struct({Message: Schema.optional(Schema.String)});
export const AssociateDistributionTenantWebACLResult = Schema.Struct({Id: Schema.optional(Schema.String), WebACLArn: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))});
export const AssociateDistributionWebACLResult = Schema.Struct({Id: Schema.optional(Schema.String), WebACLArn: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))});
export const CreateCloudFrontOriginAccessIdentityRequest = Schema.Struct({CloudFrontOriginAccessIdentityConfig: Body("CloudFrontOriginAccessIdentityConfig", CloudFrontOriginAccessIdentityConfig)});
export const CreateDistributionWithTagsRequest = Schema.Struct({DistributionConfigWithTags: Body("DistributionConfigWithTags", DistributionConfigWithTags)});
export const CreateKeyGroupRequest = Schema.Struct({KeyGroupConfig: Body("KeyGroupConfig", KeyGroupConfig)});
export const CreateKeyValueStoreRequest = Schema.Struct({Name: Schema.String, Comment: Schema.optional(Schema.String), ImportSource: Schema.optional(ImportSource)});
export const CreateOriginAccessControlRequest = Schema.Struct({OriginAccessControlConfig: Body("OriginAccessControlConfig", OriginAccessControlConfig)});
export const CreatePublicKeyRequest = Schema.Struct({PublicKeyConfig: Body("PublicKeyConfig", PublicKeyConfig)});
export const CreateStreamingDistributionWithTagsRequest = Schema.Struct({StreamingDistributionConfigWithTags: Body("StreamingDistributionConfigWithTags", StreamingDistributionConfigWithTags)});
export const CannotDeleteEntityWhileInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CachePolicyInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CloudFrontOriginAccessIdentityInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const EntityNotFound = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ContinuousDeploymentPolicyInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DistributionNotDisabled = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidIfMatchVersion = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FieldLevelEncryptionConfigInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FieldLevelEncryptionProfileInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FunctionInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchResource = Schema.Struct({Message: Schema.optional(Schema.String)});
export const PreconditionFailed = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchDistribution = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchOriginAccessControl = Schema.Struct({Message: Schema.optional(Schema.String)});
export const IllegalDelete = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchPublicKey = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidArgument = Schema.Struct({Message: Schema.optional(Schema.String)});
export const UnsupportedOperation = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchStreamingDistribution = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DisassociateDistributionTenantWebACLResult = Schema.Struct({Id: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))});
export const DisassociateDistributionWebACLResult = Schema.Struct({Id: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))});
export const GetCachePolicyConfigResult = Schema.Struct({CachePolicyConfig: Schema.optional(Body("undefined", CachePolicyConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetCloudFrontOriginAccessIdentityConfigResult = Schema.Struct({CloudFrontOriginAccessIdentityConfig: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentityConfig)), ETag: Schema.optional(Header("ETag"))});
export const ConnectionGroup = Schema.Struct({Id: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), Arn: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.Date), LastModifiedTime: Schema.optional(Schema.Date), Tags: Schema.optional(Tags), Ipv6Enabled: Schema.optional(Schema.Boolean), RoutingEndpoint: Schema.optional(Schema.String), AnycastIpListId: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean), IsDefault: Schema.optional(Schema.Boolean)});
export const GetConnectionGroupResult = Schema.Struct({ConnectionGroup: Schema.optional(Body("undefined", ConnectionGroup)), ETag: Schema.optional(Header("ETag"))});
export const GetConnectionGroupByRoutingEndpointResult = Schema.Struct({ConnectionGroup: Schema.optional(Body("undefined", ConnectionGroup)), ETag: Schema.optional(Header("ETag"))});
export const GetContinuousDeploymentPolicyConfigResult = Schema.Struct({ContinuousDeploymentPolicyConfig: Schema.optional(Body("undefined", ContinuousDeploymentPolicyConfig)), ETag: Schema.optional(Header("ETag"))});
export const KeyPairIdList = Schema.Array(Schema.String);
export const KeyPairIds = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(KeyPairIdList)});
export const Signer = Schema.Struct({AwsAccountNumber: Schema.optional(Schema.String), KeyPairIds: Schema.optional(KeyPairIds)});
export const SignerList = Schema.Array(Signer);
export const ActiveTrustedSigners = Schema.Struct({Enabled: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(SignerList)});
export const KGKeyPairIds = Schema.Struct({KeyGroupId: Schema.optional(Schema.String), KeyPairIds: Schema.optional(KeyPairIds)});
export const KGKeyPairIdsList = Schema.Array(KGKeyPairIds);
export const ActiveTrustedKeyGroups = Schema.Struct({Enabled: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(KGKeyPairIdsList)});
export const AliasICPRecordal = Schema.Struct({CNAME: Schema.optional(Schema.String), ICPRecordalStatus: Schema.optional(Schema.String)});
export const AliasICPRecordals = Schema.Array(AliasICPRecordal);
export const Distribution = Schema.Struct({Id: Schema.String, ARN: Schema.String, Status: Schema.String, LastModifiedTime: Schema.Date, InProgressInvalidationBatches: Schema.Number, DomainName: Schema.String, ActiveTrustedSigners: Schema.optional(ActiveTrustedSigners), ActiveTrustedKeyGroups: Schema.optional(ActiveTrustedKeyGroups), DistributionConfig: DistributionConfig, AliasICPRecordals: Schema.optional(AliasICPRecordals)});
export const GetDistributionResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), ETag: Schema.optional(Header("ETag"))});
export const GetDistributionConfigResult = Schema.Struct({DistributionConfig: Schema.optional(Body("undefined", DistributionConfig)), ETag: Schema.optional(Header("ETag"))});
export const DomainResult = Schema.Struct({Domain: Schema.String, Status: Schema.optional(Schema.String)});
export const DomainResultList = Schema.Array(DomainResult);
export const DistributionTenant = Schema.Struct({Id: Schema.optional(Schema.String), DistributionId: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), Arn: Schema.optional(Schema.String), Domains: Schema.optional(DomainResultList), Tags: Schema.optional(Tags), Customizations: Schema.optional(Customizations), Parameters: Schema.optional(Parameters), ConnectionGroupId: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.Date), LastModifiedTime: Schema.optional(Schema.Date), Enabled: Schema.optional(Schema.Boolean), Status: Schema.optional(Schema.String)});
export const GetDistributionTenantByDomainResult = Schema.Struct({DistributionTenant: Schema.optional(Body("undefined", DistributionTenant)), ETag: Schema.optional(Header("ETag"))});
export const GetFieldLevelEncryptionConfigResult = Schema.Struct({FieldLevelEncryptionConfig: Schema.optional(Body("undefined", FieldLevelEncryptionConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetFieldLevelEncryptionProfileConfigResult = Schema.Struct({FieldLevelEncryptionProfileConfig: Schema.optional(Body("undefined", FieldLevelEncryptionProfileConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetFunctionResult = Schema.Struct({FunctionCode: Schema.optional(Body("undefined", StreamBody())), ETag: Schema.optional(Header("ETag")), ContentType: Schema.optional(Header("Content-Type"))});
export const Invalidation = Schema.Struct({Id: Schema.String, Status: Schema.String, CreateTime: Schema.Date, InvalidationBatch: InvalidationBatch});
export const GetInvalidationResult = Schema.Struct({Invalidation: Schema.optional(Body("undefined", Invalidation))});
export const GetInvalidationForDistributionTenantResult = Schema.Struct({Invalidation: Schema.optional(Body("undefined", Invalidation))});
export const GetKeyGroupConfigResult = Schema.Struct({KeyGroupConfig: Schema.optional(Body("undefined", KeyGroupConfig)), ETag: Schema.optional(Header("ETag"))});
export const RealtimeMetricsSubscriptionConfig = Schema.Struct({RealtimeMetricsSubscriptionStatus: Schema.String});
export const MonitoringSubscription = Schema.Struct({RealtimeMetricsSubscriptionConfig: Schema.optional(RealtimeMetricsSubscriptionConfig)});
export const GetMonitoringSubscriptionResult = Schema.Struct({MonitoringSubscription: Schema.optional(Body("undefined", MonitoringSubscription))});
export const GetOriginAccessControlConfigResult = Schema.Struct({OriginAccessControlConfig: Schema.optional(Body("undefined", OriginAccessControlConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetOriginRequestPolicyConfigResult = Schema.Struct({OriginRequestPolicyConfig: Schema.optional(Body("undefined", OriginRequestPolicyConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetPublicKeyConfigResult = Schema.Struct({PublicKeyConfig: Schema.optional(Body("undefined", PublicKeyConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetResourcePolicyResult = Schema.Struct({ResourceArn: Schema.optional(Schema.String), PolicyDocument: Schema.optional(Schema.String)});
export const GetResponseHeadersPolicyConfigResult = Schema.Struct({ResponseHeadersPolicyConfig: Schema.optional(Body("undefined", ResponseHeadersPolicyConfig)), ETag: Schema.optional(Header("ETag"))});
export const GetStreamingDistributionConfigResult = Schema.Struct({StreamingDistributionConfig: Schema.optional(Body("undefined", StreamingDistributionConfig)), ETag: Schema.optional(Header("ETag"))});
export const VpcOrigin = Schema.Struct({Id: Schema.String, Arn: Schema.String, AccountId: Schema.optional(Schema.String), Status: Schema.String, CreatedTime: Schema.Date, LastModifiedTime: Schema.Date, VpcOriginEndpointConfig: VpcOriginEndpointConfig});
export const GetVpcOriginResult = Schema.Struct({VpcOrigin: Schema.optional(Body("undefined", VpcOrigin)), ETag: Schema.optional(Header("ETag"))});
export const ListConnectionGroupsRequest = Schema.Struct({AssociationFilter: Schema.optional(ConnectionGroupAssociationFilter), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const DistributionSummary = Schema.Struct({Id: Schema.String, ARN: Schema.String, ETag: Schema.optional(Schema.String), Status: Schema.String, LastModifiedTime: Schema.Date, DomainName: Schema.String, Aliases: Aliases, Origins: Origins, OriginGroups: Schema.optional(OriginGroups), DefaultCacheBehavior: DefaultCacheBehavior, CacheBehaviors: CacheBehaviors, CustomErrorResponses: CustomErrorResponses, Comment: Schema.String, PriceClass: Schema.String, Enabled: Schema.Boolean, ViewerCertificate: ViewerCertificate, Restrictions: Restrictions, WebACLId: Schema.String, HttpVersion: Schema.String, IsIPV6Enabled: Schema.Boolean, AliasICPRecordals: Schema.optional(AliasICPRecordals), Staging: Schema.Boolean, ConnectionMode: Schema.optional(Schema.String), AnycastIpListId: Schema.optional(Schema.String)});
export const DistributionSummaryList = Schema.Array(DistributionSummary);
export const DistributionList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(DistributionSummaryList)});
export const ListDistributionsByAnycastIpListIdResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))});
export const ListDistributionsByConnectionModeResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))});
export const DistributionIdListSummary = Schema.Array(Schema.String);
export const DistributionIdList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(DistributionIdListSummary)});
export const ListDistributionsByKeyGroupResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))});
export const ListDistributionsByOriginRequestPolicyIdResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))});
export const ListDistributionsByRealtimeLogConfigResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))});
export const ListDistributionsByResponseHeadersPolicyIdResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))});
export const ListDistributionsByVpcOriginIdResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))});
export const ListDistributionsByWebACLIdResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))});
export const ListDistributionTenantsRequest = Schema.Struct({AssociationFilter: Schema.optional(DistributionTenantAssociationFilter), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)});
export const ListDomainConflictsRequest = Schema.Struct({Domain: Schema.String, DomainControlValidationResource: DistributionResourceId, MaxItems: Schema.optional(Schema.Number), Marker: Schema.optional(Schema.String)});
export const InvalidationSummary = Schema.Struct({Id: Schema.String, CreateTime: Schema.Date, Status: Schema.String});
export const InvalidationSummaryList = Schema.Array(InvalidationSummary);
export const InvalidationList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(InvalidationSummaryList)});
export const ListInvalidationsForDistributionTenantResult = Schema.Struct({InvalidationList: Schema.optional(Body("undefined", InvalidationList))});
export const ListTagsForResourceResult = Schema.Struct({Tags: Body("undefined", Tags)});
export const FunctionMetadata = Schema.Struct({FunctionARN: Schema.String, Stage: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.Date), LastModifiedTime: Schema.Date});
export const FunctionSummary = Schema.Struct({Name: Schema.String, Status: Schema.optional(Schema.String), FunctionConfig: FunctionConfig, FunctionMetadata: FunctionMetadata});
export const PublishFunctionResult = Schema.Struct({FunctionSummary: Schema.optional(Body("undefined", FunctionSummary))});
export const PutResourcePolicyResult = Schema.Struct({ResourceArn: Schema.optional(Schema.String)});
export const InvalidTagging = Schema.Struct({Message: Schema.optional(Schema.String)});
export const UntagResourceRequest = Schema.Struct({Resource: Schema.String, TagKeys: Body("TagKeys", TagKeys)});
export const AnycastIps = Schema.Array(Schema.String);
export const AnycastIpList = Schema.Struct({Id: Schema.String, Name: Schema.String, Status: Schema.String, Arn: Schema.String, IpAddressType: Schema.optional(Schema.String), AnycastIps: AnycastIps, IpCount: Schema.Number, LastModifiedTime: Schema.Date});
export const UpdateAnycastIpListResult = Schema.Struct({AnycastIpList: Schema.optional(Body("undefined", AnycastIpList)), ETag: Schema.optional(Header("ETag"))});
export const CachePolicy = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, CachePolicyConfig: CachePolicyConfig});
export const UpdateCachePolicyResult = Schema.Struct({CachePolicy: Schema.optional(Body("undefined", CachePolicy)), ETag: Schema.optional(Header("ETag"))});
export const CloudFrontOriginAccessIdentity = Schema.Struct({Id: Schema.String, S3CanonicalUserId: Schema.String, CloudFrontOriginAccessIdentityConfig: Schema.optional(CloudFrontOriginAccessIdentityConfig)});
export const UpdateCloudFrontOriginAccessIdentityResult = Schema.Struct({CloudFrontOriginAccessIdentity: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentity)), ETag: Schema.optional(Header("ETag"))});
export const UpdateConnectionGroupResult = Schema.Struct({ConnectionGroup: Schema.optional(Body("undefined", ConnectionGroup)), ETag: Schema.optional(Header("ETag"))});
export const ContinuousDeploymentPolicy = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, ContinuousDeploymentPolicyConfig: ContinuousDeploymentPolicyConfig});
export const UpdateContinuousDeploymentPolicyResult = Schema.Struct({ContinuousDeploymentPolicy: Schema.optional(Body("undefined", ContinuousDeploymentPolicy)), ETag: Schema.optional(Header("ETag"))});
export const UpdateDistributionResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), ETag: Schema.optional(Header("ETag"))});
export const UpdateDistributionTenantResult = Schema.Struct({DistributionTenant: Schema.optional(Body("undefined", DistributionTenant)), ETag: Schema.optional(Header("ETag"))});
export const UpdateDistributionWithStagingConfigResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), ETag: Schema.optional(Header("ETag"))});
export const UpdateDomainAssociationResult = Schema.Struct({Domain: Schema.optional(Schema.String), ResourceId: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))});
export const FieldLevelEncryption = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, FieldLevelEncryptionConfig: FieldLevelEncryptionConfig});
export const UpdateFieldLevelEncryptionConfigResult = Schema.Struct({FieldLevelEncryption: Schema.optional(Body("undefined", FieldLevelEncryption)), ETag: Schema.optional(Header("ETag"))});
export const FieldLevelEncryptionProfile = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, FieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig});
export const UpdateFieldLevelEncryptionProfileResult = Schema.Struct({FieldLevelEncryptionProfile: Schema.optional(Body("undefined", FieldLevelEncryptionProfile)), ETag: Schema.optional(Header("ETag"))});
export const UpdateFunctionResult = Schema.Struct({FunctionSummary: Schema.optional(Body("undefined", FunctionSummary)), ETag: Schema.optional(Header("ETtag"))});
export const KeyGroup = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, KeyGroupConfig: KeyGroupConfig});
export const UpdateKeyGroupResult = Schema.Struct({KeyGroup: Schema.optional(Body("undefined", KeyGroup)), ETag: Schema.optional(Header("ETag"))});
export const KeyValueStore = Schema.Struct({Name: Schema.String, Id: Schema.String, Comment: Schema.String, ARN: Schema.String, Status: Schema.optional(Schema.String), LastModifiedTime: Schema.Date});
export const UpdateKeyValueStoreResult = Schema.Struct({KeyValueStore: Schema.optional(Body("undefined", KeyValueStore)), ETag: Schema.optional(Header("ETag"))});
export const OriginAccessControl = Schema.Struct({Id: Schema.String, OriginAccessControlConfig: Schema.optional(OriginAccessControlConfig)});
export const UpdateOriginAccessControlResult = Schema.Struct({OriginAccessControl: Schema.optional(Body("undefined", OriginAccessControl)), ETag: Schema.optional(Header("ETag"))});
export const OriginRequestPolicy = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, OriginRequestPolicyConfig: OriginRequestPolicyConfig});
export const UpdateOriginRequestPolicyResult = Schema.Struct({OriginRequestPolicy: Schema.optional(Body("undefined", OriginRequestPolicy)), ETag: Schema.optional(Header("ETag"))});
export const PublicKey = Schema.Struct({Id: Schema.String, CreatedTime: Schema.Date, PublicKeyConfig: PublicKeyConfig});
export const UpdatePublicKeyResult = Schema.Struct({PublicKey: Schema.optional(Body("undefined", PublicKey)), ETag: Schema.optional(Header("ETag"))});
export const RealtimeLogConfig = Schema.Struct({ARN: Schema.String, Name: Schema.String, SamplingRate: Schema.Number, EndPoints: EndPointList, Fields: FieldList});
export const UpdateRealtimeLogConfigResult = Schema.Struct({RealtimeLogConfig: Schema.optional(RealtimeLogConfig)});
export const ResponseHeadersPolicy = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, ResponseHeadersPolicyConfig: ResponseHeadersPolicyConfig});
export const UpdateResponseHeadersPolicyResult = Schema.Struct({ResponseHeadersPolicy: Schema.optional(Body("undefined", ResponseHeadersPolicy)), ETag: Schema.optional(Header("ETag"))});
export const StreamingDistribution = Schema.Struct({Id: Schema.String, ARN: Schema.String, Status: Schema.String, LastModifiedTime: Schema.optional(Schema.Date), DomainName: Schema.String, ActiveTrustedSigners: ActiveTrustedSigners, StreamingDistributionConfig: StreamingDistributionConfig});
export const UpdateStreamingDistributionResult = Schema.Struct({StreamingDistribution: Schema.optional(Body("undefined", StreamingDistribution)), ETag: Schema.optional(Header("ETag"))});
export const UpdateVpcOriginResult = Schema.Struct({VpcOrigin: Schema.optional(Body("undefined", VpcOrigin)), ETag: Schema.optional(Header("ETag"))});
export const FunctionSummaryList = Schema.Array(FunctionSummary);
export const KeyValueStoreSummaryList = Schema.Array(KeyValueStore);
export const RealtimeLogConfigList = Schema.Array(RealtimeLogConfig);
export const FunctionExecutionLogList = Schema.Array(Schema.String);
export const DistributionTenantSummary = Schema.Struct({Id: Schema.String, DistributionId: Schema.String, Name: Schema.String, Arn: Schema.String, Domains: DomainResultList, ConnectionGroupId: Schema.optional(Schema.String), Customizations: Schema.optional(Customizations), CreatedTime: Schema.Date, LastModifiedTime: Schema.Date, ETag: Schema.String, Enabled: Schema.optional(Schema.Boolean), Status: Schema.optional(Schema.String)});
export const DistributionTenantList = Schema.Array(DistributionTenantSummary);
export const FunctionList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(FunctionSummaryList)});
export const KeyValueStoreList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(KeyValueStoreSummaryList)});
export const RealtimeLogConfigs = Schema.Struct({MaxItems: Schema.Number, Items: Schema.optional(RealtimeLogConfigList), IsTruncated: Schema.Boolean, Marker: Schema.String, NextMarker: Schema.optional(Schema.String)});
export const TestResult = Schema.Struct({FunctionSummary: Schema.optional(FunctionSummary), ComputeUtilization: Schema.optional(Schema.String), FunctionExecutionLogs: Schema.optional(FunctionExecutionLogList), FunctionErrorMessage: Schema.optional(Schema.String), FunctionOutput: Schema.optional(Schema.String)});
export const DnsConfiguration = Schema.Struct({Domain: Schema.String, Status: Schema.String, Reason: Schema.optional(Schema.String)});
export const DnsConfigurationList = Schema.Array(DnsConfiguration);
export const IllegalUpdate = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateAnycastIpListRequest = Schema.Struct({Name: Schema.String, IpCount: Schema.Number, Tags: Schema.optional(Tags), IpAddressType: Schema.optional(Schema.String)});
export const CreateCloudFrontOriginAccessIdentityResult = Schema.Struct({CloudFrontOriginAccessIdentity: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentity)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateConnectionGroupResult = Schema.Struct({ConnectionGroup: Schema.optional(Body("undefined", ConnectionGroup)), ETag: Schema.optional(Header("ETag"))});
export const CreateDistributionTenantRequest = Schema.Struct({DistributionId: Schema.String, Name: Schema.String, Domains: DomainList, Tags: Schema.optional(Tags), Customizations: Schema.optional(Customizations), Parameters: Schema.optional(Parameters), ConnectionGroupId: Schema.optional(Schema.String), ManagedCertificateRequest: Schema.optional(ManagedCertificateRequest), Enabled: Schema.optional(Schema.Boolean)});
export const CreateDistributionWithTagsResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateInvalidationRequest = Schema.Struct({DistributionId: Schema.String, InvalidationBatch: Body("InvalidationBatch", InvalidationBatch)});
export const CreateInvalidationForDistributionTenantResult = Schema.Struct({Location: Schema.optional(Header("Location")), Invalidation: Schema.optional(Body("undefined", Invalidation))});
export const CreateKeyGroupResult = Schema.Struct({KeyGroup: Schema.optional(Body("undefined", KeyGroup)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateKeyValueStoreResult = Schema.Struct({KeyValueStore: Schema.optional(Body("undefined", KeyValueStore)), ETag: Schema.optional(Header("ETag")), Location: Schema.optional(Header("Location"))});
export const CreateMonitoringSubscriptionRequest = Schema.Struct({DistributionId: Schema.String, MonitoringSubscription: Body("MonitoringSubscription", MonitoringSubscription)});
export const CreateOriginAccessControlResult = Schema.Struct({OriginAccessControl: Schema.optional(Body("undefined", OriginAccessControl)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreatePublicKeyResult = Schema.Struct({PublicKey: Schema.optional(Body("undefined", PublicKey)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateRealtimeLogConfigRequest = Schema.Struct({EndPoints: EndPointList, Fields: FieldList, Name: Schema.String, SamplingRate: Schema.Number});
export const CreateStreamingDistributionRequest = Schema.Struct({StreamingDistributionConfig: Body("StreamingDistributionConfig", StreamingDistributionConfig)});
export const CreateStreamingDistributionWithTagsResult = Schema.Struct({StreamingDistribution: Schema.optional(Body("undefined", StreamingDistribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateVpcOriginRequest = Schema.Struct({VpcOriginEndpointConfig: VpcOriginEndpointConfig, Tags: Schema.optional(Tags)});
export const NoSuchCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchCloudFrontOriginAccessIdentity = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ResourceNotDisabled = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchContinuousDeploymentPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ResourceInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchFieldLevelEncryptionConfig = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchFieldLevelEncryptionProfile = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchFunctionExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchMonitoringSubscription = Schema.Struct({Message: Schema.optional(Schema.String)});
export const OriginAccessControlInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const PublicKeyInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchRealtimeLogConfig = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ResponseHeadersPolicyInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const StreamingDistributionNotDisabled = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DeleteVpcOriginResult = Schema.Struct({VpcOrigin: Schema.optional(Body("undefined", VpcOrigin)), ETag: Schema.optional(Header("ETag"))});
export const DescribeKeyValueStoreResult = Schema.Struct({KeyValueStore: Schema.optional(Body("undefined", KeyValueStore)), ETag: Schema.optional(Header("ETag"))});
export const GetAnycastIpListResult = Schema.Struct({AnycastIpList: Schema.optional(Body("undefined", AnycastIpList)), ETag: Schema.optional(Header("ETag"))});
export const GetCachePolicyResult = Schema.Struct({CachePolicy: Schema.optional(Body("undefined", CachePolicy)), ETag: Schema.optional(Header("ETag"))});
export const GetCloudFrontOriginAccessIdentityResult = Schema.Struct({CloudFrontOriginAccessIdentity: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentity)), ETag: Schema.optional(Header("ETag"))});
export const GetContinuousDeploymentPolicyResult = Schema.Struct({ContinuousDeploymentPolicy: Schema.optional(Body("undefined", ContinuousDeploymentPolicy)), ETag: Schema.optional(Header("ETag"))});
export const GetFieldLevelEncryptionResult = Schema.Struct({FieldLevelEncryption: Schema.optional(Body("undefined", FieldLevelEncryption)), ETag: Schema.optional(Header("ETag"))});
export const GetFieldLevelEncryptionProfileResult = Schema.Struct({FieldLevelEncryptionProfile: Schema.optional(Body("undefined", FieldLevelEncryptionProfile)), ETag: Schema.optional(Header("ETag"))});
export const NoSuchInvalidation = Schema.Struct({Message: Schema.optional(Schema.String)});
export const GetKeyGroupResult = Schema.Struct({KeyGroup: Schema.optional(Body("undefined", KeyGroup)), ETag: Schema.optional(Header("ETag"))});
export const GetOriginAccessControlResult = Schema.Struct({OriginAccessControl: Schema.optional(Body("undefined", OriginAccessControl)), ETag: Schema.optional(Header("ETag"))});
export const GetOriginRequestPolicyResult = Schema.Struct({OriginRequestPolicy: Schema.optional(Body("undefined", OriginRequestPolicy)), ETag: Schema.optional(Header("ETag"))});
export const GetPublicKeyResult = Schema.Struct({PublicKey: Schema.optional(Body("undefined", PublicKey)), ETag: Schema.optional(Header("ETag"))});
export const GetRealtimeLogConfigResult = Schema.Struct({RealtimeLogConfig: Schema.optional(RealtimeLogConfig)});
export const GetResponseHeadersPolicyResult = Schema.Struct({ResponseHeadersPolicy: Schema.optional(Body("undefined", ResponseHeadersPolicy)), ETag: Schema.optional(Header("ETag"))});
export const GetStreamingDistributionResult = Schema.Struct({StreamingDistribution: Schema.optional(Body("undefined", StreamingDistribution)), ETag: Schema.optional(Header("ETag"))});
export const ListDistributionsByCachePolicyIdResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))});
export const InvalidWebACLId = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ListDistributionTenantsResult = Schema.Struct({NextMarker: Schema.optional(Schema.String), DistributionTenantList: Schema.optional(DistributionTenantList)});
export const ListDistributionTenantsByCustomizationResult = Schema.Struct({NextMarker: Schema.optional(Schema.String), DistributionTenantList: Schema.optional(DistributionTenantList)});
export const ListFunctionsResult = Schema.Struct({FunctionList: Schema.optional(Body("undefined", FunctionList))});
export const ListKeyValueStoresResult = Schema.Struct({KeyValueStoreList: Schema.optional(Body("undefined", KeyValueStoreList))});
export const ListRealtimeLogConfigsResult = Schema.Struct({RealtimeLogConfigs: Schema.optional(Body("undefined", RealtimeLogConfigs))});
export const TestFunctionResult = Schema.Struct({TestResult: Schema.optional(Body("undefined", TestResult))});
export const CachePolicyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InconsistentQuantities = Schema.Struct({Message: Schema.optional(Schema.String)});
export const EntityAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const StagingDistributionInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CNAMEAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const EntityLimitExceeded = Schema.Struct({Message: Schema.optional(Schema.String)});
export const IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior = Schema.Struct({Message: Schema.optional(Schema.String)});
export const QueryArgProfileEmpty = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FieldLevelEncryptionProfileAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FunctionSizeLimitExceeded = Schema.Struct({Message: Schema.optional(Schema.String)});
export const KeyGroupAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const OriginAccessControlAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const OriginRequestPolicyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CannotChangeImmutablePublicKeyFields = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ResponseHeadersPolicyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidOriginAccessControl = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CannotUpdateEntityWhileInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const VerifyDnsConfigurationResult = Schema.Struct({DnsConfigurationList: Schema.optional(DnsConfigurationList)});
export const ValidationTokenDetail = Schema.Struct({Domain: Schema.String, RedirectTo: Schema.optional(Schema.String), RedirectFrom: Schema.optional(Schema.String)});
export const ValidationTokenDetailList = Schema.Array(ValidationTokenDetail);
export const AnycastIpListSummary = Schema.Struct({Id: Schema.String, Name: Schema.String, Status: Schema.String, Arn: Schema.String, IpCount: Schema.Number, LastModifiedTime: Schema.Date, IpAddressType: Schema.optional(Schema.String), ETag: Schema.optional(Schema.String)});
export const AnycastIpListSummaries = Schema.Array(AnycastIpListSummary);
export const CachePolicySummary = Schema.Struct({Type: Schema.String, CachePolicy: CachePolicy});
export const CachePolicySummaryList = Schema.Array(CachePolicySummary);
export const CloudFrontOriginAccessIdentitySummary = Schema.Struct({Id: Schema.String, S3CanonicalUserId: Schema.String, Comment: Schema.String});
export const CloudFrontOriginAccessIdentitySummaryList = Schema.Array(CloudFrontOriginAccessIdentitySummary);
export const ConflictingAlias = Schema.Struct({Alias: Schema.optional(Schema.String), DistributionId: Schema.optional(Schema.String), AccountId: Schema.optional(Schema.String)});
export const ConflictingAliases = Schema.Array(ConflictingAlias);
export const ContinuousDeploymentPolicySummary = Schema.Struct({ContinuousDeploymentPolicy: ContinuousDeploymentPolicy});
export const ContinuousDeploymentPolicySummaryList = Schema.Array(ContinuousDeploymentPolicySummary);
export const DistributionIdOwner = Schema.Struct({DistributionId: Schema.String, OwnerAccountId: Schema.String});
export const DistributionIdOwnerItemList = Schema.Array(DistributionIdOwner);
export const FieldLevelEncryptionSummary = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, Comment: Schema.optional(Schema.String), QueryArgProfileConfig: Schema.optional(QueryArgProfileConfig), ContentTypeProfileConfig: Schema.optional(ContentTypeProfileConfig)});
export const FieldLevelEncryptionSummaryList = Schema.Array(FieldLevelEncryptionSummary);
export const FieldLevelEncryptionProfileSummary = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, Name: Schema.String, EncryptionEntities: EncryptionEntities, Comment: Schema.optional(Schema.String)});
export const FieldLevelEncryptionProfileSummaryList = Schema.Array(FieldLevelEncryptionProfileSummary);
export const KeyGroupSummary = Schema.Struct({KeyGroup: KeyGroup});
export const KeyGroupSummaryList = Schema.Array(KeyGroupSummary);
export const OriginAccessControlSummary = Schema.Struct({Id: Schema.String, Description: Schema.String, Name: Schema.String, SigningProtocol: Schema.String, SigningBehavior: Schema.String, OriginAccessControlOriginType: Schema.String});
export const OriginAccessControlSummaryList = Schema.Array(OriginAccessControlSummary);
export const OriginRequestPolicySummary = Schema.Struct({Type: Schema.String, OriginRequestPolicy: OriginRequestPolicy});
export const OriginRequestPolicySummaryList = Schema.Array(OriginRequestPolicySummary);
export const PublicKeySummary = Schema.Struct({Id: Schema.String, Name: Schema.String, CreatedTime: Schema.Date, EncodedKey: Schema.String, Comment: Schema.optional(Schema.String)});
export const PublicKeySummaryList = Schema.Array(PublicKeySummary);
export const ResponseHeadersPolicySummary = Schema.Struct({Type: Schema.String, ResponseHeadersPolicy: ResponseHeadersPolicy});
export const ResponseHeadersPolicySummaryList = Schema.Array(ResponseHeadersPolicySummary);
export const StreamingDistributionSummary = Schema.Struct({Id: Schema.String, ARN: Schema.String, Status: Schema.String, LastModifiedTime: Schema.Date, DomainName: Schema.String, S3Origin: S3Origin, Aliases: Aliases, TrustedSigners: TrustedSigners, Comment: Schema.String, PriceClass: Schema.String, Enabled: Schema.Boolean});
export const StreamingDistributionSummaryList = Schema.Array(StreamingDistributionSummary);
export const VpcOriginSummary = Schema.Struct({Id: Schema.String, Name: Schema.String, Status: Schema.String, CreatedTime: Schema.Date, LastModifiedTime: Schema.Date, Arn: Schema.String, AccountId: Schema.optional(Schema.String), OriginEndpointArn: Schema.String});
export const VpcOriginSummaryList = Schema.Array(VpcOriginSummary);
export const ManagedCertificateDetails = Schema.Struct({CertificateArn: Schema.optional(Schema.String), CertificateStatus: Schema.optional(Schema.String), ValidationTokenHost: Schema.optional(Schema.String), ValidationTokenDetails: Schema.optional(ValidationTokenDetailList)});
export const AnycastIpListCollection = Schema.Struct({Items: Schema.optional(AnycastIpListSummaries), Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number});
export const CachePolicyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(CachePolicySummaryList)});
export const CloudFrontOriginAccessIdentityList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(CloudFrontOriginAccessIdentitySummaryList)});
export const ConflictingAliasesList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), Quantity: Schema.optional(Schema.Number), Items: Schema.optional(ConflictingAliases)});
export const ConnectionGroupSummary = Schema.Struct({Id: Schema.String, Name: Schema.String, Arn: Schema.String, RoutingEndpoint: Schema.String, CreatedTime: Schema.Date, LastModifiedTime: Schema.Date, ETag: Schema.String, AnycastIpListId: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean), Status: Schema.optional(Schema.String), IsDefault: Schema.optional(Schema.Boolean)});
export const ConnectionGroupSummaryList = Schema.Array(ConnectionGroupSummary);
export const ContinuousDeploymentPolicyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(ContinuousDeploymentPolicySummaryList)});
export const DistributionIdOwnerList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(DistributionIdOwnerItemList)});
export const DomainConflict = Schema.Struct({Domain: Schema.String, ResourceType: Schema.String, ResourceId: Schema.String, AccountId: Schema.String});
export const DomainConflictsList = Schema.Array(DomainConflict);
export const FieldLevelEncryptionList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(FieldLevelEncryptionSummaryList)});
export const FieldLevelEncryptionProfileList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(FieldLevelEncryptionProfileSummaryList)});
export const KeyGroupList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(KeyGroupSummaryList)});
export const OriginAccessControlList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(OriginAccessControlSummaryList)});
export const OriginRequestPolicyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(OriginRequestPolicySummaryList)});
export const PublicKeyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(PublicKeySummaryList)});
export const ResponseHeadersPolicyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(ResponseHeadersPolicySummaryList)});
export const StreamingDistributionList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(StreamingDistributionSummaryList)});
export const VpcOriginList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(VpcOriginSummaryList)});
export const TooManyDistributionCNAMEs = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateAnycastIpListResult = Schema.Struct({AnycastIpList: Schema.optional(Body("undefined", AnycastIpList)), ETag: Schema.optional(Header("ETag"))});
export const CreateCachePolicyRequest = Schema.Struct({CachePolicyConfig: Body("CachePolicyConfig", CachePolicyConfig)});
export const CloudFrontOriginAccessIdentityAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateDistributionTenantResult = Schema.Struct({DistributionTenant: Schema.optional(Body("undefined", DistributionTenant)), ETag: Schema.optional(Header("ETag"))});
export const DistributionAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateFunctionRequest = Schema.Struct({Name: Schema.String, FunctionConfig: FunctionConfig, FunctionCode: StreamBody()});
export const CreateInvalidationResult = Schema.Struct({Location: Schema.optional(Header("Location")), Invalidation: Schema.optional(Body("undefined", Invalidation))});
export const BatchTooLarge = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyKeyGroups = Schema.Struct({Message: Schema.optional(Schema.String)});
export const EntitySizeLimitExceeded = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateMonitoringSubscriptionResult = Schema.Struct({MonitoringSubscription: Schema.optional(Body("undefined", MonitoringSubscription))});
export const TooManyOriginAccessControls = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateOriginRequestPolicyRequest = Schema.Struct({OriginRequestPolicyConfig: Body("OriginRequestPolicyConfig", OriginRequestPolicyConfig)});
export const PublicKeyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateRealtimeLogConfigResult = Schema.Struct({RealtimeLogConfig: Schema.optional(RealtimeLogConfig)});
export const CreateResponseHeadersPolicyRequest = Schema.Struct({ResponseHeadersPolicyConfig: Body("ResponseHeadersPolicyConfig", ResponseHeadersPolicyConfig)});
export const CreateStreamingDistributionResult = Schema.Struct({StreamingDistribution: Schema.optional(Body("undefined", StreamingDistribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const InvalidOrigin = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateVpcOriginResult = Schema.Struct({VpcOrigin: Schema.optional(Body("undefined", VpcOrigin)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const OriginRequestPolicyInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const RealtimeLogConfigInUse = Schema.Struct({Message: Schema.optional(Schema.String)});
export const DescribeFunctionResult = Schema.Struct({FunctionSummary: Schema.optional(Body("undefined", FunctionSummary)), ETag: Schema.optional(Header("ETag"))});
export const GetDistributionTenantResult = Schema.Struct({DistributionTenant: Schema.optional(Body("undefined", DistributionTenant)), ETag: Schema.optional(Header("ETag"))});
export const GetManagedCertificateDetailsResult = Schema.Struct({ManagedCertificateDetails: Schema.optional(Body("undefined", ManagedCertificateDetails))});
export const ListAnycastIpListsResult = Schema.Struct({AnycastIpLists: Schema.optional(Body("AnycastIpListCollection", AnycastIpListCollection))});
export const ListCachePoliciesResult = Schema.Struct({CachePolicyList: Schema.optional(Body("undefined", CachePolicyList))});
export const ListCloudFrontOriginAccessIdentitiesResult = Schema.Struct({CloudFrontOriginAccessIdentityList: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentityList))});
export const ListConflictingAliasesResult = Schema.Struct({ConflictingAliasesList: Schema.optional(Body("undefined", ConflictingAliasesList))});
export const ListConnectionGroupsResult = Schema.Struct({NextMarker: Schema.optional(Schema.String), ConnectionGroups: Schema.optional(ConnectionGroupSummaryList)});
export const ListContinuousDeploymentPoliciesResult = Schema.Struct({ContinuousDeploymentPolicyList: Schema.optional(Body("undefined", ContinuousDeploymentPolicyList))});
export const ListDistributionsResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))});
export const ListDistributionsByOwnedResourceResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionIdOwnerList))});
export const ListDomainConflictsResult = Schema.Struct({DomainConflicts: Schema.optional(DomainConflictsList), NextMarker: Schema.optional(Schema.String)});
export const ListFieldLevelEncryptionConfigsResult = Schema.Struct({FieldLevelEncryptionList: Schema.optional(Body("undefined", FieldLevelEncryptionList))});
export const ListFieldLevelEncryptionProfilesResult = Schema.Struct({FieldLevelEncryptionProfileList: Schema.optional(Body("undefined", FieldLevelEncryptionProfileList))});
export const ListInvalidationsResult = Schema.Struct({InvalidationList: Schema.optional(Body("undefined", InvalidationList))});
export const ListKeyGroupsResult = Schema.Struct({KeyGroupList: Schema.optional(Body("undefined", KeyGroupList))});
export const ListOriginAccessControlsResult = Schema.Struct({OriginAccessControlList: Schema.optional(Body("undefined", OriginAccessControlList))});
export const ListOriginRequestPoliciesResult = Schema.Struct({OriginRequestPolicyList: Schema.optional(Body("undefined", OriginRequestPolicyList))});
export const ListPublicKeysResult = Schema.Struct({PublicKeyList: Schema.optional(Body("undefined", PublicKeyList))});
export const ListResponseHeadersPoliciesResult = Schema.Struct({ResponseHeadersPolicyList: Schema.optional(Body("undefined", ResponseHeadersPolicyList))});
export const ListStreamingDistributionsResult = Schema.Struct({StreamingDistributionList: Schema.optional(Body("undefined", StreamingDistributionList))});
export const ListVpcOriginsResult = Schema.Struct({VpcOriginList: Schema.optional(Body("undefined", VpcOriginList))});
export const TestFunctionFailed = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyCookiesInCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const MissingBody = Schema.Struct({Message: Schema.optional(Schema.String)});
export const IllegalOriginAccessConfiguration = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidAssociation = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidDefaultRootObject = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFieldLevelEncryptionContentTypeProfiles = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FieldLevelEncryptionProfileSizeExceeded = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyPublicKeysInKeyGroup = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyCookiesInOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooLongCSPInResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidOriginAccessIdentity = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateCachePolicyResult = Schema.Struct({CachePolicy: Schema.optional(Body("undefined", CachePolicy)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const TooManyCloudFrontOriginAccessIdentities = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateContinuousDeploymentPolicyRequest = Schema.Struct({ContinuousDeploymentPolicyConfig: Body("ContinuousDeploymentPolicyConfig", ContinuousDeploymentPolicyConfig)});
export const InvalidDomainNameForOriginAccessControl = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateFieldLevelEncryptionConfigRequest = Schema.Struct({FieldLevelEncryptionConfig: Body("FieldLevelEncryptionConfig", FieldLevelEncryptionConfig)});
export const CreateFieldLevelEncryptionProfileRequest = Schema.Struct({FieldLevelEncryptionProfileConfig: Body("FieldLevelEncryptionProfileConfig", FieldLevelEncryptionProfileConfig)});
export const CreateFunctionResult = Schema.Struct({FunctionSummary: Schema.optional(Body("undefined", FunctionSummary)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const TooManyInvalidationsInProgress = Schema.Struct({Message: Schema.optional(Schema.String)});
export const MonitoringSubscriptionAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateOriginRequestPolicyResult = Schema.Struct({OriginRequestPolicy: Schema.optional(Body("undefined", OriginRequestPolicy)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const TooManyPublicKeys = Schema.Struct({Message: Schema.optional(Schema.String)});
export const RealtimeLogConfigAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateResponseHeadersPolicyResult = Schema.Struct({ResponseHeadersPolicy: Schema.optional(Body("undefined", ResponseHeadersPolicy)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const StreamingDistributionAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyStreamingDistributionCNAMEs = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyHeadersInCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidErrorCode = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidForwardCookies = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFieldLevelEncryptionQueryArgProfiles = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFieldLevelEncryptionEncryptionEntities = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyHeadersInOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyCustomHeadersInResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyTrustedSigners = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CopyDistributionResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const TooManyCachePolicies = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateContinuousDeploymentPolicyResult = Schema.Struct({ContinuousDeploymentPolicy: Schema.optional(Body("undefined", ContinuousDeploymentPolicy)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateDistributionRequest = Schema.Struct({DistributionConfig: Body("DistributionConfig", DistributionConfig)});
export const InvalidFunctionAssociation = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateFieldLevelEncryptionConfigResult = Schema.Struct({FieldLevelEncryption: Schema.optional(Body("undefined", FieldLevelEncryption)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const CreateFieldLevelEncryptionProfileResult = Schema.Struct({FieldLevelEncryptionProfile: Schema.optional(Body("undefined", FieldLevelEncryptionProfile)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const FunctionAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyOriginRequestPolicies = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyRealtimeLogConfigs = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyRemoveHeadersInResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyStreamingDistributions = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TrustedSignerDoesNotExist = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyQueryStringsInCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidGeoRestrictionParameter = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidHeadersForS3Origin = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFieldLevelEncryptionFieldPatterns = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyQueryStringsInOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidLambdaFunctionAssociation = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ContinuousDeploymentPolicyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const CreateDistributionResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))});
export const InvalidLocationCode = Schema.Struct({Message: Schema.optional(Schema.String)});
export const FieldLevelEncryptionConfigAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFieldLevelEncryptionProfiles = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFunctions = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyResponseHeadersPolicies = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidMinimumProtocolVersion = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidOriginKeepaliveTimeout = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidOriginReadTimeout = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyContinuousDeploymentPolicies = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidProtocolSettings = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidQueryStringParameters = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFieldLevelEncryptionConfigs = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidRelativePath = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidRequiredProtocol = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidResponseCode = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidTTLOrder = Schema.Struct({Message: Schema.optional(Schema.String)});
export const InvalidViewerCertificate = Schema.Struct({Message: Schema.optional(Schema.String)});
export const NoSuchOrigin = Schema.Struct({Message: Schema.optional(Schema.String)});
export const RealtimeLogConfigOwnerMismatch = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyCacheBehaviors = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyCertificates = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyCookieNamesInWhiteList = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsAssociatedToCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsAssociatedToFieldLevelEncryptionConfig = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributions = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsAssociatedToKeyGroup = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsAssociatedToOriginAccessControl = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsAssociatedToOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsAssociatedToResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsWithFunctionAssociations = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsWithLambdaAssociations = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyDistributionsWithSingleFunctionARN = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyFunctionAssociations = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyHeadersInForwardedValues = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyKeyGroupsAssociatedToDistribution = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyLambdaFunctionAssociations = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyOriginCustomHeaders = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyOriginGroupsPerDistribution = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyOrigins = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TooManyQueryStringParameters = Schema.Struct({Message: Schema.optional(Schema.String)});
export const TrustedKeyGroupDoesNotExist = Schema.Struct({Message: Schema.optional(Schema.String)});
export const AssociateDistributionTenantWebACL = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Id}/associate-web-acl", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.AssociateDistributionTenantWebACL" }, AssociateDistributionTenantWebACLRequest, AssociateDistributionTenantWebACLResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const AssociateDistributionWebACL = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}/associate-web-acl", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.AssociateDistributionWebACL" }, AssociateDistributionWebACLRequest, AssociateDistributionWebACLResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteAnycastIpList = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/anycast-ip-list/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteAnycastIpList" }, DeleteAnycastIpListRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CannotDeleteEntityWhileInUse", CannotDeleteEntityWhileInUse), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalDelete", IllegalDelete), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteDistributionTenant" }, DeleteDistributionTenantRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResourceNotDisabled", ResourceNotDisabled))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-group/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteKeyGroup" }, DeleteKeyGroupRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchResource", NoSuchResource), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResourceInUse", ResourceInUse))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteKeyValueStore = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-value-store/{Name}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteKeyValueStore" }, DeleteKeyValueStoreRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CannotDeleteEntityWhileInUse", CannotDeleteEntityWhileInUse), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/delete-resource-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteResourcePolicy" }, DeleteResourcePolicyRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalDelete", IllegalDelete), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DisassociateDistributionTenantWebACL = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Id}/disassociate-web-acl", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DisassociateDistributionTenantWebACL" }, DisassociateDistributionTenantWebACLRequest, DisassociateDistributionTenantWebACLResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DisassociateDistributionWebACL = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}/disassociate-web-acl", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DisassociateDistributionWebACL" }, DisassociateDistributionWebACLRequest, DisassociateDistributionWebACLResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetCachePolicyConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/cache-policy/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetCachePolicyConfig" }, GetCachePolicyConfigRequest, GetCachePolicyConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetCloudFrontOriginAccessIdentityConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-identity/cloudfront/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetCloudFrontOriginAccessIdentityConfig" }, GetCloudFrontOriginAccessIdentityConfigRequest, GetCloudFrontOriginAccessIdentityConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchCloudFrontOriginAccessIdentity", NoSuchCloudFrontOriginAccessIdentity))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetConnectionGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/connection-group/{Identifier}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetConnectionGroup" }, GetConnectionGroupRequest, GetConnectionGroupResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetConnectionGroupByRoutingEndpoint = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/connection-group", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetConnectionGroupByRoutingEndpoint" }, GetConnectionGroupByRoutingEndpointRequest, GetConnectionGroupByRoutingEndpointResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetContinuousDeploymentPolicyConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/continuous-deployment-policy/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetContinuousDeploymentPolicyConfig" }, GetContinuousDeploymentPolicyConfigRequest, GetContinuousDeploymentPolicyConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetDistribution" }, GetDistributionRequest, GetDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetDistributionConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetDistributionConfig" }, GetDistributionConfigRequest, GetDistributionConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetDistributionTenantByDomain = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetDistributionTenantByDomain" }, GetDistributionTenantByDomainRequest, GetDistributionTenantByDomainResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetFieldLevelEncryptionConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetFieldLevelEncryptionConfig" }, GetFieldLevelEncryptionConfigRequest, GetFieldLevelEncryptionConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetFieldLevelEncryptionProfileConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption-profile/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetFieldLevelEncryptionProfileConfig" }, GetFieldLevelEncryptionProfileConfigRequest, GetFieldLevelEncryptionProfileConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchFieldLevelEncryptionProfile", NoSuchFieldLevelEncryptionProfile))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function/{Name}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetFunction" }, GetFunctionRequest, GetFunctionResult, Schema.Union(ErrorAnnotation("NoSuchFunctionExists", NoSuchFunctionExists), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetInvalidationForDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{DistributionTenantId}/invalidation/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetInvalidationForDistributionTenant" }, GetInvalidationForDistributionTenantRequest, GetInvalidationForDistributionTenantResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("NoSuchInvalidation", NoSuchInvalidation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetKeyGroupConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-group/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetKeyGroupConfig" }, GetKeyGroupConfigRequest, GetKeyGroupConfigResult, ErrorAnnotation("NoSuchResource", NoSuchResource)), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetMonitoringSubscription = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributions/{DistributionId}/monitoring-subscription", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetMonitoringSubscription" }, GetMonitoringSubscriptionRequest, GetMonitoringSubscriptionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("NoSuchMonitoringSubscription", NoSuchMonitoringSubscription), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetOriginAccessControlConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-control/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetOriginAccessControlConfig" }, GetOriginAccessControlConfigRequest, GetOriginAccessControlConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchOriginAccessControl", NoSuchOriginAccessControl))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetOriginRequestPolicyConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-request-policy/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetOriginRequestPolicyConfig" }, GetOriginRequestPolicyConfigRequest, GetOriginRequestPolicyConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetPublicKeyConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/public-key/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetPublicKeyConfig" }, GetPublicKeyConfigRequest, GetPublicKeyConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchPublicKey", NoSuchPublicKey))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/get-resource-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetResourcePolicy" }, GetResourcePolicyRequest, GetResourcePolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetResponseHeadersPolicyConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/response-headers-policy/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetResponseHeadersPolicyConfig" }, GetResponseHeadersPolicyConfigRequest, GetResponseHeadersPolicyConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetStreamingDistributionConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetStreamingDistributionConfig" }, GetStreamingDistributionConfigRequest, GetStreamingDistributionConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchStreamingDistribution", NoSuchStreamingDistribution))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetVpcOrigin = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/vpc-origin/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetVpcOrigin" }, GetVpcOriginRequest, GetVpcOriginResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDistributionsByAnycastIpListId = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByAnycastIpListId/{AnycastIpListId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByAnycastIpListId" }, ListDistributionsByAnycastIpListIdRequest, ListDistributionsByAnycastIpListIdResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDistributionsByConnectionMode = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByConnectionMode/{ConnectionMode}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByConnectionMode" }, ListDistributionsByConnectionModeRequest, ListDistributionsByConnectionModeResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDistributionsByKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByKeyGroupId/{KeyGroupId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByKeyGroup" }, ListDistributionsByKeyGroupRequest, ListDistributionsByKeyGroupResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchResource", NoSuchResource))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDistributionsByOriginRequestPolicyId = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByOriginRequestPolicyId/{OriginRequestPolicyId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByOriginRequestPolicyId" }, ListDistributionsByOriginRequestPolicyIdRequest, ListDistributionsByOriginRequestPolicyIdResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDistributionsByRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByRealtimeLogConfig", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByRealtimeLogConfig" }, ListDistributionsByRealtimeLogConfigRequest, ListDistributionsByRealtimeLogConfigResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDistributionsByResponseHeadersPolicyId = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByResponseHeadersPolicyId/{ResponseHeadersPolicyId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByResponseHeadersPolicyId" }, ListDistributionsByResponseHeadersPolicyIdRequest, ListDistributionsByResponseHeadersPolicyIdResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDistributionsByVpcOriginId = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByVpcOriginId/{VpcOriginId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByVpcOriginId" }, ListDistributionsByVpcOriginIdRequest, ListDistributionsByVpcOriginIdResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListInvalidationsForDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Id}/invalidation", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListInvalidationsForDistributionTenant" }, ListInvalidationsForDistributionTenantRequest, ListInvalidationsForDistributionTenantResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/tagging", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("NoSuchResource", NoSuchResource))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const PublishFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function/{Name}/publish", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.PublishFunction" }, PublishFunctionRequest, PublishFunctionResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFunctionExists", NoSuchFunctionExists), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const PutResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/put-resource-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.PutResourcePolicy" }, PutResourcePolicyRequest, PutResourcePolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const TagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/tagging?Operation=Tag", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.TagResource" }, TagResourceRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("NoSuchResource", NoSuchResource))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UntagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/tagging?Operation=Untag", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UntagResource" }, UntagResourceRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("NoSuchResource", NoSuchResource))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateAnycastIpList = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/anycast-ip-list/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateAnycastIpList" }, UpdateAnycastIpListRequest, UpdateAnycastIpListResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateDomainAssociation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/domain-association", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateDomainAssociation" }, UpdateDomainAssociationRequest, UpdateDomainAssociationResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateKeyValueStore = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-value-store/{Name}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateKeyValueStore" }, UpdateKeyValueStoreRequest, UpdateKeyValueStoreResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/realtime-log-config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateRealtimeLogConfig" }, UpdateRealtimeLogConfigRequest, UpdateRealtimeLogConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateConnectionGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/connection-group", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateConnectionGroup" }, CreateConnectionGroupRequest, CreateConnectionGroupResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidTagging", InvalidTagging))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteCachePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/cache-policy/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteCachePolicy" }, DeleteCachePolicyRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CachePolicyInUse", CachePolicyInUse), ErrorAnnotation("IllegalDelete", IllegalDelete), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteCloudFrontOriginAccessIdentity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-identity/cloudfront/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteCloudFrontOriginAccessIdentity" }, DeleteCloudFrontOriginAccessIdentityRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CloudFrontOriginAccessIdentityInUse", CloudFrontOriginAccessIdentityInUse), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchCloudFrontOriginAccessIdentity", NoSuchCloudFrontOriginAccessIdentity), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteConnectionGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/connection-group/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteConnectionGroup" }, DeleteConnectionGroupRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CannotDeleteEntityWhileInUse", CannotDeleteEntityWhileInUse), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResourceNotDisabled", ResourceNotDisabled))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteContinuousDeploymentPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/continuous-deployment-policy/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteContinuousDeploymentPolicy" }, DeleteContinuousDeploymentPolicyRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("ContinuousDeploymentPolicyInUse", ContinuousDeploymentPolicyInUse), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteDistribution" }, DeleteDistributionRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("DistributionNotDisabled", DistributionNotDisabled), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResourceInUse", ResourceInUse))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteFieldLevelEncryptionConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteFieldLevelEncryptionConfig" }, DeleteFieldLevelEncryptionConfigRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("FieldLevelEncryptionConfigInUse", FieldLevelEncryptionConfigInUse), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteFieldLevelEncryptionProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption-profile/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteFieldLevelEncryptionProfile" }, DeleteFieldLevelEncryptionProfileRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("FieldLevelEncryptionProfileInUse", FieldLevelEncryptionProfileInUse), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFieldLevelEncryptionProfile", NoSuchFieldLevelEncryptionProfile), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function/{Name}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteFunction" }, DeleteFunctionRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("FunctionInUse", FunctionInUse), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFunctionExists", NoSuchFunctionExists), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteMonitoringSubscription = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributions/{DistributionId}/monitoring-subscription", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteMonitoringSubscription" }, DeleteMonitoringSubscriptionRequest, DeleteMonitoringSubscriptionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("NoSuchMonitoringSubscription", NoSuchMonitoringSubscription), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteOriginAccessControl = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-control/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteOriginAccessControl" }, DeleteOriginAccessControlRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchOriginAccessControl", NoSuchOriginAccessControl), ErrorAnnotation("OriginAccessControlInUse", OriginAccessControlInUse), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeletePublicKey = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/public-key/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeletePublicKey" }, DeletePublicKeyRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchPublicKey", NoSuchPublicKey), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("PublicKeyInUse", PublicKeyInUse))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteResponseHeadersPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/response-headers-policy/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteResponseHeadersPolicy" }, DeleteResponseHeadersPolicyRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalDelete", IllegalDelete), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResponseHeadersPolicyInUse", ResponseHeadersPolicyInUse))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteStreamingDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteStreamingDistribution" }, DeleteStreamingDistributionRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchStreamingDistribution", NoSuchStreamingDistribution), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("StreamingDistributionNotDisabled", StreamingDistributionNotDisabled))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteVpcOrigin = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/vpc-origin/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteVpcOrigin" }, DeleteVpcOriginRequest, DeleteVpcOriginResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CannotDeleteEntityWhileInUse", CannotDeleteEntityWhileInUse), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalDelete", IllegalDelete), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DescribeKeyValueStore = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-value-store/{Name}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DescribeKeyValueStore" }, DescribeKeyValueStoreRequest, DescribeKeyValueStoreResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetAnycastIpList = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/anycast-ip-list/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetAnycastIpList" }, GetAnycastIpListRequest, GetAnycastIpListResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetCachePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/cache-policy/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetCachePolicy" }, GetCachePolicyRequest, GetCachePolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetCloudFrontOriginAccessIdentity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-identity/cloudfront/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetCloudFrontOriginAccessIdentity" }, GetCloudFrontOriginAccessIdentityRequest, GetCloudFrontOriginAccessIdentityResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchCloudFrontOriginAccessIdentity", NoSuchCloudFrontOriginAccessIdentity))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetContinuousDeploymentPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/continuous-deployment-policy/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetContinuousDeploymentPolicy" }, GetContinuousDeploymentPolicyRequest, GetContinuousDeploymentPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetFieldLevelEncryption = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetFieldLevelEncryption" }, GetFieldLevelEncryptionRequest, GetFieldLevelEncryptionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetFieldLevelEncryptionProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption-profile/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetFieldLevelEncryptionProfile" }, GetFieldLevelEncryptionProfileRequest, GetFieldLevelEncryptionProfileResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchFieldLevelEncryptionProfile", NoSuchFieldLevelEncryptionProfile))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetInvalidation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{DistributionId}/invalidation/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetInvalidation" }, GetInvalidationRequest, GetInvalidationResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("NoSuchInvalidation", NoSuchInvalidation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-group/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetKeyGroup" }, GetKeyGroupRequest, GetKeyGroupResult, ErrorAnnotation("NoSuchResource", NoSuchResource)), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetOriginAccessControl = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-control/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetOriginAccessControl" }, GetOriginAccessControlRequest, GetOriginAccessControlResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchOriginAccessControl", NoSuchOriginAccessControl))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetOriginRequestPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-request-policy/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetOriginRequestPolicy" }, GetOriginRequestPolicyRequest, GetOriginRequestPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetPublicKey = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/public-key/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetPublicKey" }, GetPublicKeyRequest, GetPublicKeyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchPublicKey", NoSuchPublicKey))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/get-realtime-log-config", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetRealtimeLogConfig" }, GetRealtimeLogConfigRequest, GetRealtimeLogConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetResponseHeadersPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/response-headers-policy/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetResponseHeadersPolicy" }, GetResponseHeadersPolicyRequest, GetResponseHeadersPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetStreamingDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetStreamingDistribution" }, GetStreamingDistributionRequest, GetStreamingDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchStreamingDistribution", NoSuchStreamingDistribution))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDistributionsByCachePolicyId = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByCachePolicyId/{CachePolicyId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByCachePolicyId" }, ListDistributionsByCachePolicyIdRequest, ListDistributionsByCachePolicyIdResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDistributionsByWebACLId = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByWebACLId/{WebACLId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByWebACLId" }, ListDistributionsByWebACLIdRequest, ListDistributionsByWebACLIdResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidWebACLId", InvalidWebACLId))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDistributionTenants = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenants", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionTenants" }, ListDistributionTenantsRequest, ListDistributionTenantsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDistributionTenantsByCustomization = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenants-by-customization", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionTenantsByCustomization" }, ListDistributionTenantsByCustomizationRequest, ListDistributionTenantsByCustomizationResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListFunctions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListFunctions" }, ListFunctionsRequest, ListFunctionsResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListKeyValueStores = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-value-store", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListKeyValueStores" }, ListKeyValueStoresRequest, ListKeyValueStoresResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListRealtimeLogConfigs = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/realtime-log-config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListRealtimeLogConfigs" }, ListRealtimeLogConfigsRequest, ListRealtimeLogConfigsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateConnectionGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/connection-group/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateConnectionGroup" }, UpdateConnectionGroupRequest, UpdateConnectionGroupResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResourceInUse", ResourceInUse))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateContinuousDeploymentPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/continuous-deployment-policy/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateContinuousDeploymentPolicy" }, UpdateContinuousDeploymentPolicyRequest, UpdateContinuousDeploymentPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("StagingDistributionInUse", StagingDistributionInUse))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function/{Name}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateFunction" }, UpdateFunctionRequest, UpdateFunctionResult, Schema.Union(ErrorAnnotation("FunctionSizeLimitExceeded", FunctionSizeLimitExceeded), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFunctionExists", NoSuchFunctionExists), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateOriginAccessControl = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-control/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateOriginAccessControl" }, UpdateOriginAccessControlRequest, UpdateOriginAccessControlResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchOriginAccessControl", NoSuchOriginAccessControl), ErrorAnnotation("OriginAccessControlAlreadyExists", OriginAccessControlAlreadyExists), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdatePublicKey = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/public-key/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdatePublicKey" }, UpdatePublicKeyRequest, UpdatePublicKeyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CannotChangeImmutablePublicKeyFields", CannotChangeImmutablePublicKeyFields), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchPublicKey", NoSuchPublicKey), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateVpcOrigin = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/vpc-origin/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateVpcOrigin" }, UpdateVpcOriginRequest, UpdateVpcOriginResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CannotUpdateEntityWhileInUse", CannotUpdateEntityWhileInUse), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const VerifyDnsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/verify-dns-configuration", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.VerifyDnsConfiguration" }, VerifyDnsConfigurationRequest, VerifyDnsConfigurationResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const AssociateAlias = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{TargetDistributionId}/associate-alias", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.AssociateAlias" }, AssociateAliasRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("TooManyDistributionCNAMEs", TooManyDistributionCNAMEs))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateAnycastIpList = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/anycast-ip-list", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateAnycastIpList" }, CreateAnycastIpListRequest, CreateAnycastIpListResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateDistributionTenant" }, CreateDistributionTenantRequest, CreateDistributionTenantResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidAssociation", InvalidAssociation), ErrorAnnotation("InvalidTagging", InvalidTagging))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateInvalidationForDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Id}/invalidation", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateInvalidationForDistributionTenant" }, CreateInvalidationForDistributionTenantRequest, CreateInvalidationForDistributionTenantResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("BatchTooLarge", BatchTooLarge), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("TooManyInvalidationsInProgress", TooManyInvalidationsInProgress))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-group", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateKeyGroup" }, CreateKeyGroupRequest, CreateKeyGroupResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("KeyGroupAlreadyExists", KeyGroupAlreadyExists), ErrorAnnotation("TooManyKeyGroups", TooManyKeyGroups), ErrorAnnotation("TooManyPublicKeysInKeyGroup", TooManyPublicKeysInKeyGroup))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateKeyValueStore = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-value-store", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateKeyValueStore" }, CreateKeyValueStoreRequest, CreateKeyValueStoreResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntitySizeLimitExceeded", EntitySizeLimitExceeded), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateOriginAccessControl = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-control", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateOriginAccessControl" }, CreateOriginAccessControlRequest, CreateOriginAccessControlResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("OriginAccessControlAlreadyExists", OriginAccessControlAlreadyExists), ErrorAnnotation("TooManyOriginAccessControls", TooManyOriginAccessControls))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateVpcOrigin = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/vpc-origin", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateVpcOrigin" }, CreateVpcOriginRequest, CreateVpcOriginResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteOriginRequestPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-request-policy/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteOriginRequestPolicy" }, DeleteOriginRequestPolicyRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalDelete", IllegalDelete), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("OriginRequestPolicyInUse", OriginRequestPolicyInUse), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DeleteRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/delete-realtime-log-config", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DeleteRealtimeLogConfig" }, DeleteRealtimeLogConfigRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig), ErrorAnnotation("RealtimeLogConfigInUse", RealtimeLogConfigInUse))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const DescribeFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function/{Name}/describe", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.DescribeFunction" }, DescribeFunctionRequest, DescribeFunctionResult, Schema.Union(ErrorAnnotation("NoSuchFunctionExists", NoSuchFunctionExists), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Identifier}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetDistributionTenant" }, GetDistributionTenantRequest, GetDistributionTenantResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const GetManagedCertificateDetails = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/managed-certificate/{Identifier}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.GetManagedCertificateDetails" }, GetManagedCertificateDetailsRequest, GetManagedCertificateDetailsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListAnycastIpLists = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/anycast-ip-list", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListAnycastIpLists" }, ListAnycastIpListsRequest, ListAnycastIpListsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListCachePolicies = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/cache-policy", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListCachePolicies" }, ListCachePoliciesRequest, ListCachePoliciesResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListCloudFrontOriginAccessIdentities = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-identity/cloudfront", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListCloudFrontOriginAccessIdentities" }, ListCloudFrontOriginAccessIdentitiesRequest, ListCloudFrontOriginAccessIdentitiesResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListConflictingAliases = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/conflicting-alias", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListConflictingAliases" }, ListConflictingAliasesRequest, ListConflictingAliasesResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListConnectionGroups = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/connection-groups", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListConnectionGroups" }, ListConnectionGroupsRequest, ListConnectionGroupsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListContinuousDeploymentPolicies = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/continuous-deployment-policy", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListContinuousDeploymentPolicies" }, ListContinuousDeploymentPoliciesRequest, ListContinuousDeploymentPoliciesResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDistributions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributions" }, ListDistributionsRequest, ListDistributionsResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDistributionsByOwnedResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributionsByOwnedResource/{ResourceArn}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDistributionsByOwnedResource" }, ListDistributionsByOwnedResourceRequest, ListDistributionsByOwnedResourceResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListDomainConflicts = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/domain-conflicts", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListDomainConflicts" }, ListDomainConflictsRequest, ListDomainConflictsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListFieldLevelEncryptionConfigs = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListFieldLevelEncryptionConfigs" }, ListFieldLevelEncryptionConfigsRequest, ListFieldLevelEncryptionConfigsResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListFieldLevelEncryptionProfiles = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption-profile", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListFieldLevelEncryptionProfiles" }, ListFieldLevelEncryptionProfilesRequest, ListFieldLevelEncryptionProfilesResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListInvalidations = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{DistributionId}/invalidation", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListInvalidations" }, ListInvalidationsRequest, ListInvalidationsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListKeyGroups = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-group", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListKeyGroups" }, ListKeyGroupsRequest, ListKeyGroupsResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListOriginAccessControls = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-control", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListOriginAccessControls" }, ListOriginAccessControlsRequest, ListOriginAccessControlsResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListOriginRequestPolicies = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-request-policy", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListOriginRequestPolicies" }, ListOriginRequestPoliciesRequest, ListOriginRequestPoliciesResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListPublicKeys = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/public-key", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListPublicKeys" }, ListPublicKeysRequest, ListPublicKeysResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListResponseHeadersPolicies = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/response-headers-policy", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListResponseHeadersPolicies" }, ListResponseHeadersPoliciesRequest, ListResponseHeadersPoliciesResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListStreamingDistributions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListStreamingDistributions" }, ListStreamingDistributionsRequest, ListStreamingDistributionsResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const ListVpcOrigins = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/vpc-origin", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.ListVpcOrigins" }, ListVpcOriginsRequest, ListVpcOriginsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const TestFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function/{Name}/test", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.TestFunction" }, TestFunctionRequest, TestFunctionResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFunctionExists", NoSuchFunctionExists), ErrorAnnotation("TestFunctionFailed", TestFunctionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateCloudFrontOriginAccessIdentity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-identity/cloudfront/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateCloudFrontOriginAccessIdentity" }, UpdateCloudFrontOriginAccessIdentityRequest, UpdateCloudFrontOriginAccessIdentityResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchCloudFrontOriginAccessIdentity", NoSuchCloudFrontOriginAccessIdentity), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution-tenant/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateDistributionTenant" }, UpdateDistributionTenantRequest, UpdateDistributionTenantResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidAssociation", InvalidAssociation), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/key-group/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateKeyGroup" }, UpdateKeyGroupRequest, UpdateKeyGroupResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("KeyGroupAlreadyExists", KeyGroupAlreadyExists), ErrorAnnotation("NoSuchResource", NoSuchResource), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("TooManyPublicKeysInKeyGroup", TooManyPublicKeysInKeyGroup))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateCloudFrontOriginAccessIdentity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-access-identity/cloudfront", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateCloudFrontOriginAccessIdentity" }, CreateCloudFrontOriginAccessIdentityRequest, CreateCloudFrontOriginAccessIdentityResult, Schema.Union(ErrorAnnotation("CloudFrontOriginAccessIdentityAlreadyExists", CloudFrontOriginAccessIdentityAlreadyExists), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("TooManyCloudFrontOriginAccessIdentities", TooManyCloudFrontOriginAccessIdentities))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateInvalidation = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{DistributionId}/invalidation", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateInvalidation" }, CreateInvalidationRequest, CreateInvalidationResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("BatchTooLarge", BatchTooLarge), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("TooManyInvalidationsInProgress", TooManyInvalidationsInProgress))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateMonitoringSubscription = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distributions/{DistributionId}/monitoring-subscription", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateMonitoringSubscription" }, CreateMonitoringSubscriptionRequest, CreateMonitoringSubscriptionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("MonitoringSubscriptionAlreadyExists", MonitoringSubscriptionAlreadyExists), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreatePublicKey = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/public-key", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreatePublicKey" }, CreatePublicKeyRequest, CreatePublicKeyResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("PublicKeyAlreadyExists", PublicKeyAlreadyExists), ErrorAnnotation("TooManyPublicKeys", TooManyPublicKeys))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateFieldLevelEncryptionConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateFieldLevelEncryptionConfig" }, UpdateFieldLevelEncryptionConfigRequest, UpdateFieldLevelEncryptionConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("NoSuchFieldLevelEncryptionProfile", NoSuchFieldLevelEncryptionProfile), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("QueryArgProfileEmpty", QueryArgProfileEmpty), ErrorAnnotation("TooManyFieldLevelEncryptionContentTypeProfiles", TooManyFieldLevelEncryptionContentTypeProfiles), ErrorAnnotation("TooManyFieldLevelEncryptionQueryArgProfiles", TooManyFieldLevelEncryptionQueryArgProfiles))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateResponseHeadersPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/response-headers-policy/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateResponseHeadersPolicy" }, UpdateResponseHeadersPolicyRequest, UpdateResponseHeadersPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResponseHeadersPolicyAlreadyExists", ResponseHeadersPolicyAlreadyExists), ErrorAnnotation("TooLongCSPInResponseHeadersPolicy", TooLongCSPInResponseHeadersPolicy), ErrorAnnotation("TooManyCustomHeadersInResponseHeadersPolicy", TooManyCustomHeadersInResponseHeadersPolicy), ErrorAnnotation("TooManyRemoveHeadersInResponseHeadersPolicy", TooManyRemoveHeadersInResponseHeadersPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateStreamingDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateStreamingDistribution" }, UpdateStreamingDistributionRequest, UpdateStreamingDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchStreamingDistribution", NoSuchStreamingDistribution), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("TooManyStreamingDistributionCNAMEs", TooManyStreamingDistributionCNAMEs), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateCachePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/cache-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateCachePolicy" }, CreateCachePolicyRequest, CreateCachePolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CachePolicyAlreadyExists", CachePolicyAlreadyExists), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("TooManyCachePolicies", TooManyCachePolicies), ErrorAnnotation("TooManyCookiesInCachePolicy", TooManyCookiesInCachePolicy), ErrorAnnotation("TooManyHeadersInCachePolicy", TooManyHeadersInCachePolicy), ErrorAnnotation("TooManyQueryStringsInCachePolicy", TooManyQueryStringsInCachePolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateOriginRequestPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-request-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateOriginRequestPolicy" }, CreateOriginRequestPolicyRequest, CreateOriginRequestPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("OriginRequestPolicyAlreadyExists", OriginRequestPolicyAlreadyExists), ErrorAnnotation("TooManyCookiesInOriginRequestPolicy", TooManyCookiesInOriginRequestPolicy), ErrorAnnotation("TooManyHeadersInOriginRequestPolicy", TooManyHeadersInOriginRequestPolicy), ErrorAnnotation("TooManyOriginRequestPolicies", TooManyOriginRequestPolicies), ErrorAnnotation("TooManyQueryStringsInOriginRequestPolicy", TooManyQueryStringsInOriginRequestPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/realtime-log-config", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateRealtimeLogConfig" }, CreateRealtimeLogConfigRequest, CreateRealtimeLogConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("RealtimeLogConfigAlreadyExists", RealtimeLogConfigAlreadyExists), ErrorAnnotation("TooManyRealtimeLogConfigs", TooManyRealtimeLogConfigs))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateStreamingDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateStreamingDistribution" }, CreateStreamingDistributionRequest, CreateStreamingDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidOrigin", InvalidOrigin), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("StreamingDistributionAlreadyExists", StreamingDistributionAlreadyExists), ErrorAnnotation("TooManyStreamingDistributionCNAMEs", TooManyStreamingDistributionCNAMEs), ErrorAnnotation("TooManyStreamingDistributions", TooManyStreamingDistributions), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateStreamingDistributionWithTags = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/streaming-distribution?WithTags", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateStreamingDistributionWithTags" }, CreateStreamingDistributionWithTagsRequest, CreateStreamingDistributionWithTagsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidOrigin", InvalidOrigin), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("StreamingDistributionAlreadyExists", StreamingDistributionAlreadyExists), ErrorAnnotation("TooManyStreamingDistributionCNAMEs", TooManyStreamingDistributionCNAMEs), ErrorAnnotation("TooManyStreamingDistributions", TooManyStreamingDistributions), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateCachePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/cache-policy/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateCachePolicy" }, UpdateCachePolicyRequest, UpdateCachePolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CachePolicyAlreadyExists", CachePolicyAlreadyExists), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("TooManyCookiesInCachePolicy", TooManyCookiesInCachePolicy), ErrorAnnotation("TooManyHeadersInCachePolicy", TooManyHeadersInCachePolicy), ErrorAnnotation("TooManyQueryStringsInCachePolicy", TooManyQueryStringsInCachePolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateFieldLevelEncryptionProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption-profile/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateFieldLevelEncryptionProfile" }, UpdateFieldLevelEncryptionProfileRequest, UpdateFieldLevelEncryptionProfileResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("FieldLevelEncryptionProfileAlreadyExists", FieldLevelEncryptionProfileAlreadyExists), ErrorAnnotation("FieldLevelEncryptionProfileSizeExceeded", FieldLevelEncryptionProfileSizeExceeded), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFieldLevelEncryptionProfile", NoSuchFieldLevelEncryptionProfile), ErrorAnnotation("NoSuchPublicKey", NoSuchPublicKey), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("TooManyFieldLevelEncryptionEncryptionEntities", TooManyFieldLevelEncryptionEncryptionEntities), ErrorAnnotation("TooManyFieldLevelEncryptionFieldPatterns", TooManyFieldLevelEncryptionFieldPatterns))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateOriginRequestPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/origin-request-policy/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateOriginRequestPolicy" }, UpdateOriginRequestPolicyRequest, UpdateOriginRequestPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("OriginRequestPolicyAlreadyExists", OriginRequestPolicyAlreadyExists), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("TooManyCookiesInOriginRequestPolicy", TooManyCookiesInOriginRequestPolicy), ErrorAnnotation("TooManyHeadersInOriginRequestPolicy", TooManyHeadersInOriginRequestPolicy), ErrorAnnotation("TooManyQueryStringsInOriginRequestPolicy", TooManyQueryStringsInOriginRequestPolicy))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateFieldLevelEncryptionProfile = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption-profile", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateFieldLevelEncryptionProfile" }, CreateFieldLevelEncryptionProfileRequest, CreateFieldLevelEncryptionProfileResult, Schema.Union(ErrorAnnotation("FieldLevelEncryptionProfileAlreadyExists", FieldLevelEncryptionProfileAlreadyExists), ErrorAnnotation("FieldLevelEncryptionProfileSizeExceeded", FieldLevelEncryptionProfileSizeExceeded), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchPublicKey", NoSuchPublicKey), ErrorAnnotation("TooManyFieldLevelEncryptionEncryptionEntities", TooManyFieldLevelEncryptionEncryptionEntities), ErrorAnnotation("TooManyFieldLevelEncryptionFieldPatterns", TooManyFieldLevelEncryptionFieldPatterns), ErrorAnnotation("TooManyFieldLevelEncryptionProfiles", TooManyFieldLevelEncryptionProfiles))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateFunction = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/function", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateFunction" }, CreateFunctionRequest, CreateFunctionResult, Schema.Union(ErrorAnnotation("FunctionAlreadyExists", FunctionAlreadyExists), ErrorAnnotation("FunctionSizeLimitExceeded", FunctionSizeLimitExceeded), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("TooManyFunctions", TooManyFunctions), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateResponseHeadersPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/response-headers-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateResponseHeadersPolicy" }, CreateResponseHeadersPolicyRequest, CreateResponseHeadersPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("ResponseHeadersPolicyAlreadyExists", ResponseHeadersPolicyAlreadyExists), ErrorAnnotation("TooLongCSPInResponseHeadersPolicy", TooLongCSPInResponseHeadersPolicy), ErrorAnnotation("TooManyCustomHeadersInResponseHeadersPolicy", TooManyCustomHeadersInResponseHeadersPolicy), ErrorAnnotation("TooManyRemoveHeadersInResponseHeadersPolicy", TooManyRemoveHeadersInResponseHeadersPolicy), ErrorAnnotation("TooManyResponseHeadersPolicies", TooManyResponseHeadersPolicies))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateContinuousDeploymentPolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/continuous-deployment-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateContinuousDeploymentPolicy" }, CreateContinuousDeploymentPolicyRequest, CreateContinuousDeploymentPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("ContinuousDeploymentPolicyAlreadyExists", ContinuousDeploymentPolicyAlreadyExists), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("StagingDistributionInUse", StagingDistributionInUse), ErrorAnnotation("TooManyContinuousDeploymentPolicies", TooManyContinuousDeploymentPolicies))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateFieldLevelEncryptionConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/field-level-encryption", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateFieldLevelEncryptionConfig" }, CreateFieldLevelEncryptionConfigRequest, CreateFieldLevelEncryptionConfigResult, Schema.Union(ErrorAnnotation("FieldLevelEncryptionConfigAlreadyExists", FieldLevelEncryptionConfigAlreadyExists), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchFieldLevelEncryptionProfile", NoSuchFieldLevelEncryptionProfile), ErrorAnnotation("QueryArgProfileEmpty", QueryArgProfileEmpty), ErrorAnnotation("TooManyFieldLevelEncryptionConfigs", TooManyFieldLevelEncryptionConfigs), ErrorAnnotation("TooManyFieldLevelEncryptionContentTypeProfiles", TooManyFieldLevelEncryptionContentTypeProfiles), ErrorAnnotation("TooManyFieldLevelEncryptionQueryArgProfiles", TooManyFieldLevelEncryptionQueryArgProfiles))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateDistributionWithTags = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution?WithTags", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateDistributionWithTags" }, CreateDistributionWithTagsRequest, CreateDistributionWithTagsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("ContinuousDeploymentPolicyInUse", ContinuousDeploymentPolicyInUse), ErrorAnnotation("DistributionAlreadyExists", DistributionAlreadyExists), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior", IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior), ErrorAnnotation("IllegalOriginAccessConfiguration", IllegalOriginAccessConfiguration), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidDefaultRootObject", InvalidDefaultRootObject), ErrorAnnotation("InvalidDomainNameForOriginAccessControl", InvalidDomainNameForOriginAccessControl), ErrorAnnotation("InvalidErrorCode", InvalidErrorCode), ErrorAnnotation("InvalidForwardCookies", InvalidForwardCookies), ErrorAnnotation("InvalidFunctionAssociation", InvalidFunctionAssociation), ErrorAnnotation("InvalidGeoRestrictionParameter", InvalidGeoRestrictionParameter), ErrorAnnotation("InvalidHeadersForS3Origin", InvalidHeadersForS3Origin), ErrorAnnotation("InvalidLambdaFunctionAssociation", InvalidLambdaFunctionAssociation), ErrorAnnotation("InvalidLocationCode", InvalidLocationCode), ErrorAnnotation("InvalidMinimumProtocolVersion", InvalidMinimumProtocolVersion), ErrorAnnotation("InvalidOrigin", InvalidOrigin), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("InvalidOriginKeepaliveTimeout", InvalidOriginKeepaliveTimeout), ErrorAnnotation("InvalidOriginReadTimeout", InvalidOriginReadTimeout), ErrorAnnotation("InvalidProtocolSettings", InvalidProtocolSettings), ErrorAnnotation("InvalidQueryStringParameters", InvalidQueryStringParameters), ErrorAnnotation("InvalidRelativePath", InvalidRelativePath), ErrorAnnotation("InvalidRequiredProtocol", InvalidRequiredProtocol), ErrorAnnotation("InvalidResponseCode", InvalidResponseCode), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("InvalidTTLOrder", InvalidTTLOrder), ErrorAnnotation("InvalidViewerCertificate", InvalidViewerCertificate), ErrorAnnotation("InvalidWebACLId", InvalidWebACLId), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("NoSuchOrigin", NoSuchOrigin), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("RealtimeLogConfigOwnerMismatch", RealtimeLogConfigOwnerMismatch), ErrorAnnotation("TooManyCacheBehaviors", TooManyCacheBehaviors), ErrorAnnotation("TooManyCertificates", TooManyCertificates), ErrorAnnotation("TooManyCookieNamesInWhiteList", TooManyCookieNamesInWhiteList), ErrorAnnotation("TooManyDistributionCNAMEs", TooManyDistributionCNAMEs), ErrorAnnotation("TooManyDistributions", TooManyDistributions), ErrorAnnotation("TooManyDistributionsAssociatedToCachePolicy", TooManyDistributionsAssociatedToCachePolicy), ErrorAnnotation("TooManyDistributionsAssociatedToFieldLevelEncryptionConfig", TooManyDistributionsAssociatedToFieldLevelEncryptionConfig), ErrorAnnotation("TooManyDistributionsAssociatedToKeyGroup", TooManyDistributionsAssociatedToKeyGroup), ErrorAnnotation("TooManyDistributionsAssociatedToOriginAccessControl", TooManyDistributionsAssociatedToOriginAccessControl), ErrorAnnotation("TooManyDistributionsAssociatedToOriginRequestPolicy", TooManyDistributionsAssociatedToOriginRequestPolicy), ErrorAnnotation("TooManyDistributionsAssociatedToResponseHeadersPolicy", TooManyDistributionsAssociatedToResponseHeadersPolicy), ErrorAnnotation("TooManyDistributionsWithFunctionAssociations", TooManyDistributionsWithFunctionAssociations), ErrorAnnotation("TooManyDistributionsWithLambdaAssociations", TooManyDistributionsWithLambdaAssociations), ErrorAnnotation("TooManyDistributionsWithSingleFunctionARN", TooManyDistributionsWithSingleFunctionARN), ErrorAnnotation("TooManyFunctionAssociations", TooManyFunctionAssociations), ErrorAnnotation("TooManyHeadersInForwardedValues", TooManyHeadersInForwardedValues), ErrorAnnotation("TooManyKeyGroupsAssociatedToDistribution", TooManyKeyGroupsAssociatedToDistribution), ErrorAnnotation("TooManyLambdaFunctionAssociations", TooManyLambdaFunctionAssociations), ErrorAnnotation("TooManyOriginCustomHeaders", TooManyOriginCustomHeaders), ErrorAnnotation("TooManyOriginGroupsPerDistribution", TooManyOriginGroupsPerDistribution), ErrorAnnotation("TooManyOrigins", TooManyOrigins), ErrorAnnotation("TooManyQueryStringParameters", TooManyQueryStringParameters), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedKeyGroupDoesNotExist", TrustedKeyGroupDoesNotExist), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateDistribution" }, UpdateDistributionRequest, UpdateDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("ContinuousDeploymentPolicyInUse", ContinuousDeploymentPolicyInUse), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior", IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior), ErrorAnnotation("IllegalOriginAccessConfiguration", IllegalOriginAccessConfiguration), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidDefaultRootObject", InvalidDefaultRootObject), ErrorAnnotation("InvalidDomainNameForOriginAccessControl", InvalidDomainNameForOriginAccessControl), ErrorAnnotation("InvalidErrorCode", InvalidErrorCode), ErrorAnnotation("InvalidForwardCookies", InvalidForwardCookies), ErrorAnnotation("InvalidFunctionAssociation", InvalidFunctionAssociation), ErrorAnnotation("InvalidGeoRestrictionParameter", InvalidGeoRestrictionParameter), ErrorAnnotation("InvalidHeadersForS3Origin", InvalidHeadersForS3Origin), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("InvalidLambdaFunctionAssociation", InvalidLambdaFunctionAssociation), ErrorAnnotation("InvalidLocationCode", InvalidLocationCode), ErrorAnnotation("InvalidMinimumProtocolVersion", InvalidMinimumProtocolVersion), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("InvalidOriginKeepaliveTimeout", InvalidOriginKeepaliveTimeout), ErrorAnnotation("InvalidOriginReadTimeout", InvalidOriginReadTimeout), ErrorAnnotation("InvalidQueryStringParameters", InvalidQueryStringParameters), ErrorAnnotation("InvalidRelativePath", InvalidRelativePath), ErrorAnnotation("InvalidRequiredProtocol", InvalidRequiredProtocol), ErrorAnnotation("InvalidResponseCode", InvalidResponseCode), ErrorAnnotation("InvalidTTLOrder", InvalidTTLOrder), ErrorAnnotation("InvalidViewerCertificate", InvalidViewerCertificate), ErrorAnnotation("InvalidWebACLId", InvalidWebACLId), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("NoSuchOrigin", NoSuchOrigin), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("RealtimeLogConfigOwnerMismatch", RealtimeLogConfigOwnerMismatch), ErrorAnnotation("StagingDistributionInUse", StagingDistributionInUse), ErrorAnnotation("TooManyCacheBehaviors", TooManyCacheBehaviors), ErrorAnnotation("TooManyCertificates", TooManyCertificates), ErrorAnnotation("TooManyCookieNamesInWhiteList", TooManyCookieNamesInWhiteList), ErrorAnnotation("TooManyDistributionCNAMEs", TooManyDistributionCNAMEs), ErrorAnnotation("TooManyDistributionsAssociatedToCachePolicy", TooManyDistributionsAssociatedToCachePolicy), ErrorAnnotation("TooManyDistributionsAssociatedToFieldLevelEncryptionConfig", TooManyDistributionsAssociatedToFieldLevelEncryptionConfig), ErrorAnnotation("TooManyDistributionsAssociatedToKeyGroup", TooManyDistributionsAssociatedToKeyGroup), ErrorAnnotation("TooManyDistributionsAssociatedToOriginAccessControl", TooManyDistributionsAssociatedToOriginAccessControl), ErrorAnnotation("TooManyDistributionsAssociatedToOriginRequestPolicy", TooManyDistributionsAssociatedToOriginRequestPolicy), ErrorAnnotation("TooManyDistributionsAssociatedToResponseHeadersPolicy", TooManyDistributionsAssociatedToResponseHeadersPolicy), ErrorAnnotation("TooManyDistributionsWithFunctionAssociations", TooManyDistributionsWithFunctionAssociations), ErrorAnnotation("TooManyDistributionsWithLambdaAssociations", TooManyDistributionsWithLambdaAssociations), ErrorAnnotation("TooManyDistributionsWithSingleFunctionARN", TooManyDistributionsWithSingleFunctionARN), ErrorAnnotation("TooManyFunctionAssociations", TooManyFunctionAssociations), ErrorAnnotation("TooManyHeadersInForwardedValues", TooManyHeadersInForwardedValues), ErrorAnnotation("TooManyKeyGroupsAssociatedToDistribution", TooManyKeyGroupsAssociatedToDistribution), ErrorAnnotation("TooManyLambdaFunctionAssociations", TooManyLambdaFunctionAssociations), ErrorAnnotation("TooManyOriginCustomHeaders", TooManyOriginCustomHeaders), ErrorAnnotation("TooManyOriginGroupsPerDistribution", TooManyOriginGroupsPerDistribution), ErrorAnnotation("TooManyOrigins", TooManyOrigins), ErrorAnnotation("TooManyQueryStringParameters", TooManyQueryStringParameters), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedKeyGroupDoesNotExist", TrustedKeyGroupDoesNotExist), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const UpdateDistributionWithStagingConfig = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{Id}/promote-staging-config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.UpdateDistributionWithStagingConfig" }, UpdateDistributionWithStagingConfigRequest, UpdateDistributionWithStagingConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior", IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidDefaultRootObject", InvalidDefaultRootObject), ErrorAnnotation("InvalidErrorCode", InvalidErrorCode), ErrorAnnotation("InvalidForwardCookies", InvalidForwardCookies), ErrorAnnotation("InvalidFunctionAssociation", InvalidFunctionAssociation), ErrorAnnotation("InvalidGeoRestrictionParameter", InvalidGeoRestrictionParameter), ErrorAnnotation("InvalidHeadersForS3Origin", InvalidHeadersForS3Origin), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("InvalidLambdaFunctionAssociation", InvalidLambdaFunctionAssociation), ErrorAnnotation("InvalidLocationCode", InvalidLocationCode), ErrorAnnotation("InvalidMinimumProtocolVersion", InvalidMinimumProtocolVersion), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("InvalidOriginKeepaliveTimeout", InvalidOriginKeepaliveTimeout), ErrorAnnotation("InvalidOriginReadTimeout", InvalidOriginReadTimeout), ErrorAnnotation("InvalidQueryStringParameters", InvalidQueryStringParameters), ErrorAnnotation("InvalidRelativePath", InvalidRelativePath), ErrorAnnotation("InvalidRequiredProtocol", InvalidRequiredProtocol), ErrorAnnotation("InvalidResponseCode", InvalidResponseCode), ErrorAnnotation("InvalidTTLOrder", InvalidTTLOrder), ErrorAnnotation("InvalidViewerCertificate", InvalidViewerCertificate), ErrorAnnotation("InvalidWebACLId", InvalidWebACLId), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("NoSuchOrigin", NoSuchOrigin), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("RealtimeLogConfigOwnerMismatch", RealtimeLogConfigOwnerMismatch), ErrorAnnotation("TooManyCacheBehaviors", TooManyCacheBehaviors), ErrorAnnotation("TooManyCertificates", TooManyCertificates), ErrorAnnotation("TooManyCookieNamesInWhiteList", TooManyCookieNamesInWhiteList), ErrorAnnotation("TooManyDistributionCNAMEs", TooManyDistributionCNAMEs), ErrorAnnotation("TooManyDistributionsAssociatedToCachePolicy", TooManyDistributionsAssociatedToCachePolicy), ErrorAnnotation("TooManyDistributionsAssociatedToFieldLevelEncryptionConfig", TooManyDistributionsAssociatedToFieldLevelEncryptionConfig), ErrorAnnotation("TooManyDistributionsAssociatedToKeyGroup", TooManyDistributionsAssociatedToKeyGroup), ErrorAnnotation("TooManyDistributionsAssociatedToOriginAccessControl", TooManyDistributionsAssociatedToOriginAccessControl), ErrorAnnotation("TooManyDistributionsAssociatedToOriginRequestPolicy", TooManyDistributionsAssociatedToOriginRequestPolicy), ErrorAnnotation("TooManyDistributionsAssociatedToResponseHeadersPolicy", TooManyDistributionsAssociatedToResponseHeadersPolicy), ErrorAnnotation("TooManyDistributionsWithFunctionAssociations", TooManyDistributionsWithFunctionAssociations), ErrorAnnotation("TooManyDistributionsWithLambdaAssociations", TooManyDistributionsWithLambdaAssociations), ErrorAnnotation("TooManyDistributionsWithSingleFunctionARN", TooManyDistributionsWithSingleFunctionARN), ErrorAnnotation("TooManyFunctionAssociations", TooManyFunctionAssociations), ErrorAnnotation("TooManyHeadersInForwardedValues", TooManyHeadersInForwardedValues), ErrorAnnotation("TooManyKeyGroupsAssociatedToDistribution", TooManyKeyGroupsAssociatedToDistribution), ErrorAnnotation("TooManyLambdaFunctionAssociations", TooManyLambdaFunctionAssociations), ErrorAnnotation("TooManyOriginCustomHeaders", TooManyOriginCustomHeaders), ErrorAnnotation("TooManyOriginGroupsPerDistribution", TooManyOriginGroupsPerDistribution), ErrorAnnotation("TooManyOrigins", TooManyOrigins), ErrorAnnotation("TooManyQueryStringParameters", TooManyQueryStringParameters), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedKeyGroupDoesNotExist", TrustedKeyGroupDoesNotExist), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CopyDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution/{PrimaryDistributionId}/copy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CopyDistribution" }, CopyDistributionRequest, CopyDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("DistributionAlreadyExists", DistributionAlreadyExists), ErrorAnnotation("IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior", IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidDefaultRootObject", InvalidDefaultRootObject), ErrorAnnotation("InvalidErrorCode", InvalidErrorCode), ErrorAnnotation("InvalidForwardCookies", InvalidForwardCookies), ErrorAnnotation("InvalidFunctionAssociation", InvalidFunctionAssociation), ErrorAnnotation("InvalidGeoRestrictionParameter", InvalidGeoRestrictionParameter), ErrorAnnotation("InvalidHeadersForS3Origin", InvalidHeadersForS3Origin), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("InvalidLambdaFunctionAssociation", InvalidLambdaFunctionAssociation), ErrorAnnotation("InvalidLocationCode", InvalidLocationCode), ErrorAnnotation("InvalidMinimumProtocolVersion", InvalidMinimumProtocolVersion), ErrorAnnotation("InvalidOrigin", InvalidOrigin), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("InvalidOriginKeepaliveTimeout", InvalidOriginKeepaliveTimeout), ErrorAnnotation("InvalidOriginReadTimeout", InvalidOriginReadTimeout), ErrorAnnotation("InvalidProtocolSettings", InvalidProtocolSettings), ErrorAnnotation("InvalidQueryStringParameters", InvalidQueryStringParameters), ErrorAnnotation("InvalidRelativePath", InvalidRelativePath), ErrorAnnotation("InvalidRequiredProtocol", InvalidRequiredProtocol), ErrorAnnotation("InvalidResponseCode", InvalidResponseCode), ErrorAnnotation("InvalidTTLOrder", InvalidTTLOrder), ErrorAnnotation("InvalidViewerCertificate", InvalidViewerCertificate), ErrorAnnotation("InvalidWebACLId", InvalidWebACLId), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("NoSuchOrigin", NoSuchOrigin), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("RealtimeLogConfigOwnerMismatch", RealtimeLogConfigOwnerMismatch), ErrorAnnotation("TooManyCacheBehaviors", TooManyCacheBehaviors), ErrorAnnotation("TooManyCertificates", TooManyCertificates), ErrorAnnotation("TooManyCookieNamesInWhiteList", TooManyCookieNamesInWhiteList), ErrorAnnotation("TooManyDistributionCNAMEs", TooManyDistributionCNAMEs), ErrorAnnotation("TooManyDistributions", TooManyDistributions), ErrorAnnotation("TooManyDistributionsAssociatedToCachePolicy", TooManyDistributionsAssociatedToCachePolicy), ErrorAnnotation("TooManyDistributionsAssociatedToFieldLevelEncryptionConfig", TooManyDistributionsAssociatedToFieldLevelEncryptionConfig), ErrorAnnotation("TooManyDistributionsAssociatedToKeyGroup", TooManyDistributionsAssociatedToKeyGroup), ErrorAnnotation("TooManyDistributionsAssociatedToOriginAccessControl", TooManyDistributionsAssociatedToOriginAccessControl), ErrorAnnotation("TooManyDistributionsAssociatedToOriginRequestPolicy", TooManyDistributionsAssociatedToOriginRequestPolicy), ErrorAnnotation("TooManyDistributionsAssociatedToResponseHeadersPolicy", TooManyDistributionsAssociatedToResponseHeadersPolicy), ErrorAnnotation("TooManyDistributionsWithFunctionAssociations", TooManyDistributionsWithFunctionAssociations), ErrorAnnotation("TooManyDistributionsWithLambdaAssociations", TooManyDistributionsWithLambdaAssociations), ErrorAnnotation("TooManyDistributionsWithSingleFunctionARN", TooManyDistributionsWithSingleFunctionARN), ErrorAnnotation("TooManyFunctionAssociations", TooManyFunctionAssociations), ErrorAnnotation("TooManyHeadersInForwardedValues", TooManyHeadersInForwardedValues), ErrorAnnotation("TooManyKeyGroupsAssociatedToDistribution", TooManyKeyGroupsAssociatedToDistribution), ErrorAnnotation("TooManyLambdaFunctionAssociations", TooManyLambdaFunctionAssociations), ErrorAnnotation("TooManyOriginCustomHeaders", TooManyOriginCustomHeaders), ErrorAnnotation("TooManyOriginGroupsPerDistribution", TooManyOriginGroupsPerDistribution), ErrorAnnotation("TooManyOrigins", TooManyOrigins), ErrorAnnotation("TooManyQueryStringParameters", TooManyQueryStringParameters), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedKeyGroupDoesNotExist", TrustedKeyGroupDoesNotExist), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
export const CreateDistribution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2020-05-31", uri: "/2020-05-31/distribution", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "Cloudfront2020_05_31.CreateDistribution" }, CreateDistributionRequest, CreateDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("ContinuousDeploymentPolicyInUse", ContinuousDeploymentPolicyInUse), ErrorAnnotation("DistributionAlreadyExists", DistributionAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior", IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior), ErrorAnnotation("IllegalOriginAccessConfiguration", IllegalOriginAccessConfiguration), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidDefaultRootObject", InvalidDefaultRootObject), ErrorAnnotation("InvalidDomainNameForOriginAccessControl", InvalidDomainNameForOriginAccessControl), ErrorAnnotation("InvalidErrorCode", InvalidErrorCode), ErrorAnnotation("InvalidForwardCookies", InvalidForwardCookies), ErrorAnnotation("InvalidFunctionAssociation", InvalidFunctionAssociation), ErrorAnnotation("InvalidGeoRestrictionParameter", InvalidGeoRestrictionParameter), ErrorAnnotation("InvalidHeadersForS3Origin", InvalidHeadersForS3Origin), ErrorAnnotation("InvalidLambdaFunctionAssociation", InvalidLambdaFunctionAssociation), ErrorAnnotation("InvalidLocationCode", InvalidLocationCode), ErrorAnnotation("InvalidMinimumProtocolVersion", InvalidMinimumProtocolVersion), ErrorAnnotation("InvalidOrigin", InvalidOrigin), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("InvalidOriginKeepaliveTimeout", InvalidOriginKeepaliveTimeout), ErrorAnnotation("InvalidOriginReadTimeout", InvalidOriginReadTimeout), ErrorAnnotation("InvalidProtocolSettings", InvalidProtocolSettings), ErrorAnnotation("InvalidQueryStringParameters", InvalidQueryStringParameters), ErrorAnnotation("InvalidRelativePath", InvalidRelativePath), ErrorAnnotation("InvalidRequiredProtocol", InvalidRequiredProtocol), ErrorAnnotation("InvalidResponseCode", InvalidResponseCode), ErrorAnnotation("InvalidTTLOrder", InvalidTTLOrder), ErrorAnnotation("InvalidViewerCertificate", InvalidViewerCertificate), ErrorAnnotation("InvalidWebACLId", InvalidWebACLId), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("NoSuchOrigin", NoSuchOrigin), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("RealtimeLogConfigOwnerMismatch", RealtimeLogConfigOwnerMismatch), ErrorAnnotation("TooManyCacheBehaviors", TooManyCacheBehaviors), ErrorAnnotation("TooManyCertificates", TooManyCertificates), ErrorAnnotation("TooManyCookieNamesInWhiteList", TooManyCookieNamesInWhiteList), ErrorAnnotation("TooManyDistributionCNAMEs", TooManyDistributionCNAMEs), ErrorAnnotation("TooManyDistributions", TooManyDistributions), ErrorAnnotation("TooManyDistributionsAssociatedToCachePolicy", TooManyDistributionsAssociatedToCachePolicy), ErrorAnnotation("TooManyDistributionsAssociatedToFieldLevelEncryptionConfig", TooManyDistributionsAssociatedToFieldLevelEncryptionConfig), ErrorAnnotation("TooManyDistributionsAssociatedToKeyGroup", TooManyDistributionsAssociatedToKeyGroup), ErrorAnnotation("TooManyDistributionsAssociatedToOriginAccessControl", TooManyDistributionsAssociatedToOriginAccessControl), ErrorAnnotation("TooManyDistributionsAssociatedToOriginRequestPolicy", TooManyDistributionsAssociatedToOriginRequestPolicy), ErrorAnnotation("TooManyDistributionsAssociatedToResponseHeadersPolicy", TooManyDistributionsAssociatedToResponseHeadersPolicy), ErrorAnnotation("TooManyDistributionsWithFunctionAssociations", TooManyDistributionsWithFunctionAssociations), ErrorAnnotation("TooManyDistributionsWithLambdaAssociations", TooManyDistributionsWithLambdaAssociations), ErrorAnnotation("TooManyDistributionsWithSingleFunctionARN", TooManyDistributionsWithSingleFunctionARN), ErrorAnnotation("TooManyFunctionAssociations", TooManyFunctionAssociations), ErrorAnnotation("TooManyHeadersInForwardedValues", TooManyHeadersInForwardedValues), ErrorAnnotation("TooManyKeyGroupsAssociatedToDistribution", TooManyKeyGroupsAssociatedToDistribution), ErrorAnnotation("TooManyLambdaFunctionAssociations", TooManyLambdaFunctionAssociations), ErrorAnnotation("TooManyOriginCustomHeaders", TooManyOriginCustomHeaders), ErrorAnnotation("TooManyOriginGroupsPerDistribution", TooManyOriginGroupsPerDistribution), ErrorAnnotation("TooManyOrigins", TooManyOrigins), ErrorAnnotation("TooManyQueryStringParameters", TooManyQueryStringParameters), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedKeyGroupDoesNotExist", TrustedKeyGroupDoesNotExist), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatAwsXMLError);
