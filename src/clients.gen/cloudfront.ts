import { Schema} from "effect"
import { FormatXMLRequest, FormatXMLResponse, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
const FieldList = Schema.Array(Schema.String)
const AssociateAliasRequest = Schema.Struct({TargetDistributionId: Schema.String, Alias: Schema.String})
const AssociateDistributionTenantWebACLRequest = Schema.Struct({Id: Schema.String, WebACLArn: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const AssociateDistributionWebACLRequest = Schema.Struct({Id: Schema.String, WebACLArn: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const CopyDistributionRequest = Schema.Struct({PrimaryDistributionId: Schema.String, Staging: Schema.optional(Header("Staging", Schema.Boolean)), IfMatch: Schema.optional(Header("If-Match")), CallerReference: Schema.String, Enabled: Schema.optional(Schema.Boolean)})
const CreateConnectionGroupRequest = Schema.Struct({Name: Schema.String, Ipv6Enabled: Schema.optional(Schema.Boolean), Tags: Schema.optional(Tags), AnycastIpListId: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean)})
const CreateInvalidationForDistributionTenantRequest = Schema.Struct({Id: Schema.String, InvalidationBatch: Body("InvalidationBatch", InvalidationBatch)})
const DeleteAnycastIpListRequest = Schema.Struct({Id: Schema.String, IfMatch: Header("If-Match")})
const DeleteCachePolicyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const DeleteCloudFrontOriginAccessIdentityRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const DeleteConnectionGroupRequest = Schema.Struct({Id: Schema.String, IfMatch: Header("If-Match")})
const DeleteContinuousDeploymentPolicyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const DeleteDistributionRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const DeleteDistributionTenantRequest = Schema.Struct({Id: Schema.String, IfMatch: Header("If-Match")})
const DeleteFieldLevelEncryptionConfigRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const DeleteFieldLevelEncryptionProfileRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const DeleteFunctionRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match")})
const DeleteKeyGroupRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const DeleteKeyValueStoreRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match")})
const DeleteMonitoringSubscriptionRequest = Schema.Struct({DistributionId: Schema.String})
const DeleteMonitoringSubscriptionResult = Schema.Struct({})
const DeleteOriginAccessControlRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const DeleteOriginRequestPolicyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const DeletePublicKeyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const DeleteRealtimeLogConfigRequest = Schema.Struct({Name: Schema.optional(Schema.String), ARN: Schema.optional(Schema.String)})
const DeleteResourcePolicyRequest = Schema.Struct({ResourceArn: Schema.String})
const DeleteResponseHeadersPolicyRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const DeleteStreamingDistributionRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const DeleteVpcOriginRequest = Schema.Struct({Id: Schema.String, IfMatch: Header("If-Match")})
const DescribeFunctionRequest = Schema.Struct({Name: Schema.String, Stage: Schema.optional(Schema.String)})
const DescribeKeyValueStoreRequest = Schema.Struct({Name: Schema.String})
const DisassociateDistributionTenantWebACLRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const DisassociateDistributionWebACLRequest = Schema.Struct({Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const GetAnycastIpListRequest = Schema.Struct({Id: Schema.String})
const GetCachePolicyRequest = Schema.Struct({Id: Schema.String})
const GetCachePolicyConfigRequest = Schema.Struct({Id: Schema.String})
const GetCloudFrontOriginAccessIdentityRequest = Schema.Struct({Id: Schema.String})
const GetCloudFrontOriginAccessIdentityConfigRequest = Schema.Struct({Id: Schema.String})
const GetConnectionGroupRequest = Schema.Struct({Identifier: Schema.String})
const GetConnectionGroupByRoutingEndpointRequest = Schema.Struct({RoutingEndpoint: Schema.String})
const GetContinuousDeploymentPolicyRequest = Schema.Struct({Id: Schema.String})
const GetContinuousDeploymentPolicyConfigRequest = Schema.Struct({Id: Schema.String})
const GetDistributionRequest = Schema.Struct({Id: Schema.String})
const GetDistributionConfigRequest = Schema.Struct({Id: Schema.String})
const GetDistributionTenantRequest = Schema.Struct({Identifier: Schema.String})
const GetDistributionTenantByDomainRequest = Schema.Struct({Domain: Schema.String})
const GetFieldLevelEncryptionRequest = Schema.Struct({Id: Schema.String})
const GetFieldLevelEncryptionConfigRequest = Schema.Struct({Id: Schema.String})
const GetFieldLevelEncryptionProfileRequest = Schema.Struct({Id: Schema.String})
const GetFieldLevelEncryptionProfileConfigRequest = Schema.Struct({Id: Schema.String})
const GetFunctionRequest = Schema.Struct({Name: Schema.String, Stage: Schema.optional(Schema.String)})
const GetInvalidationRequest = Schema.Struct({DistributionId: Schema.String, Id: Schema.String})
const GetInvalidationForDistributionTenantRequest = Schema.Struct({DistributionTenantId: Schema.String, Id: Schema.String})
const GetKeyGroupRequest = Schema.Struct({Id: Schema.String})
const GetKeyGroupConfigRequest = Schema.Struct({Id: Schema.String})
const GetManagedCertificateDetailsRequest = Schema.Struct({Identifier: Schema.String})
const GetMonitoringSubscriptionRequest = Schema.Struct({DistributionId: Schema.String})
const GetOriginAccessControlRequest = Schema.Struct({Id: Schema.String})
const GetOriginAccessControlConfigRequest = Schema.Struct({Id: Schema.String})
const GetOriginRequestPolicyRequest = Schema.Struct({Id: Schema.String})
const GetOriginRequestPolicyConfigRequest = Schema.Struct({Id: Schema.String})
const GetPublicKeyRequest = Schema.Struct({Id: Schema.String})
const GetPublicKeyConfigRequest = Schema.Struct({Id: Schema.String})
const GetRealtimeLogConfigRequest = Schema.Struct({Name: Schema.optional(Schema.String), ARN: Schema.optional(Schema.String)})
const GetResourcePolicyRequest = Schema.Struct({ResourceArn: Schema.String})
const GetResponseHeadersPolicyRequest = Schema.Struct({Id: Schema.String})
const GetResponseHeadersPolicyConfigRequest = Schema.Struct({Id: Schema.String})
const GetStreamingDistributionRequest = Schema.Struct({Id: Schema.String})
const GetStreamingDistributionConfigRequest = Schema.Struct({Id: Schema.String})
const GetVpcOriginRequest = Schema.Struct({Id: Schema.String})
const ListAnycastIpListsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListCachePoliciesRequest = Schema.Struct({Type: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListCloudFrontOriginAccessIdentitiesRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListConflictingAliasesRequest = Schema.Struct({DistributionId: Schema.String, Alias: Schema.String, Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListContinuousDeploymentPoliciesRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListDistributionsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListDistributionsByAnycastIpListIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), AnycastIpListId: Schema.String})
const ListDistributionsByCachePolicyIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), CachePolicyId: Schema.String})
const ListDistributionsByConnectionModeRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), ConnectionMode: Schema.String})
const ListDistributionsByKeyGroupRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), KeyGroupId: Schema.String})
const ListDistributionsByOriginRequestPolicyIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), OriginRequestPolicyId: Schema.String})
const ListDistributionsByOwnedResourceRequest = Schema.Struct({ResourceArn: Schema.String, Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListDistributionsByRealtimeLogConfigRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), RealtimeLogConfigName: Schema.optional(Schema.String), RealtimeLogConfigArn: Schema.optional(Schema.String)})
const ListDistributionsByResponseHeadersPolicyIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), ResponseHeadersPolicyId: Schema.String})
const ListDistributionsByVpcOriginIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), VpcOriginId: Schema.String})
const ListDistributionsByWebACLIdRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), WebACLId: Schema.String})
const ListDistributionTenantsByCustomizationRequest = Schema.Struct({WebACLArn: Schema.optional(Schema.String), CertificateArn: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListFieldLevelEncryptionConfigsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListFieldLevelEncryptionProfilesRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListFunctionsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), Stage: Schema.optional(Schema.String)})
const ListInvalidationsRequest = Schema.Struct({DistributionId: Schema.String, Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListInvalidationsForDistributionTenantRequest = Schema.Struct({Id: Schema.String, Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListKeyGroupsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListKeyValueStoresRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), Status: Schema.optional(Schema.String)})
const ListOriginAccessControlsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListOriginRequestPoliciesRequest = Schema.Struct({Type: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListPublicKeysRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListRealtimeLogConfigsRequest = Schema.Struct({MaxItems: Schema.optional(Schema.Number), Marker: Schema.optional(Schema.String)})
const ListResponseHeadersPoliciesRequest = Schema.Struct({Type: Schema.optional(Schema.String), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListStreamingDistributionsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListTagsForResourceRequest = Schema.Struct({Resource: Schema.String})
const ListVpcOriginsRequest = Schema.Struct({Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const PublishFunctionRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match")})
const PutResourcePolicyRequest = Schema.Struct({ResourceArn: Schema.String, PolicyDocument: Schema.String})
const TagResourceRequest = Schema.Struct({Resource: Schema.String, Tags: Body("Tags", Tags)})
const TestFunctionRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match"), Stage: Schema.optional(Schema.String), EventObject: StreamBody()})
const UpdateAnycastIpListRequest = Schema.Struct({Id: Schema.String, IpAddressType: Schema.optional(Schema.String), IfMatch: Header("If-Match")})
const UpdateCachePolicyRequest = Schema.Struct({CachePolicyConfig: Body("CachePolicyConfig", CachePolicyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const UpdateCloudFrontOriginAccessIdentityRequest = Schema.Struct({CloudFrontOriginAccessIdentityConfig: Body("CloudFrontOriginAccessIdentityConfig", CloudFrontOriginAccessIdentityConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const UpdateConnectionGroupRequest = Schema.Struct({Id: Schema.String, Ipv6Enabled: Schema.optional(Schema.Boolean), IfMatch: Header("If-Match"), AnycastIpListId: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean)})
const UpdateContinuousDeploymentPolicyRequest = Schema.Struct({ContinuousDeploymentPolicyConfig: Body("ContinuousDeploymentPolicyConfig", ContinuousDeploymentPolicyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const UpdateDistributionRequest = Schema.Struct({DistributionConfig: Body("DistributionConfig", DistributionConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const UpdateDistributionTenantRequest = Schema.Struct({Id: Schema.String, DistributionId: Schema.optional(Schema.String), Domains: Schema.optional(DomainList), Customizations: Schema.optional(Customizations), Parameters: Schema.optional(Parameters), ConnectionGroupId: Schema.optional(Schema.String), IfMatch: Header("If-Match"), ManagedCertificateRequest: Schema.optional(ManagedCertificateRequest), Enabled: Schema.optional(Schema.Boolean)})
const UpdateDistributionWithStagingConfigRequest = Schema.Struct({Id: Schema.String, StagingDistributionId: Schema.optional(Schema.String), IfMatch: Schema.optional(Header("If-Match"))})
const UpdateDomainAssociationRequest = Schema.Struct({Domain: Schema.String, TargetResource: DistributionResourceId, IfMatch: Schema.optional(Header("If-Match"))})
const UpdateFieldLevelEncryptionConfigRequest = Schema.Struct({FieldLevelEncryptionConfig: Body("FieldLevelEncryptionConfig", FieldLevelEncryptionConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const UpdateFieldLevelEncryptionProfileRequest = Schema.Struct({FieldLevelEncryptionProfileConfig: Body("FieldLevelEncryptionProfileConfig", FieldLevelEncryptionProfileConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const UpdateFunctionRequest = Schema.Struct({Name: Schema.String, IfMatch: Header("If-Match"), FunctionConfig: FunctionConfig, FunctionCode: StreamBody()})
const UpdateKeyGroupRequest = Schema.Struct({KeyGroupConfig: Body("KeyGroupConfig", KeyGroupConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const UpdateKeyValueStoreRequest = Schema.Struct({Name: Schema.String, Comment: Schema.String, IfMatch: Header("If-Match")})
const UpdateOriginAccessControlRequest = Schema.Struct({OriginAccessControlConfig: Body("OriginAccessControlConfig", OriginAccessControlConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const UpdateOriginRequestPolicyRequest = Schema.Struct({OriginRequestPolicyConfig: Body("OriginRequestPolicyConfig", OriginRequestPolicyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const UpdatePublicKeyRequest = Schema.Struct({PublicKeyConfig: Body("PublicKeyConfig", PublicKeyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const UpdateRealtimeLogConfigRequest = Schema.Struct({EndPoints: Schema.optional(EndPointList), Fields: Schema.optional(FieldList), Name: Schema.optional(Schema.String), ARN: Schema.optional(Schema.String), SamplingRate: Schema.optional(Schema.Number)})
const UpdateResponseHeadersPolicyRequest = Schema.Struct({ResponseHeadersPolicyConfig: Body("ResponseHeadersPolicyConfig", ResponseHeadersPolicyConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const UpdateStreamingDistributionRequest = Schema.Struct({StreamingDistributionConfig: Body("StreamingDistributionConfig", StreamingDistributionConfig), Id: Schema.String, IfMatch: Schema.optional(Header("If-Match"))})
const UpdateVpcOriginRequest = Schema.Struct({VpcOriginEndpointConfig: Body("VpcOriginEndpointConfig", VpcOriginEndpointConfig), Id: Schema.String, IfMatch: Header("If-Match")})
const VerifyDnsConfigurationRequest = Schema.Struct({Domain: Schema.optional(Schema.String), Identifier: Schema.String})
const PublicKeyIdList = Schema.Array(Schema.String)
const TagKeyList = Schema.Array(Schema.String)
const CloudFrontOriginAccessIdentityConfig = Schema.Struct({CallerReference: Schema.String, Comment: Schema.String})
const DomainItem = Schema.Struct({Domain: Schema.String})
const DomainList = Schema.Array(DomainItem)
const Parameter = Schema.Struct({Name: Schema.String, Value: Schema.String})
const Parameters = Schema.Array(Parameter)
const ManagedCertificateRequest = Schema.Struct({ValidationTokenHost: Schema.String, PrimaryDomainName: Schema.optional(Schema.String), CertificateTransparencyLoggingPreference: Schema.optional(Schema.String)})
const DistributionConfigWithTags = Schema.Struct({DistributionConfig: DistributionConfig, Tags: Tags})
const KeyGroupConfig = Schema.Struct({Name: Schema.String, Items: PublicKeyIdList, Comment: Schema.optional(Schema.String)})
const ImportSource = Schema.Struct({SourceType: Schema.String, SourceARN: Schema.String})
const OriginAccessControlConfig = Schema.Struct({Name: Schema.String, Description: Schema.optional(Schema.String), SigningProtocol: Schema.String, SigningBehavior: Schema.String, OriginAccessControlOriginType: Schema.String})
const PublicKeyConfig = Schema.Struct({CallerReference: Schema.String, Name: Schema.String, EncodedKey: Schema.String, Comment: Schema.optional(Schema.String)})
const StreamingDistributionConfigWithTags = Schema.Struct({StreamingDistributionConfig: StreamingDistributionConfig, Tags: Tags})
const ConnectionGroupAssociationFilter = Schema.Struct({AnycastIpListId: Schema.optional(Schema.String)})
const DistributionTenantAssociationFilter = Schema.Struct({DistributionId: Schema.optional(Schema.String), ConnectionGroupId: Schema.optional(Schema.String)})
const DistributionResourceId = Schema.Struct({DistributionId: Schema.optional(Schema.String), DistributionTenantId: Schema.optional(Schema.String)})
const TagKeys = Schema.Struct({Items: Schema.optional(TagKeyList)})
const StagingDistributionDnsNameList = Schema.Array(Schema.String)
const AliasList = Schema.Array(Schema.String)
const LocationList = Schema.Array(Schema.String)
const PathList = Schema.Array(Schema.String)
const AwsAccountNumberList = Schema.Array(Schema.String)
const SslProtocolsList = Schema.Array(Schema.String)
const AccessDenied = Schema.Struct({Message: Schema.optional(Schema.String)})
const AssociateDistributionTenantWebACLResult = Schema.Struct({Id: Schema.optional(Schema.String), WebACLArn: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))})
export const AssociateDistributionTenantWebACL = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution-tenant/{Id}/associate-web-acl", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "AssociateDistributionTenantWebACL" }, AssociateDistributionTenantWebACLRequest, AssociateDistributionTenantWebACLResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const AssociateDistributionWebACLResult = Schema.Struct({Id: Schema.optional(Schema.String), WebACLArn: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))})
export const AssociateDistributionWebACL = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution/{Id}/associate-web-acl", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "AssociateDistributionWebACL" }, AssociateDistributionWebACLRequest, AssociateDistributionWebACLResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateCloudFrontOriginAccessIdentityRequest = Schema.Struct({CloudFrontOriginAccessIdentityConfig: Body("CloudFrontOriginAccessIdentityConfig", CloudFrontOriginAccessIdentityConfig)})
const CreateDistributionWithTagsRequest = Schema.Struct({DistributionConfigWithTags: Body("DistributionConfigWithTags", DistributionConfigWithTags)})
const CreateKeyGroupRequest = Schema.Struct({KeyGroupConfig: Body("KeyGroupConfig", KeyGroupConfig)})
const CreateKeyValueStoreRequest = Schema.Struct({Name: Schema.String, Comment: Schema.optional(Schema.String), ImportSource: Schema.optional(ImportSource)})
const CreateOriginAccessControlRequest = Schema.Struct({OriginAccessControlConfig: Body("OriginAccessControlConfig", OriginAccessControlConfig)})
const CreatePublicKeyRequest = Schema.Struct({PublicKeyConfig: Body("PublicKeyConfig", PublicKeyConfig)})
const CreateStreamingDistributionWithTagsRequest = Schema.Struct({StreamingDistributionConfigWithTags: Body("StreamingDistributionConfigWithTags", StreamingDistributionConfigWithTags)})
const CannotDeleteEntityWhileInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteAnycastIpList = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/anycast-ip-list/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteAnycastIpList" }, DeleteAnycastIpListRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CannotDeleteEntityWhileInUse", CannotDeleteEntityWhileInUse), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalDelete", IllegalDelete), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CachePolicyInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
const CloudFrontOriginAccessIdentityInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
const EntityNotFound = Schema.Struct({Message: Schema.optional(Schema.String)})
const ContinuousDeploymentPolicyInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
const DistributionNotDisabled = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidIfMatchVersion = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution-tenant/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteDistributionTenant" }, DeleteDistributionTenantRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResourceNotDisabled", ResourceNotDisabled))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const FieldLevelEncryptionConfigInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
const FieldLevelEncryptionProfileInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
const FunctionInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
const NoSuchResource = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/key-group/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteKeyGroup" }, DeleteKeyGroupRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchResource", NoSuchResource), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResourceInUse", ResourceInUse))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PreconditionFailed = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteKeyValueStore = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/key-value-store/{Name}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteKeyValueStore" }, DeleteKeyValueStoreRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CannotDeleteEntityWhileInUse", CannotDeleteEntityWhileInUse), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NoSuchDistribution = Schema.Struct({Message: Schema.optional(Schema.String)})
const NoSuchOriginAccessControl = Schema.Struct({Message: Schema.optional(Schema.String)})
const IllegalDelete = Schema.Struct({Message: Schema.optional(Schema.String)})
const NoSuchPublicKey = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidArgument = Schema.Struct({Message: Schema.optional(Schema.String)})
const UnsupportedOperation = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/delete-resource-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteResourcePolicy" }, DeleteResourcePolicyRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalDelete", IllegalDelete), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NoSuchResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
const NoSuchStreamingDistribution = Schema.Struct({Message: Schema.optional(Schema.String)})
const DisassociateDistributionTenantWebACLResult = Schema.Struct({Id: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))})
export const DisassociateDistributionTenantWebACL = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution-tenant/{Id}/disassociate-web-acl", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DisassociateDistributionTenantWebACL" }, DisassociateDistributionTenantWebACLRequest, DisassociateDistributionTenantWebACLResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DisassociateDistributionWebACLResult = Schema.Struct({Id: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))})
export const DisassociateDistributionWebACL = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution/{Id}/disassociate-web-acl", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DisassociateDistributionWebACL" }, DisassociateDistributionWebACLRequest, DisassociateDistributionWebACLResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetCachePolicyConfigResult = Schema.Struct({CachePolicyConfig: Schema.optional(Body("undefined", CachePolicyConfig)), ETag: Schema.optional(Header("ETag"))})
export const GetCachePolicyConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/cache-policy/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetCachePolicyConfig" }, GetCachePolicyConfigRequest, GetCachePolicyConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetCloudFrontOriginAccessIdentityConfigResult = Schema.Struct({CloudFrontOriginAccessIdentityConfig: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentityConfig)), ETag: Schema.optional(Header("ETag"))})
export const GetCloudFrontOriginAccessIdentityConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-access-identity/cloudfront/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetCloudFrontOriginAccessIdentityConfig" }, GetCloudFrontOriginAccessIdentityConfigRequest, GetCloudFrontOriginAccessIdentityConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchCloudFrontOriginAccessIdentity", NoSuchCloudFrontOriginAccessIdentity))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetConnectionGroupResult = Schema.Struct({ConnectionGroup: Schema.optional(Body("undefined", ConnectionGroup)), ETag: Schema.optional(Header("ETag"))})
export const GetConnectionGroup = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/connection-group/{Identifier}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetConnectionGroup" }, GetConnectionGroupRequest, GetConnectionGroupResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetConnectionGroupByRoutingEndpointResult = Schema.Struct({ConnectionGroup: Schema.optional(Body("undefined", ConnectionGroup)), ETag: Schema.optional(Header("ETag"))})
export const GetConnectionGroupByRoutingEndpoint = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/connection-group", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetConnectionGroupByRoutingEndpoint" }, GetConnectionGroupByRoutingEndpointRequest, GetConnectionGroupByRoutingEndpointResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetContinuousDeploymentPolicyConfigResult = Schema.Struct({ContinuousDeploymentPolicyConfig: Schema.optional(Body("undefined", ContinuousDeploymentPolicyConfig)), ETag: Schema.optional(Header("ETag"))})
export const GetContinuousDeploymentPolicyConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/continuous-deployment-policy/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetContinuousDeploymentPolicyConfig" }, GetContinuousDeploymentPolicyConfigRequest, GetContinuousDeploymentPolicyConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetDistributionResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), ETag: Schema.optional(Header("ETag"))})
export const GetDistribution = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetDistribution" }, GetDistributionRequest, GetDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetDistributionConfigResult = Schema.Struct({DistributionConfig: Schema.optional(Body("undefined", DistributionConfig)), ETag: Schema.optional(Header("ETag"))})
export const GetDistributionConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetDistributionConfig" }, GetDistributionConfigRequest, GetDistributionConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetDistributionTenantByDomainResult = Schema.Struct({DistributionTenant: Schema.optional(Body("undefined", DistributionTenant)), ETag: Schema.optional(Header("ETag"))})
export const GetDistributionTenantByDomain = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution-tenant", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetDistributionTenantByDomain" }, GetDistributionTenantByDomainRequest, GetDistributionTenantByDomainResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetFieldLevelEncryptionConfigResult = Schema.Struct({FieldLevelEncryptionConfig: Schema.optional(Body("undefined", FieldLevelEncryptionConfig)), ETag: Schema.optional(Header("ETag"))})
export const GetFieldLevelEncryptionConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/field-level-encryption/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetFieldLevelEncryptionConfig" }, GetFieldLevelEncryptionConfigRequest, GetFieldLevelEncryptionConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetFieldLevelEncryptionProfileConfigResult = Schema.Struct({FieldLevelEncryptionProfileConfig: Schema.optional(Body("undefined", FieldLevelEncryptionProfileConfig)), ETag: Schema.optional(Header("ETag"))})
export const GetFieldLevelEncryptionProfileConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/field-level-encryption-profile/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetFieldLevelEncryptionProfileConfig" }, GetFieldLevelEncryptionProfileConfigRequest, GetFieldLevelEncryptionProfileConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchFieldLevelEncryptionProfile", NoSuchFieldLevelEncryptionProfile))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetFunctionResult = Schema.Struct({FunctionCode: Schema.optional(Body("undefined", StreamBody())), ETag: Schema.optional(Header("ETag")), ContentType: Schema.optional(Header("Content-Type"))})
export const GetFunction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/function/{Name}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetFunction" }, GetFunctionRequest, GetFunctionResult, Schema.Union(ErrorAnnotation("NoSuchFunctionExists", NoSuchFunctionExists), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetInvalidationResult = Schema.Struct({Invalidation: Schema.optional(Body("undefined", Invalidation))})
const GetInvalidationForDistributionTenantResult = Schema.Struct({Invalidation: Schema.optional(Body("undefined", Invalidation))})
export const GetInvalidationForDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution-tenant/{DistributionTenantId}/invalidation/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetInvalidationForDistributionTenant" }, GetInvalidationForDistributionTenantRequest, GetInvalidationForDistributionTenantResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("NoSuchInvalidation", NoSuchInvalidation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetKeyGroupConfigResult = Schema.Struct({KeyGroupConfig: Schema.optional(Body("undefined", KeyGroupConfig)), ETag: Schema.optional(Header("ETag"))})
export const GetKeyGroupConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/key-group/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetKeyGroupConfig" }, GetKeyGroupConfigRequest, GetKeyGroupConfigResult, ErrorAnnotation("NoSuchResource", NoSuchResource)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetMonitoringSubscriptionResult = Schema.Struct({MonitoringSubscription: Schema.optional(Body("undefined", MonitoringSubscription))})
export const GetMonitoringSubscription = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distributions/{DistributionId}/monitoring-subscription", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetMonitoringSubscription" }, GetMonitoringSubscriptionRequest, GetMonitoringSubscriptionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("NoSuchMonitoringSubscription", NoSuchMonitoringSubscription), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetOriginAccessControlConfigResult = Schema.Struct({OriginAccessControlConfig: Schema.optional(Body("undefined", OriginAccessControlConfig)), ETag: Schema.optional(Header("ETag"))})
export const GetOriginAccessControlConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-access-control/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetOriginAccessControlConfig" }, GetOriginAccessControlConfigRequest, GetOriginAccessControlConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchOriginAccessControl", NoSuchOriginAccessControl))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetOriginRequestPolicyConfigResult = Schema.Struct({OriginRequestPolicyConfig: Schema.optional(Body("undefined", OriginRequestPolicyConfig)), ETag: Schema.optional(Header("ETag"))})
export const GetOriginRequestPolicyConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-request-policy/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetOriginRequestPolicyConfig" }, GetOriginRequestPolicyConfigRequest, GetOriginRequestPolicyConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetPublicKeyConfigResult = Schema.Struct({PublicKeyConfig: Schema.optional(Body("undefined", PublicKeyConfig)), ETag: Schema.optional(Header("ETag"))})
export const GetPublicKeyConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/public-key/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetPublicKeyConfig" }, GetPublicKeyConfigRequest, GetPublicKeyConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchPublicKey", NoSuchPublicKey))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetResourcePolicyResult = Schema.Struct({ResourceArn: Schema.optional(Schema.String), PolicyDocument: Schema.optional(Schema.String)})
export const GetResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/get-resource-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetResourcePolicy" }, GetResourcePolicyRequest, GetResourcePolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetResponseHeadersPolicyConfigResult = Schema.Struct({ResponseHeadersPolicyConfig: Schema.optional(Body("undefined", ResponseHeadersPolicyConfig)), ETag: Schema.optional(Header("ETag"))})
export const GetResponseHeadersPolicyConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/response-headers-policy/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetResponseHeadersPolicyConfig" }, GetResponseHeadersPolicyConfigRequest, GetResponseHeadersPolicyConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetStreamingDistributionConfigResult = Schema.Struct({StreamingDistributionConfig: Schema.optional(Body("undefined", StreamingDistributionConfig)), ETag: Schema.optional(Header("ETag"))})
export const GetStreamingDistributionConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/streaming-distribution/{Id}/config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetStreamingDistributionConfig" }, GetStreamingDistributionConfigRequest, GetStreamingDistributionConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchStreamingDistribution", NoSuchStreamingDistribution))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetVpcOriginResult = Schema.Struct({VpcOrigin: Schema.optional(Body("undefined", VpcOrigin)), ETag: Schema.optional(Header("ETag"))})
export const GetVpcOrigin = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/vpc-origin/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetVpcOrigin" }, GetVpcOriginRequest, GetVpcOriginResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListConnectionGroupsRequest = Schema.Struct({AssociationFilter: Schema.optional(ConnectionGroupAssociationFilter), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListDistributionsByAnycastIpListIdResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))})
export const ListDistributionsByAnycastIpListId = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distributionsByAnycastIpListId/{AnycastIpListId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDistributionsByAnycastIpListId" }, ListDistributionsByAnycastIpListIdRequest, ListDistributionsByAnycastIpListIdResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDistributionsByConnectionModeResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))})
export const ListDistributionsByConnectionMode = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distributionsByConnectionMode/{ConnectionMode}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDistributionsByConnectionMode" }, ListDistributionsByConnectionModeRequest, ListDistributionsByConnectionModeResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDistributionsByKeyGroupResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))})
export const ListDistributionsByKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distributionsByKeyGroupId/{KeyGroupId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDistributionsByKeyGroup" }, ListDistributionsByKeyGroupRequest, ListDistributionsByKeyGroupResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchResource", NoSuchResource))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDistributionsByOriginRequestPolicyIdResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))})
export const ListDistributionsByOriginRequestPolicyId = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distributionsByOriginRequestPolicyId/{OriginRequestPolicyId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDistributionsByOriginRequestPolicyId" }, ListDistributionsByOriginRequestPolicyIdRequest, ListDistributionsByOriginRequestPolicyIdResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDistributionsByRealtimeLogConfigResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))})
export const ListDistributionsByRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distributionsByRealtimeLogConfig", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDistributionsByRealtimeLogConfig" }, ListDistributionsByRealtimeLogConfigRequest, ListDistributionsByRealtimeLogConfigResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDistributionsByResponseHeadersPolicyIdResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))})
export const ListDistributionsByResponseHeadersPolicyId = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distributionsByResponseHeadersPolicyId/{ResponseHeadersPolicyId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDistributionsByResponseHeadersPolicyId" }, ListDistributionsByResponseHeadersPolicyIdRequest, ListDistributionsByResponseHeadersPolicyIdResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDistributionsByVpcOriginIdResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))})
export const ListDistributionsByVpcOriginId = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distributionsByVpcOriginId/{VpcOriginId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDistributionsByVpcOriginId" }, ListDistributionsByVpcOriginIdRequest, ListDistributionsByVpcOriginIdResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDistributionsByWebACLIdResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))})
const ListDistributionTenantsRequest = Schema.Struct({AssociationFilter: Schema.optional(DistributionTenantAssociationFilter), Marker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number)})
const ListDomainConflictsRequest = Schema.Struct({Domain: Schema.String, DomainControlValidationResource: DistributionResourceId, MaxItems: Schema.optional(Schema.Number), Marker: Schema.optional(Schema.String)})
const ListInvalidationsForDistributionTenantResult = Schema.Struct({InvalidationList: Schema.optional(Body("undefined", InvalidationList))})
export const ListInvalidationsForDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution-tenant/{Id}/invalidation", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListInvalidationsForDistributionTenant" }, ListInvalidationsForDistributionTenantRequest, ListInvalidationsForDistributionTenantResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListTagsForResourceResult = Schema.Struct({Tags: Body("undefined", Tags)})
export const ListTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/tagging", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("NoSuchResource", NoSuchResource))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PublishFunctionResult = Schema.Struct({FunctionSummary: Schema.optional(Body("undefined", FunctionSummary))})
export const PublishFunction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/function/{Name}/publish", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "PublishFunction" }, PublishFunctionRequest, PublishFunctionResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFunctionExists", NoSuchFunctionExists), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const PutResourcePolicyResult = Schema.Struct({ResourceArn: Schema.optional(Schema.String)})
export const PutResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/put-resource-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "PutResourcePolicy" }, PutResourcePolicyRequest, PutResourcePolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidTagging = Schema.Struct({Message: Schema.optional(Schema.String)})
export const TagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/tagging?Operation=Tag", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "TagResource" }, TagResourceRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("NoSuchResource", NoSuchResource))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UntagResourceRequest = Schema.Struct({Resource: Schema.String, TagKeys: Body("TagKeys", TagKeys)})
export const UntagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/tagging?Operation=Untag", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UntagResource" }, UntagResourceRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("NoSuchResource", NoSuchResource))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateAnycastIpListResult = Schema.Struct({AnycastIpList: Schema.optional(Body("undefined", AnycastIpList)), ETag: Schema.optional(Header("ETag"))})
export const UpdateAnycastIpList = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/anycast-ip-list/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateAnycastIpList" }, UpdateAnycastIpListRequest, UpdateAnycastIpListResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateCachePolicyResult = Schema.Struct({CachePolicy: Schema.optional(Body("undefined", CachePolicy)), ETag: Schema.optional(Header("ETag"))})
const UpdateCloudFrontOriginAccessIdentityResult = Schema.Struct({CloudFrontOriginAccessIdentity: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentity)), ETag: Schema.optional(Header("ETag"))})
const UpdateConnectionGroupResult = Schema.Struct({ConnectionGroup: Schema.optional(Body("undefined", ConnectionGroup)), ETag: Schema.optional(Header("ETag"))})
const UpdateContinuousDeploymentPolicyResult = Schema.Struct({ContinuousDeploymentPolicy: Schema.optional(Body("undefined", ContinuousDeploymentPolicy)), ETag: Schema.optional(Header("ETag"))})
const UpdateDistributionResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), ETag: Schema.optional(Header("ETag"))})
const UpdateDistributionTenantResult = Schema.Struct({DistributionTenant: Schema.optional(Body("undefined", DistributionTenant)), ETag: Schema.optional(Header("ETag"))})
const UpdateDistributionWithStagingConfigResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), ETag: Schema.optional(Header("ETag"))})
const UpdateDomainAssociationResult = Schema.Struct({Domain: Schema.optional(Schema.String), ResourceId: Schema.optional(Schema.String), ETag: Schema.optional(Header("ETag"))})
export const UpdateDomainAssociation = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/domain-association", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateDomainAssociation" }, UpdateDomainAssociationRequest, UpdateDomainAssociationResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateFieldLevelEncryptionConfigResult = Schema.Struct({FieldLevelEncryption: Schema.optional(Body("undefined", FieldLevelEncryption)), ETag: Schema.optional(Header("ETag"))})
const UpdateFieldLevelEncryptionProfileResult = Schema.Struct({FieldLevelEncryptionProfile: Schema.optional(Body("undefined", FieldLevelEncryptionProfile)), ETag: Schema.optional(Header("ETag"))})
const UpdateFunctionResult = Schema.Struct({FunctionSummary: Schema.optional(Body("undefined", FunctionSummary)), ETag: Schema.optional(Header("ETtag"))})
const UpdateKeyGroupResult = Schema.Struct({KeyGroup: Schema.optional(Body("undefined", KeyGroup)), ETag: Schema.optional(Header("ETag"))})
const UpdateKeyValueStoreResult = Schema.Struct({KeyValueStore: Schema.optional(Body("undefined", KeyValueStore)), ETag: Schema.optional(Header("ETag"))})
export const UpdateKeyValueStore = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/key-value-store/{Name}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateKeyValueStore" }, UpdateKeyValueStoreRequest, UpdateKeyValueStoreResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateOriginAccessControlResult = Schema.Struct({OriginAccessControl: Schema.optional(Body("undefined", OriginAccessControl)), ETag: Schema.optional(Header("ETag"))})
const UpdateOriginRequestPolicyResult = Schema.Struct({OriginRequestPolicy: Schema.optional(Body("undefined", OriginRequestPolicy)), ETag: Schema.optional(Header("ETag"))})
const UpdatePublicKeyResult = Schema.Struct({PublicKey: Schema.optional(Body("undefined", PublicKey)), ETag: Schema.optional(Header("ETag"))})
const UpdateRealtimeLogConfigResult = Schema.Struct({RealtimeLogConfig: Schema.optional(RealtimeLogConfig)})
export const UpdateRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/realtime-log-config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateRealtimeLogConfig" }, UpdateRealtimeLogConfigRequest, UpdateRealtimeLogConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const UpdateResponseHeadersPolicyResult = Schema.Struct({ResponseHeadersPolicy: Schema.optional(Body("undefined", ResponseHeadersPolicy)), ETag: Schema.optional(Header("ETag"))})
const UpdateStreamingDistributionResult = Schema.Struct({StreamingDistribution: Schema.optional(Body("undefined", StreamingDistribution)), ETag: Schema.optional(Header("ETag"))})
const UpdateVpcOriginResult = Schema.Struct({VpcOrigin: Schema.optional(Body("undefined", VpcOrigin)), ETag: Schema.optional(Header("ETag"))})
const Tag = Schema.Struct({Key: Schema.String, Value: Schema.optional(Schema.String)})
const TagList = Schema.Array(Tag)
const StagingDistributionDnsNames = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(StagingDistributionDnsNameList)})
const Aliases = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(AliasList)})
const LoggingConfig = Schema.Struct({Enabled: Schema.optional(Schema.Boolean), IncludeCookies: Schema.optional(Schema.Boolean), Bucket: Schema.optional(Schema.String), Prefix: Schema.optional(Schema.String)})
const ViewerCertificate = Schema.Struct({CloudFrontDefaultCertificate: Schema.optional(Schema.Boolean), IAMCertificateId: Schema.optional(Schema.String), ACMCertificateArn: Schema.optional(Schema.String), SSLSupportMethod: Schema.optional(Schema.String), MinimumProtocolVersion: Schema.optional(Schema.String), Certificate: Schema.optional(Schema.String), CertificateSource: Schema.optional(Schema.String)})
const WebAclCustomization = Schema.Struct({Action: Schema.String, Arn: Schema.optional(Schema.String)})
const Certificate = Schema.Struct({Arn: Schema.String})
const GeoRestrictionCustomization = Schema.Struct({RestrictionType: Schema.String, Locations: Schema.optional(LocationList)})
const Paths = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(PathList)})
const RealtimeMetricsSubscriptionConfig = Schema.Struct({RealtimeMetricsSubscriptionStatus: Schema.String})
const KinesisStreamConfig = Schema.Struct({RoleARN: Schema.String, StreamARN: Schema.String})
const ResponseHeadersPolicyServerTimingHeadersConfig = Schema.Struct({Enabled: Schema.Boolean, SamplingRate: Schema.optional(Schema.Number)})
const S3Origin = Schema.Struct({DomainName: Schema.String, OriginAccessIdentity: Schema.String})
const StreamingLoggingConfig = Schema.Struct({Enabled: Schema.Boolean, Bucket: Schema.String, Prefix: Schema.String})
const TrustedSigners = Schema.Struct({Enabled: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(AwsAccountNumberList)})
const OriginSslProtocols = Schema.Struct({Quantity: Schema.Number, Items: SslProtocolsList})
const AnycastIps = Schema.Array(Schema.String)
const DistributionIdListSummary = Schema.Array(Schema.String)
const FunctionSummaryList = Schema.Array(FunctionSummary)
const KeyValueStoreSummaryList = Schema.Array(KeyValueStore)
const RealtimeLogConfigList = Schema.Array(RealtimeLogConfig)
const FunctionExecutionLogList = Schema.Array(Schema.String)
const TrustedKeyGroupIdList = Schema.Array(Schema.String)
const MethodsList = Schema.Array(Schema.String)
const HeaderList = Schema.Array(Schema.String)
const CookieNameList = Schema.Array(Schema.String)
const QueryStringNamesList = Schema.Array(Schema.String)
const AccessControlAllowOriginsList = Schema.Array(Schema.String)
const AccessControlAllowHeadersList = Schema.Array(Schema.String)
const AccessControlAllowMethodsList = Schema.Array(Schema.String)
const AccessControlExposeHeadersList = Schema.Array(Schema.String)
const Tags = Schema.Struct({Items: Schema.optional(TagList)})
const ConnectionGroup = Schema.Struct({Id: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), Arn: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.Date), LastModifiedTime: Schema.optional(Schema.Date), Tags: Schema.optional(Tags), Ipv6Enabled: Schema.optional(Schema.Boolean), RoutingEndpoint: Schema.optional(Schema.String), AnycastIpListId: Schema.optional(Schema.String), Status: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean), IsDefault: Schema.optional(Schema.Boolean)})
const Customizations = Schema.Struct({WebAcl: Schema.optional(WebAclCustomization), Certificate: Schema.optional(Certificate), GeoRestrictions: Schema.optional(GeoRestrictionCustomization)})
const InvalidationBatch = Schema.Struct({Paths: Paths, CallerReference: Schema.String})
const Invalidation = Schema.Struct({Id: Schema.String, Status: Schema.String, CreateTime: Schema.Date, InvalidationBatch: InvalidationBatch})
const MonitoringSubscription = Schema.Struct({RealtimeMetricsSubscriptionConfig: Schema.optional(RealtimeMetricsSubscriptionConfig)})
const EndPoint = Schema.Struct({StreamType: Schema.String, KinesisStreamConfig: Schema.optional(KinesisStreamConfig)})
const EndPointList = Schema.Array(EndPoint)
const StreamingDistributionConfig = Schema.Struct({CallerReference: Schema.String, S3Origin: S3Origin, Aliases: Schema.optional(Aliases), Comment: Schema.String, Logging: Schema.optional(StreamingLoggingConfig), TrustedSigners: TrustedSigners, PriceClass: Schema.optional(Schema.String), Enabled: Schema.Boolean})
const VpcOriginEndpointConfig = Schema.Struct({Name: Schema.String, Arn: Schema.String, HTTPPort: Schema.Number, HTTPSPort: Schema.Number, OriginProtocolPolicy: Schema.String, OriginSslProtocols: Schema.optional(OriginSslProtocols)})
const VpcOrigin = Schema.Struct({Id: Schema.String, Arn: Schema.String, AccountId: Schema.optional(Schema.String), Status: Schema.String, CreatedTime: Schema.Date, LastModifiedTime: Schema.Date, VpcOriginEndpointConfig: VpcOriginEndpointConfig})
const KeyValueStore = Schema.Struct({Name: Schema.String, Id: Schema.String, Comment: Schema.String, ARN: Schema.String, Status: Schema.optional(Schema.String), LastModifiedTime: Schema.Date})
const AnycastIpList = Schema.Struct({Id: Schema.String, Name: Schema.String, Status: Schema.String, Arn: Schema.String, IpAddressType: Schema.optional(Schema.String), AnycastIps: AnycastIps, IpCount: Schema.Number, LastModifiedTime: Schema.Date})
const CachePolicy = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, CachePolicyConfig: CachePolicyConfig})
const CloudFrontOriginAccessIdentity = Schema.Struct({Id: Schema.String, S3CanonicalUserId: Schema.String, CloudFrontOriginAccessIdentityConfig: Schema.optional(CloudFrontOriginAccessIdentityConfig)})
const ContinuousDeploymentPolicy = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, ContinuousDeploymentPolicyConfig: ContinuousDeploymentPolicyConfig})
const FieldLevelEncryption = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, FieldLevelEncryptionConfig: FieldLevelEncryptionConfig})
const FieldLevelEncryptionProfile = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, FieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig})
const KeyGroup = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, KeyGroupConfig: KeyGroupConfig})
const OriginAccessControl = Schema.Struct({Id: Schema.String, OriginAccessControlConfig: Schema.optional(OriginAccessControlConfig)})
const OriginRequestPolicy = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, OriginRequestPolicyConfig: OriginRequestPolicyConfig})
const PublicKey = Schema.Struct({Id: Schema.String, CreatedTime: Schema.Date, PublicKeyConfig: PublicKeyConfig})
const RealtimeLogConfig = Schema.Struct({ARN: Schema.String, Name: Schema.String, SamplingRate: Schema.Number, EndPoints: EndPointList, Fields: FieldList})
const ResponseHeadersPolicy = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, ResponseHeadersPolicyConfig: ResponseHeadersPolicyConfig})
const StreamingDistribution = Schema.Struct({Id: Schema.String, ARN: Schema.String, Status: Schema.String, LastModifiedTime: Schema.optional(Schema.Date), DomainName: Schema.String, ActiveTrustedSigners: ActiveTrustedSigners, StreamingDistributionConfig: StreamingDistributionConfig})
const DistributionIdList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(DistributionIdListSummary)})
const DistributionTenantSummary = Schema.Struct({Id: Schema.String, DistributionId: Schema.String, Name: Schema.String, Arn: Schema.String, Domains: DomainResultList, ConnectionGroupId: Schema.optional(Schema.String), Customizations: Schema.optional(Customizations), CreatedTime: Schema.Date, LastModifiedTime: Schema.Date, ETag: Schema.String, Enabled: Schema.optional(Schema.Boolean), Status: Schema.optional(Schema.String)})
const DistributionTenantList = Schema.Array(DistributionTenantSummary)
const FunctionList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(FunctionSummaryList)})
const KeyValueStoreList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(KeyValueStoreSummaryList)})
const RealtimeLogConfigs = Schema.Struct({MaxItems: Schema.Number, Items: Schema.optional(RealtimeLogConfigList), IsTruncated: Schema.Boolean, Marker: Schema.String, NextMarker: Schema.optional(Schema.String)})
const TestResult = Schema.Struct({FunctionSummary: Schema.optional(FunctionSummary), ComputeUtilization: Schema.optional(Schema.String), FunctionExecutionLogs: Schema.optional(FunctionExecutionLogList), FunctionErrorMessage: Schema.optional(Schema.String), FunctionOutput: Schema.optional(Schema.String)})
const DnsConfiguration = Schema.Struct({Domain: Schema.String, Status: Schema.String, Reason: Schema.optional(Schema.String)})
const DnsConfigurationList = Schema.Array(DnsConfiguration)
const CachePolicyHeadersConfig = Schema.Struct({HeaderBehavior: Schema.String, Headers: Schema.optional(Headers)})
const CachePolicyCookiesConfig = Schema.Struct({CookieBehavior: Schema.String, Cookies: Schema.optional(CookieNames)})
const CachePolicyQueryStringsConfig = Schema.Struct({QueryStringBehavior: Schema.String, QueryStrings: Schema.optional(QueryStringNames)})
const ContinuousDeploymentSingleHeaderConfig = Schema.Struct({Header: Schema.String, Value: Schema.String})
const TrustedKeyGroups = Schema.Struct({Enabled: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(TrustedKeyGroupIdList)})
const GrpcConfig = Schema.Struct({Enabled: Schema.Boolean})
const CacheBehavior = Schema.Struct({PathPattern: Schema.String, TargetOriginId: Schema.String, TrustedSigners: Schema.optional(TrustedSigners), TrustedKeyGroups: Schema.optional(TrustedKeyGroups), ViewerProtocolPolicy: Schema.String, AllowedMethods: Schema.optional(AllowedMethods), SmoothStreaming: Schema.optional(Schema.Boolean), Compress: Schema.optional(Schema.Boolean), LambdaFunctionAssociations: Schema.optional(LambdaFunctionAssociations), FunctionAssociations: Schema.optional(FunctionAssociations), FieldLevelEncryptionId: Schema.optional(Schema.String), RealtimeLogConfigArn: Schema.optional(Schema.String), CachePolicyId: Schema.optional(Schema.String), OriginRequestPolicyId: Schema.optional(Schema.String), ResponseHeadersPolicyId: Schema.optional(Schema.String), GrpcConfig: Schema.optional(GrpcConfig), ForwardedValues: Schema.optional(ForwardedValues), MinTTL: Schema.optional(Schema.Number), DefaultTTL: Schema.optional(Schema.Number), MaxTTL: Schema.optional(Schema.Number)})
const CacheBehaviorList = Schema.Array(CacheBehavior)
const CustomErrorResponse = Schema.Struct({ErrorCode: Schema.Number, ResponsePagePath: Schema.optional(Schema.String), ResponseCode: Schema.optional(Schema.String), ErrorCachingMinTTL: Schema.optional(Schema.Number)})
const CustomErrorResponseList = Schema.Array(CustomErrorResponse)
const GeoRestriction = Schema.Struct({RestrictionType: Schema.String, Quantity: Schema.Number, Items: Schema.optional(LocationList)})
const KeyValueStoreAssociation = Schema.Struct({KeyValueStoreARN: Schema.String})
const KeyValueStoreAssociationList = Schema.Array(KeyValueStoreAssociation)
const Headers = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(HeaderList)})
const CookieNames = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(CookieNameList)})
const QueryStringNames = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(QueryStringNamesList)})
const ResponseHeadersPolicyAccessControlAllowOrigins = Schema.Struct({Quantity: Schema.Number, Items: AccessControlAllowOriginsList})
const ResponseHeadersPolicyAccessControlAllowHeaders = Schema.Struct({Quantity: Schema.Number, Items: AccessControlAllowHeadersList})
const ResponseHeadersPolicyAccessControlAllowMethods = Schema.Struct({Quantity: Schema.Number, Items: AccessControlAllowMethodsList})
const ResponseHeadersPolicyAccessControlExposeHeaders = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(AccessControlExposeHeadersList)})
const ResponseHeadersPolicyXSSProtection = Schema.Struct({Override: Schema.Boolean, Protection: Schema.Boolean, ModeBlock: Schema.optional(Schema.Boolean), ReportUri: Schema.optional(Schema.String)})
const ResponseHeadersPolicyFrameOptions = Schema.Struct({Override: Schema.Boolean, FrameOption: Schema.String})
const ResponseHeadersPolicyReferrerPolicy = Schema.Struct({Override: Schema.Boolean, ReferrerPolicy: Schema.String})
const ResponseHeadersPolicyContentSecurityPolicy = Schema.Struct({Override: Schema.Boolean, ContentSecurityPolicy: Schema.String})
const ResponseHeadersPolicyContentTypeOptions = Schema.Struct({Override: Schema.Boolean})
const ResponseHeadersPolicyStrictTransportSecurity = Schema.Struct({Override: Schema.Boolean, IncludeSubdomains: Schema.optional(Schema.Boolean), Preload: Schema.optional(Schema.Boolean), AccessControlMaxAgeSec: Schema.Number})
const ResponseHeadersPolicyCustomHeader = Schema.Struct({Header: Schema.String, Value: Schema.String, Override: Schema.Boolean})
const ResponseHeadersPolicyCustomHeaderList = Schema.Array(ResponseHeadersPolicyCustomHeader)
const ResponseHeadersPolicyRemoveHeader = Schema.Struct({Header: Schema.String})
const ResponseHeadersPolicyRemoveHeaderList = Schema.Array(ResponseHeadersPolicyRemoveHeader)
const IllegalUpdate = Schema.Struct({Message: Schema.optional(Schema.String)})
const CreateAnycastIpListRequest = Schema.Struct({Name: Schema.String, IpCount: Schema.Number, Tags: Schema.optional(Tags), IpAddressType: Schema.optional(Schema.String)})
const CreateCloudFrontOriginAccessIdentityResult = Schema.Struct({CloudFrontOriginAccessIdentity: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentity)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const CreateConnectionGroupResult = Schema.Struct({ConnectionGroup: Schema.optional(Body("undefined", ConnectionGroup)), ETag: Schema.optional(Header("ETag"))})
export const CreateConnectionGroup = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/connection-group", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateConnectionGroup" }, CreateConnectionGroupRequest, CreateConnectionGroupResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidTagging", InvalidTagging))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const QueryStringCacheKeysList = Schema.Array(Schema.String)
const CreateDistributionTenantRequest = Schema.Struct({DistributionId: Schema.String, Name: Schema.String, Domains: DomainList, Tags: Schema.optional(Tags), Customizations: Schema.optional(Customizations), Parameters: Schema.optional(Parameters), ConnectionGroupId: Schema.optional(Schema.String), ManagedCertificateRequest: Schema.optional(ManagedCertificateRequest), Enabled: Schema.optional(Schema.Boolean)})
const CreateDistributionWithTagsResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const FieldPatternList = Schema.Array(Schema.String)
const CreateInvalidationRequest = Schema.Struct({DistributionId: Schema.String, InvalidationBatch: Body("InvalidationBatch", InvalidationBatch)})
const CreateInvalidationForDistributionTenantResult = Schema.Struct({Location: Schema.optional(Header("Location")), Invalidation: Schema.optional(Body("undefined", Invalidation))})
const CreateKeyGroupResult = Schema.Struct({KeyGroup: Schema.optional(Body("undefined", KeyGroup)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const CreateKeyValueStoreResult = Schema.Struct({KeyValueStore: Schema.optional(Body("undefined", KeyValueStore)), ETag: Schema.optional(Header("ETag")), Location: Schema.optional(Header("Location"))})
const CreateMonitoringSubscriptionRequest = Schema.Struct({DistributionId: Schema.String, MonitoringSubscription: Body("MonitoringSubscription", MonitoringSubscription)})
const CreateOriginAccessControlResult = Schema.Struct({OriginAccessControl: Schema.optional(Body("undefined", OriginAccessControl)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const CreatePublicKeyResult = Schema.Struct({PublicKey: Schema.optional(Body("undefined", PublicKey)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const CreateRealtimeLogConfigRequest = Schema.Struct({EndPoints: EndPointList, Fields: FieldList, Name: Schema.String, SamplingRate: Schema.Number})
const CreateStreamingDistributionRequest = Schema.Struct({StreamingDistributionConfig: Body("StreamingDistributionConfig", StreamingDistributionConfig)})
const CreateStreamingDistributionWithTagsResult = Schema.Struct({StreamingDistribution: Schema.optional(Body("undefined", StreamingDistribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const CreateVpcOriginRequest = Schema.Struct({VpcOriginEndpointConfig: VpcOriginEndpointConfig, Tags: Schema.optional(Tags)})
const NoSuchCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteCachePolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/cache-policy/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteCachePolicy" }, DeleteCachePolicyRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CachePolicyInUse", CachePolicyInUse), ErrorAnnotation("IllegalDelete", IllegalDelete), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NoSuchCloudFrontOriginAccessIdentity = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteCloudFrontOriginAccessIdentity = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-access-identity/cloudfront/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteCloudFrontOriginAccessIdentity" }, DeleteCloudFrontOriginAccessIdentityRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CloudFrontOriginAccessIdentityInUse", CloudFrontOriginAccessIdentityInUse), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchCloudFrontOriginAccessIdentity", NoSuchCloudFrontOriginAccessIdentity), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ResourceNotDisabled = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteConnectionGroup = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/connection-group/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteConnectionGroup" }, DeleteConnectionGroupRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CannotDeleteEntityWhileInUse", CannotDeleteEntityWhileInUse), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResourceNotDisabled", ResourceNotDisabled))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NoSuchContinuousDeploymentPolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteContinuousDeploymentPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/continuous-deployment-policy/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteContinuousDeploymentPolicy" }, DeleteContinuousDeploymentPolicyRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("ContinuousDeploymentPolicyInUse", ContinuousDeploymentPolicyInUse), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ResourceInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteDistribution = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteDistribution" }, DeleteDistributionRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("DistributionNotDisabled", DistributionNotDisabled), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResourceInUse", ResourceInUse))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NoSuchFieldLevelEncryptionConfig = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteFieldLevelEncryptionConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/field-level-encryption/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteFieldLevelEncryptionConfig" }, DeleteFieldLevelEncryptionConfigRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("FieldLevelEncryptionConfigInUse", FieldLevelEncryptionConfigInUse), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NoSuchFieldLevelEncryptionProfile = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteFieldLevelEncryptionProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/field-level-encryption-profile/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteFieldLevelEncryptionProfile" }, DeleteFieldLevelEncryptionProfileRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("FieldLevelEncryptionProfileInUse", FieldLevelEncryptionProfileInUse), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFieldLevelEncryptionProfile", NoSuchFieldLevelEncryptionProfile), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NoSuchFunctionExists = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteFunction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/function/{Name}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteFunction" }, DeleteFunctionRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("FunctionInUse", FunctionInUse), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFunctionExists", NoSuchFunctionExists), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NoSuchMonitoringSubscription = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteMonitoringSubscription = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distributions/{DistributionId}/monitoring-subscription", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteMonitoringSubscription" }, DeleteMonitoringSubscriptionRequest, DeleteMonitoringSubscriptionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("NoSuchMonitoringSubscription", NoSuchMonitoringSubscription), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const OriginAccessControlInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteOriginAccessControl = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-access-control/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteOriginAccessControl" }, DeleteOriginAccessControlRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchOriginAccessControl", NoSuchOriginAccessControl), ErrorAnnotation("OriginAccessControlInUse", OriginAccessControlInUse), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NoSuchOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
const PublicKeyInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeletePublicKey = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/public-key/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeletePublicKey" }, DeletePublicKeyRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchPublicKey", NoSuchPublicKey), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("PublicKeyInUse", PublicKeyInUse))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NoSuchRealtimeLogConfig = Schema.Struct({Message: Schema.optional(Schema.String)})
const ResponseHeadersPolicyInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteResponseHeadersPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/response-headers-policy/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteResponseHeadersPolicy" }, DeleteResponseHeadersPolicyRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalDelete", IllegalDelete), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResponseHeadersPolicyInUse", ResponseHeadersPolicyInUse))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const StreamingDistributionNotDisabled = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteStreamingDistribution = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/streaming-distribution/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteStreamingDistribution" }, DeleteStreamingDistributionRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchStreamingDistribution", NoSuchStreamingDistribution), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("StreamingDistributionNotDisabled", StreamingDistributionNotDisabled))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DeleteVpcOriginResult = Schema.Struct({VpcOrigin: Schema.optional(Body("undefined", VpcOrigin)), ETag: Schema.optional(Header("ETag"))})
export const DeleteVpcOrigin = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/vpc-origin/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteVpcOrigin" }, DeleteVpcOriginRequest, DeleteVpcOriginResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CannotDeleteEntityWhileInUse", CannotDeleteEntityWhileInUse), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalDelete", IllegalDelete), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeKeyValueStoreResult = Schema.Struct({KeyValueStore: Schema.optional(Body("undefined", KeyValueStore)), ETag: Schema.optional(Header("ETag"))})
export const DescribeKeyValueStore = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/key-value-store/{Name}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DescribeKeyValueStore" }, DescribeKeyValueStoreRequest, DescribeKeyValueStoreResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetAnycastIpListResult = Schema.Struct({AnycastIpList: Schema.optional(Body("undefined", AnycastIpList)), ETag: Schema.optional(Header("ETag"))})
export const GetAnycastIpList = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/anycast-ip-list/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetAnycastIpList" }, GetAnycastIpListRequest, GetAnycastIpListResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetCachePolicyResult = Schema.Struct({CachePolicy: Schema.optional(Body("undefined", CachePolicy)), ETag: Schema.optional(Header("ETag"))})
export const GetCachePolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/cache-policy/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetCachePolicy" }, GetCachePolicyRequest, GetCachePolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetCloudFrontOriginAccessIdentityResult = Schema.Struct({CloudFrontOriginAccessIdentity: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentity)), ETag: Schema.optional(Header("ETag"))})
export const GetCloudFrontOriginAccessIdentity = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-access-identity/cloudfront/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetCloudFrontOriginAccessIdentity" }, GetCloudFrontOriginAccessIdentityRequest, GetCloudFrontOriginAccessIdentityResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchCloudFrontOriginAccessIdentity", NoSuchCloudFrontOriginAccessIdentity))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetContinuousDeploymentPolicyResult = Schema.Struct({ContinuousDeploymentPolicy: Schema.optional(Body("undefined", ContinuousDeploymentPolicy)), ETag: Schema.optional(Header("ETag"))})
export const GetContinuousDeploymentPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/continuous-deployment-policy/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetContinuousDeploymentPolicy" }, GetContinuousDeploymentPolicyRequest, GetContinuousDeploymentPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetFieldLevelEncryptionResult = Schema.Struct({FieldLevelEncryption: Schema.optional(Body("undefined", FieldLevelEncryption)), ETag: Schema.optional(Header("ETag"))})
export const GetFieldLevelEncryption = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/field-level-encryption/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetFieldLevelEncryption" }, GetFieldLevelEncryptionRequest, GetFieldLevelEncryptionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetFieldLevelEncryptionProfileResult = Schema.Struct({FieldLevelEncryptionProfile: Schema.optional(Body("undefined", FieldLevelEncryptionProfile)), ETag: Schema.optional(Header("ETag"))})
export const GetFieldLevelEncryptionProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/field-level-encryption-profile/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetFieldLevelEncryptionProfile" }, GetFieldLevelEncryptionProfileRequest, GetFieldLevelEncryptionProfileResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchFieldLevelEncryptionProfile", NoSuchFieldLevelEncryptionProfile))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const NoSuchInvalidation = Schema.Struct({Message: Schema.optional(Schema.String)})
export const GetInvalidation = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution/{DistributionId}/invalidation/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetInvalidation" }, GetInvalidationRequest, GetInvalidationResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("NoSuchInvalidation", NoSuchInvalidation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetKeyGroupResult = Schema.Struct({KeyGroup: Schema.optional(Body("undefined", KeyGroup)), ETag: Schema.optional(Header("ETag"))})
export const GetKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/key-group/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetKeyGroup" }, GetKeyGroupRequest, GetKeyGroupResult, ErrorAnnotation("NoSuchResource", NoSuchResource)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetOriginAccessControlResult = Schema.Struct({OriginAccessControl: Schema.optional(Body("undefined", OriginAccessControl)), ETag: Schema.optional(Header("ETag"))})
export const GetOriginAccessControl = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-access-control/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetOriginAccessControl" }, GetOriginAccessControlRequest, GetOriginAccessControlResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchOriginAccessControl", NoSuchOriginAccessControl))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetOriginRequestPolicyResult = Schema.Struct({OriginRequestPolicy: Schema.optional(Body("undefined", OriginRequestPolicy)), ETag: Schema.optional(Header("ETag"))})
export const GetOriginRequestPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-request-policy/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetOriginRequestPolicy" }, GetOriginRequestPolicyRequest, GetOriginRequestPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetPublicKeyResult = Schema.Struct({PublicKey: Schema.optional(Body("undefined", PublicKey)), ETag: Schema.optional(Header("ETag"))})
export const GetPublicKey = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/public-key/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetPublicKey" }, GetPublicKeyRequest, GetPublicKeyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchPublicKey", NoSuchPublicKey))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetRealtimeLogConfigResult = Schema.Struct({RealtimeLogConfig: Schema.optional(RealtimeLogConfig)})
export const GetRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/get-realtime-log-config", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetRealtimeLogConfig" }, GetRealtimeLogConfigRequest, GetRealtimeLogConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetResponseHeadersPolicyResult = Schema.Struct({ResponseHeadersPolicy: Schema.optional(Body("undefined", ResponseHeadersPolicy)), ETag: Schema.optional(Header("ETag"))})
export const GetResponseHeadersPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/response-headers-policy/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetResponseHeadersPolicy" }, GetResponseHeadersPolicyRequest, GetResponseHeadersPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetStreamingDistributionResult = Schema.Struct({StreamingDistribution: Schema.optional(Body("undefined", StreamingDistribution)), ETag: Schema.optional(Header("ETag"))})
export const GetStreamingDistribution = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/streaming-distribution/{Id}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetStreamingDistribution" }, GetStreamingDistributionRequest, GetStreamingDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("NoSuchStreamingDistribution", NoSuchStreamingDistribution))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDistributionsByCachePolicyIdResult = Schema.Struct({DistributionIdList: Schema.optional(Body("undefined", DistributionIdList))})
export const ListDistributionsByCachePolicyId = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distributionsByCachePolicyId/{CachePolicyId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDistributionsByCachePolicyId" }, ListDistributionsByCachePolicyIdRequest, ListDistributionsByCachePolicyIdResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidWebACLId = Schema.Struct({Message: Schema.optional(Schema.String)})
export const ListDistributionsByWebACLId = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distributionsByWebACLId/{WebACLId}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDistributionsByWebACLId" }, ListDistributionsByWebACLIdRequest, ListDistributionsByWebACLIdResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidWebACLId", InvalidWebACLId))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDistributionTenantsResult = Schema.Struct({NextMarker: Schema.optional(Schema.String), DistributionTenantList: Schema.optional(DistributionTenantList)})
export const ListDistributionTenants = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution-tenants", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDistributionTenants" }, ListDistributionTenantsRequest, ListDistributionTenantsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDistributionTenantsByCustomizationResult = Schema.Struct({NextMarker: Schema.optional(Schema.String), DistributionTenantList: Schema.optional(DistributionTenantList)})
export const ListDistributionTenantsByCustomization = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution-tenants-by-customization", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDistributionTenantsByCustomization" }, ListDistributionTenantsByCustomizationRequest, ListDistributionTenantsByCustomizationResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListFunctionsResult = Schema.Struct({FunctionList: Schema.optional(Body("undefined", FunctionList))})
export const ListFunctions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/function", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListFunctions" }, ListFunctionsRequest, ListFunctionsResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListKeyValueStoresResult = Schema.Struct({KeyValueStoreList: Schema.optional(Body("undefined", KeyValueStoreList))})
export const ListKeyValueStores = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/key-value-store", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListKeyValueStores" }, ListKeyValueStoresRequest, ListKeyValueStoresResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListRealtimeLogConfigsResult = Schema.Struct({RealtimeLogConfigs: Schema.optional(Body("undefined", RealtimeLogConfigs))})
export const ListRealtimeLogConfigs = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/realtime-log-config", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListRealtimeLogConfigs" }, ListRealtimeLogConfigsRequest, ListRealtimeLogConfigsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TestFunctionResult = Schema.Struct({TestResult: Schema.optional(Body("undefined", TestResult))})
const CachePolicyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const InconsistentQuantities = Schema.Struct({Message: Schema.optional(Schema.String)})
const EntityAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateConnectionGroup = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/connection-group/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateConnectionGroup" }, UpdateConnectionGroupRequest, UpdateConnectionGroupResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResourceInUse", ResourceInUse))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const StagingDistributionInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateContinuousDeploymentPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/continuous-deployment-policy/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateContinuousDeploymentPolicy" }, UpdateContinuousDeploymentPolicyRequest, UpdateContinuousDeploymentPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("StagingDistributionInUse", StagingDistributionInUse))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CNAMEAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const EntityLimitExceeded = Schema.Struct({Message: Schema.optional(Schema.String)})
const IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior = Schema.Struct({Message: Schema.optional(Schema.String)})
const QueryArgProfileEmpty = Schema.Struct({Message: Schema.optional(Schema.String)})
const FieldLevelEncryptionProfileAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const FunctionSizeLimitExceeded = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateFunction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/function/{Name}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateFunction" }, UpdateFunctionRequest, UpdateFunctionResult, Schema.Union(ErrorAnnotation("FunctionSizeLimitExceeded", FunctionSizeLimitExceeded), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFunctionExists", NoSuchFunctionExists), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const KeyGroupAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const OriginAccessControlAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateOriginAccessControl = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-access-control/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateOriginAccessControl" }, UpdateOriginAccessControlRequest, UpdateOriginAccessControlResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchOriginAccessControl", NoSuchOriginAccessControl), ErrorAnnotation("OriginAccessControlAlreadyExists", OriginAccessControlAlreadyExists), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const OriginRequestPolicyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const CannotChangeImmutablePublicKeyFields = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdatePublicKey = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/public-key/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdatePublicKey" }, UpdatePublicKeyRequest, UpdatePublicKeyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CannotChangeImmutablePublicKeyFields", CannotChangeImmutablePublicKeyFields), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchPublicKey", NoSuchPublicKey), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ResponseHeadersPolicyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidOriginAccessControl = Schema.Struct({Message: Schema.optional(Schema.String)})
const CannotUpdateEntityWhileInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateVpcOrigin = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/vpc-origin/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateVpcOrigin" }, UpdateVpcOriginRequest, UpdateVpcOriginResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CannotUpdateEntityWhileInUse", CannotUpdateEntityWhileInUse), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const VerifyDnsConfigurationResult = Schema.Struct({DnsConfigurationList: Schema.optional(DnsConfigurationList)})
export const VerifyDnsConfiguration = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/verify-dns-configuration", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "VerifyDnsConfiguration" }, VerifyDnsConfigurationRequest, VerifyDnsConfigurationResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const AliasICPRecordal = Schema.Struct({CNAME: Schema.optional(Schema.String), ICPRecordalStatus: Schema.optional(Schema.String)})
const AliasICPRecordals = Schema.Array(AliasICPRecordal)
const ParametersInCacheKeyAndForwardedToOrigin = Schema.Struct({EnableAcceptEncodingGzip: Schema.Boolean, EnableAcceptEncodingBrotli: Schema.optional(Schema.Boolean), HeadersConfig: CachePolicyHeadersConfig, CookiesConfig: CachePolicyCookiesConfig, QueryStringsConfig: CachePolicyQueryStringsConfig})
const CacheBehaviors = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(CacheBehaviorList)})
const CustomErrorResponses = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(CustomErrorResponseList)})
const Restrictions = Schema.Struct({GeoRestriction: GeoRestriction})
const KeyValueStoreAssociations = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(KeyValueStoreAssociationList)})
const OriginRequestPolicyHeadersConfig = Schema.Struct({HeaderBehavior: Schema.String, Headers: Schema.optional(Headers)})
const OriginRequestPolicyCookiesConfig = Schema.Struct({CookieBehavior: Schema.String, Cookies: Schema.optional(CookieNames)})
const OriginRequestPolicyQueryStringsConfig = Schema.Struct({QueryStringBehavior: Schema.String, QueryStrings: Schema.optional(QueryStringNames)})
const ResponseHeadersPolicyCorsConfig = Schema.Struct({AccessControlAllowOrigins: ResponseHeadersPolicyAccessControlAllowOrigins, AccessControlAllowHeaders: ResponseHeadersPolicyAccessControlAllowHeaders, AccessControlAllowMethods: ResponseHeadersPolicyAccessControlAllowMethods, AccessControlAllowCredentials: Schema.Boolean, AccessControlExposeHeaders: Schema.optional(ResponseHeadersPolicyAccessControlExposeHeaders), AccessControlMaxAgeSec: Schema.optional(Schema.Number), OriginOverride: Schema.Boolean})
const ResponseHeadersPolicySecurityHeadersConfig = Schema.Struct({XSSProtection: Schema.optional(ResponseHeadersPolicyXSSProtection), FrameOptions: Schema.optional(ResponseHeadersPolicyFrameOptions), ReferrerPolicy: Schema.optional(ResponseHeadersPolicyReferrerPolicy), ContentSecurityPolicy: Schema.optional(ResponseHeadersPolicyContentSecurityPolicy), ContentTypeOptions: Schema.optional(ResponseHeadersPolicyContentTypeOptions), StrictTransportSecurity: Schema.optional(ResponseHeadersPolicyStrictTransportSecurity)})
const ResponseHeadersPolicyCustomHeadersConfig = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(ResponseHeadersPolicyCustomHeaderList)})
const ResponseHeadersPolicyRemoveHeadersConfig = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(ResponseHeadersPolicyRemoveHeaderList)})
const FunctionMetadata = Schema.Struct({FunctionARN: Schema.String, Stage: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.Date), LastModifiedTime: Schema.Date})
const DomainResult = Schema.Struct({Domain: Schema.String, Status: Schema.optional(Schema.String)})
const DomainResultList = Schema.Array(DomainResult)
const ValidationTokenDetail = Schema.Struct({Domain: Schema.String, RedirectTo: Schema.optional(Schema.String), RedirectFrom: Schema.optional(Schema.String)})
const ValidationTokenDetailList = Schema.Array(ValidationTokenDetail)
const AnycastIpListSummary = Schema.Struct({Id: Schema.String, Name: Schema.String, Status: Schema.String, Arn: Schema.String, IpCount: Schema.Number, LastModifiedTime: Schema.Date, IpAddressType: Schema.optional(Schema.String), ETag: Schema.optional(Schema.String)})
const AnycastIpListSummaries = Schema.Array(AnycastIpListSummary)
const CachePolicySummary = Schema.Struct({Type: Schema.String, CachePolicy: CachePolicy})
const CachePolicySummaryList = Schema.Array(CachePolicySummary)
const CloudFrontOriginAccessIdentitySummary = Schema.Struct({Id: Schema.String, S3CanonicalUserId: Schema.String, Comment: Schema.String})
const CloudFrontOriginAccessIdentitySummaryList = Schema.Array(CloudFrontOriginAccessIdentitySummary)
const ConflictingAlias = Schema.Struct({Alias: Schema.optional(Schema.String), DistributionId: Schema.optional(Schema.String), AccountId: Schema.optional(Schema.String)})
const ConflictingAliases = Schema.Array(ConflictingAlias)
const ContinuousDeploymentPolicySummary = Schema.Struct({ContinuousDeploymentPolicy: ContinuousDeploymentPolicy})
const ContinuousDeploymentPolicySummaryList = Schema.Array(ContinuousDeploymentPolicySummary)
const DistributionSummary = Schema.Struct({Id: Schema.String, ARN: Schema.String, ETag: Schema.optional(Schema.String), Status: Schema.String, LastModifiedTime: Schema.Date, DomainName: Schema.String, Aliases: Aliases, Origins: Origins, OriginGroups: Schema.optional(OriginGroups), DefaultCacheBehavior: DefaultCacheBehavior, CacheBehaviors: CacheBehaviors, CustomErrorResponses: CustomErrorResponses, Comment: Schema.String, PriceClass: Schema.String, Enabled: Schema.Boolean, ViewerCertificate: ViewerCertificate, Restrictions: Restrictions, WebACLId: Schema.String, HttpVersion: Schema.String, IsIPV6Enabled: Schema.Boolean, AliasICPRecordals: Schema.optional(AliasICPRecordals), Staging: Schema.Boolean, ConnectionMode: Schema.optional(Schema.String), AnycastIpListId: Schema.optional(Schema.String)})
const DistributionSummaryList = Schema.Array(DistributionSummary)
const DistributionIdOwner = Schema.Struct({DistributionId: Schema.String, OwnerAccountId: Schema.String})
const DistributionIdOwnerItemList = Schema.Array(DistributionIdOwner)
const FieldLevelEncryptionSummary = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, Comment: Schema.optional(Schema.String), QueryArgProfileConfig: Schema.optional(QueryArgProfileConfig), ContentTypeProfileConfig: Schema.optional(ContentTypeProfileConfig)})
const FieldLevelEncryptionSummaryList = Schema.Array(FieldLevelEncryptionSummary)
const FieldLevelEncryptionProfileSummary = Schema.Struct({Id: Schema.String, LastModifiedTime: Schema.Date, Name: Schema.String, EncryptionEntities: EncryptionEntities, Comment: Schema.optional(Schema.String)})
const FieldLevelEncryptionProfileSummaryList = Schema.Array(FieldLevelEncryptionProfileSummary)
const InvalidationSummary = Schema.Struct({Id: Schema.String, CreateTime: Schema.Date, Status: Schema.String})
const InvalidationSummaryList = Schema.Array(InvalidationSummary)
const KeyGroupSummary = Schema.Struct({KeyGroup: KeyGroup})
const KeyGroupSummaryList = Schema.Array(KeyGroupSummary)
const OriginAccessControlSummary = Schema.Struct({Id: Schema.String, Description: Schema.String, Name: Schema.String, SigningProtocol: Schema.String, SigningBehavior: Schema.String, OriginAccessControlOriginType: Schema.String})
const OriginAccessControlSummaryList = Schema.Array(OriginAccessControlSummary)
const OriginRequestPolicySummary = Schema.Struct({Type: Schema.String, OriginRequestPolicy: OriginRequestPolicy})
const OriginRequestPolicySummaryList = Schema.Array(OriginRequestPolicySummary)
const PublicKeySummary = Schema.Struct({Id: Schema.String, Name: Schema.String, CreatedTime: Schema.Date, EncodedKey: Schema.String, Comment: Schema.optional(Schema.String)})
const PublicKeySummaryList = Schema.Array(PublicKeySummary)
const ResponseHeadersPolicySummary = Schema.Struct({Type: Schema.String, ResponseHeadersPolicy: ResponseHeadersPolicy})
const ResponseHeadersPolicySummaryList = Schema.Array(ResponseHeadersPolicySummary)
const StreamingDistributionSummary = Schema.Struct({Id: Schema.String, ARN: Schema.String, Status: Schema.String, LastModifiedTime: Schema.Date, DomainName: Schema.String, S3Origin: S3Origin, Aliases: Aliases, TrustedSigners: TrustedSigners, Comment: Schema.String, PriceClass: Schema.String, Enabled: Schema.Boolean})
const StreamingDistributionSummaryList = Schema.Array(StreamingDistributionSummary)
const VpcOriginSummary = Schema.Struct({Id: Schema.String, Name: Schema.String, Status: Schema.String, CreatedTime: Schema.Date, LastModifiedTime: Schema.Date, Arn: Schema.String, AccountId: Schema.optional(Schema.String), OriginEndpointArn: Schema.String})
const VpcOriginSummaryList = Schema.Array(VpcOriginSummary)
const SessionStickinessConfig = Schema.Struct({IdleTTL: Schema.Number, MaximumTTL: Schema.Number})
const S3OriginConfig = Schema.Struct({OriginAccessIdentity: Schema.String, OriginReadTimeout: Schema.optional(Schema.Number)})
const CustomOriginConfig = Schema.Struct({HTTPPort: Schema.Number, HTTPSPort: Schema.Number, OriginProtocolPolicy: Schema.String, OriginSslProtocols: Schema.optional(OriginSslProtocols), OriginReadTimeout: Schema.optional(Schema.Number), OriginKeepaliveTimeout: Schema.optional(Schema.Number), IpAddressType: Schema.optional(Schema.String)})
const VpcOriginConfig = Schema.Struct({VpcOriginId: Schema.String, OwnerAccountId: Schema.optional(Schema.String), OriginReadTimeout: Schema.optional(Schema.Number), OriginKeepaliveTimeout: Schema.optional(Schema.Number)})
const OriginShield = Schema.Struct({Enabled: Schema.Boolean, OriginShieldRegion: Schema.optional(Schema.String)})
const CachedMethods = Schema.Struct({Quantity: Schema.Number, Items: MethodsList})
const LambdaFunctionAssociation = Schema.Struct({LambdaFunctionARN: Schema.String, EventType: Schema.String, IncludeBody: Schema.optional(Schema.Boolean)})
const LambdaFunctionAssociationList = Schema.Array(LambdaFunctionAssociation)
const FunctionAssociation = Schema.Struct({FunctionARN: Schema.String, EventType: Schema.String})
const FunctionAssociationList = Schema.Array(FunctionAssociation)
const CookiePreference = Schema.Struct({Forward: Schema.String, WhitelistedNames: Schema.optional(CookieNames)})
const QueryStringCacheKeys = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(QueryStringCacheKeysList)})
const QueryArgProfile = Schema.Struct({QueryArg: Schema.String, ProfileId: Schema.String})
const QueryArgProfileList = Schema.Array(QueryArgProfile)
const ContentTypeProfile = Schema.Struct({Format: Schema.String, ProfileId: Schema.optional(Schema.String), ContentType: Schema.String})
const ContentTypeProfileList = Schema.Array(ContentTypeProfile)
const FieldPatterns = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(FieldPatternList)})
const CachePolicyConfig = Schema.Struct({Comment: Schema.optional(Schema.String), Name: Schema.String, DefaultTTL: Schema.optional(Schema.Number), MaxTTL: Schema.optional(Schema.Number), MinTTL: Schema.Number, ParametersInCacheKeyAndForwardedToOrigin: Schema.optional(ParametersInCacheKeyAndForwardedToOrigin)})
const StatusCodeList = Schema.Array(Schema.Number)
const FunctionConfig = Schema.Struct({Comment: Schema.String, Runtime: Schema.String, KeyValueStoreAssociations: Schema.optional(KeyValueStoreAssociations)})
const OriginRequestPolicyConfig = Schema.Struct({Comment: Schema.optional(Schema.String), Name: Schema.String, HeadersConfig: OriginRequestPolicyHeadersConfig, CookiesConfig: OriginRequestPolicyCookiesConfig, QueryStringsConfig: OriginRequestPolicyQueryStringsConfig})
const ResponseHeadersPolicyConfig = Schema.Struct({Comment: Schema.optional(Schema.String), Name: Schema.String, CorsConfig: Schema.optional(ResponseHeadersPolicyCorsConfig), SecurityHeadersConfig: Schema.optional(ResponseHeadersPolicySecurityHeadersConfig), ServerTimingHeadersConfig: Schema.optional(ResponseHeadersPolicyServerTimingHeadersConfig), CustomHeadersConfig: Schema.optional(ResponseHeadersPolicyCustomHeadersConfig), RemoveHeadersConfig: Schema.optional(ResponseHeadersPolicyRemoveHeadersConfig)})
const FunctionSummary = Schema.Struct({Name: Schema.String, Status: Schema.optional(Schema.String), FunctionConfig: FunctionConfig, FunctionMetadata: FunctionMetadata})
const DistributionTenant = Schema.Struct({Id: Schema.optional(Schema.String), DistributionId: Schema.optional(Schema.String), Name: Schema.optional(Schema.String), Arn: Schema.optional(Schema.String), Domains: Schema.optional(DomainResultList), Tags: Schema.optional(Tags), Customizations: Schema.optional(Customizations), Parameters: Schema.optional(Parameters), ConnectionGroupId: Schema.optional(Schema.String), CreatedTime: Schema.optional(Schema.Date), LastModifiedTime: Schema.optional(Schema.Date), Enabled: Schema.optional(Schema.Boolean), Status: Schema.optional(Schema.String)})
const ManagedCertificateDetails = Schema.Struct({CertificateArn: Schema.optional(Schema.String), CertificateStatus: Schema.optional(Schema.String), ValidationTokenHost: Schema.optional(Schema.String), ValidationTokenDetails: Schema.optional(ValidationTokenDetailList)})
const AnycastIpListCollection = Schema.Struct({Items: Schema.optional(AnycastIpListSummaries), Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number})
const CachePolicyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(CachePolicySummaryList)})
const CloudFrontOriginAccessIdentityList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(CloudFrontOriginAccessIdentitySummaryList)})
const ConflictingAliasesList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.optional(Schema.Number), Quantity: Schema.optional(Schema.Number), Items: Schema.optional(ConflictingAliases)})
const ConnectionGroupSummary = Schema.Struct({Id: Schema.String, Name: Schema.String, Arn: Schema.String, RoutingEndpoint: Schema.String, CreatedTime: Schema.Date, LastModifiedTime: Schema.Date, ETag: Schema.String, AnycastIpListId: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean), Status: Schema.optional(Schema.String), IsDefault: Schema.optional(Schema.Boolean)})
const ConnectionGroupSummaryList = Schema.Array(ConnectionGroupSummary)
const ContinuousDeploymentPolicyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(ContinuousDeploymentPolicySummaryList)})
const DistributionList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(DistributionSummaryList)})
const DistributionIdOwnerList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(DistributionIdOwnerItemList)})
const DomainConflict = Schema.Struct({Domain: Schema.String, ResourceType: Schema.String, ResourceId: Schema.String, AccountId: Schema.String})
const DomainConflictsList = Schema.Array(DomainConflict)
const FieldLevelEncryptionList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(FieldLevelEncryptionSummaryList)})
const FieldLevelEncryptionProfileList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(FieldLevelEncryptionProfileSummaryList)})
const InvalidationList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(InvalidationSummaryList)})
const KeyGroupList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(KeyGroupSummaryList)})
const OriginAccessControlList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(OriginAccessControlSummaryList)})
const OriginRequestPolicyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(OriginRequestPolicySummaryList)})
const PublicKeyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(PublicKeySummaryList)})
const ResponseHeadersPolicyList = Schema.Struct({NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, Quantity: Schema.Number, Items: Schema.optional(ResponseHeadersPolicySummaryList)})
const StreamingDistributionList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(StreamingDistributionSummaryList)})
const VpcOriginList = Schema.Struct({Marker: Schema.String, NextMarker: Schema.optional(Schema.String), MaxItems: Schema.Number, IsTruncated: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(VpcOriginSummaryList)})
const KGKeyPairIds = Schema.Struct({KeyGroupId: Schema.optional(Schema.String), KeyPairIds: Schema.optional(KeyPairIds)})
const KGKeyPairIdsList = Schema.Array(KGKeyPairIds)
const ContinuousDeploymentSingleWeightConfig = Schema.Struct({Weight: Schema.Number, SessionStickinessConfig: Schema.optional(SessionStickinessConfig)})
const AllowedMethods = Schema.Struct({Quantity: Schema.Number, Items: MethodsList, CachedMethods: Schema.optional(CachedMethods)})
const LambdaFunctionAssociations = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(LambdaFunctionAssociationList)})
const FunctionAssociations = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(FunctionAssociationList)})
const ForwardedValues = Schema.Struct({QueryString: Schema.Boolean, Cookies: CookiePreference, Headers: Schema.optional(Headers), QueryStringCacheKeys: Schema.optional(QueryStringCacheKeys)})
const QueryArgProfiles = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(QueryArgProfileList)})
const ContentTypeProfiles = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(ContentTypeProfileList)})
const EncryptionEntity = Schema.Struct({PublicKeyId: Schema.String, ProviderId: Schema.String, FieldPatterns: FieldPatterns})
const EncryptionEntityList = Schema.Array(EncryptionEntity)
const TooManyDistributionCNAMEs = Schema.Struct({Message: Schema.optional(Schema.String)})
export const AssociateAlias = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution/{TargetDistributionId}/associate-alias", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "AssociateAlias" }, AssociateAliasRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("TooManyDistributionCNAMEs", TooManyDistributionCNAMEs))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const KeyPairIdList = Schema.Array(Schema.String)
const CreateAnycastIpListResult = Schema.Struct({AnycastIpList: Schema.optional(Body("undefined", AnycastIpList)), ETag: Schema.optional(Header("ETag"))})
export const CreateAnycastIpList = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/anycast-ip-list", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateAnycastIpList" }, CreateAnycastIpListRequest, CreateAnycastIpListResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateCachePolicyRequest = Schema.Struct({CachePolicyConfig: Body("CachePolicyConfig", CachePolicyConfig)})
const CloudFrontOriginAccessIdentityAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const OriginCustomHeader = Schema.Struct({HeaderName: Schema.String, HeaderValue: Schema.String})
const OriginCustomHeadersList = Schema.Array(OriginCustomHeader)
const StatusCodes = Schema.Struct({Quantity: Schema.Number, Items: StatusCodeList})
const OriginGroupMember = Schema.Struct({OriginId: Schema.String})
const OriginGroupMemberList = Schema.Array(OriginGroupMember)
const StringSchemaConfig = Schema.Struct({Comment: Schema.optional(Schema.String), DefaultValue: Schema.optional(Schema.String), Required: Schema.Boolean})
const CreateDistributionTenantResult = Schema.Struct({DistributionTenant: Schema.optional(Body("undefined", DistributionTenant)), ETag: Schema.optional(Header("ETag"))})
export const CreateDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution-tenant", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateDistributionTenant" }, CreateDistributionTenantRequest, CreateDistributionTenantResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidAssociation", InvalidAssociation), ErrorAnnotation("InvalidTagging", InvalidTagging))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DistributionAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const CreateFunctionRequest = Schema.Struct({Name: Schema.String, FunctionConfig: FunctionConfig, FunctionCode: StreamBody()})
const CreateInvalidationResult = Schema.Struct({Location: Schema.optional(Header("Location")), Invalidation: Schema.optional(Body("undefined", Invalidation))})
const BatchTooLarge = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateInvalidationForDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution-tenant/{Id}/invalidation", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateInvalidationForDistributionTenant" }, CreateInvalidationForDistributionTenantRequest, CreateInvalidationForDistributionTenantResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("BatchTooLarge", BatchTooLarge), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("TooManyInvalidationsInProgress", TooManyInvalidationsInProgress))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyKeyGroups = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/key-group", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateKeyGroup" }, CreateKeyGroupRequest, CreateKeyGroupResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("KeyGroupAlreadyExists", KeyGroupAlreadyExists), ErrorAnnotation("TooManyKeyGroups", TooManyKeyGroups), ErrorAnnotation("TooManyPublicKeysInKeyGroup", TooManyPublicKeysInKeyGroup))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const EntitySizeLimitExceeded = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateKeyValueStore = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/key-value-store", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateKeyValueStore" }, CreateKeyValueStoreRequest, CreateKeyValueStoreResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntitySizeLimitExceeded", EntitySizeLimitExceeded), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateMonitoringSubscriptionResult = Schema.Struct({MonitoringSubscription: Schema.optional(Body("undefined", MonitoringSubscription))})
const TooManyOriginAccessControls = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateOriginAccessControl = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-access-control", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateOriginAccessControl" }, CreateOriginAccessControlRequest, CreateOriginAccessControlResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("OriginAccessControlAlreadyExists", OriginAccessControlAlreadyExists), ErrorAnnotation("TooManyOriginAccessControls", TooManyOriginAccessControls))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateOriginRequestPolicyRequest = Schema.Struct({OriginRequestPolicyConfig: Body("OriginRequestPolicyConfig", OriginRequestPolicyConfig)})
const PublicKeyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const CreateRealtimeLogConfigResult = Schema.Struct({RealtimeLogConfig: Schema.optional(RealtimeLogConfig)})
const CreateResponseHeadersPolicyRequest = Schema.Struct({ResponseHeadersPolicyConfig: Body("ResponseHeadersPolicyConfig", ResponseHeadersPolicyConfig)})
const CreateStreamingDistributionResult = Schema.Struct({StreamingDistribution: Schema.optional(Body("undefined", StreamingDistribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const InvalidOrigin = Schema.Struct({Message: Schema.optional(Schema.String)})
const CreateVpcOriginResult = Schema.Struct({VpcOrigin: Schema.optional(Body("undefined", VpcOrigin)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
export const CreateVpcOrigin = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/vpc-origin", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateVpcOrigin" }, CreateVpcOriginRequest, CreateVpcOriginResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const OriginRequestPolicyInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteOriginRequestPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-request-policy/{Id}", method: "DELETE", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteOriginRequestPolicy" }, DeleteOriginRequestPolicyRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalDelete", IllegalDelete), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("OriginRequestPolicyInUse", OriginRequestPolicyInUse), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const RealtimeLogConfigInUse = Schema.Struct({Message: Schema.optional(Schema.String)})
export const DeleteRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/delete-realtime-log-config", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DeleteRealtimeLogConfig" }, DeleteRealtimeLogConfigRequest, Schema.Struct({}), Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig), ErrorAnnotation("RealtimeLogConfigInUse", RealtimeLogConfigInUse))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const DescribeFunctionResult = Schema.Struct({FunctionSummary: Schema.optional(Body("undefined", FunctionSummary)), ETag: Schema.optional(Header("ETag"))})
export const DescribeFunction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/function/{Name}/describe", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "DescribeFunction" }, DescribeFunctionRequest, DescribeFunctionResult, Schema.Union(ErrorAnnotation("NoSuchFunctionExists", NoSuchFunctionExists), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetDistributionTenantResult = Schema.Struct({DistributionTenant: Schema.optional(Body("undefined", DistributionTenant)), ETag: Schema.optional(Header("ETag"))})
export const GetDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution-tenant/{Identifier}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetDistributionTenant" }, GetDistributionTenantRequest, GetDistributionTenantResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const GetManagedCertificateDetailsResult = Schema.Struct({ManagedCertificateDetails: Schema.optional(Body("undefined", ManagedCertificateDetails))})
export const GetManagedCertificateDetails = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/managed-certificate/{Identifier}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "GetManagedCertificateDetails" }, GetManagedCertificateDetailsRequest, GetManagedCertificateDetailsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListAnycastIpListsResult = Schema.Struct({AnycastIpLists: Schema.optional(Body("AnycastIpListCollection", AnycastIpListCollection))})
export const ListAnycastIpLists = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/anycast-ip-list", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListAnycastIpLists" }, ListAnycastIpListsRequest, ListAnycastIpListsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListCachePoliciesResult = Schema.Struct({CachePolicyList: Schema.optional(Body("undefined", CachePolicyList))})
export const ListCachePolicies = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/cache-policy", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListCachePolicies" }, ListCachePoliciesRequest, ListCachePoliciesResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListCloudFrontOriginAccessIdentitiesResult = Schema.Struct({CloudFrontOriginAccessIdentityList: Schema.optional(Body("undefined", CloudFrontOriginAccessIdentityList))})
export const ListCloudFrontOriginAccessIdentities = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-access-identity/cloudfront", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListCloudFrontOriginAccessIdentities" }, ListCloudFrontOriginAccessIdentitiesRequest, ListCloudFrontOriginAccessIdentitiesResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListConflictingAliasesResult = Schema.Struct({ConflictingAliasesList: Schema.optional(Body("undefined", ConflictingAliasesList))})
export const ListConflictingAliases = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/conflicting-alias", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListConflictingAliases" }, ListConflictingAliasesRequest, ListConflictingAliasesResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListConnectionGroupsResult = Schema.Struct({NextMarker: Schema.optional(Schema.String), ConnectionGroups: Schema.optional(ConnectionGroupSummaryList)})
export const ListConnectionGroups = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/connection-groups", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListConnectionGroups" }, ListConnectionGroupsRequest, ListConnectionGroupsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListContinuousDeploymentPoliciesResult = Schema.Struct({ContinuousDeploymentPolicyList: Schema.optional(Body("undefined", ContinuousDeploymentPolicyList))})
export const ListContinuousDeploymentPolicies = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/continuous-deployment-policy", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListContinuousDeploymentPolicies" }, ListContinuousDeploymentPoliciesRequest, ListContinuousDeploymentPoliciesResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDistributionsResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionList))})
export const ListDistributions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDistributions" }, ListDistributionsRequest, ListDistributionsResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDistributionsByOwnedResourceResult = Schema.Struct({DistributionList: Schema.optional(Body("undefined", DistributionIdOwnerList))})
export const ListDistributionsByOwnedResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distributionsByOwnedResource/{ResourceArn}", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDistributionsByOwnedResource" }, ListDistributionsByOwnedResourceRequest, ListDistributionsByOwnedResourceResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListDomainConflictsResult = Schema.Struct({DomainConflicts: Schema.optional(DomainConflictsList), NextMarker: Schema.optional(Schema.String)})
export const ListDomainConflicts = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/domain-conflicts", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListDomainConflicts" }, ListDomainConflictsRequest, ListDomainConflictsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListFieldLevelEncryptionConfigsResult = Schema.Struct({FieldLevelEncryptionList: Schema.optional(Body("undefined", FieldLevelEncryptionList))})
export const ListFieldLevelEncryptionConfigs = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/field-level-encryption", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListFieldLevelEncryptionConfigs" }, ListFieldLevelEncryptionConfigsRequest, ListFieldLevelEncryptionConfigsResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListFieldLevelEncryptionProfilesResult = Schema.Struct({FieldLevelEncryptionProfileList: Schema.optional(Body("undefined", FieldLevelEncryptionProfileList))})
export const ListFieldLevelEncryptionProfiles = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/field-level-encryption-profile", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListFieldLevelEncryptionProfiles" }, ListFieldLevelEncryptionProfilesRequest, ListFieldLevelEncryptionProfilesResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListInvalidationsResult = Schema.Struct({InvalidationList: Schema.optional(Body("undefined", InvalidationList))})
export const ListInvalidations = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution/{DistributionId}/invalidation", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListInvalidations" }, ListInvalidationsRequest, ListInvalidationsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListKeyGroupsResult = Schema.Struct({KeyGroupList: Schema.optional(Body("undefined", KeyGroupList))})
export const ListKeyGroups = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/key-group", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListKeyGroups" }, ListKeyGroupsRequest, ListKeyGroupsResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListOriginAccessControlsResult = Schema.Struct({OriginAccessControlList: Schema.optional(Body("undefined", OriginAccessControlList))})
export const ListOriginAccessControls = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-access-control", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListOriginAccessControls" }, ListOriginAccessControlsRequest, ListOriginAccessControlsResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListOriginRequestPoliciesResult = Schema.Struct({OriginRequestPolicyList: Schema.optional(Body("undefined", OriginRequestPolicyList))})
export const ListOriginRequestPolicies = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-request-policy", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListOriginRequestPolicies" }, ListOriginRequestPoliciesRequest, ListOriginRequestPoliciesResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListPublicKeysResult = Schema.Struct({PublicKeyList: Schema.optional(Body("undefined", PublicKeyList))})
export const ListPublicKeys = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/public-key", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListPublicKeys" }, ListPublicKeysRequest, ListPublicKeysResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListResponseHeadersPoliciesResult = Schema.Struct({ResponseHeadersPolicyList: Schema.optional(Body("undefined", ResponseHeadersPolicyList))})
export const ListResponseHeadersPolicies = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/response-headers-policy", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListResponseHeadersPolicies" }, ListResponseHeadersPoliciesRequest, ListResponseHeadersPoliciesResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListStreamingDistributionsResult = Schema.Struct({StreamingDistributionList: Schema.optional(Body("undefined", StreamingDistributionList))})
export const ListStreamingDistributions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/streaming-distribution", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListStreamingDistributions" }, ListStreamingDistributionsRequest, ListStreamingDistributionsResult, ErrorAnnotation("InvalidArgument", InvalidArgument)), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ListVpcOriginsResult = Schema.Struct({VpcOriginList: Schema.optional(Body("undefined", VpcOriginList))})
export const ListVpcOrigins = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/vpc-origin", method: "GET", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "ListVpcOrigins" }, ListVpcOriginsRequest, ListVpcOriginsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TestFunctionFailed = Schema.Struct({Message: Schema.optional(Schema.String)})
export const TestFunction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/function/{Name}/test", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "TestFunction" }, TestFunctionRequest, TestFunctionResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFunctionExists", NoSuchFunctionExists), ErrorAnnotation("TestFunctionFailed", TestFunctionFailed), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyCookiesInCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
const MissingBody = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateCloudFrontOriginAccessIdentity = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-access-identity/cloudfront/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateCloudFrontOriginAccessIdentity" }, UpdateCloudFrontOriginAccessIdentityRequest, UpdateCloudFrontOriginAccessIdentityResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchCloudFrontOriginAccessIdentity", NoSuchCloudFrontOriginAccessIdentity), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const IllegalOriginAccessConfiguration = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidAssociation = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateDistributionTenant = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution-tenant/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateDistributionTenant" }, UpdateDistributionTenantRequest, UpdateDistributionTenantResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("EntityAlreadyExists", EntityAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidAssociation", InvalidAssociation), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("PreconditionFailed", PreconditionFailed))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidDefaultRootObject = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyFieldLevelEncryptionContentTypeProfiles = Schema.Struct({Message: Schema.optional(Schema.String)})
const FieldLevelEncryptionProfileSizeExceeded = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyPublicKeysInKeyGroup = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateKeyGroup = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/key-group/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateKeyGroup" }, UpdateKeyGroupRequest, UpdateKeyGroupResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("KeyGroupAlreadyExists", KeyGroupAlreadyExists), ErrorAnnotation("NoSuchResource", NoSuchResource), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("TooManyPublicKeysInKeyGroup", TooManyPublicKeysInKeyGroup))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyCookiesInOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooLongCSPInResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidOriginAccessIdentity = Schema.Struct({Message: Schema.optional(Schema.String)})
const ActiveTrustedKeyGroups = Schema.Struct({Enabled: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(KGKeyPairIdsList)})
const TrafficConfig = Schema.Struct({SingleWeightConfig: Schema.optional(ContinuousDeploymentSingleWeightConfig), SingleHeaderConfig: Schema.optional(ContinuousDeploymentSingleHeaderConfig), Type: Schema.String})
const DefaultCacheBehavior = Schema.Struct({TargetOriginId: Schema.String, TrustedSigners: Schema.optional(TrustedSigners), TrustedKeyGroups: Schema.optional(TrustedKeyGroups), ViewerProtocolPolicy: Schema.String, AllowedMethods: Schema.optional(AllowedMethods), SmoothStreaming: Schema.optional(Schema.Boolean), Compress: Schema.optional(Schema.Boolean), LambdaFunctionAssociations: Schema.optional(LambdaFunctionAssociations), FunctionAssociations: Schema.optional(FunctionAssociations), FieldLevelEncryptionId: Schema.optional(Schema.String), RealtimeLogConfigArn: Schema.optional(Schema.String), CachePolicyId: Schema.optional(Schema.String), OriginRequestPolicyId: Schema.optional(Schema.String), ResponseHeadersPolicyId: Schema.optional(Schema.String), GrpcConfig: Schema.optional(GrpcConfig), ForwardedValues: Schema.optional(ForwardedValues), MinTTL: Schema.optional(Schema.Number), DefaultTTL: Schema.optional(Schema.Number), MaxTTL: Schema.optional(Schema.Number)})
const QueryArgProfileConfig = Schema.Struct({ForwardWhenQueryArgProfileIsUnknown: Schema.Boolean, QueryArgProfiles: Schema.optional(QueryArgProfiles)})
const ContentTypeProfileConfig = Schema.Struct({ForwardWhenContentTypeIsUnknown: Schema.Boolean, ContentTypeProfiles: Schema.optional(ContentTypeProfiles)})
const EncryptionEntities = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(EncryptionEntityList)})
const KeyPairIds = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(KeyPairIdList)})
const CustomHeaders = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(OriginCustomHeadersList)})
const OriginGroupFailoverCriteria = Schema.Struct({StatusCodes: StatusCodes})
const OriginGroupMembers = Schema.Struct({Quantity: Schema.Number, Items: OriginGroupMemberList})
const ParameterDefinitionSchema = Schema.Struct({StringSchema: Schema.optional(StringSchemaConfig)})
const ContinuousDeploymentPolicyConfig = Schema.Struct({StagingDistributionDnsNames: StagingDistributionDnsNames, Enabled: Schema.Boolean, TrafficConfig: Schema.optional(TrafficConfig)})
const FieldLevelEncryptionConfig = Schema.Struct({CallerReference: Schema.String, Comment: Schema.optional(Schema.String), QueryArgProfileConfig: Schema.optional(QueryArgProfileConfig), ContentTypeProfileConfig: Schema.optional(ContentTypeProfileConfig)})
const FieldLevelEncryptionProfileConfig = Schema.Struct({Name: Schema.String, CallerReference: Schema.String, Comment: Schema.optional(Schema.String), EncryptionEntities: EncryptionEntities})
const Signer = Schema.Struct({AwsAccountNumber: Schema.optional(Schema.String), KeyPairIds: Schema.optional(KeyPairIds)})
const SignerList = Schema.Array(Signer)
const Origin = Schema.Struct({Id: Schema.String, DomainName: Schema.String, OriginPath: Schema.optional(Schema.String), CustomHeaders: Schema.optional(CustomHeaders), S3OriginConfig: Schema.optional(S3OriginConfig), CustomOriginConfig: Schema.optional(CustomOriginConfig), VpcOriginConfig: Schema.optional(VpcOriginConfig), ConnectionAttempts: Schema.optional(Schema.Number), ConnectionTimeout: Schema.optional(Schema.Number), ResponseCompletionTimeout: Schema.optional(Schema.Number), OriginShield: Schema.optional(OriginShield), OriginAccessControlId: Schema.optional(Schema.String)})
const OriginList = Schema.Array(Origin)
const OriginGroup = Schema.Struct({Id: Schema.String, FailoverCriteria: OriginGroupFailoverCriteria, Members: OriginGroupMembers, SelectionCriteria: Schema.optional(Schema.String)})
const OriginGroupList = Schema.Array(OriginGroup)
const ParameterDefinition = Schema.Struct({Name: Schema.String, Definition: ParameterDefinitionSchema})
const ParameterDefinitions = Schema.Array(ParameterDefinition)
const CreateCachePolicyResult = Schema.Struct({CachePolicy: Schema.optional(Body("undefined", CachePolicy)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const TooManyCloudFrontOriginAccessIdentities = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateCloudFrontOriginAccessIdentity = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-access-identity/cloudfront", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateCloudFrontOriginAccessIdentity" }, CreateCloudFrontOriginAccessIdentityRequest, CreateCloudFrontOriginAccessIdentityResult, Schema.Union(ErrorAnnotation("CloudFrontOriginAccessIdentityAlreadyExists", CloudFrontOriginAccessIdentityAlreadyExists), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("TooManyCloudFrontOriginAccessIdentities", TooManyCloudFrontOriginAccessIdentities))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateContinuousDeploymentPolicyRequest = Schema.Struct({ContinuousDeploymentPolicyConfig: Body("ContinuousDeploymentPolicyConfig", ContinuousDeploymentPolicyConfig)})
const InvalidDomainNameForOriginAccessControl = Schema.Struct({Message: Schema.optional(Schema.String)})
const CreateFieldLevelEncryptionConfigRequest = Schema.Struct({FieldLevelEncryptionConfig: Body("FieldLevelEncryptionConfig", FieldLevelEncryptionConfig)})
const CreateFieldLevelEncryptionProfileRequest = Schema.Struct({FieldLevelEncryptionProfileConfig: Body("FieldLevelEncryptionProfileConfig", FieldLevelEncryptionProfileConfig)})
const CreateFunctionResult = Schema.Struct({FunctionSummary: Schema.optional(Body("undefined", FunctionSummary)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const TooManyInvalidationsInProgress = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateInvalidation = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution/{DistributionId}/invalidation", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateInvalidation" }, CreateInvalidationRequest, CreateInvalidationResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("BatchTooLarge", BatchTooLarge), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("TooManyInvalidationsInProgress", TooManyInvalidationsInProgress))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const MonitoringSubscriptionAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateMonitoringSubscription = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distributions/{DistributionId}/monitoring-subscription", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateMonitoringSubscription" }, CreateMonitoringSubscriptionRequest, CreateMonitoringSubscriptionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("MonitoringSubscriptionAlreadyExists", MonitoringSubscriptionAlreadyExists), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateOriginRequestPolicyResult = Schema.Struct({OriginRequestPolicy: Schema.optional(Body("undefined", OriginRequestPolicy)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const TooManyPublicKeys = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreatePublicKey = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/public-key", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreatePublicKey" }, CreatePublicKeyRequest, CreatePublicKeyResult, Schema.Union(ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("PublicKeyAlreadyExists", PublicKeyAlreadyExists), ErrorAnnotation("TooManyPublicKeys", TooManyPublicKeys))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const RealtimeLogConfigAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const CreateResponseHeadersPolicyResult = Schema.Struct({ResponseHeadersPolicy: Schema.optional(Body("undefined", ResponseHeadersPolicy)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const StreamingDistributionAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyStreamingDistributionCNAMEs = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyHeadersInCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidErrorCode = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidForwardCookies = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyFieldLevelEncryptionQueryArgProfiles = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateFieldLevelEncryptionConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/field-level-encryption/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateFieldLevelEncryptionConfig" }, UpdateFieldLevelEncryptionConfigRequest, UpdateFieldLevelEncryptionConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("NoSuchFieldLevelEncryptionProfile", NoSuchFieldLevelEncryptionProfile), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("QueryArgProfileEmpty", QueryArgProfileEmpty), ErrorAnnotation("TooManyFieldLevelEncryptionContentTypeProfiles", TooManyFieldLevelEncryptionContentTypeProfiles), ErrorAnnotation("TooManyFieldLevelEncryptionQueryArgProfiles", TooManyFieldLevelEncryptionQueryArgProfiles))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyFieldLevelEncryptionEncryptionEntities = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyHeadersInOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyCustomHeadersInResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateResponseHeadersPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/response-headers-policy/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateResponseHeadersPolicy" }, UpdateResponseHeadersPolicyRequest, UpdateResponseHeadersPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("ResponseHeadersPolicyAlreadyExists", ResponseHeadersPolicyAlreadyExists), ErrorAnnotation("TooLongCSPInResponseHeadersPolicy", TooLongCSPInResponseHeadersPolicy), ErrorAnnotation("TooManyCustomHeadersInResponseHeadersPolicy", TooManyCustomHeadersInResponseHeadersPolicy), ErrorAnnotation("TooManyRemoveHeadersInResponseHeadersPolicy", TooManyRemoveHeadersInResponseHeadersPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyTrustedSigners = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateStreamingDistribution = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/streaming-distribution/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateStreamingDistribution" }, UpdateStreamingDistributionRequest, UpdateStreamingDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchStreamingDistribution", NoSuchStreamingDistribution), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("TooManyStreamingDistributionCNAMEs", TooManyStreamingDistributionCNAMEs), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const ActiveTrustedSigners = Schema.Struct({Enabled: Schema.Boolean, Quantity: Schema.Number, Items: Schema.optional(SignerList)})
const Origins = Schema.Struct({Quantity: Schema.Number, Items: OriginList})
const OriginGroups = Schema.Struct({Quantity: Schema.Number, Items: Schema.optional(OriginGroupList)})
const TenantConfig = Schema.Struct({ParameterDefinitions: Schema.optional(ParameterDefinitions)})
const Distribution = Schema.Struct({Id: Schema.String, ARN: Schema.String, Status: Schema.String, LastModifiedTime: Schema.Date, InProgressInvalidationBatches: Schema.Number, DomainName: Schema.String, ActiveTrustedSigners: Schema.optional(ActiveTrustedSigners), ActiveTrustedKeyGroups: Schema.optional(ActiveTrustedKeyGroups), DistributionConfig: DistributionConfig, AliasICPRecordals: Schema.optional(AliasICPRecordals)})
const DistributionConfig = Schema.Struct({CallerReference: Schema.String, Aliases: Schema.optional(Aliases), DefaultRootObject: Schema.optional(Schema.String), Origins: Origins, OriginGroups: Schema.optional(OriginGroups), DefaultCacheBehavior: DefaultCacheBehavior, CacheBehaviors: Schema.optional(CacheBehaviors), CustomErrorResponses: Schema.optional(CustomErrorResponses), Comment: Schema.String, Logging: Schema.optional(LoggingConfig), PriceClass: Schema.optional(Schema.String), Enabled: Schema.Boolean, ViewerCertificate: Schema.optional(ViewerCertificate), Restrictions: Schema.optional(Restrictions), WebACLId: Schema.optional(Schema.String), HttpVersion: Schema.optional(Schema.String), IsIPV6Enabled: Schema.optional(Schema.Boolean), ContinuousDeploymentPolicyId: Schema.optional(Schema.String), Staging: Schema.optional(Schema.Boolean), AnycastIpListId: Schema.optional(Schema.String), TenantConfig: Schema.optional(TenantConfig), ConnectionMode: Schema.optional(Schema.String)})
const CopyDistributionResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const TooManyCachePolicies = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateCachePolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/cache-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateCachePolicy" }, CreateCachePolicyRequest, CreateCachePolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CachePolicyAlreadyExists", CachePolicyAlreadyExists), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("TooManyCachePolicies", TooManyCachePolicies), ErrorAnnotation("TooManyCookiesInCachePolicy", TooManyCookiesInCachePolicy), ErrorAnnotation("TooManyHeadersInCachePolicy", TooManyHeadersInCachePolicy), ErrorAnnotation("TooManyQueryStringsInCachePolicy", TooManyQueryStringsInCachePolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const CreateContinuousDeploymentPolicyResult = Schema.Struct({ContinuousDeploymentPolicy: Schema.optional(Body("undefined", ContinuousDeploymentPolicy)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const CreateDistributionRequest = Schema.Struct({DistributionConfig: Body("DistributionConfig", DistributionConfig)})
const InvalidFunctionAssociation = Schema.Struct({Message: Schema.optional(Schema.String)})
const CreateFieldLevelEncryptionConfigResult = Schema.Struct({FieldLevelEncryption: Schema.optional(Body("undefined", FieldLevelEncryption)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const CreateFieldLevelEncryptionProfileResult = Schema.Struct({FieldLevelEncryptionProfile: Schema.optional(Body("undefined", FieldLevelEncryptionProfile)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const FunctionAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyOriginRequestPolicies = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateOriginRequestPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-request-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateOriginRequestPolicy" }, CreateOriginRequestPolicyRequest, CreateOriginRequestPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("OriginRequestPolicyAlreadyExists", OriginRequestPolicyAlreadyExists), ErrorAnnotation("TooManyCookiesInOriginRequestPolicy", TooManyCookiesInOriginRequestPolicy), ErrorAnnotation("TooManyHeadersInOriginRequestPolicy", TooManyHeadersInOriginRequestPolicy), ErrorAnnotation("TooManyOriginRequestPolicies", TooManyOriginRequestPolicies), ErrorAnnotation("TooManyQueryStringsInOriginRequestPolicy", TooManyQueryStringsInOriginRequestPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyRealtimeLogConfigs = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateRealtimeLogConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/realtime-log-config", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateRealtimeLogConfig" }, CreateRealtimeLogConfigRequest, CreateRealtimeLogConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("RealtimeLogConfigAlreadyExists", RealtimeLogConfigAlreadyExists), ErrorAnnotation("TooManyRealtimeLogConfigs", TooManyRealtimeLogConfigs))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyRemoveHeadersInResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyStreamingDistributions = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateStreamingDistribution = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/streaming-distribution", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateStreamingDistribution" }, CreateStreamingDistributionRequest, CreateStreamingDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidOrigin", InvalidOrigin), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("StreamingDistributionAlreadyExists", StreamingDistributionAlreadyExists), ErrorAnnotation("TooManyStreamingDistributionCNAMEs", TooManyStreamingDistributionCNAMEs), ErrorAnnotation("TooManyStreamingDistributions", TooManyStreamingDistributions), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TrustedSignerDoesNotExist = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateStreamingDistributionWithTags = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/streaming-distribution?WithTags", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateStreamingDistributionWithTags" }, CreateStreamingDistributionWithTagsRequest, CreateStreamingDistributionWithTagsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidOrigin", InvalidOrigin), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("StreamingDistributionAlreadyExists", StreamingDistributionAlreadyExists), ErrorAnnotation("TooManyStreamingDistributionCNAMEs", TooManyStreamingDistributionCNAMEs), ErrorAnnotation("TooManyStreamingDistributions", TooManyStreamingDistributions), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyQueryStringsInCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateCachePolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/cache-policy/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateCachePolicy" }, UpdateCachePolicyRequest, UpdateCachePolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CachePolicyAlreadyExists", CachePolicyAlreadyExists), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("TooManyCookiesInCachePolicy", TooManyCookiesInCachePolicy), ErrorAnnotation("TooManyHeadersInCachePolicy", TooManyHeadersInCachePolicy), ErrorAnnotation("TooManyQueryStringsInCachePolicy", TooManyQueryStringsInCachePolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidGeoRestrictionParameter = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidHeadersForS3Origin = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyFieldLevelEncryptionFieldPatterns = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateFieldLevelEncryptionProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/field-level-encryption-profile/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateFieldLevelEncryptionProfile" }, UpdateFieldLevelEncryptionProfileRequest, UpdateFieldLevelEncryptionProfileResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("FieldLevelEncryptionProfileAlreadyExists", FieldLevelEncryptionProfileAlreadyExists), ErrorAnnotation("FieldLevelEncryptionProfileSizeExceeded", FieldLevelEncryptionProfileSizeExceeded), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchFieldLevelEncryptionProfile", NoSuchFieldLevelEncryptionProfile), ErrorAnnotation("NoSuchPublicKey", NoSuchPublicKey), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("TooManyFieldLevelEncryptionEncryptionEntities", TooManyFieldLevelEncryptionEncryptionEntities), ErrorAnnotation("TooManyFieldLevelEncryptionFieldPatterns", TooManyFieldLevelEncryptionFieldPatterns))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyQueryStringsInOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateOriginRequestPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/origin-request-policy/{Id}", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateOriginRequestPolicy" }, UpdateOriginRequestPolicyRequest, UpdateOriginRequestPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("OriginRequestPolicyAlreadyExists", OriginRequestPolicyAlreadyExists), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("TooManyCookiesInOriginRequestPolicy", TooManyCookiesInOriginRequestPolicy), ErrorAnnotation("TooManyHeadersInOriginRequestPolicy", TooManyHeadersInOriginRequestPolicy), ErrorAnnotation("TooManyQueryStringsInOriginRequestPolicy", TooManyQueryStringsInOriginRequestPolicy))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidLambdaFunctionAssociation = Schema.Struct({Message: Schema.optional(Schema.String)})
const ContinuousDeploymentPolicyAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const CreateDistributionResult = Schema.Struct({Distribution: Schema.optional(Body("undefined", Distribution)), Location: Schema.optional(Header("Location")), ETag: Schema.optional(Header("ETag"))})
const InvalidLocationCode = Schema.Struct({Message: Schema.optional(Schema.String)})
const FieldLevelEncryptionConfigAlreadyExists = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyFieldLevelEncryptionProfiles = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateFieldLevelEncryptionProfile = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/field-level-encryption-profile", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateFieldLevelEncryptionProfile" }, CreateFieldLevelEncryptionProfileRequest, CreateFieldLevelEncryptionProfileResult, Schema.Union(ErrorAnnotation("FieldLevelEncryptionProfileAlreadyExists", FieldLevelEncryptionProfileAlreadyExists), ErrorAnnotation("FieldLevelEncryptionProfileSizeExceeded", FieldLevelEncryptionProfileSizeExceeded), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchPublicKey", NoSuchPublicKey), ErrorAnnotation("TooManyFieldLevelEncryptionEncryptionEntities", TooManyFieldLevelEncryptionEncryptionEntities), ErrorAnnotation("TooManyFieldLevelEncryptionFieldPatterns", TooManyFieldLevelEncryptionFieldPatterns), ErrorAnnotation("TooManyFieldLevelEncryptionProfiles", TooManyFieldLevelEncryptionProfiles))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyFunctions = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateFunction = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/function", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateFunction" }, CreateFunctionRequest, CreateFunctionResult, Schema.Union(ErrorAnnotation("FunctionAlreadyExists", FunctionAlreadyExists), ErrorAnnotation("FunctionSizeLimitExceeded", FunctionSizeLimitExceeded), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("TooManyFunctions", TooManyFunctions), ErrorAnnotation("UnsupportedOperation", UnsupportedOperation))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyResponseHeadersPolicies = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateResponseHeadersPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/response-headers-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateResponseHeadersPolicy" }, CreateResponseHeadersPolicyRequest, CreateResponseHeadersPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("ResponseHeadersPolicyAlreadyExists", ResponseHeadersPolicyAlreadyExists), ErrorAnnotation("TooLongCSPInResponseHeadersPolicy", TooLongCSPInResponseHeadersPolicy), ErrorAnnotation("TooManyCustomHeadersInResponseHeadersPolicy", TooManyCustomHeadersInResponseHeadersPolicy), ErrorAnnotation("TooManyRemoveHeadersInResponseHeadersPolicy", TooManyRemoveHeadersInResponseHeadersPolicy), ErrorAnnotation("TooManyResponseHeadersPolicies", TooManyResponseHeadersPolicies))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidMinimumProtocolVersion = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidOriginKeepaliveTimeout = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidOriginReadTimeout = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyContinuousDeploymentPolicies = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateContinuousDeploymentPolicy = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/continuous-deployment-policy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateContinuousDeploymentPolicy" }, CreateContinuousDeploymentPolicyRequest, CreateContinuousDeploymentPolicyResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("ContinuousDeploymentPolicyAlreadyExists", ContinuousDeploymentPolicyAlreadyExists), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("StagingDistributionInUse", StagingDistributionInUse), ErrorAnnotation("TooManyContinuousDeploymentPolicies", TooManyContinuousDeploymentPolicies))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidProtocolSettings = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidQueryStringParameters = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyFieldLevelEncryptionConfigs = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateFieldLevelEncryptionConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/field-level-encryption", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateFieldLevelEncryptionConfig" }, CreateFieldLevelEncryptionConfigRequest, CreateFieldLevelEncryptionConfigResult, Schema.Union(ErrorAnnotation("FieldLevelEncryptionConfigAlreadyExists", FieldLevelEncryptionConfigAlreadyExists), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("NoSuchFieldLevelEncryptionProfile", NoSuchFieldLevelEncryptionProfile), ErrorAnnotation("QueryArgProfileEmpty", QueryArgProfileEmpty), ErrorAnnotation("TooManyFieldLevelEncryptionConfigs", TooManyFieldLevelEncryptionConfigs), ErrorAnnotation("TooManyFieldLevelEncryptionContentTypeProfiles", TooManyFieldLevelEncryptionContentTypeProfiles), ErrorAnnotation("TooManyFieldLevelEncryptionQueryArgProfiles", TooManyFieldLevelEncryptionQueryArgProfiles))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const InvalidRelativePath = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidRequiredProtocol = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidResponseCode = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidTTLOrder = Schema.Struct({Message: Schema.optional(Schema.String)})
const InvalidViewerCertificate = Schema.Struct({Message: Schema.optional(Schema.String)})
const NoSuchOrigin = Schema.Struct({Message: Schema.optional(Schema.String)})
const RealtimeLogConfigOwnerMismatch = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyCacheBehaviors = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyCertificates = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyCookieNamesInWhiteList = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyDistributionsAssociatedToCachePolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyDistributionsAssociatedToFieldLevelEncryptionConfig = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyDistributions = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyDistributionsAssociatedToKeyGroup = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyDistributionsAssociatedToOriginAccessControl = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyDistributionsAssociatedToOriginRequestPolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyDistributionsAssociatedToResponseHeadersPolicy = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyDistributionsWithFunctionAssociations = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyDistributionsWithLambdaAssociations = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyDistributionsWithSingleFunctionARN = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyFunctionAssociations = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyHeadersInForwardedValues = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyKeyGroupsAssociatedToDistribution = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyLambdaFunctionAssociations = Schema.Struct({Message: Schema.optional(Schema.String)})
const TooManyOriginCustomHeaders = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateDistributionWithTags = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution?WithTags", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateDistributionWithTags" }, CreateDistributionWithTagsRequest, CreateDistributionWithTagsResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("ContinuousDeploymentPolicyInUse", ContinuousDeploymentPolicyInUse), ErrorAnnotation("DistributionAlreadyExists", DistributionAlreadyExists), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior", IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior), ErrorAnnotation("IllegalOriginAccessConfiguration", IllegalOriginAccessConfiguration), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidDefaultRootObject", InvalidDefaultRootObject), ErrorAnnotation("InvalidDomainNameForOriginAccessControl", InvalidDomainNameForOriginAccessControl), ErrorAnnotation("InvalidErrorCode", InvalidErrorCode), ErrorAnnotation("InvalidForwardCookies", InvalidForwardCookies), ErrorAnnotation("InvalidFunctionAssociation", InvalidFunctionAssociation), ErrorAnnotation("InvalidGeoRestrictionParameter", InvalidGeoRestrictionParameter), ErrorAnnotation("InvalidHeadersForS3Origin", InvalidHeadersForS3Origin), ErrorAnnotation("InvalidLambdaFunctionAssociation", InvalidLambdaFunctionAssociation), ErrorAnnotation("InvalidLocationCode", InvalidLocationCode), ErrorAnnotation("InvalidMinimumProtocolVersion", InvalidMinimumProtocolVersion), ErrorAnnotation("InvalidOrigin", InvalidOrigin), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("InvalidOriginKeepaliveTimeout", InvalidOriginKeepaliveTimeout), ErrorAnnotation("InvalidOriginReadTimeout", InvalidOriginReadTimeout), ErrorAnnotation("InvalidProtocolSettings", InvalidProtocolSettings), ErrorAnnotation("InvalidQueryStringParameters", InvalidQueryStringParameters), ErrorAnnotation("InvalidRelativePath", InvalidRelativePath), ErrorAnnotation("InvalidRequiredProtocol", InvalidRequiredProtocol), ErrorAnnotation("InvalidResponseCode", InvalidResponseCode), ErrorAnnotation("InvalidTagging", InvalidTagging), ErrorAnnotation("InvalidTTLOrder", InvalidTTLOrder), ErrorAnnotation("InvalidViewerCertificate", InvalidViewerCertificate), ErrorAnnotation("InvalidWebACLId", InvalidWebACLId), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("NoSuchOrigin", NoSuchOrigin), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("RealtimeLogConfigOwnerMismatch", RealtimeLogConfigOwnerMismatch), ErrorAnnotation("TooManyCacheBehaviors", TooManyCacheBehaviors), ErrorAnnotation("TooManyCertificates", TooManyCertificates), ErrorAnnotation("TooManyCookieNamesInWhiteList", TooManyCookieNamesInWhiteList), ErrorAnnotation("TooManyDistributionCNAMEs", TooManyDistributionCNAMEs), ErrorAnnotation("TooManyDistributions", TooManyDistributions), ErrorAnnotation("TooManyDistributionsAssociatedToCachePolicy", TooManyDistributionsAssociatedToCachePolicy), ErrorAnnotation("TooManyDistributionsAssociatedToFieldLevelEncryptionConfig", TooManyDistributionsAssociatedToFieldLevelEncryptionConfig), ErrorAnnotation("TooManyDistributionsAssociatedToKeyGroup", TooManyDistributionsAssociatedToKeyGroup), ErrorAnnotation("TooManyDistributionsAssociatedToOriginAccessControl", TooManyDistributionsAssociatedToOriginAccessControl), ErrorAnnotation("TooManyDistributionsAssociatedToOriginRequestPolicy", TooManyDistributionsAssociatedToOriginRequestPolicy), ErrorAnnotation("TooManyDistributionsAssociatedToResponseHeadersPolicy", TooManyDistributionsAssociatedToResponseHeadersPolicy), ErrorAnnotation("TooManyDistributionsWithFunctionAssociations", TooManyDistributionsWithFunctionAssociations), ErrorAnnotation("TooManyDistributionsWithLambdaAssociations", TooManyDistributionsWithLambdaAssociations), ErrorAnnotation("TooManyDistributionsWithSingleFunctionARN", TooManyDistributionsWithSingleFunctionARN), ErrorAnnotation("TooManyFunctionAssociations", TooManyFunctionAssociations), ErrorAnnotation("TooManyHeadersInForwardedValues", TooManyHeadersInForwardedValues), ErrorAnnotation("TooManyKeyGroupsAssociatedToDistribution", TooManyKeyGroupsAssociatedToDistribution), ErrorAnnotation("TooManyLambdaFunctionAssociations", TooManyLambdaFunctionAssociations), ErrorAnnotation("TooManyOriginCustomHeaders", TooManyOriginCustomHeaders), ErrorAnnotation("TooManyOriginGroupsPerDistribution", TooManyOriginGroupsPerDistribution), ErrorAnnotation("TooManyOrigins", TooManyOrigins), ErrorAnnotation("TooManyQueryStringParameters", TooManyQueryStringParameters), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedKeyGroupDoesNotExist", TrustedKeyGroupDoesNotExist), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyOriginGroupsPerDistribution = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateDistribution = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution/{Id}/config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateDistribution" }, UpdateDistributionRequest, UpdateDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("ContinuousDeploymentPolicyInUse", ContinuousDeploymentPolicyInUse), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior", IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior), ErrorAnnotation("IllegalOriginAccessConfiguration", IllegalOriginAccessConfiguration), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidDefaultRootObject", InvalidDefaultRootObject), ErrorAnnotation("InvalidDomainNameForOriginAccessControl", InvalidDomainNameForOriginAccessControl), ErrorAnnotation("InvalidErrorCode", InvalidErrorCode), ErrorAnnotation("InvalidForwardCookies", InvalidForwardCookies), ErrorAnnotation("InvalidFunctionAssociation", InvalidFunctionAssociation), ErrorAnnotation("InvalidGeoRestrictionParameter", InvalidGeoRestrictionParameter), ErrorAnnotation("InvalidHeadersForS3Origin", InvalidHeadersForS3Origin), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("InvalidLambdaFunctionAssociation", InvalidLambdaFunctionAssociation), ErrorAnnotation("InvalidLocationCode", InvalidLocationCode), ErrorAnnotation("InvalidMinimumProtocolVersion", InvalidMinimumProtocolVersion), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("InvalidOriginKeepaliveTimeout", InvalidOriginKeepaliveTimeout), ErrorAnnotation("InvalidOriginReadTimeout", InvalidOriginReadTimeout), ErrorAnnotation("InvalidQueryStringParameters", InvalidQueryStringParameters), ErrorAnnotation("InvalidRelativePath", InvalidRelativePath), ErrorAnnotation("InvalidRequiredProtocol", InvalidRequiredProtocol), ErrorAnnotation("InvalidResponseCode", InvalidResponseCode), ErrorAnnotation("InvalidTTLOrder", InvalidTTLOrder), ErrorAnnotation("InvalidViewerCertificate", InvalidViewerCertificate), ErrorAnnotation("InvalidWebACLId", InvalidWebACLId), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("NoSuchOrigin", NoSuchOrigin), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("RealtimeLogConfigOwnerMismatch", RealtimeLogConfigOwnerMismatch), ErrorAnnotation("StagingDistributionInUse", StagingDistributionInUse), ErrorAnnotation("TooManyCacheBehaviors", TooManyCacheBehaviors), ErrorAnnotation("TooManyCertificates", TooManyCertificates), ErrorAnnotation("TooManyCookieNamesInWhiteList", TooManyCookieNamesInWhiteList), ErrorAnnotation("TooManyDistributionCNAMEs", TooManyDistributionCNAMEs), ErrorAnnotation("TooManyDistributionsAssociatedToCachePolicy", TooManyDistributionsAssociatedToCachePolicy), ErrorAnnotation("TooManyDistributionsAssociatedToFieldLevelEncryptionConfig", TooManyDistributionsAssociatedToFieldLevelEncryptionConfig), ErrorAnnotation("TooManyDistributionsAssociatedToKeyGroup", TooManyDistributionsAssociatedToKeyGroup), ErrorAnnotation("TooManyDistributionsAssociatedToOriginAccessControl", TooManyDistributionsAssociatedToOriginAccessControl), ErrorAnnotation("TooManyDistributionsAssociatedToOriginRequestPolicy", TooManyDistributionsAssociatedToOriginRequestPolicy), ErrorAnnotation("TooManyDistributionsAssociatedToResponseHeadersPolicy", TooManyDistributionsAssociatedToResponseHeadersPolicy), ErrorAnnotation("TooManyDistributionsWithFunctionAssociations", TooManyDistributionsWithFunctionAssociations), ErrorAnnotation("TooManyDistributionsWithLambdaAssociations", TooManyDistributionsWithLambdaAssociations), ErrorAnnotation("TooManyDistributionsWithSingleFunctionARN", TooManyDistributionsWithSingleFunctionARN), ErrorAnnotation("TooManyFunctionAssociations", TooManyFunctionAssociations), ErrorAnnotation("TooManyHeadersInForwardedValues", TooManyHeadersInForwardedValues), ErrorAnnotation("TooManyKeyGroupsAssociatedToDistribution", TooManyKeyGroupsAssociatedToDistribution), ErrorAnnotation("TooManyLambdaFunctionAssociations", TooManyLambdaFunctionAssociations), ErrorAnnotation("TooManyOriginCustomHeaders", TooManyOriginCustomHeaders), ErrorAnnotation("TooManyOriginGroupsPerDistribution", TooManyOriginGroupsPerDistribution), ErrorAnnotation("TooManyOrigins", TooManyOrigins), ErrorAnnotation("TooManyQueryStringParameters", TooManyQueryStringParameters), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedKeyGroupDoesNotExist", TrustedKeyGroupDoesNotExist), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyOrigins = Schema.Struct({Message: Schema.optional(Schema.String)})
export const UpdateDistributionWithStagingConfig = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution/{Id}/promote-staging-config", method: "PUT", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "UpdateDistributionWithStagingConfig" }, UpdateDistributionWithStagingConfigRequest, UpdateDistributionWithStagingConfigResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior", IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior), ErrorAnnotation("IllegalUpdate", IllegalUpdate), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidDefaultRootObject", InvalidDefaultRootObject), ErrorAnnotation("InvalidErrorCode", InvalidErrorCode), ErrorAnnotation("InvalidForwardCookies", InvalidForwardCookies), ErrorAnnotation("InvalidFunctionAssociation", InvalidFunctionAssociation), ErrorAnnotation("InvalidGeoRestrictionParameter", InvalidGeoRestrictionParameter), ErrorAnnotation("InvalidHeadersForS3Origin", InvalidHeadersForS3Origin), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("InvalidLambdaFunctionAssociation", InvalidLambdaFunctionAssociation), ErrorAnnotation("InvalidLocationCode", InvalidLocationCode), ErrorAnnotation("InvalidMinimumProtocolVersion", InvalidMinimumProtocolVersion), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("InvalidOriginKeepaliveTimeout", InvalidOriginKeepaliveTimeout), ErrorAnnotation("InvalidOriginReadTimeout", InvalidOriginReadTimeout), ErrorAnnotation("InvalidQueryStringParameters", InvalidQueryStringParameters), ErrorAnnotation("InvalidRelativePath", InvalidRelativePath), ErrorAnnotation("InvalidRequiredProtocol", InvalidRequiredProtocol), ErrorAnnotation("InvalidResponseCode", InvalidResponseCode), ErrorAnnotation("InvalidTTLOrder", InvalidTTLOrder), ErrorAnnotation("InvalidViewerCertificate", InvalidViewerCertificate), ErrorAnnotation("InvalidWebACLId", InvalidWebACLId), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("NoSuchOrigin", NoSuchOrigin), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("RealtimeLogConfigOwnerMismatch", RealtimeLogConfigOwnerMismatch), ErrorAnnotation("TooManyCacheBehaviors", TooManyCacheBehaviors), ErrorAnnotation("TooManyCertificates", TooManyCertificates), ErrorAnnotation("TooManyCookieNamesInWhiteList", TooManyCookieNamesInWhiteList), ErrorAnnotation("TooManyDistributionCNAMEs", TooManyDistributionCNAMEs), ErrorAnnotation("TooManyDistributionsAssociatedToCachePolicy", TooManyDistributionsAssociatedToCachePolicy), ErrorAnnotation("TooManyDistributionsAssociatedToFieldLevelEncryptionConfig", TooManyDistributionsAssociatedToFieldLevelEncryptionConfig), ErrorAnnotation("TooManyDistributionsAssociatedToKeyGroup", TooManyDistributionsAssociatedToKeyGroup), ErrorAnnotation("TooManyDistributionsAssociatedToOriginAccessControl", TooManyDistributionsAssociatedToOriginAccessControl), ErrorAnnotation("TooManyDistributionsAssociatedToOriginRequestPolicy", TooManyDistributionsAssociatedToOriginRequestPolicy), ErrorAnnotation("TooManyDistributionsAssociatedToResponseHeadersPolicy", TooManyDistributionsAssociatedToResponseHeadersPolicy), ErrorAnnotation("TooManyDistributionsWithFunctionAssociations", TooManyDistributionsWithFunctionAssociations), ErrorAnnotation("TooManyDistributionsWithLambdaAssociations", TooManyDistributionsWithLambdaAssociations), ErrorAnnotation("TooManyDistributionsWithSingleFunctionARN", TooManyDistributionsWithSingleFunctionARN), ErrorAnnotation("TooManyFunctionAssociations", TooManyFunctionAssociations), ErrorAnnotation("TooManyHeadersInForwardedValues", TooManyHeadersInForwardedValues), ErrorAnnotation("TooManyKeyGroupsAssociatedToDistribution", TooManyKeyGroupsAssociatedToDistribution), ErrorAnnotation("TooManyLambdaFunctionAssociations", TooManyLambdaFunctionAssociations), ErrorAnnotation("TooManyOriginCustomHeaders", TooManyOriginCustomHeaders), ErrorAnnotation("TooManyOriginGroupsPerDistribution", TooManyOriginGroupsPerDistribution), ErrorAnnotation("TooManyOrigins", TooManyOrigins), ErrorAnnotation("TooManyQueryStringParameters", TooManyQueryStringParameters), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedKeyGroupDoesNotExist", TrustedKeyGroupDoesNotExist), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TooManyQueryStringParameters = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CopyDistribution = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution/{PrimaryDistributionId}/copy", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CopyDistribution" }, CopyDistributionRequest, CopyDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("DistributionAlreadyExists", DistributionAlreadyExists), ErrorAnnotation("IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior", IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidDefaultRootObject", InvalidDefaultRootObject), ErrorAnnotation("InvalidErrorCode", InvalidErrorCode), ErrorAnnotation("InvalidForwardCookies", InvalidForwardCookies), ErrorAnnotation("InvalidFunctionAssociation", InvalidFunctionAssociation), ErrorAnnotation("InvalidGeoRestrictionParameter", InvalidGeoRestrictionParameter), ErrorAnnotation("InvalidHeadersForS3Origin", InvalidHeadersForS3Origin), ErrorAnnotation("InvalidIfMatchVersion", InvalidIfMatchVersion), ErrorAnnotation("InvalidLambdaFunctionAssociation", InvalidLambdaFunctionAssociation), ErrorAnnotation("InvalidLocationCode", InvalidLocationCode), ErrorAnnotation("InvalidMinimumProtocolVersion", InvalidMinimumProtocolVersion), ErrorAnnotation("InvalidOrigin", InvalidOrigin), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("InvalidOriginKeepaliveTimeout", InvalidOriginKeepaliveTimeout), ErrorAnnotation("InvalidOriginReadTimeout", InvalidOriginReadTimeout), ErrorAnnotation("InvalidProtocolSettings", InvalidProtocolSettings), ErrorAnnotation("InvalidQueryStringParameters", InvalidQueryStringParameters), ErrorAnnotation("InvalidRelativePath", InvalidRelativePath), ErrorAnnotation("InvalidRequiredProtocol", InvalidRequiredProtocol), ErrorAnnotation("InvalidResponseCode", InvalidResponseCode), ErrorAnnotation("InvalidTTLOrder", InvalidTTLOrder), ErrorAnnotation("InvalidViewerCertificate", InvalidViewerCertificate), ErrorAnnotation("InvalidWebACLId", InvalidWebACLId), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("NoSuchDistribution", NoSuchDistribution), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("NoSuchOrigin", NoSuchOrigin), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("PreconditionFailed", PreconditionFailed), ErrorAnnotation("RealtimeLogConfigOwnerMismatch", RealtimeLogConfigOwnerMismatch), ErrorAnnotation("TooManyCacheBehaviors", TooManyCacheBehaviors), ErrorAnnotation("TooManyCertificates", TooManyCertificates), ErrorAnnotation("TooManyCookieNamesInWhiteList", TooManyCookieNamesInWhiteList), ErrorAnnotation("TooManyDistributionCNAMEs", TooManyDistributionCNAMEs), ErrorAnnotation("TooManyDistributions", TooManyDistributions), ErrorAnnotation("TooManyDistributionsAssociatedToCachePolicy", TooManyDistributionsAssociatedToCachePolicy), ErrorAnnotation("TooManyDistributionsAssociatedToFieldLevelEncryptionConfig", TooManyDistributionsAssociatedToFieldLevelEncryptionConfig), ErrorAnnotation("TooManyDistributionsAssociatedToKeyGroup", TooManyDistributionsAssociatedToKeyGroup), ErrorAnnotation("TooManyDistributionsAssociatedToOriginAccessControl", TooManyDistributionsAssociatedToOriginAccessControl), ErrorAnnotation("TooManyDistributionsAssociatedToOriginRequestPolicy", TooManyDistributionsAssociatedToOriginRequestPolicy), ErrorAnnotation("TooManyDistributionsAssociatedToResponseHeadersPolicy", TooManyDistributionsAssociatedToResponseHeadersPolicy), ErrorAnnotation("TooManyDistributionsWithFunctionAssociations", TooManyDistributionsWithFunctionAssociations), ErrorAnnotation("TooManyDistributionsWithLambdaAssociations", TooManyDistributionsWithLambdaAssociations), ErrorAnnotation("TooManyDistributionsWithSingleFunctionARN", TooManyDistributionsWithSingleFunctionARN), ErrorAnnotation("TooManyFunctionAssociations", TooManyFunctionAssociations), ErrorAnnotation("TooManyHeadersInForwardedValues", TooManyHeadersInForwardedValues), ErrorAnnotation("TooManyKeyGroupsAssociatedToDistribution", TooManyKeyGroupsAssociatedToDistribution), ErrorAnnotation("TooManyLambdaFunctionAssociations", TooManyLambdaFunctionAssociations), ErrorAnnotation("TooManyOriginCustomHeaders", TooManyOriginCustomHeaders), ErrorAnnotation("TooManyOriginGroupsPerDistribution", TooManyOriginGroupsPerDistribution), ErrorAnnotation("TooManyOrigins", TooManyOrigins), ErrorAnnotation("TooManyQueryStringParameters", TooManyQueryStringParameters), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedKeyGroupDoesNotExist", TrustedKeyGroupDoesNotExist), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
const TrustedKeyGroupDoesNotExist = Schema.Struct({Message: Schema.optional(Schema.String)})
export const CreateDistribution = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/2020-05-31/distribution", method: "POST", sdkId: "CloudFront", sigV4ServiceName: "cloudfront", name: "CreateDistribution" }, CreateDistributionRequest, CreateDistributionResult, Schema.Union(ErrorAnnotation("AccessDenied", AccessDenied), ErrorAnnotation("CNAMEAlreadyExists", CNAMEAlreadyExists), ErrorAnnotation("ContinuousDeploymentPolicyInUse", ContinuousDeploymentPolicyInUse), ErrorAnnotation("DistributionAlreadyExists", DistributionAlreadyExists), ErrorAnnotation("EntityLimitExceeded", EntityLimitExceeded), ErrorAnnotation("EntityNotFound", EntityNotFound), ErrorAnnotation("IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior", IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior), ErrorAnnotation("IllegalOriginAccessConfiguration", IllegalOriginAccessConfiguration), ErrorAnnotation("InconsistentQuantities", InconsistentQuantities), ErrorAnnotation("InvalidArgument", InvalidArgument), ErrorAnnotation("InvalidDefaultRootObject", InvalidDefaultRootObject), ErrorAnnotation("InvalidDomainNameForOriginAccessControl", InvalidDomainNameForOriginAccessControl), ErrorAnnotation("InvalidErrorCode", InvalidErrorCode), ErrorAnnotation("InvalidForwardCookies", InvalidForwardCookies), ErrorAnnotation("InvalidFunctionAssociation", InvalidFunctionAssociation), ErrorAnnotation("InvalidGeoRestrictionParameter", InvalidGeoRestrictionParameter), ErrorAnnotation("InvalidHeadersForS3Origin", InvalidHeadersForS3Origin), ErrorAnnotation("InvalidLambdaFunctionAssociation", InvalidLambdaFunctionAssociation), ErrorAnnotation("InvalidLocationCode", InvalidLocationCode), ErrorAnnotation("InvalidMinimumProtocolVersion", InvalidMinimumProtocolVersion), ErrorAnnotation("InvalidOrigin", InvalidOrigin), ErrorAnnotation("InvalidOriginAccessControl", InvalidOriginAccessControl), ErrorAnnotation("InvalidOriginAccessIdentity", InvalidOriginAccessIdentity), ErrorAnnotation("InvalidOriginKeepaliveTimeout", InvalidOriginKeepaliveTimeout), ErrorAnnotation("InvalidOriginReadTimeout", InvalidOriginReadTimeout), ErrorAnnotation("InvalidProtocolSettings", InvalidProtocolSettings), ErrorAnnotation("InvalidQueryStringParameters", InvalidQueryStringParameters), ErrorAnnotation("InvalidRelativePath", InvalidRelativePath), ErrorAnnotation("InvalidRequiredProtocol", InvalidRequiredProtocol), ErrorAnnotation("InvalidResponseCode", InvalidResponseCode), ErrorAnnotation("InvalidTTLOrder", InvalidTTLOrder), ErrorAnnotation("InvalidViewerCertificate", InvalidViewerCertificate), ErrorAnnotation("InvalidWebACLId", InvalidWebACLId), ErrorAnnotation("MissingBody", MissingBody), ErrorAnnotation("NoSuchCachePolicy", NoSuchCachePolicy), ErrorAnnotation("NoSuchContinuousDeploymentPolicy", NoSuchContinuousDeploymentPolicy), ErrorAnnotation("NoSuchFieldLevelEncryptionConfig", NoSuchFieldLevelEncryptionConfig), ErrorAnnotation("NoSuchOrigin", NoSuchOrigin), ErrorAnnotation("NoSuchOriginRequestPolicy", NoSuchOriginRequestPolicy), ErrorAnnotation("NoSuchRealtimeLogConfig", NoSuchRealtimeLogConfig), ErrorAnnotation("NoSuchResponseHeadersPolicy", NoSuchResponseHeadersPolicy), ErrorAnnotation("RealtimeLogConfigOwnerMismatch", RealtimeLogConfigOwnerMismatch), ErrorAnnotation("TooManyCacheBehaviors", TooManyCacheBehaviors), ErrorAnnotation("TooManyCertificates", TooManyCertificates), ErrorAnnotation("TooManyCookieNamesInWhiteList", TooManyCookieNamesInWhiteList), ErrorAnnotation("TooManyDistributionCNAMEs", TooManyDistributionCNAMEs), ErrorAnnotation("TooManyDistributions", TooManyDistributions), ErrorAnnotation("TooManyDistributionsAssociatedToCachePolicy", TooManyDistributionsAssociatedToCachePolicy), ErrorAnnotation("TooManyDistributionsAssociatedToFieldLevelEncryptionConfig", TooManyDistributionsAssociatedToFieldLevelEncryptionConfig), ErrorAnnotation("TooManyDistributionsAssociatedToKeyGroup", TooManyDistributionsAssociatedToKeyGroup), ErrorAnnotation("TooManyDistributionsAssociatedToOriginAccessControl", TooManyDistributionsAssociatedToOriginAccessControl), ErrorAnnotation("TooManyDistributionsAssociatedToOriginRequestPolicy", TooManyDistributionsAssociatedToOriginRequestPolicy), ErrorAnnotation("TooManyDistributionsAssociatedToResponseHeadersPolicy", TooManyDistributionsAssociatedToResponseHeadersPolicy), ErrorAnnotation("TooManyDistributionsWithFunctionAssociations", TooManyDistributionsWithFunctionAssociations), ErrorAnnotation("TooManyDistributionsWithLambdaAssociations", TooManyDistributionsWithLambdaAssociations), ErrorAnnotation("TooManyDistributionsWithSingleFunctionARN", TooManyDistributionsWithSingleFunctionARN), ErrorAnnotation("TooManyFunctionAssociations", TooManyFunctionAssociations), ErrorAnnotation("TooManyHeadersInForwardedValues", TooManyHeadersInForwardedValues), ErrorAnnotation("TooManyKeyGroupsAssociatedToDistribution", TooManyKeyGroupsAssociatedToDistribution), ErrorAnnotation("TooManyLambdaFunctionAssociations", TooManyLambdaFunctionAssociations), ErrorAnnotation("TooManyOriginCustomHeaders", TooManyOriginCustomHeaders), ErrorAnnotation("TooManyOriginGroupsPerDistribution", TooManyOriginGroupsPerDistribution), ErrorAnnotation("TooManyOrigins", TooManyOrigins), ErrorAnnotation("TooManyQueryStringParameters", TooManyQueryStringParameters), ErrorAnnotation("TooManyTrustedSigners", TooManyTrustedSigners), ErrorAnnotation("TrustedKeyGroupDoesNotExist", TrustedKeyGroupDoesNotExist), ErrorAnnotation("TrustedSignerDoesNotExist", TrustedSignerDoesNotExist))), FormatXMLRequest, FormatXMLResponse, FormatXMLResponse);
