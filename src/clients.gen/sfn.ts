import { Schema} from "effect"
import { FormatAwsJSON10Request,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const TagKeyList = Schema.Array(Schema.String);
export const DeleteActivityInput = Schema.Struct({activityArn: Schema.String});
export const DeleteActivityOutput = Schema.Struct({});
export const DeleteStateMachineInput = Schema.Struct({stateMachineArn: Schema.String});
export const DeleteStateMachineOutput = Schema.Struct({});
export const DeleteStateMachineAliasInput = Schema.Struct({stateMachineAliasArn: Schema.String});
export const DeleteStateMachineAliasOutput = Schema.Struct({});
export const DeleteStateMachineVersionInput = Schema.Struct({stateMachineVersionArn: Schema.String});
export const DeleteStateMachineVersionOutput = Schema.Struct({});
export const DescribeActivityInput = Schema.Struct({activityArn: Schema.String});
export const DescribeExecutionInput = Schema.Struct({executionArn: Schema.String, includedData: Schema.optional(Schema.String)});
export const DescribeMapRunInput = Schema.Struct({mapRunArn: Schema.String});
export const DescribeStateMachineInput = Schema.Struct({stateMachineArn: Schema.String, includedData: Schema.optional(Schema.String)});
export const DescribeStateMachineAliasInput = Schema.Struct({stateMachineAliasArn: Schema.String});
export const DescribeStateMachineForExecutionInput = Schema.Struct({executionArn: Schema.String, includedData: Schema.optional(Schema.String)});
export const GetActivityTaskInput = Schema.Struct({activityArn: Schema.String, workerName: Schema.optional(Schema.String)});
export const GetExecutionHistoryInput = Schema.Struct({executionArn: Schema.String, maxResults: Schema.optional(Schema.Number), reverseOrder: Schema.optional(Schema.Boolean), nextToken: Schema.optional(Schema.String), includeExecutionData: Schema.optional(Schema.Boolean)});
export const ListActivitiesInput = Schema.Struct({maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListExecutionsInput = Schema.Struct({stateMachineArn: Schema.optional(Schema.String), statusFilter: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), mapRunArn: Schema.optional(Schema.String), redriveFilter: Schema.optional(Schema.String)});
export const ListMapRunsInput = Schema.Struct({executionArn: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListStateMachineAliasesInput = Schema.Struct({stateMachineArn: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListStateMachinesInput = Schema.Struct({maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListStateMachineVersionsInput = Schema.Struct({stateMachineArn: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListTagsForResourceInput = Schema.Struct({resourceArn: Schema.String});
export const PublishStateMachineVersionInput = Schema.Struct({stateMachineArn: Schema.String, revisionId: Schema.optional(Schema.String), description: Schema.optional(Schema.String)});
export const RedriveExecutionInput = Schema.Struct({executionArn: Schema.String, clientToken: Schema.optional(Schema.String)});
export const SendTaskFailureInput = Schema.Struct({taskToken: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const SendTaskFailureOutput = Schema.Struct({});
export const SendTaskHeartbeatInput = Schema.Struct({taskToken: Schema.String});
export const SendTaskHeartbeatOutput = Schema.Struct({});
export const SendTaskSuccessInput = Schema.Struct({taskToken: Schema.String, output: Schema.String});
export const SendTaskSuccessOutput = Schema.Struct({});
export const StartExecutionInput = Schema.Struct({stateMachineArn: Schema.String, name: Schema.optional(Schema.String), input: Schema.optional(Schema.String), traceHeader: Schema.optional(Schema.String)});
export const StartSyncExecutionInput = Schema.Struct({stateMachineArn: Schema.String, name: Schema.optional(Schema.String), input: Schema.optional(Schema.String), traceHeader: Schema.optional(Schema.String), includedData: Schema.optional(Schema.String)});
export const StopExecutionInput = Schema.Struct({executionArn: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const Tag = Schema.Struct({key: Schema.optional(Schema.String), value: Schema.optional(Schema.String)});
export const TagList = Schema.Array(Tag);
export const TagResourceInput = Schema.Struct({resourceArn: Schema.String, tags: TagList});
export const TagResourceOutput = Schema.Struct({});
export const TestStateInput = Schema.Struct({definition: Schema.String, roleArn: Schema.optional(Schema.String), input: Schema.optional(Schema.String), inspectionLevel: Schema.optional(Schema.String), revealSecrets: Schema.optional(Schema.Boolean), variables: Schema.optional(Schema.String)});
export const UntagResourceInput = Schema.Struct({resourceArn: Schema.String, tagKeys: TagKeyList});
export const UntagResourceOutput = Schema.Struct({});
export const UpdateMapRunInput = Schema.Struct({mapRunArn: Schema.String, maxConcurrency: Schema.optional(Schema.Number), toleratedFailurePercentage: Schema.optional(Schema.Number), toleratedFailureCount: Schema.optional(Schema.Number)});
export const UpdateMapRunOutput = Schema.Struct({});
export const CloudWatchLogsLogGroup = Schema.Struct({logGroupArn: Schema.optional(Schema.String)});
export const LogDestination = Schema.Struct({cloudWatchLogsLogGroup: Schema.optional(CloudWatchLogsLogGroup)});
export const LogDestinationList = Schema.Array(LogDestination);
export const LoggingConfiguration = Schema.Struct({level: Schema.optional(Schema.String), includeExecutionData: Schema.optional(Schema.Boolean), destinations: Schema.optional(LogDestinationList)});
export const TracingConfiguration = Schema.Struct({enabled: Schema.optional(Schema.Boolean)});
export const EncryptionConfiguration = Schema.Struct({kmsKeyId: Schema.optional(Schema.String), kmsDataKeyReusePeriodSeconds: Schema.optional(Schema.Number), type: Schema.String});
export const UpdateStateMachineInput = Schema.Struct({stateMachineArn: Schema.String, definition: Schema.optional(Schema.String), roleArn: Schema.optional(Schema.String), loggingConfiguration: Schema.optional(LoggingConfiguration), tracingConfiguration: Schema.optional(TracingConfiguration), publish: Schema.optional(Schema.Boolean), versionDescription: Schema.optional(Schema.String), encryptionConfiguration: Schema.optional(EncryptionConfiguration)});
export const RoutingConfigurationListItem = Schema.Struct({stateMachineVersionArn: Schema.String, weight: Schema.Number});
export const RoutingConfigurationList = Schema.Array(RoutingConfigurationListItem);
export const UpdateStateMachineAliasInput = Schema.Struct({stateMachineAliasArn: Schema.String, description: Schema.optional(Schema.String), routingConfiguration: Schema.optional(RoutingConfigurationList)});
export const ValidateStateMachineDefinitionInput = Schema.Struct({definition: Schema.String, type: Schema.optional(Schema.String), severity: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const CreateActivityInput = Schema.Struct({name: Schema.String, tags: Schema.optional(TagList), encryptionConfiguration: Schema.optional(EncryptionConfiguration)});
export const CreateStateMachineAliasInput = Schema.Struct({description: Schema.optional(Schema.String), name: Schema.String, routingConfiguration: RoutingConfigurationList});
export const InvalidArn = Schema.Struct({message: Schema.optional(Schema.String)});
export const ValidationException = Schema.Struct({message: Schema.optional(Schema.String), reason: Schema.optional(Schema.String)});
export const ConflictException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeActivityOutput = Schema.Struct({activityArn: Schema.String, name: Schema.String, creationDate: Schema.Date, encryptionConfiguration: Schema.optional(EncryptionConfiguration)});
export const DescribeStateMachineAliasOutput = Schema.Struct({stateMachineAliasArn: Schema.optional(Schema.String), name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), routingConfiguration: Schema.optional(RoutingConfigurationList), creationDate: Schema.optional(Schema.Date), updateDate: Schema.optional(Schema.Date)});
export const VariableNameList = Schema.Array(Schema.String);
export const VariableReferences = Schema.Record({key: Schema.String, value: VariableNameList});
export const DescribeStateMachineForExecutionOutput = Schema.Struct({stateMachineArn: Schema.String, name: Schema.String, definition: Schema.String, roleArn: Schema.String, updateDate: Schema.Date, loggingConfiguration: Schema.optional(LoggingConfiguration), tracingConfiguration: Schema.optional(TracingConfiguration), mapRunArn: Schema.optional(Schema.String), label: Schema.optional(Schema.String), revisionId: Schema.optional(Schema.String), encryptionConfiguration: Schema.optional(EncryptionConfiguration), variableReferences: Schema.optional(VariableReferences)});
export const GetActivityTaskOutput = Schema.Struct({taskToken: Schema.optional(Schema.String), input: Schema.optional(Schema.String)});
export const ListTagsForResourceOutput = Schema.Struct({tags: Schema.optional(TagList)});
export const PublishStateMachineVersionOutput = Schema.Struct({creationDate: Schema.Date, stateMachineVersionArn: Schema.String});
export const RedriveExecutionOutput = Schema.Struct({redriveDate: Schema.Date});
export const InvalidToken = Schema.Struct({message: Schema.optional(Schema.String)});
export const TaskDoesNotExist = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidOutput = Schema.Struct({message: Schema.optional(Schema.String)});
export const StartExecutionOutput = Schema.Struct({executionArn: Schema.String, startDate: Schema.Date});
export const StopExecutionOutput = Schema.Struct({stopDate: Schema.Date});
export const ResourceNotFound = Schema.Struct({message: Schema.optional(Schema.String), resourceName: Schema.optional(Schema.String)});
export const UpdateStateMachineOutput = Schema.Struct({updateDate: Schema.Date, revisionId: Schema.optional(Schema.String), stateMachineVersionArn: Schema.optional(Schema.String)});
export const UpdateStateMachineAliasOutput = Schema.Struct({updateDate: Schema.Date});
export const CloudWatchEventsExecutionDataDetails = Schema.Struct({included: Schema.optional(Schema.Boolean)});
export const MapRunItemCounts = Schema.Struct({pending: Schema.Number, running: Schema.Number, succeeded: Schema.Number, failed: Schema.Number, timedOut: Schema.Number, aborted: Schema.Number, total: Schema.Number, resultsWritten: Schema.Number, failuresNotRedrivable: Schema.optional(Schema.Number), pendingRedrive: Schema.optional(Schema.Number)});
export const MapRunExecutionCounts = Schema.Struct({pending: Schema.Number, running: Schema.Number, succeeded: Schema.Number, failed: Schema.Number, timedOut: Schema.Number, aborted: Schema.Number, total: Schema.Number, resultsWritten: Schema.Number, failuresNotRedrivable: Schema.optional(Schema.Number), pendingRedrive: Schema.optional(Schema.Number)});
export const ActivityListItem = Schema.Struct({activityArn: Schema.String, name: Schema.String, creationDate: Schema.Date});
export const ActivityList = Schema.Array(ActivityListItem);
export const ExecutionListItem = Schema.Struct({executionArn: Schema.String, stateMachineArn: Schema.String, name: Schema.String, status: Schema.String, startDate: Schema.Date, stopDate: Schema.optional(Schema.Date), mapRunArn: Schema.optional(Schema.String), itemCount: Schema.optional(Schema.Number), stateMachineVersionArn: Schema.optional(Schema.String), stateMachineAliasArn: Schema.optional(Schema.String), redriveCount: Schema.optional(Schema.Number), redriveDate: Schema.optional(Schema.Date)});
export const ExecutionList = Schema.Array(ExecutionListItem);
export const MapRunListItem = Schema.Struct({executionArn: Schema.String, mapRunArn: Schema.String, stateMachineArn: Schema.String, startDate: Schema.Date, stopDate: Schema.optional(Schema.Date)});
export const MapRunList = Schema.Array(MapRunListItem);
export const StateMachineAliasListItem = Schema.Struct({stateMachineAliasArn: Schema.String, creationDate: Schema.Date});
export const StateMachineAliasList = Schema.Array(StateMachineAliasListItem);
export const StateMachineListItem = Schema.Struct({stateMachineArn: Schema.String, name: Schema.String, type: Schema.String, creationDate: Schema.Date});
export const StateMachineList = Schema.Array(StateMachineListItem);
export const StateMachineVersionListItem = Schema.Struct({stateMachineVersionArn: Schema.String, creationDate: Schema.Date});
export const StateMachineVersionList = Schema.Array(StateMachineVersionListItem);
export const BillingDetails = Schema.Struct({billedMemoryUsedInMB: Schema.optional(Schema.Number), billedDurationInMilliseconds: Schema.optional(Schema.Number)});
export const ValidateStateMachineDefinitionDiagnostic = Schema.Struct({severity: Schema.String, code: Schema.String, message: Schema.String, location: Schema.optional(Schema.String)});
export const ValidateStateMachineDefinitionDiagnosticList = Schema.Array(ValidateStateMachineDefinitionDiagnostic);
export const CreateActivityOutput = Schema.Struct({activityArn: Schema.String, creationDate: Schema.Date});
export const CreateStateMachineAliasOutput = Schema.Struct({stateMachineAliasArn: Schema.String, creationDate: Schema.Date});
export const ActivityDoesNotExist = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeExecutionOutput = Schema.Struct({executionArn: Schema.String, stateMachineArn: Schema.String, name: Schema.optional(Schema.String), status: Schema.String, startDate: Schema.Date, stopDate: Schema.optional(Schema.Date), input: Schema.optional(Schema.String), inputDetails: Schema.optional(CloudWatchEventsExecutionDataDetails), output: Schema.optional(Schema.String), outputDetails: Schema.optional(CloudWatchEventsExecutionDataDetails), traceHeader: Schema.optional(Schema.String), mapRunArn: Schema.optional(Schema.String), error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String), stateMachineVersionArn: Schema.optional(Schema.String), stateMachineAliasArn: Schema.optional(Schema.String), redriveCount: Schema.optional(Schema.Number), redriveDate: Schema.optional(Schema.Date), redriveStatus: Schema.optional(Schema.String), redriveStatusReason: Schema.optional(Schema.String)});
export const DescribeMapRunOutput = Schema.Struct({mapRunArn: Schema.String, executionArn: Schema.String, status: Schema.String, startDate: Schema.Date, stopDate: Schema.optional(Schema.Date), maxConcurrency: Schema.Number, toleratedFailurePercentage: Schema.Number, toleratedFailureCount: Schema.Number, itemCounts: MapRunItemCounts, executionCounts: MapRunExecutionCounts, redriveCount: Schema.optional(Schema.Number), redriveDate: Schema.optional(Schema.Date)});
export const DescribeStateMachineOutput = Schema.Struct({stateMachineArn: Schema.String, name: Schema.String, status: Schema.optional(Schema.String), definition: Schema.String, roleArn: Schema.String, type: Schema.String, creationDate: Schema.Date, loggingConfiguration: Schema.optional(LoggingConfiguration), tracingConfiguration: Schema.optional(TracingConfiguration), label: Schema.optional(Schema.String), revisionId: Schema.optional(Schema.String), description: Schema.optional(Schema.String), encryptionConfiguration: Schema.optional(EncryptionConfiguration), variableReferences: Schema.optional(VariableReferences)});
export const ExecutionDoesNotExist = Schema.Struct({message: Schema.optional(Schema.String)});
export const ActivityWorkerLimitExceeded = Schema.Struct({message: Schema.optional(Schema.String)});
export const ListActivitiesOutput = Schema.Struct({activities: ActivityList, nextToken: Schema.optional(Schema.String)});
export const ListExecutionsOutput = Schema.Struct({executions: ExecutionList, nextToken: Schema.optional(Schema.String)});
export const ListMapRunsOutput = Schema.Struct({mapRuns: MapRunList, nextToken: Schema.optional(Schema.String)});
export const ListStateMachineAliasesOutput = Schema.Struct({stateMachineAliases: StateMachineAliasList, nextToken: Schema.optional(Schema.String)});
export const ListStateMachinesOutput = Schema.Struct({stateMachines: StateMachineList, nextToken: Schema.optional(Schema.String)});
export const ListStateMachineVersionsOutput = Schema.Struct({stateMachineVersions: StateMachineVersionList, nextToken: Schema.optional(Schema.String)});
export const ServiceQuotaExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ExecutionLimitExceeded = Schema.Struct({message: Schema.optional(Schema.String)});
export const KmsAccessDeniedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TaskTimedOut = Schema.Struct({message: Schema.optional(Schema.String)});
export const KmsInvalidStateException = Schema.Struct({kmsKeyState: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const ExecutionAlreadyExists = Schema.Struct({message: Schema.optional(Schema.String)});
export const StartSyncExecutionOutput = Schema.Struct({executionArn: Schema.String, stateMachineArn: Schema.optional(Schema.String), name: Schema.optional(Schema.String), startDate: Schema.Date, stopDate: Schema.Date, status: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String), input: Schema.optional(Schema.String), inputDetails: Schema.optional(CloudWatchEventsExecutionDataDetails), output: Schema.optional(Schema.String), outputDetails: Schema.optional(CloudWatchEventsExecutionDataDetails), traceHeader: Schema.optional(Schema.String), billingDetails: Schema.optional(BillingDetails)});
export const KmsThrottlingException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TooManyTags = Schema.Struct({message: Schema.optional(Schema.String), resourceName: Schema.optional(Schema.String)});
export const InvalidDefinition = Schema.Struct({message: Schema.optional(Schema.String)});
export const StateMachineDeleting = Schema.Struct({message: Schema.optional(Schema.String)});
export const ValidateStateMachineDefinitionOutput = Schema.Struct({result: Schema.String, diagnostics: ValidateStateMachineDefinitionDiagnosticList, truncated: Schema.optional(Schema.Boolean)});
export const ActivityFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const ActivityScheduleFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const ActivityStartedEventDetails = Schema.Struct({workerName: Schema.optional(Schema.String)});
export const HistoryEventExecutionDataDetails = Schema.Struct({truncated: Schema.optional(Schema.Boolean)});
export const ActivitySucceededEventDetails = Schema.Struct({output: Schema.optional(Schema.String), outputDetails: Schema.optional(HistoryEventExecutionDataDetails)});
export const ActivityTimedOutEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const TaskFailedEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const TaskStartFailedEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const TaskStartedEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String});
export const TaskSubmitFailedEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const TaskSubmittedEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, output: Schema.optional(Schema.String), outputDetails: Schema.optional(HistoryEventExecutionDataDetails)});
export const TaskSucceededEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, output: Schema.optional(Schema.String), outputDetails: Schema.optional(HistoryEventExecutionDataDetails)});
export const TaskTimedOutEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const ExecutionFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const ExecutionStartedEventDetails = Schema.Struct({input: Schema.optional(Schema.String), inputDetails: Schema.optional(HistoryEventExecutionDataDetails), roleArn: Schema.optional(Schema.String), stateMachineAliasArn: Schema.optional(Schema.String), stateMachineVersionArn: Schema.optional(Schema.String)});
export const ExecutionSucceededEventDetails = Schema.Struct({output: Schema.optional(Schema.String), outputDetails: Schema.optional(HistoryEventExecutionDataDetails)});
export const ExecutionAbortedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const ExecutionTimedOutEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const ExecutionRedrivenEventDetails = Schema.Struct({redriveCount: Schema.optional(Schema.Number)});
export const MapStateStartedEventDetails = Schema.Struct({length: Schema.optional(Schema.Number)});
export const MapIterationEventDetails = Schema.Struct({name: Schema.optional(Schema.String), index: Schema.optional(Schema.Number)});
export const LambdaFunctionFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const LambdaFunctionScheduleFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const TaskCredentials = Schema.Struct({roleArn: Schema.optional(Schema.String)});
export const LambdaFunctionScheduledEventDetails = Schema.Struct({resource: Schema.String, input: Schema.optional(Schema.String), inputDetails: Schema.optional(HistoryEventExecutionDataDetails), timeoutInSeconds: Schema.optional(Schema.Number), taskCredentials: Schema.optional(TaskCredentials)});
export const LambdaFunctionStartFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const LambdaFunctionSucceededEventDetails = Schema.Struct({output: Schema.optional(Schema.String), outputDetails: Schema.optional(HistoryEventExecutionDataDetails)});
export const LambdaFunctionTimedOutEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const StateEnteredEventDetails = Schema.Struct({name: Schema.String, input: Schema.optional(Schema.String), inputDetails: Schema.optional(HistoryEventExecutionDataDetails)});
export const MapRunStartedEventDetails = Schema.Struct({mapRunArn: Schema.optional(Schema.String)});
export const MapRunFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const MapRunRedrivenEventDetails = Schema.Struct({mapRunArn: Schema.optional(Schema.String), redriveCount: Schema.optional(Schema.Number)});
export const EvaluationFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String), location: Schema.optional(Schema.String), state: Schema.String});
export const InspectionDataRequest = Schema.Struct({protocol: Schema.optional(Schema.String), method: Schema.optional(Schema.String), url: Schema.optional(Schema.String), headers: Schema.optional(Schema.String), body: Schema.optional(Schema.String)});
export const InspectionDataResponse = Schema.Struct({protocol: Schema.optional(Schema.String), statusCode: Schema.optional(Schema.String), statusMessage: Schema.optional(Schema.String), headers: Schema.optional(Schema.String), body: Schema.optional(Schema.String)});
export const InspectionData = Schema.Struct({input: Schema.optional(Schema.String), afterArguments: Schema.optional(Schema.String), afterInputPath: Schema.optional(Schema.String), afterParameters: Schema.optional(Schema.String), result: Schema.optional(Schema.String), afterResultSelector: Schema.optional(Schema.String), afterResultPath: Schema.optional(Schema.String), request: Schema.optional(InspectionDataRequest), response: Schema.optional(InspectionDataResponse), variables: Schema.optional(Schema.String)});
export const AssignedVariables = Schema.Record({key: Schema.String, value: Schema.String});
export const AssignedVariablesDetails = Schema.Struct({truncated: Schema.optional(Schema.Boolean)});
export const ActivityAlreadyExists = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreateStateMachineInput = Schema.Struct({name: Schema.String, definition: Schema.String, roleArn: Schema.String, type: Schema.optional(Schema.String), loggingConfiguration: Schema.optional(LoggingConfiguration), tags: Schema.optional(TagList), tracingConfiguration: Schema.optional(TracingConfiguration), publish: Schema.optional(Schema.Boolean), versionDescription: Schema.optional(Schema.String), encryptionConfiguration: Schema.optional(EncryptionConfiguration)});
export const InvalidName = Schema.Struct({message: Schema.optional(Schema.String)});
export const StateMachineDoesNotExist = Schema.Struct({message: Schema.optional(Schema.String)});
export const StateMachineTypeNotSupported = Schema.Struct({message: Schema.optional(Schema.String)});
export const ExecutionNotRedrivable = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidExecutionInput = Schema.Struct({message: Schema.optional(Schema.String)});
export const TestStateOutput = Schema.Struct({output: Schema.optional(Schema.String), error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String), inspectionData: Schema.optional(InspectionData), nextState: Schema.optional(Schema.String), status: Schema.optional(Schema.String)});
export const InvalidEncryptionConfiguration = Schema.Struct({message: Schema.optional(Schema.String)});
export const ActivityScheduledEventDetails = Schema.Struct({resource: Schema.String, input: Schema.optional(Schema.String), inputDetails: Schema.optional(HistoryEventExecutionDataDetails), timeoutInSeconds: Schema.optional(Schema.Number), heartbeatInSeconds: Schema.optional(Schema.Number)});
export const TaskScheduledEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, region: Schema.String, parameters: Schema.String, timeoutInSeconds: Schema.optional(Schema.Number), heartbeatInSeconds: Schema.optional(Schema.Number), taskCredentials: Schema.optional(TaskCredentials)});
export const StateExitedEventDetails = Schema.Struct({name: Schema.String, output: Schema.optional(Schema.String), outputDetails: Schema.optional(HistoryEventExecutionDataDetails), assignedVariables: Schema.optional(AssignedVariables), assignedVariablesDetails: Schema.optional(AssignedVariablesDetails)});
export const HistoryEvent = Schema.Struct({timestamp: Schema.Date, type: Schema.String, id: Schema.Number, previousEventId: Schema.optional(Schema.Number), activityFailedEventDetails: Schema.optional(ActivityFailedEventDetails), activityScheduleFailedEventDetails: Schema.optional(ActivityScheduleFailedEventDetails), activityScheduledEventDetails: Schema.optional(ActivityScheduledEventDetails), activityStartedEventDetails: Schema.optional(ActivityStartedEventDetails), activitySucceededEventDetails: Schema.optional(ActivitySucceededEventDetails), activityTimedOutEventDetails: Schema.optional(ActivityTimedOutEventDetails), taskFailedEventDetails: Schema.optional(TaskFailedEventDetails), taskScheduledEventDetails: Schema.optional(TaskScheduledEventDetails), taskStartFailedEventDetails: Schema.optional(TaskStartFailedEventDetails), taskStartedEventDetails: Schema.optional(TaskStartedEventDetails), taskSubmitFailedEventDetails: Schema.optional(TaskSubmitFailedEventDetails), taskSubmittedEventDetails: Schema.optional(TaskSubmittedEventDetails), taskSucceededEventDetails: Schema.optional(TaskSucceededEventDetails), taskTimedOutEventDetails: Schema.optional(TaskTimedOutEventDetails), executionFailedEventDetails: Schema.optional(ExecutionFailedEventDetails), executionStartedEventDetails: Schema.optional(ExecutionStartedEventDetails), executionSucceededEventDetails: Schema.optional(ExecutionSucceededEventDetails), executionAbortedEventDetails: Schema.optional(ExecutionAbortedEventDetails), executionTimedOutEventDetails: Schema.optional(ExecutionTimedOutEventDetails), executionRedrivenEventDetails: Schema.optional(ExecutionRedrivenEventDetails), mapStateStartedEventDetails: Schema.optional(MapStateStartedEventDetails), mapIterationStartedEventDetails: Schema.optional(MapIterationEventDetails), mapIterationSucceededEventDetails: Schema.optional(MapIterationEventDetails), mapIterationFailedEventDetails: Schema.optional(MapIterationEventDetails), mapIterationAbortedEventDetails: Schema.optional(MapIterationEventDetails), lambdaFunctionFailedEventDetails: Schema.optional(LambdaFunctionFailedEventDetails), lambdaFunctionScheduleFailedEventDetails: Schema.optional(LambdaFunctionScheduleFailedEventDetails), lambdaFunctionScheduledEventDetails: Schema.optional(LambdaFunctionScheduledEventDetails), lambdaFunctionStartFailedEventDetails: Schema.optional(LambdaFunctionStartFailedEventDetails), lambdaFunctionSucceededEventDetails: Schema.optional(LambdaFunctionSucceededEventDetails), lambdaFunctionTimedOutEventDetails: Schema.optional(LambdaFunctionTimedOutEventDetails), stateEnteredEventDetails: Schema.optional(StateEnteredEventDetails), stateExitedEventDetails: Schema.optional(StateExitedEventDetails), mapRunStartedEventDetails: Schema.optional(MapRunStartedEventDetails), mapRunFailedEventDetails: Schema.optional(MapRunFailedEventDetails), mapRunRedrivenEventDetails: Schema.optional(MapRunRedrivenEventDetails), evaluationFailedEventDetails: Schema.optional(EvaluationFailedEventDetails)});
export const HistoryEventList = Schema.Array(HistoryEvent);
export const ActivityLimitExceeded = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreateStateMachineOutput = Schema.Struct({stateMachineArn: Schema.String, creationDate: Schema.Date, stateMachineVersionArn: Schema.optional(Schema.String)});
export const GetExecutionHistoryOutput = Schema.Struct({events: HistoryEventList, nextToken: Schema.optional(Schema.String)});
export const InvalidLoggingConfiguration = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTracingConfiguration = Schema.Struct({message: Schema.optional(Schema.String)});
export const MissingRequiredParameter = Schema.Struct({message: Schema.optional(Schema.String)});
export const StateMachineAlreadyExists = Schema.Struct({message: Schema.optional(Schema.String)});
export const StateMachineLimitExceeded = Schema.Struct({message: Schema.optional(Schema.String)});

//# Errors
export class InvalidArnError extends Schema.TaggedError<InvalidArnError>()("InvalidArn", InvalidArn) {};
export class ConflictExceptionError extends Schema.TaggedError<ConflictExceptionError>()("ConflictException", ConflictException) {};
export class ValidationExceptionError extends Schema.TaggedError<ValidationExceptionError>()("ValidationException", ValidationException) {};
export class InvalidTokenError extends Schema.TaggedError<InvalidTokenError>()("InvalidToken", InvalidToken) {};
export class ResourceNotFoundError extends Schema.TaggedError<ResourceNotFoundError>()("ResourceNotFound", ResourceNotFound) {};
export class ActivityDoesNotExistError extends Schema.TaggedError<ActivityDoesNotExistError>()("ActivityDoesNotExist", ActivityDoesNotExist) {};
export class ExecutionDoesNotExistError extends Schema.TaggedError<ExecutionDoesNotExistError>()("ExecutionDoesNotExist", ExecutionDoesNotExist) {};
export class TaskDoesNotExistError extends Schema.TaggedError<TaskDoesNotExistError>()("TaskDoesNotExist", TaskDoesNotExist) {};
export class InvalidOutputError extends Schema.TaggedError<InvalidOutputError>()("InvalidOutput", InvalidOutput) {};
export class KmsAccessDeniedExceptionError extends Schema.TaggedError<KmsAccessDeniedExceptionError>()("KmsAccessDeniedException", KmsAccessDeniedException) {};
export class KmsInvalidStateExceptionError extends Schema.TaggedError<KmsInvalidStateExceptionError>()("KmsInvalidStateException", KmsInvalidStateException) {};
export class KmsThrottlingExceptionError extends Schema.TaggedError<KmsThrottlingExceptionError>()("KmsThrottlingException", KmsThrottlingException) {};
export class ActivityWorkerLimitExceededError extends Schema.TaggedError<ActivityWorkerLimitExceededError>()("ActivityWorkerLimitExceeded", ActivityWorkerLimitExceeded) {};
export class StateMachineDoesNotExistError extends Schema.TaggedError<StateMachineDoesNotExistError>()("StateMachineDoesNotExist", StateMachineDoesNotExist) {};
export class StateMachineDeletingError extends Schema.TaggedError<StateMachineDeletingError>()("StateMachineDeleting", StateMachineDeleting) {};
export class ServiceQuotaExceededExceptionError extends Schema.TaggedError<ServiceQuotaExceededExceptionError>()("ServiceQuotaExceededException", ServiceQuotaExceededException) {};
export class ExecutionLimitExceededError extends Schema.TaggedError<ExecutionLimitExceededError>()("ExecutionLimitExceeded", ExecutionLimitExceeded) {};
export class TaskTimedOutError extends Schema.TaggedError<TaskTimedOutError>()("TaskTimedOut", TaskTimedOut) {};
export class ExecutionAlreadyExistsError extends Schema.TaggedError<ExecutionAlreadyExistsError>()("ExecutionAlreadyExists", ExecutionAlreadyExists) {};
export class InvalidExecutionInputError extends Schema.TaggedError<InvalidExecutionInputError>()("InvalidExecutionInput", InvalidExecutionInput) {};
export class InvalidNameError extends Schema.TaggedError<InvalidNameError>()("InvalidName", InvalidName) {};
export class StateMachineTypeNotSupportedError extends Schema.TaggedError<StateMachineTypeNotSupportedError>()("StateMachineTypeNotSupported", StateMachineTypeNotSupported) {};
export class TooManyTagsError extends Schema.TaggedError<TooManyTagsError>()("TooManyTags", TooManyTags) {};
export class InvalidDefinitionError extends Schema.TaggedError<InvalidDefinitionError>()("InvalidDefinition", InvalidDefinition) {};
export class ActivityAlreadyExistsError extends Schema.TaggedError<ActivityAlreadyExistsError>()("ActivityAlreadyExists", ActivityAlreadyExists) {};
export class ExecutionNotRedrivableError extends Schema.TaggedError<ExecutionNotRedrivableError>()("ExecutionNotRedrivable", ExecutionNotRedrivable) {};
export class InvalidEncryptionConfigurationError extends Schema.TaggedError<InvalidEncryptionConfigurationError>()("InvalidEncryptionConfiguration", InvalidEncryptionConfiguration) {};
export class ActivityLimitExceededError extends Schema.TaggedError<ActivityLimitExceededError>()("ActivityLimitExceeded", ActivityLimitExceeded) {};
export class InvalidLoggingConfigurationError extends Schema.TaggedError<InvalidLoggingConfigurationError>()("InvalidLoggingConfiguration", InvalidLoggingConfiguration) {};
export class InvalidTracingConfigurationError extends Schema.TaggedError<InvalidTracingConfigurationError>()("InvalidTracingConfiguration", InvalidTracingConfiguration) {};
export class MissingRequiredParameterError extends Schema.TaggedError<MissingRequiredParameterError>()("MissingRequiredParameter", MissingRequiredParameter) {};
export class StateMachineAlreadyExistsError extends Schema.TaggedError<StateMachineAlreadyExistsError>()("StateMachineAlreadyExists", StateMachineAlreadyExists) {};
export class StateMachineLimitExceededError extends Schema.TaggedError<StateMachineLimitExceededError>()("StateMachineLimitExceeded", StateMachineLimitExceeded) {};

//# Operations
export const deleteStateMachineVersion = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DeleteStateMachineVersion" }, DeleteStateMachineVersionInput, DeleteStateMachineVersionOutput, [ConflictExceptionError, InvalidArnError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const untagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.UntagResource" }, UntagResourceInput, UntagResourceOutput, [InvalidArnError, ResourceNotFoundError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateMapRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.UpdateMapRun" }, UpdateMapRunInput, UpdateMapRunOutput, [InvalidArnError, ResourceNotFoundError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteActivity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DeleteActivity" }, DeleteActivityInput, DeleteActivityOutput, [InvalidArnError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteStateMachine = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DeleteStateMachine" }, DeleteStateMachineInput, DeleteStateMachineOutput, [InvalidArnError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteStateMachineAlias = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DeleteStateMachineAlias" }, DeleteStateMachineAliasInput, DeleteStateMachineAliasOutput, [ConflictExceptionError, InvalidArnError, ResourceNotFoundError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeStateMachineAlias = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DescribeStateMachineAlias" }, DescribeStateMachineAliasInput, DescribeStateMachineAliasOutput, [InvalidArnError, ResourceNotFoundError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListTagsForResource" }, ListTagsForResourceInput, ListTagsForResourceOutput, [InvalidArnError, ResourceNotFoundError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeActivity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DescribeActivity" }, DescribeActivityInput, DescribeActivityOutput, [ActivityDoesNotExistError, InvalidArnError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DescribeExecution" }, DescribeExecutionInput, DescribeExecutionOutput, [ExecutionDoesNotExistError, InvalidArnError, KmsAccessDeniedExceptionError, KmsInvalidStateExceptionError, KmsThrottlingExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeMapRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DescribeMapRun" }, DescribeMapRunInput, DescribeMapRunOutput, [InvalidArnError, ResourceNotFoundError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeStateMachineForExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DescribeStateMachineForExecution" }, DescribeStateMachineForExecutionInput, DescribeStateMachineForExecutionOutput, [ExecutionDoesNotExistError, InvalidArnError, KmsAccessDeniedExceptionError, KmsInvalidStateExceptionError, KmsThrottlingExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getActivityTask = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.GetActivityTask" }, GetActivityTaskInput, GetActivityTaskOutput, [ActivityDoesNotExistError, ActivityWorkerLimitExceededError, InvalidArnError, KmsAccessDeniedExceptionError, KmsInvalidStateExceptionError, KmsThrottlingExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listActivities = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListActivities" }, ListActivitiesInput, ListActivitiesOutput, [InvalidTokenError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listMapRuns = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListMapRuns" }, ListMapRunsInput, ListMapRunsOutput, [ExecutionDoesNotExistError, InvalidArnError, InvalidTokenError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listStateMachineAliases = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListStateMachineAliases" }, ListStateMachineAliasesInput, ListStateMachineAliasesOutput, [InvalidArnError, InvalidTokenError, ResourceNotFoundError, StateMachineDeletingError, StateMachineDoesNotExistError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listStateMachines = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListStateMachines" }, ListStateMachinesInput, ListStateMachinesOutput, [InvalidTokenError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listStateMachineVersions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListStateMachineVersions" }, ListStateMachineVersionsInput, ListStateMachineVersionsOutput, [InvalidArnError, InvalidTokenError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const publishStateMachineVersion = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.PublishStateMachineVersion" }, PublishStateMachineVersionInput, PublishStateMachineVersionOutput, [ConflictExceptionError, InvalidArnError, ServiceQuotaExceededExceptionError, StateMachineDeletingError, StateMachineDoesNotExistError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const sendTaskFailure = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.SendTaskFailure" }, SendTaskFailureInput, SendTaskFailureOutput, [InvalidTokenError, KmsAccessDeniedExceptionError, KmsInvalidStateExceptionError, KmsThrottlingExceptionError, TaskDoesNotExistError, TaskTimedOutError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const sendTaskHeartbeat = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.SendTaskHeartbeat" }, SendTaskHeartbeatInput, SendTaskHeartbeatOutput, [InvalidTokenError, TaskDoesNotExistError, TaskTimedOutError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const sendTaskSuccess = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.SendTaskSuccess" }, SendTaskSuccessInput, SendTaskSuccessOutput, [InvalidOutputError, InvalidTokenError, KmsAccessDeniedExceptionError, KmsInvalidStateExceptionError, KmsThrottlingExceptionError, TaskDoesNotExistError, TaskTimedOutError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startSyncExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.StartSyncExecution" }, StartSyncExecutionInput, StartSyncExecutionOutput, [InvalidArnError, InvalidExecutionInputError, InvalidNameError, KmsAccessDeniedExceptionError, KmsInvalidStateExceptionError, KmsThrottlingExceptionError, StateMachineDeletingError, StateMachineDoesNotExistError, StateMachineTypeNotSupportedError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const stopExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.StopExecution" }, StopExecutionInput, StopExecutionOutput, [ExecutionDoesNotExistError, InvalidArnError, KmsAccessDeniedExceptionError, KmsInvalidStateExceptionError, KmsThrottlingExceptionError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const tagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.TagResource" }, TagResourceInput, TagResourceOutput, [InvalidArnError, ResourceNotFoundError, TooManyTagsError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateStateMachineAlias = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.UpdateStateMachineAlias" }, UpdateStateMachineAliasInput, UpdateStateMachineAliasOutput, [ConflictExceptionError, InvalidArnError, ResourceNotFoundError, StateMachineDeletingError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const validateStateMachineDefinition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ValidateStateMachineDefinition" }, ValidateStateMachineDefinitionInput, ValidateStateMachineDefinitionOutput, [ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createStateMachineAlias = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.CreateStateMachineAlias" }, CreateStateMachineAliasInput, CreateStateMachineAliasOutput, [ConflictExceptionError, InvalidArnError, InvalidNameError, ResourceNotFoundError, ServiceQuotaExceededExceptionError, StateMachineDeletingError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeStateMachine = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DescribeStateMachine" }, DescribeStateMachineInput, DescribeStateMachineOutput, [InvalidArnError, KmsAccessDeniedExceptionError, KmsInvalidStateExceptionError, KmsThrottlingExceptionError, StateMachineDoesNotExistError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listExecutions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListExecutions" }, ListExecutionsInput, ListExecutionsOutput, [InvalidArnError, InvalidTokenError, ResourceNotFoundError, StateMachineDoesNotExistError, StateMachineTypeNotSupportedError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const redriveExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.RedriveExecution" }, RedriveExecutionInput, RedriveExecutionOutput, [ExecutionDoesNotExistError, ExecutionLimitExceededError, ExecutionNotRedrivableError, InvalidArnError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.StartExecution" }, StartExecutionInput, StartExecutionOutput, [ExecutionAlreadyExistsError, ExecutionLimitExceededError, InvalidArnError, InvalidExecutionInputError, InvalidNameError, KmsAccessDeniedExceptionError, KmsInvalidStateExceptionError, KmsThrottlingExceptionError, StateMachineDeletingError, StateMachineDoesNotExistError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const testState = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.TestState" }, TestStateInput, TestStateOutput, [InvalidArnError, InvalidDefinitionError, InvalidExecutionInputError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createActivity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.CreateActivity" }, CreateActivityInput, CreateActivityOutput, [ActivityAlreadyExistsError, ActivityLimitExceededError, InvalidEncryptionConfigurationError, InvalidNameError, KmsAccessDeniedExceptionError, KmsThrottlingExceptionError, TooManyTagsError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getExecutionHistory = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.GetExecutionHistory" }, GetExecutionHistoryInput, GetExecutionHistoryOutput, [ExecutionDoesNotExistError, InvalidArnError, InvalidTokenError, KmsAccessDeniedExceptionError, KmsInvalidStateExceptionError, KmsThrottlingExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateStateMachine = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.UpdateStateMachine" }, UpdateStateMachineInput, UpdateStateMachineOutput, [ConflictExceptionError, InvalidArnError, InvalidDefinitionError, InvalidEncryptionConfigurationError, InvalidLoggingConfigurationError, InvalidTracingConfigurationError, KmsAccessDeniedExceptionError, KmsThrottlingExceptionError, MissingRequiredParameterError, ServiceQuotaExceededExceptionError, StateMachineDeletingError, StateMachineDoesNotExistError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createStateMachine = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.CreateStateMachine" }, CreateStateMachineInput, CreateStateMachineOutput, [ConflictExceptionError, InvalidArnError, InvalidDefinitionError, InvalidEncryptionConfigurationError, InvalidLoggingConfigurationError, InvalidNameError, InvalidTracingConfigurationError, KmsAccessDeniedExceptionError, KmsThrottlingExceptionError, StateMachineAlreadyExistsError, StateMachineDeletingError, StateMachineLimitExceededError, StateMachineTypeNotSupportedError, TooManyTagsError, ValidationExceptionError]), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
