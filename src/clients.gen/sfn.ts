import { Schema} from "effect"
import { FormatAwsJSON10Request,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
export const TagKeyList = Schema.Array(Schema.String);
export const DeleteActivityInput = Schema.Struct({activityArn: Schema.String});
export const DeleteActivityOutput = Schema.Struct({});
export const DeleteStateMachineInput = Schema.Struct({stateMachineArn: Schema.String});
export const DeleteStateMachineOutput = Schema.Struct({});
export const DeleteStateMachineAliasInput = Schema.Struct({stateMachineAliasArn: Schema.String});
export const DeleteStateMachineAliasOutput = Schema.Struct({});
export const DeleteStateMachineVersionInput = Schema.Struct({stateMachineVersionArn: Schema.String});
export const DeleteStateMachineVersionOutput = Schema.Struct({});
export const DescribeActivityInput = Schema.Struct({activityArn: Schema.String});
export const DescribeExecutionInput = Schema.Struct({executionArn: Schema.String, includedData: Schema.optional(Schema.String)});
export const DescribeMapRunInput = Schema.Struct({mapRunArn: Schema.String});
export const DescribeStateMachineInput = Schema.Struct({stateMachineArn: Schema.String, includedData: Schema.optional(Schema.String)});
export const DescribeStateMachineAliasInput = Schema.Struct({stateMachineAliasArn: Schema.String});
export const DescribeStateMachineForExecutionInput = Schema.Struct({executionArn: Schema.String, includedData: Schema.optional(Schema.String)});
export const GetActivityTaskInput = Schema.Struct({activityArn: Schema.String, workerName: Schema.optional(Schema.String)});
export const GetExecutionHistoryInput = Schema.Struct({executionArn: Schema.String, maxResults: Schema.optional(Schema.Number), reverseOrder: Schema.optional(Schema.Boolean), nextToken: Schema.optional(Schema.String), includeExecutionData: Schema.optional(Schema.Boolean)});
export const ListActivitiesInput = Schema.Struct({maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListExecutionsInput = Schema.Struct({stateMachineArn: Schema.optional(Schema.String), statusFilter: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), mapRunArn: Schema.optional(Schema.String), redriveFilter: Schema.optional(Schema.String)});
export const ListMapRunsInput = Schema.Struct({executionArn: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListStateMachineAliasesInput = Schema.Struct({stateMachineArn: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListStateMachinesInput = Schema.Struct({maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListStateMachineVersionsInput = Schema.Struct({stateMachineArn: Schema.String, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListTagsForResourceInput = Schema.Struct({resourceArn: Schema.String});
export const PublishStateMachineVersionInput = Schema.Struct({stateMachineArn: Schema.String, revisionId: Schema.optional(Schema.String), description: Schema.optional(Schema.String)});
export const RedriveExecutionInput = Schema.Struct({executionArn: Schema.String, clientToken: Schema.optional(Schema.String)});
export const SendTaskFailureInput = Schema.Struct({taskToken: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const SendTaskFailureOutput = Schema.Struct({});
export const SendTaskHeartbeatInput = Schema.Struct({taskToken: Schema.String});
export const SendTaskHeartbeatOutput = Schema.Struct({});
export const SendTaskSuccessInput = Schema.Struct({taskToken: Schema.String, output: Schema.String});
export const SendTaskSuccessOutput = Schema.Struct({});
export const StartExecutionInput = Schema.Struct({stateMachineArn: Schema.String, name: Schema.optional(Schema.String), input: Schema.optional(Schema.String), traceHeader: Schema.optional(Schema.String)});
export const StartSyncExecutionInput = Schema.Struct({stateMachineArn: Schema.String, name: Schema.optional(Schema.String), input: Schema.optional(Schema.String), traceHeader: Schema.optional(Schema.String), includedData: Schema.optional(Schema.String)});
export const StopExecutionInput = Schema.Struct({executionArn: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const Tag = Schema.Struct({key: Schema.optional(Schema.String), value: Schema.optional(Schema.String)});
export const TagList = Schema.Array(Tag);
export const TagResourceInput = Schema.Struct({resourceArn: Schema.String, tags: TagList});
export const TagResourceOutput = Schema.Struct({});
export const TestStateInput = Schema.Struct({definition: Schema.String, roleArn: Schema.optional(Schema.String), input: Schema.optional(Schema.String), inspectionLevel: Schema.optional(Schema.String), revealSecrets: Schema.optional(Schema.Boolean), variables: Schema.optional(Schema.String)});
export const UntagResourceInput = Schema.Struct({resourceArn: Schema.String, tagKeys: TagKeyList});
export const UntagResourceOutput = Schema.Struct({});
export const UpdateMapRunInput = Schema.Struct({mapRunArn: Schema.String, maxConcurrency: Schema.optional(Schema.Number), toleratedFailurePercentage: Schema.optional(Schema.Number), toleratedFailureCount: Schema.optional(Schema.Number)});
export const UpdateMapRunOutput = Schema.Struct({});
export const CloudWatchLogsLogGroup = Schema.Struct({logGroupArn: Schema.optional(Schema.String)});
export const LogDestination = Schema.Struct({cloudWatchLogsLogGroup: Schema.optional(CloudWatchLogsLogGroup)});
export const LogDestinationList = Schema.Array(LogDestination);
export const LoggingConfiguration = Schema.Struct({level: Schema.optional(Schema.String), includeExecutionData: Schema.optional(Schema.Boolean), destinations: Schema.optional(LogDestinationList)});
export const TracingConfiguration = Schema.Struct({enabled: Schema.optional(Schema.Boolean)});
export const EncryptionConfiguration = Schema.Struct({kmsKeyId: Schema.optional(Schema.String), kmsDataKeyReusePeriodSeconds: Schema.optional(Schema.Number), type: Schema.String});
export const UpdateStateMachineInput = Schema.Struct({stateMachineArn: Schema.String, definition: Schema.optional(Schema.String), roleArn: Schema.optional(Schema.String), loggingConfiguration: Schema.optional(LoggingConfiguration), tracingConfiguration: Schema.optional(TracingConfiguration), publish: Schema.optional(Schema.Boolean), versionDescription: Schema.optional(Schema.String), encryptionConfiguration: Schema.optional(EncryptionConfiguration)});
export const RoutingConfigurationListItem = Schema.Struct({stateMachineVersionArn: Schema.String, weight: Schema.Number});
export const RoutingConfigurationList = Schema.Array(RoutingConfigurationListItem);
export const UpdateStateMachineAliasInput = Schema.Struct({stateMachineAliasArn: Schema.String, description: Schema.optional(Schema.String), routingConfiguration: Schema.optional(RoutingConfigurationList)});
export const ValidateStateMachineDefinitionInput = Schema.Struct({definition: Schema.String, type: Schema.optional(Schema.String), severity: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const CreateActivityInput = Schema.Struct({name: Schema.String, tags: Schema.optional(TagList), encryptionConfiguration: Schema.optional(EncryptionConfiguration)});
export const CreateStateMachineAliasInput = Schema.Struct({description: Schema.optional(Schema.String), name: Schema.String, routingConfiguration: RoutingConfigurationList});
export const InvalidArn = Schema.Struct({message: Schema.optional(Schema.String)});
export const ValidationException = Schema.Struct({message: Schema.optional(Schema.String), reason: Schema.optional(Schema.String)});
export const ConflictException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeActivityOutput = Schema.Struct({activityArn: Schema.String, name: Schema.String, creationDate: Schema.Date, encryptionConfiguration: Schema.optional(EncryptionConfiguration)});
export const DescribeStateMachineAliasOutput = Schema.Struct({stateMachineAliasArn: Schema.optional(Schema.String), name: Schema.optional(Schema.String), description: Schema.optional(Schema.String), routingConfiguration: Schema.optional(RoutingConfigurationList), creationDate: Schema.optional(Schema.Date), updateDate: Schema.optional(Schema.Date)});
export const VariableNameList = Schema.Array(Schema.String);
export const VariableReferences = Schema.Record({key: Schema.String, value: VariableNameList});
export const DescribeStateMachineForExecutionOutput = Schema.Struct({stateMachineArn: Schema.String, name: Schema.String, definition: Schema.String, roleArn: Schema.String, updateDate: Schema.Date, loggingConfiguration: Schema.optional(LoggingConfiguration), tracingConfiguration: Schema.optional(TracingConfiguration), mapRunArn: Schema.optional(Schema.String), label: Schema.optional(Schema.String), revisionId: Schema.optional(Schema.String), encryptionConfiguration: Schema.optional(EncryptionConfiguration), variableReferences: Schema.optional(VariableReferences)});
export const GetActivityTaskOutput = Schema.Struct({taskToken: Schema.optional(Schema.String), input: Schema.optional(Schema.String)});
export const ListTagsForResourceOutput = Schema.Struct({tags: Schema.optional(TagList)});
export const PublishStateMachineVersionOutput = Schema.Struct({creationDate: Schema.Date, stateMachineVersionArn: Schema.String});
export const RedriveExecutionOutput = Schema.Struct({redriveDate: Schema.Date});
export const InvalidToken = Schema.Struct({message: Schema.optional(Schema.String)});
export const TaskDoesNotExist = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidOutput = Schema.Struct({message: Schema.optional(Schema.String)});
export const StartExecutionOutput = Schema.Struct({executionArn: Schema.String, startDate: Schema.Date});
export const StopExecutionOutput = Schema.Struct({stopDate: Schema.Date});
export const ResourceNotFound = Schema.Struct({message: Schema.optional(Schema.String), resourceName: Schema.optional(Schema.String)});
export const UpdateStateMachineOutput = Schema.Struct({updateDate: Schema.Date, revisionId: Schema.optional(Schema.String), stateMachineVersionArn: Schema.optional(Schema.String)});
export const UpdateStateMachineAliasOutput = Schema.Struct({updateDate: Schema.Date});
export const CloudWatchEventsExecutionDataDetails = Schema.Struct({included: Schema.optional(Schema.Boolean)});
export const MapRunItemCounts = Schema.Struct({pending: Schema.Number, running: Schema.Number, succeeded: Schema.Number, failed: Schema.Number, timedOut: Schema.Number, aborted: Schema.Number, total: Schema.Number, resultsWritten: Schema.Number, failuresNotRedrivable: Schema.optional(Schema.Number), pendingRedrive: Schema.optional(Schema.Number)});
export const MapRunExecutionCounts = Schema.Struct({pending: Schema.Number, running: Schema.Number, succeeded: Schema.Number, failed: Schema.Number, timedOut: Schema.Number, aborted: Schema.Number, total: Schema.Number, resultsWritten: Schema.Number, failuresNotRedrivable: Schema.optional(Schema.Number), pendingRedrive: Schema.optional(Schema.Number)});
export const ActivityListItem = Schema.Struct({activityArn: Schema.String, name: Schema.String, creationDate: Schema.Date});
export const ActivityList = Schema.Array(ActivityListItem);
export const ExecutionListItem = Schema.Struct({executionArn: Schema.String, stateMachineArn: Schema.String, name: Schema.String, status: Schema.String, startDate: Schema.Date, stopDate: Schema.optional(Schema.Date), mapRunArn: Schema.optional(Schema.String), itemCount: Schema.optional(Schema.Number), stateMachineVersionArn: Schema.optional(Schema.String), stateMachineAliasArn: Schema.optional(Schema.String), redriveCount: Schema.optional(Schema.Number), redriveDate: Schema.optional(Schema.Date)});
export const ExecutionList = Schema.Array(ExecutionListItem);
export const MapRunListItem = Schema.Struct({executionArn: Schema.String, mapRunArn: Schema.String, stateMachineArn: Schema.String, startDate: Schema.Date, stopDate: Schema.optional(Schema.Date)});
export const MapRunList = Schema.Array(MapRunListItem);
export const StateMachineAliasListItem = Schema.Struct({stateMachineAliasArn: Schema.String, creationDate: Schema.Date});
export const StateMachineAliasList = Schema.Array(StateMachineAliasListItem);
export const StateMachineListItem = Schema.Struct({stateMachineArn: Schema.String, name: Schema.String, type: Schema.String, creationDate: Schema.Date});
export const StateMachineList = Schema.Array(StateMachineListItem);
export const StateMachineVersionListItem = Schema.Struct({stateMachineVersionArn: Schema.String, creationDate: Schema.Date});
export const StateMachineVersionList = Schema.Array(StateMachineVersionListItem);
export const BillingDetails = Schema.Struct({billedMemoryUsedInMB: Schema.optional(Schema.Number), billedDurationInMilliseconds: Schema.optional(Schema.Number)});
export const ValidateStateMachineDefinitionDiagnostic = Schema.Struct({severity: Schema.String, code: Schema.String, message: Schema.String, location: Schema.optional(Schema.String)});
export const ValidateStateMachineDefinitionDiagnosticList = Schema.Array(ValidateStateMachineDefinitionDiagnostic);
export const CreateActivityOutput = Schema.Struct({activityArn: Schema.String, creationDate: Schema.Date});
export const CreateStateMachineAliasOutput = Schema.Struct({stateMachineAliasArn: Schema.String, creationDate: Schema.Date});
export const ActivityDoesNotExist = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeExecutionOutput = Schema.Struct({executionArn: Schema.String, stateMachineArn: Schema.String, name: Schema.optional(Schema.String), status: Schema.String, startDate: Schema.Date, stopDate: Schema.optional(Schema.Date), input: Schema.optional(Schema.String), inputDetails: Schema.optional(CloudWatchEventsExecutionDataDetails), output: Schema.optional(Schema.String), outputDetails: Schema.optional(CloudWatchEventsExecutionDataDetails), traceHeader: Schema.optional(Schema.String), mapRunArn: Schema.optional(Schema.String), error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String), stateMachineVersionArn: Schema.optional(Schema.String), stateMachineAliasArn: Schema.optional(Schema.String), redriveCount: Schema.optional(Schema.Number), redriveDate: Schema.optional(Schema.Date), redriveStatus: Schema.optional(Schema.String), redriveStatusReason: Schema.optional(Schema.String)});
export const DescribeMapRunOutput = Schema.Struct({mapRunArn: Schema.String, executionArn: Schema.String, status: Schema.String, startDate: Schema.Date, stopDate: Schema.optional(Schema.Date), maxConcurrency: Schema.Number, toleratedFailurePercentage: Schema.Number, toleratedFailureCount: Schema.Number, itemCounts: MapRunItemCounts, executionCounts: MapRunExecutionCounts, redriveCount: Schema.optional(Schema.Number), redriveDate: Schema.optional(Schema.Date)});
export const DescribeStateMachineOutput = Schema.Struct({stateMachineArn: Schema.String, name: Schema.String, status: Schema.optional(Schema.String), definition: Schema.String, roleArn: Schema.String, type: Schema.String, creationDate: Schema.Date, loggingConfiguration: Schema.optional(LoggingConfiguration), tracingConfiguration: Schema.optional(TracingConfiguration), label: Schema.optional(Schema.String), revisionId: Schema.optional(Schema.String), description: Schema.optional(Schema.String), encryptionConfiguration: Schema.optional(EncryptionConfiguration), variableReferences: Schema.optional(VariableReferences)});
export const ExecutionDoesNotExist = Schema.Struct({message: Schema.optional(Schema.String)});
export const ActivityWorkerLimitExceeded = Schema.Struct({message: Schema.optional(Schema.String)});
export const ListActivitiesOutput = Schema.Struct({activities: ActivityList, nextToken: Schema.optional(Schema.String)});
export const ListExecutionsOutput = Schema.Struct({executions: ExecutionList, nextToken: Schema.optional(Schema.String)});
export const ListMapRunsOutput = Schema.Struct({mapRuns: MapRunList, nextToken: Schema.optional(Schema.String)});
export const ListStateMachineAliasesOutput = Schema.Struct({stateMachineAliases: StateMachineAliasList, nextToken: Schema.optional(Schema.String)});
export const ListStateMachinesOutput = Schema.Struct({stateMachines: StateMachineList, nextToken: Schema.optional(Schema.String)});
export const ListStateMachineVersionsOutput = Schema.Struct({stateMachineVersions: StateMachineVersionList, nextToken: Schema.optional(Schema.String)});
export const ServiceQuotaExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ExecutionLimitExceeded = Schema.Struct({message: Schema.optional(Schema.String)});
export const KmsAccessDeniedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TaskTimedOut = Schema.Struct({message: Schema.optional(Schema.String)});
export const KmsInvalidStateException = Schema.Struct({kmsKeyState: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const ExecutionAlreadyExists = Schema.Struct({message: Schema.optional(Schema.String)});
export const StartSyncExecutionOutput = Schema.Struct({executionArn: Schema.String, stateMachineArn: Schema.optional(Schema.String), name: Schema.optional(Schema.String), startDate: Schema.Date, stopDate: Schema.Date, status: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String), input: Schema.optional(Schema.String), inputDetails: Schema.optional(CloudWatchEventsExecutionDataDetails), output: Schema.optional(Schema.String), outputDetails: Schema.optional(CloudWatchEventsExecutionDataDetails), traceHeader: Schema.optional(Schema.String), billingDetails: Schema.optional(BillingDetails)});
export const KmsThrottlingException = Schema.Struct({message: Schema.optional(Schema.String)});
export const TooManyTags = Schema.Struct({message: Schema.optional(Schema.String), resourceName: Schema.optional(Schema.String)});
export const InvalidDefinition = Schema.Struct({message: Schema.optional(Schema.String)});
export const StateMachineDeleting = Schema.Struct({message: Schema.optional(Schema.String)});
export const ValidateStateMachineDefinitionOutput = Schema.Struct({result: Schema.String, diagnostics: ValidateStateMachineDefinitionDiagnosticList, truncated: Schema.optional(Schema.Boolean)});
export const ActivityFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const ActivityScheduleFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const ActivityStartedEventDetails = Schema.Struct({workerName: Schema.optional(Schema.String)});
export const HistoryEventExecutionDataDetails = Schema.Struct({truncated: Schema.optional(Schema.Boolean)});
export const ActivitySucceededEventDetails = Schema.Struct({output: Schema.optional(Schema.String), outputDetails: Schema.optional(HistoryEventExecutionDataDetails)});
export const ActivityTimedOutEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const TaskFailedEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const TaskStartFailedEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const TaskStartedEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String});
export const TaskSubmitFailedEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const TaskSubmittedEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, output: Schema.optional(Schema.String), outputDetails: Schema.optional(HistoryEventExecutionDataDetails)});
export const TaskSucceededEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, output: Schema.optional(Schema.String), outputDetails: Schema.optional(HistoryEventExecutionDataDetails)});
export const TaskTimedOutEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const ExecutionFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const ExecutionStartedEventDetails = Schema.Struct({input: Schema.optional(Schema.String), inputDetails: Schema.optional(HistoryEventExecutionDataDetails), roleArn: Schema.optional(Schema.String), stateMachineAliasArn: Schema.optional(Schema.String), stateMachineVersionArn: Schema.optional(Schema.String)});
export const ExecutionSucceededEventDetails = Schema.Struct({output: Schema.optional(Schema.String), outputDetails: Schema.optional(HistoryEventExecutionDataDetails)});
export const ExecutionAbortedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const ExecutionTimedOutEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const ExecutionRedrivenEventDetails = Schema.Struct({redriveCount: Schema.optional(Schema.Number)});
export const MapStateStartedEventDetails = Schema.Struct({length: Schema.optional(Schema.Number)});
export const MapIterationEventDetails = Schema.Struct({name: Schema.optional(Schema.String), index: Schema.optional(Schema.Number)});
export const LambdaFunctionFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const LambdaFunctionScheduleFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const TaskCredentials = Schema.Struct({roleArn: Schema.optional(Schema.String)});
export const LambdaFunctionScheduledEventDetails = Schema.Struct({resource: Schema.String, input: Schema.optional(Schema.String), inputDetails: Schema.optional(HistoryEventExecutionDataDetails), timeoutInSeconds: Schema.optional(Schema.Number), taskCredentials: Schema.optional(TaskCredentials)});
export const LambdaFunctionStartFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const LambdaFunctionSucceededEventDetails = Schema.Struct({output: Schema.optional(Schema.String), outputDetails: Schema.optional(HistoryEventExecutionDataDetails)});
export const LambdaFunctionTimedOutEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const StateEnteredEventDetails = Schema.Struct({name: Schema.String, input: Schema.optional(Schema.String), inputDetails: Schema.optional(HistoryEventExecutionDataDetails)});
export const MapRunStartedEventDetails = Schema.Struct({mapRunArn: Schema.optional(Schema.String)});
export const MapRunFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String)});
export const MapRunRedrivenEventDetails = Schema.Struct({mapRunArn: Schema.optional(Schema.String), redriveCount: Schema.optional(Schema.Number)});
export const EvaluationFailedEventDetails = Schema.Struct({error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String), location: Schema.optional(Schema.String), state: Schema.String});
export const InspectionDataRequest = Schema.Struct({protocol: Schema.optional(Schema.String), method: Schema.optional(Schema.String), url: Schema.optional(Schema.String), headers: Schema.optional(Schema.String), body: Schema.optional(Schema.String)});
export const InspectionDataResponse = Schema.Struct({protocol: Schema.optional(Schema.String), statusCode: Schema.optional(Schema.String), statusMessage: Schema.optional(Schema.String), headers: Schema.optional(Schema.String), body: Schema.optional(Schema.String)});
export const InspectionData = Schema.Struct({input: Schema.optional(Schema.String), afterArguments: Schema.optional(Schema.String), afterInputPath: Schema.optional(Schema.String), afterParameters: Schema.optional(Schema.String), result: Schema.optional(Schema.String), afterResultSelector: Schema.optional(Schema.String), afterResultPath: Schema.optional(Schema.String), request: Schema.optional(InspectionDataRequest), response: Schema.optional(InspectionDataResponse), variables: Schema.optional(Schema.String)});
export const AssignedVariables = Schema.Record({key: Schema.String, value: Schema.String});
export const AssignedVariablesDetails = Schema.Struct({truncated: Schema.optional(Schema.Boolean)});
export const ActivityAlreadyExists = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreateStateMachineInput = Schema.Struct({name: Schema.String, definition: Schema.String, roleArn: Schema.String, type: Schema.optional(Schema.String), loggingConfiguration: Schema.optional(LoggingConfiguration), tags: Schema.optional(TagList), tracingConfiguration: Schema.optional(TracingConfiguration), publish: Schema.optional(Schema.Boolean), versionDescription: Schema.optional(Schema.String), encryptionConfiguration: Schema.optional(EncryptionConfiguration)});
export const InvalidName = Schema.Struct({message: Schema.optional(Schema.String)});
export const StateMachineDoesNotExist = Schema.Struct({message: Schema.optional(Schema.String)});
export const StateMachineTypeNotSupported = Schema.Struct({message: Schema.optional(Schema.String)});
export const ExecutionNotRedrivable = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidExecutionInput = Schema.Struct({message: Schema.optional(Schema.String)});
export const TestStateOutput = Schema.Struct({output: Schema.optional(Schema.String), error: Schema.optional(Schema.String), cause: Schema.optional(Schema.String), inspectionData: Schema.optional(InspectionData), nextState: Schema.optional(Schema.String), status: Schema.optional(Schema.String)});
export const InvalidEncryptionConfiguration = Schema.Struct({message: Schema.optional(Schema.String)});
export const ActivityScheduledEventDetails = Schema.Struct({resource: Schema.String, input: Schema.optional(Schema.String), inputDetails: Schema.optional(HistoryEventExecutionDataDetails), timeoutInSeconds: Schema.optional(Schema.Number), heartbeatInSeconds: Schema.optional(Schema.Number)});
export const TaskScheduledEventDetails = Schema.Struct({resourceType: Schema.String, resource: Schema.String, region: Schema.String, parameters: Schema.String, timeoutInSeconds: Schema.optional(Schema.Number), heartbeatInSeconds: Schema.optional(Schema.Number), taskCredentials: Schema.optional(TaskCredentials)});
export const StateExitedEventDetails = Schema.Struct({name: Schema.String, output: Schema.optional(Schema.String), outputDetails: Schema.optional(HistoryEventExecutionDataDetails), assignedVariables: Schema.optional(AssignedVariables), assignedVariablesDetails: Schema.optional(AssignedVariablesDetails)});
export const HistoryEvent = Schema.Struct({timestamp: Schema.Date, type: Schema.String, id: Schema.Number, previousEventId: Schema.optional(Schema.Number), activityFailedEventDetails: Schema.optional(ActivityFailedEventDetails), activityScheduleFailedEventDetails: Schema.optional(ActivityScheduleFailedEventDetails), activityScheduledEventDetails: Schema.optional(ActivityScheduledEventDetails), activityStartedEventDetails: Schema.optional(ActivityStartedEventDetails), activitySucceededEventDetails: Schema.optional(ActivitySucceededEventDetails), activityTimedOutEventDetails: Schema.optional(ActivityTimedOutEventDetails), taskFailedEventDetails: Schema.optional(TaskFailedEventDetails), taskScheduledEventDetails: Schema.optional(TaskScheduledEventDetails), taskStartFailedEventDetails: Schema.optional(TaskStartFailedEventDetails), taskStartedEventDetails: Schema.optional(TaskStartedEventDetails), taskSubmitFailedEventDetails: Schema.optional(TaskSubmitFailedEventDetails), taskSubmittedEventDetails: Schema.optional(TaskSubmittedEventDetails), taskSucceededEventDetails: Schema.optional(TaskSucceededEventDetails), taskTimedOutEventDetails: Schema.optional(TaskTimedOutEventDetails), executionFailedEventDetails: Schema.optional(ExecutionFailedEventDetails), executionStartedEventDetails: Schema.optional(ExecutionStartedEventDetails), executionSucceededEventDetails: Schema.optional(ExecutionSucceededEventDetails), executionAbortedEventDetails: Schema.optional(ExecutionAbortedEventDetails), executionTimedOutEventDetails: Schema.optional(ExecutionTimedOutEventDetails), executionRedrivenEventDetails: Schema.optional(ExecutionRedrivenEventDetails), mapStateStartedEventDetails: Schema.optional(MapStateStartedEventDetails), mapIterationStartedEventDetails: Schema.optional(MapIterationEventDetails), mapIterationSucceededEventDetails: Schema.optional(MapIterationEventDetails), mapIterationFailedEventDetails: Schema.optional(MapIterationEventDetails), mapIterationAbortedEventDetails: Schema.optional(MapIterationEventDetails), lambdaFunctionFailedEventDetails: Schema.optional(LambdaFunctionFailedEventDetails), lambdaFunctionScheduleFailedEventDetails: Schema.optional(LambdaFunctionScheduleFailedEventDetails), lambdaFunctionScheduledEventDetails: Schema.optional(LambdaFunctionScheduledEventDetails), lambdaFunctionStartFailedEventDetails: Schema.optional(LambdaFunctionStartFailedEventDetails), lambdaFunctionSucceededEventDetails: Schema.optional(LambdaFunctionSucceededEventDetails), lambdaFunctionTimedOutEventDetails: Schema.optional(LambdaFunctionTimedOutEventDetails), stateEnteredEventDetails: Schema.optional(StateEnteredEventDetails), stateExitedEventDetails: Schema.optional(StateExitedEventDetails), mapRunStartedEventDetails: Schema.optional(MapRunStartedEventDetails), mapRunFailedEventDetails: Schema.optional(MapRunFailedEventDetails), mapRunRedrivenEventDetails: Schema.optional(MapRunRedrivenEventDetails), evaluationFailedEventDetails: Schema.optional(EvaluationFailedEventDetails)});
export const HistoryEventList = Schema.Array(HistoryEvent);
export const ActivityLimitExceeded = Schema.Struct({message: Schema.optional(Schema.String)});
export const CreateStateMachineOutput = Schema.Struct({stateMachineArn: Schema.String, creationDate: Schema.Date, stateMachineVersionArn: Schema.optional(Schema.String)});
export const GetExecutionHistoryOutput = Schema.Struct({events: HistoryEventList, nextToken: Schema.optional(Schema.String)});
export const InvalidLoggingConfiguration = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidTracingConfiguration = Schema.Struct({message: Schema.optional(Schema.String)});
export const MissingRequiredParameter = Schema.Struct({message: Schema.optional(Schema.String)});
export const StateMachineAlreadyExists = Schema.Struct({message: Schema.optional(Schema.String)});
export const StateMachineLimitExceeded = Schema.Struct({message: Schema.optional(Schema.String)});
export const DeleteStateMachineVersion = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DeleteStateMachineVersion" }, DeleteStateMachineVersionInput, DeleteStateMachineVersionOutput, Schema.Union(ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UntagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.UntagResource" }, UntagResourceInput, UntagResourceOutput, Schema.Union(ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("ResourceNotFound", ResourceNotFound))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateMapRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.UpdateMapRun" }, UpdateMapRunInput, UpdateMapRunOutput, Schema.Union(ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("ResourceNotFound", ResourceNotFound), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteActivity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DeleteActivity" }, DeleteActivityInput, DeleteActivityOutput, ErrorAnnotation("InvalidArn", InvalidArn)), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteStateMachine = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DeleteStateMachine" }, DeleteStateMachineInput, DeleteStateMachineOutput, Schema.Union(ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DeleteStateMachineAlias = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DeleteStateMachineAlias" }, DeleteStateMachineAliasInput, DeleteStateMachineAliasOutput, Schema.Union(ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("ResourceNotFound", ResourceNotFound), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeStateMachineAlias = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DescribeStateMachineAlias" }, DescribeStateMachineAliasInput, DescribeStateMachineAliasOutput, Schema.Union(ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("ResourceNotFound", ResourceNotFound), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListTagsForResource" }, ListTagsForResourceInput, ListTagsForResourceOutput, Schema.Union(ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("ResourceNotFound", ResourceNotFound))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeActivity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DescribeActivity" }, DescribeActivityInput, DescribeActivityOutput, Schema.Union(ErrorAnnotation("ActivityDoesNotExist", ActivityDoesNotExist), ErrorAnnotation("InvalidArn", InvalidArn))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DescribeExecution" }, DescribeExecutionInput, DescribeExecutionOutput, Schema.Union(ErrorAnnotation("ExecutionDoesNotExist", ExecutionDoesNotExist), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("KmsAccessDeniedException", KmsAccessDeniedException), ErrorAnnotation("KmsInvalidStateException", KmsInvalidStateException), ErrorAnnotation("KmsThrottlingException", KmsThrottlingException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeMapRun = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DescribeMapRun" }, DescribeMapRunInput, DescribeMapRunOutput, Schema.Union(ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("ResourceNotFound", ResourceNotFound))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeStateMachineForExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DescribeStateMachineForExecution" }, DescribeStateMachineForExecutionInput, DescribeStateMachineForExecutionOutput, Schema.Union(ErrorAnnotation("ExecutionDoesNotExist", ExecutionDoesNotExist), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("KmsAccessDeniedException", KmsAccessDeniedException), ErrorAnnotation("KmsInvalidStateException", KmsInvalidStateException), ErrorAnnotation("KmsThrottlingException", KmsThrottlingException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetActivityTask = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.GetActivityTask" }, GetActivityTaskInput, GetActivityTaskOutput, Schema.Union(ErrorAnnotation("ActivityDoesNotExist", ActivityDoesNotExist), ErrorAnnotation("ActivityWorkerLimitExceeded", ActivityWorkerLimitExceeded), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("KmsAccessDeniedException", KmsAccessDeniedException), ErrorAnnotation("KmsInvalidStateException", KmsInvalidStateException), ErrorAnnotation("KmsThrottlingException", KmsThrottlingException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListActivities = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListActivities" }, ListActivitiesInput, ListActivitiesOutput, ErrorAnnotation("InvalidToken", InvalidToken)), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListMapRuns = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListMapRuns" }, ListMapRunsInput, ListMapRunsOutput, Schema.Union(ErrorAnnotation("ExecutionDoesNotExist", ExecutionDoesNotExist), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("InvalidToken", InvalidToken))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListStateMachineAliases = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListStateMachineAliases" }, ListStateMachineAliasesInput, ListStateMachineAliasesOutput, Schema.Union(ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("InvalidToken", InvalidToken), ErrorAnnotation("ResourceNotFound", ResourceNotFound), ErrorAnnotation("StateMachineDeleting", StateMachineDeleting), ErrorAnnotation("StateMachineDoesNotExist", StateMachineDoesNotExist))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListStateMachines = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListStateMachines" }, ListStateMachinesInput, ListStateMachinesOutput, ErrorAnnotation("InvalidToken", InvalidToken)), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListStateMachineVersions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListStateMachineVersions" }, ListStateMachineVersionsInput, ListStateMachineVersionsOutput, Schema.Union(ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("InvalidToken", InvalidToken), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const PublishStateMachineVersion = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.PublishStateMachineVersion" }, PublishStateMachineVersionInput, PublishStateMachineVersionOutput, Schema.Union(ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("StateMachineDeleting", StateMachineDeleting), ErrorAnnotation("StateMachineDoesNotExist", StateMachineDoesNotExist), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const SendTaskFailure = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.SendTaskFailure" }, SendTaskFailureInput, SendTaskFailureOutput, Schema.Union(ErrorAnnotation("InvalidToken", InvalidToken), ErrorAnnotation("KmsAccessDeniedException", KmsAccessDeniedException), ErrorAnnotation("KmsInvalidStateException", KmsInvalidStateException), ErrorAnnotation("KmsThrottlingException", KmsThrottlingException), ErrorAnnotation("TaskDoesNotExist", TaskDoesNotExist), ErrorAnnotation("TaskTimedOut", TaskTimedOut))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const SendTaskHeartbeat = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.SendTaskHeartbeat" }, SendTaskHeartbeatInput, SendTaskHeartbeatOutput, Schema.Union(ErrorAnnotation("InvalidToken", InvalidToken), ErrorAnnotation("TaskDoesNotExist", TaskDoesNotExist), ErrorAnnotation("TaskTimedOut", TaskTimedOut))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const SendTaskSuccess = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.SendTaskSuccess" }, SendTaskSuccessInput, SendTaskSuccessOutput, Schema.Union(ErrorAnnotation("InvalidOutput", InvalidOutput), ErrorAnnotation("InvalidToken", InvalidToken), ErrorAnnotation("KmsAccessDeniedException", KmsAccessDeniedException), ErrorAnnotation("KmsInvalidStateException", KmsInvalidStateException), ErrorAnnotation("KmsThrottlingException", KmsThrottlingException), ErrorAnnotation("TaskDoesNotExist", TaskDoesNotExist), ErrorAnnotation("TaskTimedOut", TaskTimedOut))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const StartSyncExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.StartSyncExecution" }, StartSyncExecutionInput, StartSyncExecutionOutput, Schema.Union(ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("InvalidExecutionInput", InvalidExecutionInput), ErrorAnnotation("InvalidName", InvalidName), ErrorAnnotation("KmsAccessDeniedException", KmsAccessDeniedException), ErrorAnnotation("KmsInvalidStateException", KmsInvalidStateException), ErrorAnnotation("KmsThrottlingException", KmsThrottlingException), ErrorAnnotation("StateMachineDeleting", StateMachineDeleting), ErrorAnnotation("StateMachineDoesNotExist", StateMachineDoesNotExist), ErrorAnnotation("StateMachineTypeNotSupported", StateMachineTypeNotSupported))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const StopExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.StopExecution" }, StopExecutionInput, StopExecutionOutput, Schema.Union(ErrorAnnotation("ExecutionDoesNotExist", ExecutionDoesNotExist), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("KmsAccessDeniedException", KmsAccessDeniedException), ErrorAnnotation("KmsInvalidStateException", KmsInvalidStateException), ErrorAnnotation("KmsThrottlingException", KmsThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const TagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.TagResource" }, TagResourceInput, TagResourceOutput, Schema.Union(ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("ResourceNotFound", ResourceNotFound), ErrorAnnotation("TooManyTags", TooManyTags))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateStateMachineAlias = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.UpdateStateMachineAlias" }, UpdateStateMachineAliasInput, UpdateStateMachineAliasOutput, Schema.Union(ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("ResourceNotFound", ResourceNotFound), ErrorAnnotation("StateMachineDeleting", StateMachineDeleting), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ValidateStateMachineDefinition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ValidateStateMachineDefinition" }, ValidateStateMachineDefinitionInput, ValidateStateMachineDefinitionOutput, ErrorAnnotation("ValidationException", ValidationException)), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateStateMachineAlias = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.CreateStateMachineAlias" }, CreateStateMachineAliasInput, CreateStateMachineAliasOutput, Schema.Union(ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("InvalidName", InvalidName), ErrorAnnotation("ResourceNotFound", ResourceNotFound), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("StateMachineDeleting", StateMachineDeleting), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DescribeStateMachine = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.DescribeStateMachine" }, DescribeStateMachineInput, DescribeStateMachineOutput, Schema.Union(ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("KmsAccessDeniedException", KmsAccessDeniedException), ErrorAnnotation("KmsInvalidStateException", KmsInvalidStateException), ErrorAnnotation("KmsThrottlingException", KmsThrottlingException), ErrorAnnotation("StateMachineDoesNotExist", StateMachineDoesNotExist))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ListExecutions = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.ListExecutions" }, ListExecutionsInput, ListExecutionsOutput, Schema.Union(ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("InvalidToken", InvalidToken), ErrorAnnotation("ResourceNotFound", ResourceNotFound), ErrorAnnotation("StateMachineDoesNotExist", StateMachineDoesNotExist), ErrorAnnotation("StateMachineTypeNotSupported", StateMachineTypeNotSupported), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const RedriveExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.RedriveExecution" }, RedriveExecutionInput, RedriveExecutionOutput, Schema.Union(ErrorAnnotation("ExecutionDoesNotExist", ExecutionDoesNotExist), ErrorAnnotation("ExecutionLimitExceeded", ExecutionLimitExceeded), ErrorAnnotation("ExecutionNotRedrivable", ExecutionNotRedrivable), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const StartExecution = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.StartExecution" }, StartExecutionInput, StartExecutionOutput, Schema.Union(ErrorAnnotation("ExecutionAlreadyExists", ExecutionAlreadyExists), ErrorAnnotation("ExecutionLimitExceeded", ExecutionLimitExceeded), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("InvalidExecutionInput", InvalidExecutionInput), ErrorAnnotation("InvalidName", InvalidName), ErrorAnnotation("KmsAccessDeniedException", KmsAccessDeniedException), ErrorAnnotation("KmsInvalidStateException", KmsInvalidStateException), ErrorAnnotation("KmsThrottlingException", KmsThrottlingException), ErrorAnnotation("StateMachineDeleting", StateMachineDeleting), ErrorAnnotation("StateMachineDoesNotExist", StateMachineDoesNotExist), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const TestState = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.TestState" }, TestStateInput, TestStateOutput, Schema.Union(ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("InvalidDefinition", InvalidDefinition), ErrorAnnotation("InvalidExecutionInput", InvalidExecutionInput), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateActivity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.CreateActivity" }, CreateActivityInput, CreateActivityOutput, Schema.Union(ErrorAnnotation("ActivityAlreadyExists", ActivityAlreadyExists), ErrorAnnotation("ActivityLimitExceeded", ActivityLimitExceeded), ErrorAnnotation("InvalidEncryptionConfiguration", InvalidEncryptionConfiguration), ErrorAnnotation("InvalidName", InvalidName), ErrorAnnotation("KmsAccessDeniedException", KmsAccessDeniedException), ErrorAnnotation("KmsThrottlingException", KmsThrottlingException), ErrorAnnotation("TooManyTags", TooManyTags))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetExecutionHistory = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.GetExecutionHistory" }, GetExecutionHistoryInput, GetExecutionHistoryOutput, Schema.Union(ErrorAnnotation("ExecutionDoesNotExist", ExecutionDoesNotExist), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("InvalidToken", InvalidToken), ErrorAnnotation("KmsAccessDeniedException", KmsAccessDeniedException), ErrorAnnotation("KmsInvalidStateException", KmsInvalidStateException), ErrorAnnotation("KmsThrottlingException", KmsThrottlingException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UpdateStateMachine = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.UpdateStateMachine" }, UpdateStateMachineInput, UpdateStateMachineOutput, Schema.Union(ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("InvalidDefinition", InvalidDefinition), ErrorAnnotation("InvalidEncryptionConfiguration", InvalidEncryptionConfiguration), ErrorAnnotation("InvalidLoggingConfiguration", InvalidLoggingConfiguration), ErrorAnnotation("InvalidTracingConfiguration", InvalidTracingConfiguration), ErrorAnnotation("KmsAccessDeniedException", KmsAccessDeniedException), ErrorAnnotation("KmsThrottlingException", KmsThrottlingException), ErrorAnnotation("MissingRequiredParameter", MissingRequiredParameter), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("StateMachineDeleting", StateMachineDeleting), ErrorAnnotation("StateMachineDoesNotExist", StateMachineDoesNotExist), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const CreateStateMachine = /*#__PURE__*/ makeOperation(() => Operation({ version: "2016-11-23", uri: "/", method: "POST", sdkId: "SFN", sigV4ServiceName: "states", name: "AWSStepFunctions.CreateStateMachine" }, CreateStateMachineInput, CreateStateMachineOutput, Schema.Union(ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InvalidArn", InvalidArn), ErrorAnnotation("InvalidDefinition", InvalidDefinition), ErrorAnnotation("InvalidEncryptionConfiguration", InvalidEncryptionConfiguration), ErrorAnnotation("InvalidLoggingConfiguration", InvalidLoggingConfiguration), ErrorAnnotation("InvalidName", InvalidName), ErrorAnnotation("InvalidTracingConfiguration", InvalidTracingConfiguration), ErrorAnnotation("KmsAccessDeniedException", KmsAccessDeniedException), ErrorAnnotation("KmsThrottlingException", KmsThrottlingException), ErrorAnnotation("StateMachineAlreadyExists", StateMachineAlreadyExists), ErrorAnnotation("StateMachineDeleting", StateMachineDeleting), ErrorAnnotation("StateMachineLimitExceeded", StateMachineLimitExceeded), ErrorAnnotation("StateMachineTypeNotSupported", StateMachineTypeNotSupported), ErrorAnnotation("TooManyTags", TooManyTags), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
