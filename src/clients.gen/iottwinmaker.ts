import { Schema} from "effect"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const GetPricingPlanRequest = Schema.Struct({});
export const ExtendsFrom = Schema.Array(Schema.String);
export const SceneCapabilities = Schema.Array(Schema.String);
export const SelectedPropertyList = Schema.Array(Schema.String);
export const TagKeyList = Schema.Array(Schema.String);
export const PricingBundles = Schema.Array(Schema.String);
export const CancelMetadataTransferJobRequest = Schema.Struct({metadataTransferJobId: Schema.String});
export const TagMap = Schema.Record({key: Schema.String, value: Schema.String});
export const CreateSyncJobRequest = Schema.Struct({workspaceId: Schema.String, syncSource: Schema.String, syncRole: Schema.String, tags: Schema.optional(TagMap)});
export const CreateWorkspaceRequest = Schema.Struct({workspaceId: Schema.String, description: Schema.optional(Schema.String), s3Location: Schema.optional(Schema.String), role: Schema.optional(Schema.String), tags: Schema.optional(TagMap)});
export const DeleteComponentTypeRequest = Schema.Struct({workspaceId: Schema.String, componentTypeId: Schema.String});
export const DeleteEntityRequest = Schema.Struct({workspaceId: Schema.String, entityId: Schema.String, isRecursive: Schema.optional(Schema.Boolean)});
export const DeleteSceneRequest = Schema.Struct({workspaceId: Schema.String, sceneId: Schema.String});
export const DeleteSceneResponse = Schema.Struct({});
export const DeleteSyncJobRequest = Schema.Struct({workspaceId: Schema.String, syncSource: Schema.String});
export const DeleteWorkspaceRequest = Schema.Struct({workspaceId: Schema.String});
export const ExecuteQueryRequest = Schema.Struct({workspaceId: Schema.String, queryStatement: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const GetComponentTypeRequest = Schema.Struct({workspaceId: Schema.String, componentTypeId: Schema.String});
export const GetEntityRequest = Schema.Struct({workspaceId: Schema.String, entityId: Schema.String});
export const GetMetadataTransferJobRequest = Schema.Struct({metadataTransferJobId: Schema.String});
export const GetSceneRequest = Schema.Struct({workspaceId: Schema.String, sceneId: Schema.String});
export const GetSyncJobRequest = Schema.Struct({syncSource: Schema.String, workspaceId: Schema.optional(Schema.String)});
export const GetWorkspaceRequest = Schema.Struct({workspaceId: Schema.String});
export const ListComponentsRequest = Schema.Struct({workspaceId: Schema.String, entityId: Schema.String, componentPath: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListPropertiesRequest = Schema.Struct({workspaceId: Schema.String, componentName: Schema.optional(Schema.String), componentPath: Schema.optional(Schema.String), entityId: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListScenesRequest = Schema.Struct({workspaceId: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListSyncJobsRequest = Schema.Struct({workspaceId: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListTagsForResourceRequest = Schema.Struct({resourceARN: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListWorkspacesRequest = Schema.Struct({maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const TagResourceRequest = Schema.Struct({resourceARN: Schema.String, tags: TagMap});
export const TagResourceResponse = Schema.Struct({});
export const UntagResourceRequest = Schema.Struct({resourceARN: Schema.String, tagKeys: TagKeyList});
export const UntagResourceResponse = Schema.Struct({});
export const DataValueMap = Schema.Record({key: Schema.String, value: DataValue});
export const RelationshipValue = Schema.Struct({targetEntityId: Schema.optional(Schema.String), targetComponentName: Schema.optional(Schema.String)});
export const DataValue = Schema.Struct({booleanValue: Schema.optional(Schema.Boolean), doubleValue: Schema.optional(Schema.Number), integerValue: Schema.optional(Schema.Number), longValue: Schema.optional(Schema.Number), stringValue: Schema.optional(Schema.String), listValue: Schema.optional(DataValueList), mapValue: Schema.optional(DataValueMap), relationshipValue: Schema.optional(RelationshipValue), expression: Schema.optional(Schema.String)});
export const DataValueList = Schema.Array(DataValue);
export const Relationship = Schema.Struct({targetComponentTypeId: Schema.optional(Schema.String), relationshipType: Schema.optional(Schema.String)});
export const DataType = Schema.Struct({type: Schema.String, nestedType: Schema.optional(DataType), allowedValues: Schema.optional(DataValueList), unitOfMeasure: Schema.optional(Schema.String), relationship: Schema.optional(Relationship)});
export const Configuration = Schema.Record({key: Schema.String, value: Schema.String});
export const PropertyDefinitionRequest = Schema.Struct({dataType: Schema.optional(DataType), isRequiredInEntity: Schema.optional(Schema.Boolean), isExternalId: Schema.optional(Schema.Boolean), isStoredExternally: Schema.optional(Schema.Boolean), isTimeSeries: Schema.optional(Schema.Boolean), defaultValue: Schema.optional(DataValue), configuration: Schema.optional(Configuration), displayName: Schema.optional(Schema.String)});
export const PropertyDefinitionsRequest = Schema.Record({key: Schema.String, value: PropertyDefinitionRequest});
export const RequiredProperties = Schema.Array(Schema.String);
export const LambdaFunction = Schema.Struct({arn: Schema.String});
export const DataConnector = Schema.Struct({lambda: Schema.optional(LambdaFunction), isNative: Schema.optional(Schema.Boolean)});
export const FunctionRequest = Schema.Struct({requiredProperties: Schema.optional(RequiredProperties), scope: Schema.optional(Schema.String), implementedBy: Schema.optional(DataConnector)});
export const FunctionsRequest = Schema.Record({key: Schema.String, value: FunctionRequest});
export const PropertyNames = Schema.Array(Schema.String);
export const PropertyGroupRequest = Schema.Struct({groupType: Schema.optional(Schema.String), propertyNames: Schema.optional(PropertyNames)});
export const PropertyGroupsRequest = Schema.Record({key: Schema.String, value: PropertyGroupRequest});
export const CompositeComponentTypeRequest = Schema.Struct({componentTypeId: Schema.optional(Schema.String)});
export const CompositeComponentTypesRequest = Schema.Record({key: Schema.String, value: CompositeComponentTypeRequest});
export const UpdateComponentTypeRequest = Schema.Struct({workspaceId: Schema.String, isSingleton: Schema.optional(Schema.Boolean), componentTypeId: Schema.String, description: Schema.optional(Schema.String), propertyDefinitions: Schema.optional(PropertyDefinitionsRequest), extendsFrom: Schema.optional(ExtendsFrom), functions: Schema.optional(FunctionsRequest), propertyGroups: Schema.optional(PropertyGroupsRequest), componentTypeName: Schema.optional(Schema.String), compositeComponentTypes: Schema.optional(CompositeComponentTypesRequest)});
export const UpdatePricingPlanRequest = Schema.Struct({pricingMode: Schema.String, bundleNames: Schema.optional(PricingBundles)});
export const SceneMetadataMap = Schema.Record({key: Schema.String, value: Schema.String});
export const UpdateSceneRequest = Schema.Struct({workspaceId: Schema.String, sceneId: Schema.String, contentLocation: Schema.optional(Schema.String), description: Schema.optional(Schema.String), capabilities: Schema.optional(SceneCapabilities), sceneMetadata: Schema.optional(SceneMetadataMap)});
export const UpdateWorkspaceRequest = Schema.Struct({workspaceId: Schema.String, description: Schema.optional(Schema.String), role: Schema.optional(Schema.String), s3Location: Schema.optional(Schema.String)});
export const InterpolationParameters = Schema.Struct({interpolationType: Schema.optional(Schema.String), intervalInSeconds: Schema.optional(Schema.Number)});
export const LinkedServices = Schema.Array(Schema.String);
export const ListComponentTypesFilter = Schema.Union(Schema.String, Schema.String, Schema.Boolean);
export const ListComponentTypesFilters = Schema.Array(ListComponentTypesFilter);
export const ListEntitiesFilter = Schema.Union(Schema.String, Schema.String, Schema.String);
export const ListEntitiesFilters = Schema.Array(ListEntitiesFilter);
export const ListMetadataTransferJobsFilter = Schema.Union(Schema.String, Schema.String);
export const ListMetadataTransferJobsFilters = Schema.Array(ListMetadataTransferJobsFilter);
export const SyncResourceFilter = Schema.Union(Schema.String, Schema.String, Schema.String, Schema.String);
export const SyncResourceFilters = Schema.Array(SyncResourceFilter);
export const ParentEntityUpdateRequest = Schema.Struct({updateType: Schema.String, parentEntityId: Schema.optional(Schema.String)});
export const CreateSceneRequest = Schema.Struct({workspaceId: Schema.String, sceneId: Schema.String, contentLocation: Schema.String, description: Schema.optional(Schema.String), capabilities: Schema.optional(SceneCapabilities), tags: Schema.optional(TagMap), sceneMetadata: Schema.optional(SceneMetadataMap)});
export const CreateSyncJobResponse = Schema.Struct({arn: Schema.String, creationDateTime: Schema.Date, state: Schema.String});
export const CreateWorkspaceResponse = Schema.Struct({arn: Schema.String, creationDateTime: Schema.Date});
export const DeleteComponentTypeResponse = Schema.Struct({state: Schema.String});
export const DeleteEntityResponse = Schema.Struct({state: Schema.String});
export const AccessDeniedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DeleteSyncJobResponse = Schema.Struct({state: Schema.String});
export const DeleteWorkspaceResponse = Schema.Struct({message: Schema.optional(Schema.String)});
export const S3SourceConfiguration = Schema.Struct({location: Schema.String});
export const FilterByAssetModel = Schema.Struct({assetModelId: Schema.optional(Schema.String), assetModelExternalId: Schema.optional(Schema.String), includeOffspring: Schema.optional(Schema.Boolean), includeAssets: Schema.optional(Schema.Boolean)});
export const FilterByAsset = Schema.Struct({assetId: Schema.optional(Schema.String), assetExternalId: Schema.optional(Schema.String), includeOffspring: Schema.optional(Schema.Boolean), includeAssetModel: Schema.optional(Schema.Boolean)});
export const IotSiteWiseSourceConfigurationFilter = Schema.Union(FilterByAssetModel, FilterByAsset);
export const IotSiteWiseSourceConfigurationFilters = Schema.Array(IotSiteWiseSourceConfigurationFilter);
export const IotSiteWiseSourceConfiguration = Schema.Struct({filters: Schema.optional(IotSiteWiseSourceConfigurationFilters)});
export const FilterByComponentType = Schema.Struct({componentTypeId: Schema.String});
export const FilterByEntity = Schema.Struct({entityId: Schema.String});
export const IotTwinMakerSourceConfigurationFilter = Schema.Union(FilterByComponentType, FilterByEntity);
export const IotTwinMakerSourceConfigurationFilters = Schema.Array(IotTwinMakerSourceConfigurationFilter);
export const IotTwinMakerSourceConfiguration = Schema.Struct({workspace: Schema.String, filters: Schema.optional(IotTwinMakerSourceConfigurationFilters)});
export const SourceConfiguration = Schema.Struct({type: Schema.String, s3Configuration: Schema.optional(S3SourceConfiguration), iotSiteWiseConfiguration: Schema.optional(IotSiteWiseSourceConfiguration), iotTwinMakerConfiguration: Schema.optional(IotTwinMakerSourceConfiguration)});
export const SourceConfigurations = Schema.Array(SourceConfiguration);
export const S3DestinationConfiguration = Schema.Struct({location: Schema.String});
export const IotTwinMakerDestinationConfiguration = Schema.Struct({workspace: Schema.String});
export const DestinationConfiguration = Schema.Struct({type: Schema.String, s3Configuration: Schema.optional(S3DestinationConfiguration), iotTwinMakerConfiguration: Schema.optional(IotTwinMakerDestinationConfiguration)});
export const ErrorDetails = Schema.Struct({code: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const MetadataTransferJobStatus = Schema.Struct({state: Schema.optional(Schema.String), error: Schema.optional(ErrorDetails), queuedPosition: Schema.optional(Schema.Number)});
export const MetadataTransferJobProgress = Schema.Struct({totalCount: Schema.optional(Schema.Number), succeededCount: Schema.optional(Schema.Number), skippedCount: Schema.optional(Schema.Number), failedCount: Schema.optional(Schema.Number)});
export const GetMetadataTransferJobResponse = Schema.Struct({metadataTransferJobId: Schema.String, arn: Schema.String, description: Schema.optional(Schema.String), sources: SourceConfigurations, destination: DestinationConfiguration, metadataTransferJobRole: Schema.String, reportUrl: Schema.optional(Schema.String), creationDateTime: Schema.Date, updateDateTime: Schema.Date, status: MetadataTransferJobStatus, progress: Schema.optional(MetadataTransferJobProgress)});
export const GetWorkspaceResponse = Schema.Struct({workspaceId: Schema.String, arn: Schema.String, description: Schema.optional(Schema.String), linkedServices: Schema.optional(LinkedServices), s3Location: Schema.optional(Schema.String), role: Schema.optional(Schema.String), creationDateTime: Schema.Date, updateDateTime: Schema.Date});
export const ListComponentTypesRequest = Schema.Struct({workspaceId: Schema.String, filters: Schema.optional(ListComponentTypesFilters), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListEntitiesRequest = Schema.Struct({workspaceId: Schema.String, filters: Schema.optional(ListEntitiesFilters), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListMetadataTransferJobsRequest = Schema.Struct({sourceType: Schema.String, destinationType: Schema.String, filters: Schema.optional(ListMetadataTransferJobsFilters), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListSyncResourcesRequest = Schema.Struct({workspaceId: Schema.String, syncSource: Schema.String, filters: Schema.optional(SyncResourceFilters), maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String)});
export const ListTagsForResourceResponse = Schema.Struct({tags: Schema.optional(TagMap), nextToken: Schema.optional(Schema.String)});
export const ResourceNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdateComponentTypeResponse = Schema.Struct({workspaceId: Schema.String, arn: Schema.String, componentTypeId: Schema.String, state: Schema.String});
export const BundleInformation = Schema.Struct({bundleNames: PricingBundles, pricingTier: Schema.optional(Schema.String)});
export const PricingPlan = Schema.Struct({billableEntityCount: Schema.optional(Schema.Number), bundleInformation: Schema.optional(BundleInformation), effectiveDateTime: Schema.Date, pricingMode: Schema.String, updateDateTime: Schema.Date, updateReason: Schema.String});
export const UpdatePricingPlanResponse = Schema.Struct({currentPricingPlan: PricingPlan, pendingPricingPlan: Schema.optional(PricingPlan)});
export const UpdateSceneResponse = Schema.Struct({updateDateTime: Schema.Date});
export const UpdateWorkspaceResponse = Schema.Struct({updateDateTime: Schema.Date});
export const PropertyValue = Schema.Struct({timestamp: Schema.optional(Schema.Date), value: DataValue, time: Schema.optional(Schema.String)});
export const PropertyValues = Schema.Array(PropertyValue);
export const PropertyRequest = Schema.Struct({definition: Schema.optional(PropertyDefinitionRequest), value: Schema.optional(DataValue), updateType: Schema.optional(Schema.String)});
export const PropertyRequests = Schema.Record({key: Schema.String, value: PropertyRequest});
export const ComponentPropertyGroupRequest = Schema.Struct({groupType: Schema.optional(Schema.String), propertyNames: Schema.optional(PropertyNames), updateType: Schema.optional(Schema.String)});
export const ComponentPropertyGroupRequests = Schema.Record({key: Schema.String, value: ComponentPropertyGroupRequest});
export const CompositeComponentRequest = Schema.Struct({description: Schema.optional(Schema.String), properties: Schema.optional(PropertyRequests), propertyGroups: Schema.optional(ComponentPropertyGroupRequests)});
export const RowData = Schema.Array(Schema.JsonValue);
export const OrderBy = Schema.Struct({order: Schema.optional(Schema.String), propertyName: Schema.String});
export const OrderByList = Schema.Array(OrderBy);
export const ComponentUpdateRequest = Schema.Struct({updateType: Schema.optional(Schema.String), description: Schema.optional(Schema.String), componentTypeId: Schema.optional(Schema.String), propertyUpdates: Schema.optional(PropertyRequests), propertyGroupUpdates: Schema.optional(ComponentPropertyGroupRequests)});
export const CompositeComponentUpdateRequest = Schema.Struct({updateType: Schema.optional(Schema.String), description: Schema.optional(Schema.String), propertyUpdates: Schema.optional(PropertyRequests), propertyGroupUpdates: Schema.optional(ComponentPropertyGroupRequests)});
export const CompositeComponentsMapRequest = Schema.Record({key: Schema.String, value: CompositeComponentRequest});
export const ColumnDescription = Schema.Struct({name: Schema.optional(Schema.String), type: Schema.optional(Schema.String)});
export const ColumnDescriptions = Schema.Array(ColumnDescription);
export const Row = Schema.Struct({rowData: Schema.optional(RowData)});
export const Rows = Schema.Array(Row);
export const Status = Schema.Struct({state: Schema.optional(Schema.String), error: Schema.optional(ErrorDetails)});
export const PropertyFilter = Schema.Struct({propertyName: Schema.optional(Schema.String), operator: Schema.optional(Schema.String), value: Schema.optional(DataValue)});
export const PropertyFilters = Schema.Array(PropertyFilter);
export const TabularConditions = Schema.Struct({orderBy: Schema.optional(OrderByList), propertyFilters: Schema.optional(PropertyFilters)});
export const GeneratedSceneMetadataMap = Schema.Record({key: Schema.String, value: Schema.String});
export const SceneError = Schema.Struct({code: Schema.optional(Schema.String), message: Schema.optional(Schema.String)});
export const SyncJobStatus = Schema.Struct({state: Schema.optional(Schema.String), error: Schema.optional(ErrorDetails)});
export const PropertyDefinitionResponse = Schema.Struct({dataType: DataType, isTimeSeries: Schema.Boolean, isRequiredInEntity: Schema.Boolean, isExternalId: Schema.Boolean, isStoredExternally: Schema.Boolean, isImported: Schema.Boolean, isFinal: Schema.Boolean, isInherited: Schema.Boolean, defaultValue: Schema.optional(DataValue), configuration: Schema.optional(Configuration), displayName: Schema.optional(Schema.String)});
export const PropertySummary = Schema.Struct({definition: Schema.optional(PropertyDefinitionResponse), propertyName: Schema.String, value: Schema.optional(DataValue), areAllPropertyValuesReturned: Schema.optional(Schema.Boolean)});
export const PropertySummaries = Schema.Array(PropertySummary);
export const SceneSummary = Schema.Struct({sceneId: Schema.String, contentLocation: Schema.String, arn: Schema.String, creationDateTime: Schema.Date, updateDateTime: Schema.Date, description: Schema.optional(Schema.String)});
export const SceneSummaries = Schema.Array(SceneSummary);
export const SyncJobSummary = Schema.Struct({arn: Schema.optional(Schema.String), workspaceId: Schema.optional(Schema.String), syncSource: Schema.optional(Schema.String), status: Schema.optional(SyncJobStatus), creationDateTime: Schema.optional(Schema.Date), updateDateTime: Schema.optional(Schema.Date)});
export const SyncJobSummaries = Schema.Array(SyncJobSummary);
export const WorkspaceSummary = Schema.Struct({workspaceId: Schema.String, arn: Schema.String, description: Schema.optional(Schema.String), linkedServices: Schema.optional(LinkedServices), creationDateTime: Schema.Date, updateDateTime: Schema.Date});
export const WorkspaceSummaries = Schema.Array(WorkspaceSummary);
export const ComponentUpdatesMapRequest = Schema.Record({key: Schema.String, value: ComponentUpdateRequest});
export const CompositeComponentUpdatesMapRequest = Schema.Record({key: Schema.String, value: CompositeComponentUpdateRequest});
export const ExternalIdProperty = Schema.Record({key: Schema.String, value: Schema.String});
export const CreateSceneResponse = Schema.Struct({arn: Schema.String, creationDateTime: Schema.Date});
export const ConflictException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InternalServerException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ThrottlingException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ServiceQuotaExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ValidationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ExecuteQueryResponse = Schema.Struct({columnDescriptions: Schema.optional(ColumnDescriptions), rows: Schema.optional(Rows), nextToken: Schema.optional(Schema.String)});
export const GetPricingPlanResponse = Schema.Struct({currentPricingPlan: PricingPlan, pendingPricingPlan: Schema.optional(PricingPlan)});
export const GetPropertyValueRequest = Schema.Struct({componentName: Schema.optional(Schema.String), componentPath: Schema.optional(Schema.String), componentTypeId: Schema.optional(Schema.String), entityId: Schema.optional(Schema.String), selectedProperties: SelectedPropertyList, workspaceId: Schema.String, maxResults: Schema.optional(Schema.Number), nextToken: Schema.optional(Schema.String), propertyGroupName: Schema.optional(Schema.String), tabularConditions: Schema.optional(TabularConditions)});
export const GetSceneResponse = Schema.Struct({workspaceId: Schema.String, sceneId: Schema.String, contentLocation: Schema.String, arn: Schema.String, creationDateTime: Schema.Date, updateDateTime: Schema.Date, description: Schema.optional(Schema.String), capabilities: Schema.optional(SceneCapabilities), sceneMetadata: Schema.optional(SceneMetadataMap), generatedSceneMetadata: Schema.optional(GeneratedSceneMetadataMap), error: Schema.optional(SceneError)});
export const GetSyncJobResponse = Schema.Struct({arn: Schema.String, workspaceId: Schema.String, syncSource: Schema.String, syncRole: Schema.String, status: SyncJobStatus, creationDateTime: Schema.Date, updateDateTime: Schema.Date});
export const ListPropertiesResponse = Schema.Struct({propertySummaries: PropertySummaries, nextToken: Schema.optional(Schema.String)});
export const ListScenesResponse = Schema.Struct({sceneSummaries: Schema.optional(SceneSummaries), nextToken: Schema.optional(Schema.String)});
export const ListSyncJobsResponse = Schema.Struct({syncJobSummaries: Schema.optional(SyncJobSummaries), nextToken: Schema.optional(Schema.String)});
export const ListWorkspacesResponse = Schema.Struct({workspaceSummaries: Schema.optional(WorkspaceSummaries), nextToken: Schema.optional(Schema.String)});
export const TooManyTagsException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdateEntityRequest = Schema.Struct({workspaceId: Schema.String, entityId: Schema.String, entityName: Schema.optional(Schema.String), description: Schema.optional(Schema.String), componentUpdates: Schema.optional(ComponentUpdatesMapRequest), compositeComponentUpdates: Schema.optional(CompositeComponentUpdatesMapRequest), parentEntityUpdate: Schema.optional(ParentEntityUpdateRequest)});
export const EntityPropertyReference = Schema.Struct({componentName: Schema.optional(Schema.String), componentPath: Schema.optional(Schema.String), externalIdProperty: Schema.optional(ExternalIdProperty), entityId: Schema.optional(Schema.String), propertyName: Schema.String});
export const FunctionResponse = Schema.Struct({requiredProperties: Schema.optional(RequiredProperties), scope: Schema.optional(Schema.String), implementedBy: Schema.optional(DataConnector), isInherited: Schema.optional(Schema.Boolean)});
export const PropertyGroupResponse = Schema.Struct({groupType: Schema.String, propertyNames: PropertyNames, isInherited: Schema.Boolean});
export const CompositeComponentTypeResponse = Schema.Struct({componentTypeId: Schema.optional(Schema.String), isInherited: Schema.optional(Schema.Boolean)});
export const PropertyValueEntry = Schema.Struct({entityPropertyReference: EntityPropertyReference, propertyValues: Schema.optional(PropertyValues)});
export const Entries = Schema.Array(PropertyValueEntry);
export const PropertyDefinitionsResponse = Schema.Record({key: Schema.String, value: PropertyDefinitionResponse});
export const FunctionsResponse = Schema.Record({key: Schema.String, value: FunctionResponse});
export const PropertyGroupsResponse = Schema.Record({key: Schema.String, value: PropertyGroupResponse});
export const CompositeComponentTypesResponse = Schema.Record({key: Schema.String, value: CompositeComponentTypeResponse});
export const ComponentTypeSummary = Schema.Struct({arn: Schema.String, componentTypeId: Schema.String, creationDateTime: Schema.Date, updateDateTime: Schema.Date, description: Schema.optional(Schema.String), status: Schema.optional(Status), componentTypeName: Schema.optional(Schema.String)});
export const ComponentTypeSummaries = Schema.Array(ComponentTypeSummary);
export const EntitySummary = Schema.Struct({entityId: Schema.String, entityName: Schema.String, arn: Schema.String, parentEntityId: Schema.optional(Schema.String), status: Status, description: Schema.optional(Schema.String), hasChildEntities: Schema.optional(Schema.Boolean), creationDateTime: Schema.Date, updateDateTime: Schema.Date});
export const EntitySummaries = Schema.Array(EntitySummary);
export const MetadataTransferJobSummary = Schema.Struct({metadataTransferJobId: Schema.String, arn: Schema.String, creationDateTime: Schema.Date, updateDateTime: Schema.Date, status: MetadataTransferJobStatus, progress: Schema.optional(MetadataTransferJobProgress)});
export const MetadataTransferJobSummaries = Schema.Array(MetadataTransferJobSummary);
export const ComponentPropertyGroupResponse = Schema.Struct({groupType: Schema.String, propertyNames: PropertyNames, isInherited: Schema.Boolean});
export const ComponentPropertyGroupResponses = Schema.Record({key: Schema.String, value: ComponentPropertyGroupResponse});
export const ComponentSummary = Schema.Struct({componentName: Schema.String, componentTypeId: Schema.String, definedIn: Schema.optional(Schema.String), description: Schema.optional(Schema.String), propertyGroups: Schema.optional(ComponentPropertyGroupResponses), status: Status, syncSource: Schema.optional(Schema.String), componentPath: Schema.optional(Schema.String)});
export const CompositeComponentResponse = Schema.Record({key: Schema.String, value: ComponentSummary});
export const BatchPutPropertyValuesRequest = Schema.Struct({workspaceId: Schema.String, entries: Entries});
export const CancelMetadataTransferJobResponse = Schema.Struct({metadataTransferJobId: Schema.String, arn: Schema.String, updateDateTime: Schema.Date, status: MetadataTransferJobStatus, progress: Schema.optional(MetadataTransferJobProgress)});
export const QueryTimeoutException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GetComponentTypeResponse = Schema.Struct({workspaceId: Schema.String, isSingleton: Schema.optional(Schema.Boolean), componentTypeId: Schema.String, description: Schema.optional(Schema.String), propertyDefinitions: Schema.optional(PropertyDefinitionsResponse), extendsFrom: Schema.optional(ExtendsFrom), functions: Schema.optional(FunctionsResponse), creationDateTime: Schema.Date, updateDateTime: Schema.Date, arn: Schema.String, isAbstract: Schema.optional(Schema.Boolean), isSchemaInitialized: Schema.optional(Schema.Boolean), status: Schema.optional(Status), propertyGroups: Schema.optional(PropertyGroupsResponse), syncSource: Schema.optional(Schema.String), componentTypeName: Schema.optional(Schema.String), compositeComponentTypes: Schema.optional(CompositeComponentTypesResponse)});
export const GetPropertyValueHistoryRequest = Schema.Struct({workspaceId: Schema.String, entityId: Schema.optional(Schema.String), componentName: Schema.optional(Schema.String), componentPath: Schema.optional(Schema.String), componentTypeId: Schema.optional(Schema.String), selectedProperties: SelectedPropertyList, propertyFilters: Schema.optional(PropertyFilters), startDateTime: Schema.optional(Schema.Date), endDateTime: Schema.optional(Schema.Date), interpolation: Schema.optional(InterpolationParameters), nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number), orderByTime: Schema.optional(Schema.String), startTime: Schema.optional(Schema.String), endTime: Schema.optional(Schema.String)});
export const ListComponentTypesResponse = Schema.Struct({workspaceId: Schema.String, componentTypeSummaries: ComponentTypeSummaries, nextToken: Schema.optional(Schema.String), maxResults: Schema.optional(Schema.Number)});
export const ListEntitiesResponse = Schema.Struct({entitySummaries: Schema.optional(EntitySummaries), nextToken: Schema.optional(Schema.String)});
export const ListMetadataTransferJobsResponse = Schema.Struct({metadataTransferJobSummaries: MetadataTransferJobSummaries, nextToken: Schema.optional(Schema.String)});
export const UpdateEntityResponse = Schema.Struct({updateDateTime: Schema.Date, state: Schema.String});
export const ComponentRequest = Schema.Struct({description: Schema.optional(Schema.String), componentTypeId: Schema.optional(Schema.String), properties: Schema.optional(PropertyRequests), propertyGroups: Schema.optional(ComponentPropertyGroupRequests)});
export const SyncResourceStatus = Schema.Struct({state: Schema.optional(Schema.String), error: Schema.optional(ErrorDetails)});
export const PropertyResponse = Schema.Struct({definition: Schema.optional(PropertyDefinitionResponse), value: Schema.optional(DataValue), areAllPropertyValuesReturned: Schema.optional(Schema.Boolean)});
export const ComponentsMapRequest = Schema.Record({key: Schema.String, value: ComponentRequest});
export const PropertyTableValue = Schema.Record({key: Schema.String, value: DataValue});
export const TabularPropertyValue = Schema.Array(PropertyTableValue);
export const TabularPropertyValues = Schema.Array(TabularPropertyValue);
export const ComponentSummaries = Schema.Array(ComponentSummary);
export const SyncResourceSummary = Schema.Struct({resourceType: Schema.optional(Schema.String), externalId: Schema.optional(Schema.String), resourceId: Schema.optional(Schema.String), status: Schema.optional(SyncResourceStatus), updateDateTime: Schema.optional(Schema.Date)});
export const SyncResourceSummaries = Schema.Array(SyncResourceSummary);
export const PropertyResponses = Schema.Record({key: Schema.String, value: PropertyResponse});
export const CreateComponentTypeRequest = Schema.Struct({workspaceId: Schema.String, isSingleton: Schema.optional(Schema.Boolean), componentTypeId: Schema.String, description: Schema.optional(Schema.String), propertyDefinitions: Schema.optional(PropertyDefinitionsRequest), extendsFrom: Schema.optional(ExtendsFrom), functions: Schema.optional(FunctionsRequest), tags: Schema.optional(TagMap), propertyGroups: Schema.optional(PropertyGroupsRequest), componentTypeName: Schema.optional(Schema.String), compositeComponentTypes: Schema.optional(CompositeComponentTypesRequest)});
export const CreateEntityRequest = Schema.Struct({workspaceId: Schema.String, entityId: Schema.optional(Schema.String), entityName: Schema.String, description: Schema.optional(Schema.String), components: Schema.optional(ComponentsMapRequest), compositeComponents: Schema.optional(CompositeComponentsMapRequest), parentEntityId: Schema.optional(Schema.String), tags: Schema.optional(TagMap)});
export const CreateMetadataTransferJobRequest = Schema.Struct({metadataTransferJobId: Schema.optional(Schema.String), description: Schema.optional(Schema.String), sources: SourceConfigurations, destination: DestinationConfiguration});
export const ListComponentsResponse = Schema.Struct({componentSummaries: ComponentSummaries, nextToken: Schema.optional(Schema.String)});
export const ListSyncResourcesResponse = Schema.Struct({syncResources: Schema.optional(SyncResourceSummaries), nextToken: Schema.optional(Schema.String)});
export const ComponentResponse = Schema.Struct({componentName: Schema.optional(Schema.String), description: Schema.optional(Schema.String), componentTypeId: Schema.optional(Schema.String), status: Schema.optional(Status), definedIn: Schema.optional(Schema.String), properties: Schema.optional(PropertyResponses), propertyGroups: Schema.optional(ComponentPropertyGroupResponses), syncSource: Schema.optional(Schema.String), areAllPropertiesReturned: Schema.optional(Schema.Boolean), compositeComponents: Schema.optional(CompositeComponentResponse), areAllCompositeComponentsReturned: Schema.optional(Schema.Boolean)});
export const PropertyLatestValue = Schema.Struct({propertyReference: EntityPropertyReference, propertyValue: Schema.optional(DataValue)});
export const Values = Schema.Array(PropertyValue);
export const ComponentsMap = Schema.Record({key: Schema.String, value: ComponentResponse});
export const PropertyLatestValueMap = Schema.Record({key: Schema.String, value: PropertyLatestValue});
export const PropertyValueHistory = Schema.Struct({entityPropertyReference: EntityPropertyReference, values: Schema.optional(Values)});
export const PropertyValueList = Schema.Array(PropertyValueHistory);
export const CreateComponentTypeResponse = Schema.Struct({arn: Schema.String, creationDateTime: Schema.Date, state: Schema.String});
export const CreateEntityResponse = Schema.Struct({entityId: Schema.String, arn: Schema.String, creationDateTime: Schema.Date, state: Schema.String});
export const CreateMetadataTransferJobResponse = Schema.Struct({metadataTransferJobId: Schema.String, arn: Schema.String, creationDateTime: Schema.Date, status: MetadataTransferJobStatus});
export const GetEntityResponse = Schema.Struct({entityId: Schema.String, entityName: Schema.String, arn: Schema.String, status: Status, workspaceId: Schema.String, description: Schema.optional(Schema.String), components: Schema.optional(ComponentsMap), parentEntityId: Schema.String, hasChildEntities: Schema.Boolean, creationDateTime: Schema.Date, updateDateTime: Schema.Date, syncSource: Schema.optional(Schema.String), areAllComponentsReturned: Schema.optional(Schema.Boolean)});
export const GetPropertyValueResponse = Schema.Struct({propertyValues: Schema.optional(PropertyLatestValueMap), nextToken: Schema.optional(Schema.String), tabularPropertyValues: Schema.optional(TabularPropertyValues)});
export const GetPropertyValueHistoryResponse = Schema.Struct({propertyValues: PropertyValueList, nextToken: Schema.optional(Schema.String)});
export const BatchPutPropertyError = Schema.Struct({errorCode: Schema.String, errorMessage: Schema.String, entry: PropertyValueEntry});
export const Errors = Schema.Array(BatchPutPropertyError);
export const BatchPutPropertyErrorEntry = Schema.Struct({errors: Errors});
export const ErrorEntries = Schema.Array(BatchPutPropertyErrorEntry);
export const BatchPutPropertyValuesResponse = Schema.Struct({errorEntries: ErrorEntries});
export const ConnectorFailureException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ConnectorTimeoutException = Schema.Struct({message: Schema.optional(Schema.String)});

//# Errors
export class AccessDeniedExceptionError extends Schema.TaggedError<AccessDeniedExceptionError>()("AccessDeniedException", AccessDeniedException) {};
export class ResourceNotFoundExceptionError extends Schema.TaggedError<ResourceNotFoundExceptionError>()("ResourceNotFoundException", ResourceNotFoundException) {};
export class ConflictExceptionError extends Schema.TaggedError<ConflictExceptionError>()("ConflictException", ConflictException) {};
export class InternalServerExceptionError extends Schema.TaggedError<InternalServerExceptionError>()("InternalServerException", InternalServerException) {};
export class ThrottlingExceptionError extends Schema.TaggedError<ThrottlingExceptionError>()("ThrottlingException", ThrottlingException) {};
export class ServiceQuotaExceededExceptionError extends Schema.TaggedError<ServiceQuotaExceededExceptionError>()("ServiceQuotaExceededException", ServiceQuotaExceededException) {};
export class ValidationExceptionError extends Schema.TaggedError<ValidationExceptionError>()("ValidationException", ValidationException) {};
export class TooManyTagsExceptionError extends Schema.TaggedError<TooManyTagsExceptionError>()("TooManyTagsException", TooManyTagsException) {};
export class QueryTimeoutExceptionError extends Schema.TaggedError<QueryTimeoutExceptionError>()("QueryTimeoutException", QueryTimeoutException) {};
export class ConnectorFailureExceptionError extends Schema.TaggedError<ConnectorFailureExceptionError>()("ConnectorFailureException", ConnectorFailureException) {};
export class ConnectorTimeoutExceptionError extends Schema.TaggedError<ConnectorTimeoutExceptionError>()("ConnectorTimeoutException", ConnectorTimeoutException) {};

//# Operations
export const untagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/tags", method: "DELETE", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.UntagResource" }, UntagResourceRequest, UntagResourceResponse, [AccessDeniedExceptionError, ResourceNotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteSyncJob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/sync-jobs/{syncSource}", method: "DELETE", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.DeleteSyncJob" }, DeleteSyncJobRequest, DeleteSyncJobResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteWorkspace = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}", method: "DELETE", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.DeleteWorkspace" }, DeleteWorkspaceRequest, DeleteWorkspaceResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getMetadataTransferJob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/metadata-transfer-jobs/{metadataTransferJobId}", method: "GET", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.GetMetadataTransferJob" }, GetMetadataTransferJobRequest, GetMetadataTransferJobResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getWorkspace = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}", method: "GET", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.GetWorkspace" }, GetWorkspaceRequest, GetWorkspaceResponse, [InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/tags-list", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.ListTagsForResource" }, ListTagsForResourceRequest, ListTagsForResourceResponse, [AccessDeniedExceptionError, ResourceNotFoundExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateComponentType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/component-types/{componentTypeId}", method: "PUT", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.UpdateComponentType" }, UpdateComponentTypeRequest, UpdateComponentTypeResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updatePricingPlan = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/pricingplan", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.UpdatePricingPlan" }, UpdatePricingPlanRequest, UpdatePricingPlanResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateScene = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/scenes/{sceneId}", method: "PUT", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.UpdateScene" }, UpdateSceneRequest, UpdateSceneResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateWorkspace = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}", method: "PUT", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.UpdateWorkspace" }, UpdateWorkspaceRequest, UpdateWorkspaceResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createScene = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/scenes", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.CreateScene" }, CreateSceneRequest, CreateSceneResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createSyncJob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/sync-jobs/{syncSource}", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.CreateSyncJob" }, CreateSyncJobRequest, CreateSyncJobResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createWorkspace = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.CreateWorkspace" }, CreateWorkspaceRequest, CreateWorkspaceResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteComponentType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/component-types/{componentTypeId}", method: "DELETE", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.DeleteComponentType" }, DeleteComponentTypeRequest, DeleteComponentTypeResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteEntity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/entities/{entityId}", method: "DELETE", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.DeleteEntity" }, DeleteEntityRequest, DeleteEntityResponse, [InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteScene = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/scenes/{sceneId}", method: "DELETE", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.DeleteScene" }, DeleteSceneRequest, DeleteSceneResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getPricingPlan = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/pricingplan", method: "GET", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.GetPricingPlan" }, GetPricingPlanRequest, GetPricingPlanResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getScene = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/scenes/{sceneId}", method: "GET", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.GetScene" }, GetSceneRequest, GetSceneResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getSyncJob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/sync-jobs/{syncSource}", method: "GET", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.GetSyncJob" }, GetSyncJobRequest, GetSyncJobResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listProperties = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/properties-list", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.ListProperties" }, ListPropertiesRequest, ListPropertiesResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listScenes = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/scenes-list", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.ListScenes" }, ListScenesRequest, ListScenesResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listSyncJobs = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/sync-jobs-list", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.ListSyncJobs" }, ListSyncJobsRequest, ListSyncJobsResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listWorkspaces = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces-list", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.ListWorkspaces" }, ListWorkspacesRequest, ListWorkspacesResponse, [InternalServerExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const tagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/tags", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.TagResource" }, TagResourceRequest, TagResourceResponse, [AccessDeniedExceptionError, ResourceNotFoundExceptionError, TooManyTagsExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const cancelMetadataTransferJob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/metadata-transfer-jobs/{metadataTransferJobId}/cancel", method: "PUT", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.CancelMetadataTransferJob" }, CancelMetadataTransferJobRequest, CancelMetadataTransferJobResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const executeQuery = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/queries/execution", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.ExecuteQuery" }, ExecuteQueryRequest, ExecuteQueryResponse, [AccessDeniedExceptionError, InternalServerExceptionError, QueryTimeoutExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getComponentType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/component-types/{componentTypeId}", method: "GET", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.GetComponentType" }, GetComponentTypeRequest, GetComponentTypeResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listComponentTypes = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/component-types-list", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.ListComponentTypes" }, ListComponentTypesRequest, ListComponentTypesResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listEntities = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/entities-list", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.ListEntities" }, ListEntitiesRequest, ListEntitiesResponse, [InternalServerExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listMetadataTransferJobs = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/metadata-transfer-jobs-list", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.ListMetadataTransferJobs" }, ListMetadataTransferJobsRequest, ListMetadataTransferJobsResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const updateEntity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/entities/{entityId}", method: "PUT", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.UpdateEntity" }, UpdateEntityRequest, UpdateEntityResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listComponents = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/entities/{entityId}/components-list", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.ListComponents" }, ListComponentsRequest, ListComponentsResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const listSyncResources = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/sync-jobs/{syncSource}/resources-list", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.ListSyncResources" }, ListSyncResourcesRequest, ListSyncResourcesResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createComponentType = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/component-types/{componentTypeId}", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.CreateComponentType" }, CreateComponentTypeRequest, CreateComponentTypeResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createEntity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/entities", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.CreateEntity" }, CreateEntityRequest, CreateEntityResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const createMetadataTransferJob = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/metadata-transfer-jobs", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.CreateMetadataTransferJob" }, CreateMetadataTransferJobRequest, CreateMetadataTransferJobResponse, [AccessDeniedExceptionError, ConflictExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getEntity = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/entities/{entityId}", method: "GET", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.GetEntity" }, GetEntityRequest, GetEntityResponse, [InternalServerExceptionError, ResourceNotFoundExceptionError, ServiceQuotaExceededExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const batchPutPropertyValues = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/entity-properties", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.BatchPutPropertyValues" }, BatchPutPropertyValuesRequest, BatchPutPropertyValuesResponse, [InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getPropertyValue = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/entity-properties/value", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.GetPropertyValue" }, GetPropertyValueRequest, GetPropertyValueResponse, [AccessDeniedExceptionError, ConnectorFailureExceptionError, ConnectorTimeoutExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
export const getPropertyValueHistory = /*#__PURE__*/ makeOperation(() => Operation({ version: "2021-11-29", uri: "/workspaces/{workspaceId}/entity-properties/history", method: "POST", sdkId: "IoTTwinMaker", sigV4ServiceName: "iottwinmaker", name: "AWSIoTTwinMaker.GetPropertyValueHistory" }, GetPropertyValueHistoryRequest, GetPropertyValueHistoryResponse, [AccessDeniedExceptionError, ConnectorFailureExceptionError, ConnectorTimeoutExceptionError, InternalServerExceptionError, ResourceNotFoundExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
