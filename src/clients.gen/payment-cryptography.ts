import { Schema} from "effect"
import { FormatAwsJSON10Request,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client";
import { Operation, Path, Header, StreamBody, Body, ErrorAnnotation } from "../schema-helpers";
export const ServiceUnavailableException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ValidationException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ThrottlingException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const GetCertificateSigningRequestOutput = Schema.Struct({CertificateSigningRequest: Schema.String});
export const OptionalBlocks = Schema.Record({key: Schema.String, value: Schema.String});
export const KeyModesOfUse = Schema.Struct({Encrypt: Schema.optional(Schema.Boolean), Decrypt: Schema.optional(Schema.Boolean), Wrap: Schema.optional(Schema.Boolean), Unwrap: Schema.optional(Schema.Boolean), Generate: Schema.optional(Schema.Boolean), Sign: Schema.optional(Schema.Boolean), Verify: Schema.optional(Schema.Boolean), DeriveKey: Schema.optional(Schema.Boolean), NoRestrictions: Schema.optional(Schema.Boolean)});
export const ReplicationStatusType = Schema.Struct({Status: Schema.String, StatusMessage: Schema.optional(Schema.String)});
export const WrappedKey = Schema.Struct({WrappingKeyArn: Schema.String, WrappedKeyMaterialFormat: Schema.String, KeyMaterial: Schema.String, KeyCheckValue: Schema.optional(Schema.String), KeyCheckValueAlgorithm: Schema.optional(Schema.String)});
export const ServiceQuotaExceededException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ResourceNotFoundException = Schema.Struct({ResourceId: Schema.optional(Schema.String)});
export const ExportKeyOutput = Schema.Struct({WrappedKey: Schema.optional(WrappedKey)});
export const ReplicationStatus = Schema.Record({key: Schema.String, value: ReplicationStatusType});
export const KeyAttributes = Schema.Struct({KeyUsage: Schema.String, KeyClass: Schema.String, KeyAlgorithm: Schema.String, KeyModesOfUse: KeyModesOfUse});
export const DiffieHellmanDerivationData = Schema.Union(Schema.String);
export const Key = Schema.Struct({KeyArn: Schema.String, KeyAttributes: KeyAttributes, KeyCheckValue: Schema.String, KeyCheckValueAlgorithm: Schema.String, Enabled: Schema.Boolean, Exportable: Schema.Boolean, KeyState: Schema.String, KeyOrigin: Schema.String, CreateTimestamp: Schema.Date, UsageStartTimestamp: Schema.optional(Schema.Date), UsageStopTimestamp: Schema.optional(Schema.Date), DeletePendingTimestamp: Schema.optional(Schema.Date), DeleteTimestamp: Schema.optional(Schema.Date), DeriveKeyUsage: Schema.optional(Schema.String), MultiRegionKeyType: Schema.optional(Schema.String), PrimaryRegion: Schema.optional(Schema.String), ReplicationStatus: Schema.optional(ReplicationStatus), UsingDefaultReplicationRegions: Schema.optional(Schema.Boolean)});
export const ImportDiffieHellmanTr31KeyBlock = Schema.Struct({PrivateKeyIdentifier: Schema.String, CertificateAuthorityPublicKeyIdentifier: Schema.String, PublicKeyCertificate: Schema.String, DeriveKeyAlgorithm: Schema.String, KeyDerivationFunction: Schema.String, KeyDerivationHashAlgorithm: Schema.String, DerivationData: DiffieHellmanDerivationData, WrappedKeyBlock: Schema.String});
export const ImportKeyOutput = Schema.Struct({Key: Key});
export const ImportKeyCryptogram = Schema.Struct({KeyAttributes: KeyAttributes, Exportable: Schema.Boolean, WrappedKeyCryptogram: Schema.String, ImportToken: Schema.String, WrappingSpec: Schema.optional(Schema.String)});
export const ImportTr34KeyBlock = Schema.Struct({CertificateAuthorityPublicKeyIdentifier: Schema.String, SigningKeyCertificate: Schema.String, ImportToken: Schema.optional(Schema.String), WrappingKeyIdentifier: Schema.optional(Schema.String), WrappingKeyCertificate: Schema.optional(Schema.String), WrappedKeyBlock: Schema.String, KeyBlockFormat: Schema.String, RandomNonce: Schema.optional(Schema.String)});
export const ImportTr31KeyBlock = Schema.Struct({WrappingKeyIdentifier: Schema.String, WrappedKeyBlock: Schema.String});
export const TrustedCertificatePublicKey = Schema.Struct({KeyAttributes: KeyAttributes, PublicKeyCertificate: Schema.String, CertificateAuthorityPublicKeyIdentifier: Schema.String});
export const ExportDukptInitialKey = Schema.Struct({KeySerialNumber: Schema.String});
export const KeyBlockHeaders = Schema.Struct({KeyModesOfUse: Schema.optional(KeyModesOfUse), KeyExportability: Schema.optional(Schema.String), KeyVersion: Schema.optional(Schema.String), OptionalBlocks: Schema.optional(OptionalBlocks)});
export const ExportKeyCryptogram = Schema.Struct({CertificateAuthorityPublicKeyIdentifier: Schema.String, WrappingKeyCertificate: Schema.String, WrappingSpec: Schema.optional(Schema.String)});
export const ExportTr34KeyBlock = Schema.Struct({CertificateAuthorityPublicKeyIdentifier: Schema.String, WrappingKeyCertificate: Schema.String, ExportToken: Schema.optional(Schema.String), SigningKeyIdentifier: Schema.optional(Schema.String), SigningKeyCertificate: Schema.optional(Schema.String), KeyBlockFormat: Schema.String, RandomNonce: Schema.optional(Schema.String), KeyBlockHeaders: Schema.optional(KeyBlockHeaders)});
export const InternalServerException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const ConflictException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const RootCertificatePublicKey = Schema.Struct({KeyAttributes: KeyAttributes, PublicKeyCertificate: Schema.String});
export const ListTagsForResourceOutput = Schema.Struct({Tags: Tags, NextToken: Schema.optional(Schema.String)});
export const ExportDiffieHellmanTr31KeyBlock = Schema.Struct({PrivateKeyIdentifier: Schema.String, CertificateAuthorityPublicKeyIdentifier: Schema.String, PublicKeyCertificate: Schema.String, DeriveKeyAlgorithm: Schema.String, KeyDerivationFunction: Schema.String, KeyDerivationHashAlgorithm: Schema.String, DerivationData: DiffieHellmanDerivationData, KeyBlockHeaders: Schema.optional(KeyBlockHeaders)});
export const GetPublicKeyCertificateOutput = Schema.Struct({KeyCertificate: Schema.String, KeyCertificateChain: Schema.String});
export const GetParametersForImportOutput = Schema.Struct({WrappingKeyCertificate: Schema.String, WrappingKeyCertificateChain: Schema.String, WrappingKeyAlgorithm: Schema.String, ImportToken: Schema.String, ParametersValidUntilTimestamp: Schema.Date});
export const GetParametersForExportOutput = Schema.Struct({SigningKeyCertificate: Schema.String, SigningKeyCertificateChain: Schema.String, SigningKeyAlgorithm: Schema.String, ExportToken: Schema.String, ParametersValidUntilTimestamp: Schema.Date});
export const AccessDeniedException = Schema.Struct({Message: Schema.optional(Schema.String)});
export const EnableDefaultKeyReplicationRegionsOutput = Schema.Struct({EnabledReplicationRegions: Regions});
export const ExportTr31KeyBlock = Schema.Struct({WrappingKeyIdentifier: Schema.String, KeyBlockHeaders: Schema.optional(KeyBlockHeaders)});
export const DisableDefaultKeyReplicationRegionsOutput = Schema.Struct({EnabledReplicationRegions: Regions});
export const Tags = Schema.Array(Tag);
export const Tag = Schema.Struct({Key: Schema.String, Value: Schema.String});
export const CertificateSubjectType = Schema.Struct({CommonName: Schema.String, OrganizationUnit: Schema.optional(Schema.String), Organization: Schema.optional(Schema.String), City: Schema.optional(Schema.String), Country: Schema.optional(Schema.String), StateOrProvince: Schema.optional(Schema.String), EmailAddress: Schema.optional(Schema.String)});
export const UntagResourceOutput = Schema.Struct({});
export const UntagResourceInput = Schema.Struct({ResourceArn: Schema.String, TagKeys: TagKeys});
export const TagResourceOutput = Schema.Struct({});
export const TagResourceInput = Schema.Struct({ResourceArn: Schema.String, Tags: Tags});
export const ExportAttributes = Schema.Struct({ExportDukptInitialKey: Schema.optional(ExportDukptInitialKey), KeyCheckValueAlgorithm: Schema.optional(Schema.String)});
export const ListTagsForResourceInput = Schema.Struct({ResourceArn: Schema.String, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number)});
export const GetPublicKeyCertificateInput = Schema.Struct({KeyIdentifier: Schema.String});
export const GetParametersForImportInput = Schema.Struct({KeyMaterialType: Schema.String, WrappingKeyAlgorithm: Schema.String});
export const GetParametersForExportInput = Schema.Struct({KeyMaterialType: Schema.String, SigningKeyAlgorithm: Schema.String});
export const ImportKeyMaterial = Schema.Union(RootCertificatePublicKey, TrustedCertificatePublicKey, ImportTr31KeyBlock, ImportTr34KeyBlock, ImportKeyCryptogram, ImportDiffieHellmanTr31KeyBlock);
export const GetDefaultKeyReplicationRegionsOutput = Schema.Struct({EnabledReplicationRegions: Regions});
export const TagKeys = Schema.Array(Schema.String);
export const Regions = Schema.Array(Schema.String);
export const GetCertificateSigningRequestInput = Schema.Struct({KeyIdentifier: Schema.String, SigningAlgorithm: Schema.String, CertificateSubject: CertificateSubjectType});
export const ExportKeyMaterial = Schema.Union(ExportTr31KeyBlock, ExportTr34KeyBlock, ExportKeyCryptogram, ExportDiffieHellmanTr31KeyBlock);
export const GetDefaultKeyReplicationRegionsInput = Schema.Struct({});
export const EnableDefaultKeyReplicationRegionsInput = Schema.Struct({ReplicationRegions: Regions});
export const DisableDefaultKeyReplicationRegionsInput = Schema.Struct({ReplicationRegions: Regions});
export const GetPublicKeyCertificate = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Payment Cryptography", sigV4ServiceName: "payment-cryptography", name: "PaymentCryptographyControlPlane.GetPublicKeyCertificate" }, GetPublicKeyCertificateInput, GetPublicKeyCertificateOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ImportKeyInput = Schema.Struct({KeyMaterial: ImportKeyMaterial, KeyCheckValueAlgorithm: Schema.optional(Schema.String), Enabled: Schema.optional(Schema.Boolean), Tags: Schema.optional(Tags), ReplicationRegions: Schema.optional(Regions)});
export const ListTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Payment Cryptography", sigV4ServiceName: "payment-cryptography", name: "PaymentCryptographyControlPlane.ListTagsForResource" }, ListTagsForResourceInput, ListTagsForResourceOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const TagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Payment Cryptography", sigV4ServiceName: "payment-cryptography", name: "PaymentCryptographyControlPlane.TagResource" }, TagResourceInput, TagResourceOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const UntagResource = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Payment Cryptography", sigV4ServiceName: "payment-cryptography", name: "PaymentCryptographyControlPlane.UntagResource" }, UntagResourceInput, UntagResourceOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const DisableDefaultKeyReplicationRegions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Payment Cryptography", sigV4ServiceName: "payment-cryptography", name: "PaymentCryptographyControlPlane.DisableDefaultKeyReplicationRegions" }, DisableDefaultKeyReplicationRegionsInput, DisableDefaultKeyReplicationRegionsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const EnableDefaultKeyReplicationRegions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Payment Cryptography", sigV4ServiceName: "payment-cryptography", name: "PaymentCryptographyControlPlane.EnableDefaultKeyReplicationRegions" }, EnableDefaultKeyReplicationRegionsInput, EnableDefaultKeyReplicationRegionsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetCertificateSigningRequest = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Payment Cryptography", sigV4ServiceName: "payment-cryptography", name: "PaymentCryptographyControlPlane.GetCertificateSigningRequest" }, GetCertificateSigningRequestInput, GetCertificateSigningRequestOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetDefaultKeyReplicationRegions = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Payment Cryptography", sigV4ServiceName: "payment-cryptography", name: "PaymentCryptographyControlPlane.GetDefaultKeyReplicationRegions" }, GetDefaultKeyReplicationRegionsInput, GetDefaultKeyReplicationRegionsOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ExportKeyInput = Schema.Struct({KeyMaterial: ExportKeyMaterial, ExportKeyIdentifier: Schema.String, ExportAttributes: Schema.optional(ExportAttributes)});
export const GetParametersForExport = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Payment Cryptography", sigV4ServiceName: "payment-cryptography", name: "PaymentCryptographyControlPlane.GetParametersForExport" }, GetParametersForExportInput, GetParametersForExportOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const GetParametersForImport = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Payment Cryptography", sigV4ServiceName: "payment-cryptography", name: "PaymentCryptographyControlPlane.GetParametersForImport" }, GetParametersForImportInput, GetParametersForImportOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ExportKey = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Payment Cryptography", sigV4ServiceName: "payment-cryptography", name: "PaymentCryptographyControlPlane.ExportKey" }, ExportKeyInput, ExportKeyOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
export const ImportKey = /*#__PURE__*/ makeOperation(() => Operation({ uri: "/", method: "POST", sdkId: "Payment Cryptography", sigV4ServiceName: "payment-cryptography", name: "PaymentCryptographyControlPlane.ImportKey" }, ImportKeyInput, ImportKeyOutput, Schema.Union(ErrorAnnotation("AccessDeniedException", AccessDeniedException), ErrorAnnotation("ConflictException", ConflictException), ErrorAnnotation("InternalServerException", InternalServerException), ErrorAnnotation("ResourceNotFoundException", ResourceNotFoundException), ErrorAnnotation("ServiceQuotaExceededException", ServiceQuotaExceededException), ErrorAnnotation("ServiceUnavailableException", ServiceUnavailableException), ErrorAnnotation("ThrottlingException", ThrottlingException), ErrorAnnotation("ValidationException", ValidationException))), FormatAwsJSON10Request, FormatJSONResponse, FormatAwsRestJSONError);
