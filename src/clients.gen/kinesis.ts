import { Schema} from "effect"
import { FormatAwsJSON11Request,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const DescribeAccountSettingsInput = Schema.Struct({});
export const DescribeLimitsInput = Schema.Struct({});
export const MetricsNameList = Schema.Array(Schema.String);
export const TagKeyList = Schema.Array(Schema.String);
export const DecreaseStreamRetentionPeriodInput = Schema.Struct({StreamName: Schema.optional(Schema.String), RetentionPeriodHours: Schema.Number, StreamARN: Schema.optional(Schema.String)});
export const DeleteResourcePolicyInput = Schema.Struct({ResourceARN: Schema.String});
export const DeleteStreamInput = Schema.Struct({StreamName: Schema.optional(Schema.String), EnforceConsumerDeletion: Schema.optional(Schema.Boolean), StreamARN: Schema.optional(Schema.String)});
export const DeregisterStreamConsumerInput = Schema.Struct({StreamARN: Schema.optional(Schema.String), ConsumerName: Schema.optional(Schema.String), ConsumerARN: Schema.optional(Schema.String)});
export const DescribeLimitsOutput = Schema.Struct({ShardLimit: Schema.Number, OpenShardCount: Schema.Number, OnDemandStreamCount: Schema.Number, OnDemandStreamCountLimit: Schema.Number});
export const DescribeStreamInput = Schema.Struct({StreamName: Schema.optional(Schema.String), Limit: Schema.optional(Schema.Number), ExclusiveStartShardId: Schema.optional(Schema.String), StreamARN: Schema.optional(Schema.String)});
export const DescribeStreamConsumerInput = Schema.Struct({StreamARN: Schema.optional(Schema.String), ConsumerName: Schema.optional(Schema.String), ConsumerARN: Schema.optional(Schema.String)});
export const DescribeStreamSummaryInput = Schema.Struct({StreamName: Schema.optional(Schema.String), StreamARN: Schema.optional(Schema.String)});
export const DisableEnhancedMonitoringInput = Schema.Struct({StreamName: Schema.optional(Schema.String), ShardLevelMetrics: MetricsNameList, StreamARN: Schema.optional(Schema.String)});
export const EnableEnhancedMonitoringInput = Schema.Struct({StreamName: Schema.optional(Schema.String), ShardLevelMetrics: MetricsNameList, StreamARN: Schema.optional(Schema.String)});
export const GetRecordsInput = Schema.Struct({ShardIterator: Schema.String, Limit: Schema.optional(Schema.Number), StreamARN: Schema.optional(Schema.String)});
export const GetResourcePolicyInput = Schema.Struct({ResourceARN: Schema.String});
export const GetShardIteratorInput = Schema.Struct({StreamName: Schema.optional(Schema.String), ShardId: Schema.String, ShardIteratorType: Schema.String, StartingSequenceNumber: Schema.optional(Schema.String), Timestamp: Schema.optional(Schema.Date), StreamARN: Schema.optional(Schema.String)});
export const IncreaseStreamRetentionPeriodInput = Schema.Struct({StreamName: Schema.optional(Schema.String), RetentionPeriodHours: Schema.Number, StreamARN: Schema.optional(Schema.String)});
export const ListStreamConsumersInput = Schema.Struct({StreamARN: Schema.String, NextToken: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), StreamCreationTimestamp: Schema.optional(Schema.Date)});
export const ListStreamsInput = Schema.Struct({Limit: Schema.optional(Schema.Number), ExclusiveStartStreamName: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String)});
export const ListTagsForResourceInput = Schema.Struct({ResourceARN: Schema.String});
export const ListTagsForStreamInput = Schema.Struct({StreamName: Schema.optional(Schema.String), ExclusiveStartTagKey: Schema.optional(Schema.String), Limit: Schema.optional(Schema.Number), StreamARN: Schema.optional(Schema.String)});
export const MergeShardsInput = Schema.Struct({StreamName: Schema.optional(Schema.String), ShardToMerge: Schema.String, AdjacentShardToMerge: Schema.String, StreamARN: Schema.optional(Schema.String)});
export const PutRecordInput = Schema.Struct({StreamName: Schema.optional(Schema.String), Data: StreamBody(), PartitionKey: Schema.String, ExplicitHashKey: Schema.optional(Schema.String), SequenceNumberForOrdering: Schema.optional(Schema.String), StreamARN: Schema.optional(Schema.String)});
export const PutResourcePolicyInput = Schema.Struct({ResourceARN: Schema.String, Policy: Schema.String});
export const TagMap = Schema.Record({key: Schema.String, value: Schema.String});
export const RegisterStreamConsumerInput = Schema.Struct({StreamARN: Schema.String, ConsumerName: Schema.String, Tags: Schema.optional(TagMap)});
export const RemoveTagsFromStreamInput = Schema.Struct({StreamName: Schema.optional(Schema.String), TagKeys: TagKeyList, StreamARN: Schema.optional(Schema.String)});
export const SplitShardInput = Schema.Struct({StreamName: Schema.optional(Schema.String), ShardToSplit: Schema.String, NewStartingHashKey: Schema.String, StreamARN: Schema.optional(Schema.String)});
export const StartStreamEncryptionInput = Schema.Struct({StreamName: Schema.optional(Schema.String), EncryptionType: Schema.String, KeyId: Schema.String, StreamARN: Schema.optional(Schema.String)});
export const StopStreamEncryptionInput = Schema.Struct({StreamName: Schema.optional(Schema.String), EncryptionType: Schema.String, KeyId: Schema.String, StreamARN: Schema.optional(Schema.String)});
export const TagResourceInput = Schema.Struct({Tags: TagMap, ResourceARN: Schema.String});
export const UntagResourceInput = Schema.Struct({TagKeys: TagKeyList, ResourceARN: Schema.String});
export const UpdateMaxRecordSizeInput = Schema.Struct({StreamARN: Schema.optional(Schema.String), MaxRecordSizeInKiB: Schema.Number});
export const UpdateShardCountInput = Schema.Struct({StreamName: Schema.optional(Schema.String), TargetShardCount: Schema.Number, ScalingType: Schema.String, StreamARN: Schema.optional(Schema.String)});
export const StreamModeDetails = Schema.Struct({StreamMode: Schema.String});
export const UpdateStreamModeInput = Schema.Struct({StreamARN: Schema.String, StreamModeDetails: StreamModeDetails, WarmThroughputMiBps: Schema.optional(Schema.Number)});
export const UpdateStreamWarmThroughputInput = Schema.Struct({StreamARN: Schema.optional(Schema.String), StreamName: Schema.optional(Schema.String), WarmThroughputMiBps: Schema.Number});
export const MinimumThroughputBillingCommitmentOutput = Schema.Struct({Status: Schema.String, StartedAt: Schema.optional(Schema.Date), EndedAt: Schema.optional(Schema.Date), EarliestAllowedEndAt: Schema.optional(Schema.Date)});
export const ShardFilter = Schema.Struct({Type: Schema.String, ShardId: Schema.optional(Schema.String), Timestamp: Schema.optional(Schema.Date)});
export const StreamNameList = Schema.Array(Schema.String);
export const PutRecordsRequestEntry = Schema.Struct({Data: StreamBody(), ExplicitHashKey: Schema.optional(Schema.String), PartitionKey: Schema.String});
export const PutRecordsRequestEntryList = Schema.Array(PutRecordsRequestEntry);
export const StartingPosition = Schema.Struct({Type: Schema.String, SequenceNumber: Schema.optional(Schema.String), Timestamp: Schema.optional(Schema.Date)});
export const MinimumThroughputBillingCommitmentInput = Schema.Struct({Status: Schema.String});
export const AddTagsToStreamInput = Schema.Struct({StreamName: Schema.optional(Schema.String), Tags: TagMap, StreamARN: Schema.optional(Schema.String)});
export const CreateStreamInput = Schema.Struct({StreamName: Schema.String, ShardCount: Schema.optional(Schema.Number), StreamModeDetails: Schema.optional(StreamModeDetails), Tags: Schema.optional(TagMap), WarmThroughputMiBps: Schema.optional(Schema.Number), MaxRecordSizeInKiB: Schema.optional(Schema.Number)});
export const AccessDeniedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InvalidArgumentException = Schema.Struct({message: Schema.optional(Schema.String)});
export const LimitExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ResourceNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const DescribeAccountSettingsOutput = Schema.Struct({MinimumThroughputBillingCommitment: Schema.optional(MinimumThroughputBillingCommitmentOutput)});
export const EnhancedMonitoringOutput = Schema.Struct({StreamName: Schema.optional(Schema.String), CurrentShardLevelMetrics: Schema.optional(MetricsNameList), DesiredShardLevelMetrics: Schema.optional(MetricsNameList), StreamARN: Schema.optional(Schema.String)});
export const ResourceInUseException = Schema.Struct({message: Schema.optional(Schema.String)});
export const GetResourcePolicyOutput = Schema.Struct({Policy: Schema.String});
export const GetShardIteratorOutput = Schema.Struct({ShardIterator: Schema.optional(Schema.String)});
export const ListShardsInput = Schema.Struct({StreamName: Schema.optional(Schema.String), NextToken: Schema.optional(Schema.String), ExclusiveStartShardId: Schema.optional(Schema.String), MaxResults: Schema.optional(Schema.Number), StreamCreationTimestamp: Schema.optional(Schema.Date), ShardFilter: Schema.optional(ShardFilter), StreamARN: Schema.optional(Schema.String)});
export const Tag = Schema.Struct({Key: Schema.String, Value: Schema.optional(Schema.String)});
export const TagList = Schema.Array(Tag);
export const ListTagsForStreamOutput = Schema.Struct({Tags: TagList, HasMoreTags: Schema.Boolean});
export const ValidationException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PutRecordOutput = Schema.Struct({ShardId: Schema.String, SequenceNumber: Schema.String, EncryptionType: Schema.optional(Schema.String)});
export const PutRecordsInput = Schema.Struct({Records: PutRecordsRequestEntryList, StreamName: Schema.optional(Schema.String), StreamARN: Schema.optional(Schema.String)});
export const Consumer = Schema.Struct({ConsumerName: Schema.String, ConsumerARN: Schema.String, ConsumerStatus: Schema.String, ConsumerCreationTimestamp: Schema.Date});
export const RegisterStreamConsumerOutput = Schema.Struct({Consumer: Consumer});
export const KMSAccessDeniedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SubscribeToShardInput = Schema.Struct({ConsumerARN: Schema.String, ShardId: Schema.String, StartingPosition: StartingPosition});
export const UpdateAccountSettingsInput = Schema.Struct({MinimumThroughputBillingCommitment: MinimumThroughputBillingCommitmentInput});
export const UpdateShardCountOutput = Schema.Struct({StreamName: Schema.optional(Schema.String), CurrentShardCount: Schema.optional(Schema.Number), TargetShardCount: Schema.optional(Schema.Number), StreamARN: Schema.optional(Schema.String)});
export const ShardIdList = Schema.Array(Schema.String);
export const ConsumerDescription = Schema.Struct({ConsumerName: Schema.String, ConsumerARN: Schema.String, ConsumerStatus: Schema.String, ConsumerCreationTimestamp: Schema.Date, StreamARN: Schema.String});
export const EnhancedMetrics = Schema.Struct({ShardLevelMetrics: Schema.optional(MetricsNameList)});
export const EnhancedMonitoringList = Schema.Array(EnhancedMetrics);
export const WarmThroughputObject = Schema.Struct({TargetMiBps: Schema.optional(Schema.Number), CurrentMiBps: Schema.optional(Schema.Number)});
export const StreamDescriptionSummary = Schema.Struct({StreamName: Schema.String, StreamARN: Schema.String, StreamStatus: Schema.String, StreamModeDetails: Schema.optional(StreamModeDetails), RetentionPeriodHours: Schema.Number, StreamCreationTimestamp: Schema.Date, EnhancedMonitoring: EnhancedMonitoringList, EncryptionType: Schema.optional(Schema.String), KeyId: Schema.optional(Schema.String), OpenShardCount: Schema.Number, ConsumerCount: Schema.optional(Schema.Number), WarmThroughput: Schema.optional(WarmThroughputObject), MaxRecordSizeInKiB: Schema.optional(Schema.Number)});
export const Record = Schema.Struct({SequenceNumber: Schema.String, ApproximateArrivalTimestamp: Schema.optional(Schema.Date), Data: StreamBody(), PartitionKey: Schema.String, EncryptionType: Schema.optional(Schema.String)});
export const RecordList = Schema.Array(Record);
export const ConsumerList = Schema.Array(Consumer);
export const StreamSummary = Schema.Struct({StreamName: Schema.String, StreamARN: Schema.String, StreamStatus: Schema.String, StreamModeDetails: Schema.optional(StreamModeDetails), StreamCreationTimestamp: Schema.optional(Schema.Date)});
export const StreamSummaryList = Schema.Array(StreamSummary);
export const DescribeStreamConsumerOutput = Schema.Struct({ConsumerDescription: ConsumerDescription});
export const DescribeStreamSummaryOutput = Schema.Struct({StreamDescriptionSummary: StreamDescriptionSummary});
export const InternalFailureException = Schema.Struct({message: Schema.optional(Schema.String)});
export const HashKeyRange = Schema.Struct({StartingHashKey: Schema.String, EndingHashKey: Schema.String});
export const SequenceNumberRange = Schema.Struct({StartingSequenceNumber: Schema.String, EndingSequenceNumber: Schema.optional(Schema.String)});
export const Shard = Schema.Struct({ShardId: Schema.String, ParentShardId: Schema.optional(Schema.String), AdjacentParentShardId: Schema.optional(Schema.String), HashKeyRange: HashKeyRange, SequenceNumberRange: SequenceNumberRange});
export const ShardList = Schema.Array(Shard);
export const ListShardsOutput = Schema.Struct({Shards: Schema.optional(ShardList), NextToken: Schema.optional(Schema.String)});
export const ListStreamConsumersOutput = Schema.Struct({Consumers: Schema.optional(ConsumerList), NextToken: Schema.optional(Schema.String)});
export const ListStreamsOutput = Schema.Struct({StreamNames: StreamNameList, HasMoreStreams: Schema.Boolean, NextToken: Schema.optional(Schema.String), StreamSummaries: Schema.optional(StreamSummaryList)});
export const ListTagsForResourceOutput = Schema.Struct({Tags: Schema.optional(TagList)});
export const KMSDisabledException = Schema.Struct({message: Schema.optional(Schema.String)});
export const KMSInvalidStateException = Schema.Struct({message: Schema.optional(Schema.String)});
export const UpdateAccountSettingsOutput = Schema.Struct({MinimumThroughputBillingCommitment: Schema.optional(MinimumThroughputBillingCommitmentOutput)});
export const UpdateStreamWarmThroughputOutput = Schema.Struct({StreamARN: Schema.optional(Schema.String), StreamName: Schema.optional(Schema.String), WarmThroughput: Schema.optional(WarmThroughputObject)});
export const ChildShard = Schema.Struct({ShardId: Schema.String, ParentShards: ShardIdList, HashKeyRange: HashKeyRange});
export const ChildShardList = Schema.Array(ChildShard);
export const PutRecordsResultEntry = Schema.Struct({SequenceNumber: Schema.optional(Schema.String), ShardId: Schema.optional(Schema.String), ErrorCode: Schema.optional(Schema.String), ErrorMessage: Schema.optional(Schema.String)});
export const PutRecordsResultEntryList = Schema.Array(PutRecordsResultEntry);
export const GetRecordsOutput = Schema.Struct({Records: RecordList, NextShardIterator: Schema.optional(Schema.String), MillisBehindLatest: Schema.optional(Schema.Number), ChildShards: Schema.optional(ChildShardList)});
export const ProvisionedThroughputExceededException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ExpiredNextTokenException = Schema.Struct({message: Schema.optional(Schema.String)});
export const KMSNotFoundException = Schema.Struct({message: Schema.optional(Schema.String)});
export const PutRecordsOutput = Schema.Struct({FailedRecordCount: Schema.optional(Schema.Number), Records: PutRecordsResultEntryList, EncryptionType: Schema.optional(Schema.String)});
export const KMSOptInRequired = Schema.Struct({message: Schema.optional(Schema.String)});
export const SubscribeToShardEvent = Schema.Struct({Records: RecordList, ContinuationSequenceNumber: Schema.String, MillisBehindLatest: Schema.Number, ChildShards: Schema.optional(ChildShardList)});
export const KMSThrottlingException = Schema.Struct({message: Schema.optional(Schema.String)});
export const StreamDescription = Schema.Struct({StreamName: Schema.String, StreamARN: Schema.String, StreamStatus: Schema.String, StreamModeDetails: Schema.optional(StreamModeDetails), Shards: ShardList, HasMoreShards: Schema.Boolean, RetentionPeriodHours: Schema.Number, StreamCreationTimestamp: Schema.Date, EnhancedMonitoring: EnhancedMonitoringList, EncryptionType: Schema.optional(Schema.String), KeyId: Schema.optional(Schema.String)});
export const SubscribeToShardEventStream = Schema.Union(SubscribeToShardEvent, ResourceNotFoundException, ResourceInUseException, KMSDisabledException, KMSInvalidStateException, KMSAccessDeniedException, KMSNotFoundException, KMSOptInRequired, KMSThrottlingException, InternalFailureException);
export const DescribeStreamOutput = Schema.Struct({StreamDescription: StreamDescription});
export const ExpiredIteratorException = Schema.Struct({message: Schema.optional(Schema.String)});
export const SubscribeToShardOutput = Schema.Struct({EventStream: SubscribeToShardEventStream});

//# Errors
export class AccessDeniedExceptionError extends Schema.TaggedError<AccessDeniedExceptionError>()("AccessDeniedException", AccessDeniedException) {};
export class InvalidArgumentExceptionError extends Schema.TaggedError<InvalidArgumentExceptionError>()("InvalidArgumentException", InvalidArgumentException) {};
export class LimitExceededExceptionError extends Schema.TaggedError<LimitExceededExceptionError>()("LimitExceededException", LimitExceededException) {};
export class ResourceInUseExceptionError extends Schema.TaggedError<ResourceInUseExceptionError>()("ResourceInUseException", ResourceInUseException) {};
export class ResourceNotFoundExceptionError extends Schema.TaggedError<ResourceNotFoundExceptionError>()("ResourceNotFoundException", ResourceNotFoundException) {};
export class ValidationExceptionError extends Schema.TaggedError<ValidationExceptionError>()("ValidationException", ValidationException) {};
export class InternalFailureExceptionError extends Schema.TaggedError<InternalFailureExceptionError>()("InternalFailureException", InternalFailureException) {};
export class KMSAccessDeniedExceptionError extends Schema.TaggedError<KMSAccessDeniedExceptionError>()("KMSAccessDeniedException", KMSAccessDeniedException) {};
export class KMSDisabledExceptionError extends Schema.TaggedError<KMSDisabledExceptionError>()("KMSDisabledException", KMSDisabledException) {};
export class ExpiredNextTokenExceptionError extends Schema.TaggedError<ExpiredNextTokenExceptionError>()("ExpiredNextTokenException", ExpiredNextTokenException) {};
export class KMSInvalidStateExceptionError extends Schema.TaggedError<KMSInvalidStateExceptionError>()("KMSInvalidStateException", KMSInvalidStateException) {};
export class KMSNotFoundExceptionError extends Schema.TaggedError<KMSNotFoundExceptionError>()("KMSNotFoundException", KMSNotFoundException) {};
export class ProvisionedThroughputExceededExceptionError extends Schema.TaggedError<ProvisionedThroughputExceededExceptionError>()("ProvisionedThroughputExceededException", ProvisionedThroughputExceededException) {};
export class KMSOptInRequiredError extends Schema.TaggedError<KMSOptInRequiredError>()("KMSOptInRequired", KMSOptInRequired) {};
export class KMSThrottlingExceptionError extends Schema.TaggedError<KMSThrottlingExceptionError>()("KMSThrottlingException", KMSThrottlingException) {};
export class ExpiredIteratorExceptionError extends Schema.TaggedError<ExpiredIteratorExceptionError>()("ExpiredIteratorException", ExpiredIteratorException) {};

//# Operations
export const describeLimits = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.DescribeLimits" }, DescribeLimitsInput, DescribeLimitsOutput, [LimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const increaseStreamRetentionPeriod = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.IncreaseStreamRetentionPeriod" }, IncreaseStreamRetentionPeriodInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.PutResourcePolicy" }, PutResourcePolicyInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const removeTagsFromStream = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.RemoveTagsFromStream" }, RemoveTagsFromStreamInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const splitShard = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.SplitShard" }, SplitShardInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const stopStreamEncryption = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.StopStreamEncryption" }, StopStreamEncryptionInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const tagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.TagResource" }, TagResourceInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const untagResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.UntagResource" }, UntagResourceInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateMaxRecordSize = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.UpdateMaxRecordSize" }, UpdateMaxRecordSizeInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateStreamMode = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.UpdateStreamMode" }, UpdateStreamModeInput, Schema.Struct({}), [InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const addTagsToStream = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.AddTagsToStream" }, AddTagsToStreamInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const createStream = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.CreateStream" }, CreateStreamInput, Schema.Struct({}), [InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const decreaseStreamRetentionPeriod = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.DecreaseStreamRetentionPeriod" }, DecreaseStreamRetentionPeriodInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.DeleteResourcePolicy" }, DeleteResourcePolicyInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deleteStream = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.DeleteStream" }, DeleteStreamInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const deregisterStreamConsumer = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.DeregisterStreamConsumer" }, DeregisterStreamConsumerInput, Schema.Struct({}), [InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeAccountSettings = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.DescribeAccountSettings" }, DescribeAccountSettingsInput, DescribeAccountSettingsOutput, [LimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const disableEnhancedMonitoring = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.DisableEnhancedMonitoring" }, DisableEnhancedMonitoringInput, EnhancedMonitoringOutput, [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const enableEnhancedMonitoring = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.EnableEnhancedMonitoring" }, EnableEnhancedMonitoringInput, EnhancedMonitoringOutput, [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getResourcePolicy = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.GetResourcePolicy" }, GetResourcePolicyInput, GetResourcePolicyOutput, [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listTagsForStream = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.ListTagsForStream" }, ListTagsForStreamInput, ListTagsForStreamOutput, [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const mergeShards = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.MergeShards" }, MergeShardsInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const registerStreamConsumer = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.RegisterStreamConsumer" }, RegisterStreamConsumerInput, RegisterStreamConsumerOutput, [InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateShardCount = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.UpdateShardCount" }, UpdateShardCountInput, UpdateShardCountOutput, [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeStreamConsumer = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.DescribeStreamConsumer" }, DescribeStreamConsumerInput, DescribeStreamConsumerOutput, [InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeStreamSummary = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.DescribeStreamSummary" }, DescribeStreamSummaryInput, DescribeStreamSummaryOutput, [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listStreamConsumers = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.ListStreamConsumers" }, ListStreamConsumersInput, ListStreamConsumersOutput, [ExpiredNextTokenExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listStreams = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.ListStreams" }, ListStreamsInput, ListStreamsOutput, [ExpiredNextTokenExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listTagsForResource = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.ListTagsForResource" }, ListTagsForResourceInput, ListTagsForResourceOutput, [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateAccountSettings = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.UpdateAccountSettings" }, UpdateAccountSettingsInput, UpdateAccountSettingsOutput, [InvalidArgumentExceptionError, LimitExceededExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const updateStreamWarmThroughput = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.UpdateStreamWarmThroughput" }, UpdateStreamWarmThroughputInput, UpdateStreamWarmThroughputOutput, [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError, ValidationExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getShardIterator = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.GetShardIterator" }, GetShardIteratorInput, GetShardIteratorOutput, [AccessDeniedExceptionError, InternalFailureExceptionError, InvalidArgumentExceptionError, ProvisionedThroughputExceededExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const listShards = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.ListShards" }, ListShardsInput, ListShardsOutput, [AccessDeniedExceptionError, ExpiredNextTokenExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putRecord = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.PutRecord" }, PutRecordInput, PutRecordOutput, [AccessDeniedExceptionError, InternalFailureExceptionError, InvalidArgumentExceptionError, KMSAccessDeniedExceptionError, KMSDisabledExceptionError, KMSInvalidStateExceptionError, KMSNotFoundExceptionError, KMSOptInRequiredError, KMSThrottlingExceptionError, ProvisionedThroughputExceededExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const putRecords = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.PutRecords" }, PutRecordsInput, PutRecordsOutput, [AccessDeniedExceptionError, InternalFailureExceptionError, InvalidArgumentExceptionError, KMSAccessDeniedExceptionError, KMSDisabledExceptionError, KMSInvalidStateExceptionError, KMSNotFoundExceptionError, KMSOptInRequiredError, KMSThrottlingExceptionError, ProvisionedThroughputExceededExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const startStreamEncryption = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.StartStreamEncryption" }, StartStreamEncryptionInput, Schema.Struct({}), [AccessDeniedExceptionError, InvalidArgumentExceptionError, KMSAccessDeniedExceptionError, KMSDisabledExceptionError, KMSInvalidStateExceptionError, KMSNotFoundExceptionError, KMSOptInRequiredError, KMSThrottlingExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const describeStream = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.DescribeStream" }, DescribeStreamInput, DescribeStreamOutput, [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const getRecords = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.GetRecords" }, GetRecordsInput, GetRecordsOutput, [AccessDeniedExceptionError, ExpiredIteratorExceptionError, InternalFailureExceptionError, InvalidArgumentExceptionError, KMSAccessDeniedExceptionError, KMSDisabledExceptionError, KMSInvalidStateExceptionError, KMSNotFoundExceptionError, KMSOptInRequiredError, KMSThrottlingExceptionError, ProvisionedThroughputExceededExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
export const subscribeToShard = /*#__PURE__*/ makeOperation(() => Operation({ version: "2013-12-02", uri: "/", method: "POST", sdkId: "Kinesis", sigV4ServiceName: "kinesis", name: "Kinesis_20131202.SubscribeToShard" }, SubscribeToShardInput, SubscribeToShardOutput, [AccessDeniedExceptionError, InvalidArgumentExceptionError, LimitExceededExceptionError, ResourceInUseExceptionError, ResourceNotFoundExceptionError]), FormatAwsJSON11Request, FormatJSONResponse, FormatAwsRestJSONError);
