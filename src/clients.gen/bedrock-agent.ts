import { Schema} from "effect"
import { FormatJSONRequest,FormatJSONResponse,FormatAwsRestJSONError, makeOperation } from "../client.ts";
import { Operation, Path, Header, StreamBody, Body } from "../schema-helpers.ts";

//# Schemas
export const InputFlowNodeConfiguration = Schema.Struct({});
export const OutputFlowNodeConfiguration = Schema.Struct({});
export const IteratorFlowNodeConfiguration = Schema.Struct({});
export const CollectorFlowNodeConfiguration = Schema.Struct({});
export const LoopInputFlowNodeConfiguration = Schema.Struct({});
export const FlowNodeInput = Schema.Struct({name: Schema.String, type: Schema.String, expression: Schema.String, category: Schema.optional(Schema.String)});
export const FlowNodeInputs = Schema.Array(FlowNodeInput);
export const FlowNodeOutput = Schema.Struct({name: Schema.String, type: Schema.String});
export const FlowNodeOutputs = Schema.Array(FlowNodeOutput);
export const LexFlowNodeConfiguration = Schema.Struct({botAliasArn: Schema.String, localeId: Schema.String});
export const LambdaFunctionFlowNodeConfiguration = Schema.Struct({lambdaArn: Schema.String});
export const AgentFlowNodeConfiguration = Schema.Struct({agentAliasArn: Schema.String});
export const InlineCodeFlowNodeConfiguration = Schema.Struct({code: Schema.String, language: Schema.String});
export const GuardrailConfiguration = Schema.Struct({guardrailIdentifier: Schema.optional(Schema.String), guardrailVersion: Schema.optional(Schema.String)});
export const KnowledgeBasePromptTemplate = Schema.Struct({textPromptTemplate: Schema.optional(Schema.String)});
export const StopSequences = Schema.Array(Schema.String);
export const PromptModelInferenceConfiguration = Schema.Struct({temperature: Schema.optional(Schema.Number), topP: Schema.optional(Schema.Number), maxTokens: Schema.optional(Schema.Number), stopSequences: Schema.optional(StopSequences)});
export const PromptInferenceConfiguration = Schema.Union(PromptModelInferenceConfiguration);
export const AdditionalModelRequestFields = Schema.Record({key: Schema.String, value: Schema.JsonValue});
export const VectorSearchBedrockRerankingModelConfiguration = Schema.Struct({modelArn: Schema.String, additionalModelRequestFields: Schema.optional(AdditionalModelRequestFields)});
export const FieldForReranking = Schema.Struct({fieldName: Schema.String});
export const FieldsForReranking = Schema.Array(FieldForReranking);
export const RerankingMetadataSelectiveModeConfiguration = Schema.Union(FieldsForReranking, FieldsForReranking);
export const MetadataConfigurationForReranking = Schema.Struct({selectionMode: Schema.String, selectiveModeConfiguration: Schema.optional(RerankingMetadataSelectiveModeConfiguration)});
export const VectorSearchBedrockRerankingConfiguration = Schema.Struct({modelConfiguration: VectorSearchBedrockRerankingModelConfiguration, numberOfRerankedResults: Schema.optional(Schema.Number), metadataConfiguration: Schema.optional(MetadataConfigurationForReranking)});
export const VectorSearchRerankingConfiguration = Schema.Struct({type: Schema.String, bedrockRerankingConfiguration: Schema.optional(VectorSearchBedrockRerankingConfiguration)});
export const PerformanceConfiguration = Schema.Struct({latency: Schema.optional(Schema.String)});
export const KnowledgeBaseOrchestrationConfiguration = Schema.Struct({promptTemplate: Schema.optional(KnowledgeBasePromptTemplate), inferenceConfig: Schema.optional(PromptInferenceConfiguration), additionalModelRequestFields: Schema.optional(AdditionalModelRequestFields), performanceConfig: Schema.optional(PerformanceConfiguration)});
export const KnowledgeBaseFlowNodeConfiguration = Schema.Struct({knowledgeBaseId: Schema.String, modelId: Schema.optional(Schema.String), guardrailConfiguration: Schema.optional(GuardrailConfiguration), numberOfResults: Schema.optional(Schema.Number), promptTemplate: Schema.optional(KnowledgeBasePromptTemplate), inferenceConfiguration: Schema.optional(PromptInferenceConfiguration), rerankingConfiguration: Schema.optional(VectorSearchRerankingConfiguration), orchestrationConfiguration: Schema.optional(KnowledgeBaseOrchestrationConfiguration)});
export const FlowCondition = Schema.Struct({name: Schema.String, expression: Schema.optional(Schema.String)});
export const FlowConditions = Schema.Array(FlowCondition);
export const ConditionFlowNodeConfiguration = Schema.Struct({conditions: FlowConditions});
export const PromptFlowNodeResourceConfiguration = Schema.Struct({promptArn: Schema.String});
export const CachePointBlock = Schema.Struct({type: Schema.String});
export const PromptInputVariable = Schema.Struct({name: Schema.optional(Schema.String)});
export const PromptInputVariablesList = Schema.Array(PromptInputVariable);
export const TextPromptTemplateConfiguration = Schema.Struct({text: Schema.String, cachePoint: Schema.optional(CachePointBlock), inputVariables: Schema.optional(PromptInputVariablesList)});
export const ContentBlock = Schema.Union(Schema.String, CachePointBlock);
export const ContentBlocks = Schema.Array(ContentBlock);
export const Message = Schema.Struct({role: Schema.String, content: ContentBlocks});
export const Messages = Schema.Array(Message);
export const SystemContentBlock = Schema.Union(Schema.String, CachePointBlock);
export const SystemContentBlocks = Schema.Array(SystemContentBlock);
export const ToolInputSchema = Schema.Union(Schema.JsonValue);
export const ToolSpecification = Schema.Struct({name: Schema.String, description: Schema.optional(Schema.String), inputSchema: ToolInputSchema});
export const Tool = Schema.Union(ToolSpecification, CachePointBlock);
export const Tools = Schema.Array(Tool);
export const AutoToolChoice = Schema.Struct({});
export const AnyToolChoice = Schema.Struct({});
export const SpecificToolChoice = Schema.Struct({name: Schema.String});
export const ToolChoice = Schema.Union(AutoToolChoice, AnyToolChoice, SpecificToolChoice);
export const ToolConfiguration = Schema.Struct({tools: Tools, toolChoice: Schema.optional(ToolChoice)});
export const ChatPromptTemplateConfiguration = Schema.Struct({messages: Messages, system: Schema.optional(SystemContentBlocks), inputVariables: Schema.optional(PromptInputVariablesList), toolConfiguration: Schema.optional(ToolConfiguration)});
export const PromptTemplateConfiguration = Schema.Union(TextPromptTemplateConfiguration, ChatPromptTemplateConfiguration);
export const PromptFlowNodeInlineConfiguration = Schema.Struct({templateType: Schema.String, templateConfiguration: PromptTemplateConfiguration, modelId: Schema.String, inferenceConfiguration: Schema.optional(PromptInferenceConfiguration), additionalModelRequestFields: Schema.optional(Schema.JsonValue)});
export const PromptFlowNodeSourceConfiguration = Schema.Union(PromptFlowNodeResourceConfiguration, PromptFlowNodeInlineConfiguration);
export const PromptFlowNodeConfiguration = Schema.Struct({sourceConfiguration: PromptFlowNodeSourceConfiguration, guardrailConfiguration: Schema.optional(GuardrailConfiguration)});
export const StorageFlowNodeS3Configuration = Schema.Struct({bucketName: Schema.String});
export const StorageFlowNodeServiceConfiguration = Schema.Union(StorageFlowNodeS3Configuration);
export const StorageFlowNodeConfiguration = Schema.Struct({serviceConfiguration: StorageFlowNodeServiceConfiguration});
export const RetrievalFlowNodeS3Configuration = Schema.Struct({bucketName: Schema.String});
export const RetrievalFlowNodeServiceConfiguration = Schema.Union(RetrievalFlowNodeS3Configuration);
export const RetrievalFlowNodeConfiguration = Schema.Struct({serviceConfiguration: RetrievalFlowNodeServiceConfiguration});
export const LoopControllerFlowNodeConfiguration = Schema.Struct({continueCondition: FlowCondition, maxIterations: Schema.optional(Schema.Number)});
export const FlowNodeConfiguration = Schema.Union(InputFlowNodeConfiguration, OutputFlowNodeConfiguration, KnowledgeBaseFlowNodeConfiguration, ConditionFlowNodeConfiguration, LexFlowNodeConfiguration, PromptFlowNodeConfiguration, LambdaFunctionFlowNodeConfiguration, StorageFlowNodeConfiguration, AgentFlowNodeConfiguration, RetrievalFlowNodeConfiguration, IteratorFlowNodeConfiguration, CollectorFlowNodeConfiguration, InlineCodeFlowNodeConfiguration, LoopFlowNodeConfiguration, LoopInputFlowNodeConfiguration, LoopControllerFlowNodeConfiguration);
export const FlowNode = Schema.Struct({name: Schema.String, type: Schema.String, configuration: Schema.optional(FlowNodeConfiguration), inputs: Schema.optional(FlowNodeInputs), outputs: Schema.optional(FlowNodeOutputs)});
export const FlowNodes = Schema.Array(FlowNode);
export const FlowDataConnectionConfiguration = Schema.Struct({sourceOutput: Schema.String, targetInput: Schema.String});
export const FlowConditionalConnectionConfiguration = Schema.Struct({condition: Schema.String});
export const FlowConnectionConfiguration = Schema.Union(FlowDataConnectionConfiguration, FlowConditionalConnectionConfiguration);
export const FlowConnection = Schema.Struct({type: Schema.String, name: Schema.String, source: Schema.String, target: Schema.String, configuration: Schema.optional(FlowConnectionConfiguration)});
export const FlowConnections = Schema.Array(FlowConnection);
export const FlowDefinition = Schema.Struct({nodes: Schema.optional(FlowNodes), connections: Schema.optional(FlowConnections)});
export const LoopFlowNodeConfiguration = Schema.Struct({definition: FlowDefinition});
export const ValidateFlowDefinitionRequest = Schema.Struct({definition: FlowDefinition});
export const MissingEndingNodesFlowValidationDetails = Schema.Struct({});
export const MissingStartingNodesFlowValidationDetails = Schema.Struct({});
export const UnspecifiedFlowValidationDetails = Schema.Struct({});
export const CyclicConnectionFlowValidationDetails = Schema.Struct({connection: Schema.String});
export const DuplicateConnectionsFlowValidationDetails = Schema.Struct({source: Schema.String, target: Schema.String});
export const DuplicateConditionExpressionFlowValidationDetails = Schema.Struct({node: Schema.String, expression: Schema.String});
export const UnreachableNodeFlowValidationDetails = Schema.Struct({node: Schema.String});
export const UnknownConnectionSourceFlowValidationDetails = Schema.Struct({connection: Schema.String});
export const UnknownConnectionSourceOutputFlowValidationDetails = Schema.Struct({connection: Schema.String});
export const UnknownConnectionTargetFlowValidationDetails = Schema.Struct({connection: Schema.String});
export const UnknownConnectionTargetInputFlowValidationDetails = Schema.Struct({connection: Schema.String});
export const UnknownConnectionConditionFlowValidationDetails = Schema.Struct({connection: Schema.String});
export const MalformedConditionExpressionFlowValidationDetails = Schema.Struct({node: Schema.String, condition: Schema.String, cause: Schema.String});
export const MalformedNodeInputExpressionFlowValidationDetails = Schema.Struct({node: Schema.String, input: Schema.String, cause: Schema.String});
export const MismatchedNodeInputTypeFlowValidationDetails = Schema.Struct({node: Schema.String, input: Schema.String, expectedType: Schema.String});
export const MismatchedNodeOutputTypeFlowValidationDetails = Schema.Struct({node: Schema.String, output: Schema.String, expectedType: Schema.String});
export const IncompatibleConnectionDataTypeFlowValidationDetails = Schema.Struct({connection: Schema.String});
export const MissingConnectionConfigurationFlowValidationDetails = Schema.Struct({connection: Schema.String});
export const MissingDefaultConditionFlowValidationDetails = Schema.Struct({node: Schema.String});
export const MissingNodeConfigurationFlowValidationDetails = Schema.Struct({node: Schema.String});
export const MissingNodeInputFlowValidationDetails = Schema.Struct({node: Schema.String, input: Schema.String});
export const MissingNodeOutputFlowValidationDetails = Schema.Struct({node: Schema.String, output: Schema.String});
export const MultipleNodeInputConnectionsFlowValidationDetails = Schema.Struct({node: Schema.String, input: Schema.String});
export const UnfulfilledNodeInputFlowValidationDetails = Schema.Struct({node: Schema.String, input: Schema.String});
export const UnsatisfiedConnectionConditionsFlowValidationDetails = Schema.Struct({connection: Schema.String});
export const UnknownNodeInputFlowValidationDetails = Schema.Struct({node: Schema.String, input: Schema.String});
export const UnknownNodeOutputFlowValidationDetails = Schema.Struct({node: Schema.String, output: Schema.String});
export const MissingLoopInputNodeFlowValidationDetails = Schema.Struct({loopNode: Schema.String});
export const MissingLoopControllerNodeFlowValidationDetails = Schema.Struct({loopNode: Schema.String});
export const MultipleLoopInputNodesFlowValidationDetails = Schema.Struct({loopNode: Schema.String});
export const MultipleLoopControllerNodesFlowValidationDetails = Schema.Struct({loopNode: Schema.String});
export const LoopIncompatibleNodeTypeFlowValidationDetails = Schema.Struct({node: Schema.String, incompatibleNodeType: Schema.String, incompatibleNodeName: Schema.String});
export const InvalidLoopBoundaryFlowValidationDetails = Schema.Struct({connection: Schema.String, source: Schema.String, target: Schema.String});
export const FlowValidationDetails = Schema.Union(CyclicConnectionFlowValidationDetails, DuplicateConnectionsFlowValidationDetails, DuplicateConditionExpressionFlowValidationDetails, UnreachableNodeFlowValidationDetails, UnknownConnectionSourceFlowValidationDetails, UnknownConnectionSourceOutputFlowValidationDetails, UnknownConnectionTargetFlowValidationDetails, UnknownConnectionTargetInputFlowValidationDetails, UnknownConnectionConditionFlowValidationDetails, MalformedConditionExpressionFlowValidationDetails, MalformedNodeInputExpressionFlowValidationDetails, MismatchedNodeInputTypeFlowValidationDetails, MismatchedNodeOutputTypeFlowValidationDetails, IncompatibleConnectionDataTypeFlowValidationDetails, MissingConnectionConfigurationFlowValidationDetails, MissingDefaultConditionFlowValidationDetails, MissingEndingNodesFlowValidationDetails, MissingNodeConfigurationFlowValidationDetails, MissingNodeInputFlowValidationDetails, MissingNodeOutputFlowValidationDetails, MissingStartingNodesFlowValidationDetails, MultipleNodeInputConnectionsFlowValidationDetails, UnfulfilledNodeInputFlowValidationDetails, UnsatisfiedConnectionConditionsFlowValidationDetails, UnspecifiedFlowValidationDetails, UnknownNodeInputFlowValidationDetails, UnknownNodeOutputFlowValidationDetails, MissingLoopInputNodeFlowValidationDetails, MissingLoopControllerNodeFlowValidationDetails, MultipleLoopInputNodesFlowValidationDetails, MultipleLoopControllerNodesFlowValidationDetails, LoopIncompatibleNodeTypeFlowValidationDetails, InvalidLoopBoundaryFlowValidationDetails);
export const FlowValidation = Schema.Struct({message: Schema.String, severity: Schema.String, details: Schema.optional(FlowValidationDetails), type: Schema.optional(Schema.String)});
export const FlowValidations = Schema.Array(FlowValidation);
export const ValidateFlowDefinitionResponse = Schema.Struct({validations: FlowValidations});
export const AccessDeniedException = Schema.Struct({message: Schema.optional(Schema.String)});
export const InternalServerException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ThrottlingException = Schema.Struct({message: Schema.optional(Schema.String)});
export const ValidationExceptionField = Schema.Struct({name: Schema.String, message: Schema.String});
export const ValidationExceptionFieldList = Schema.Array(ValidationExceptionField);
export const ValidationException = Schema.Struct({message: Schema.optional(Schema.String), fieldList: Schema.optional(ValidationExceptionFieldList)});

//# Errors
export class AccessDeniedExceptionError extends Schema.TaggedError<AccessDeniedExceptionError>()("AccessDeniedException", AccessDeniedException) {};
export class InternalServerExceptionError extends Schema.TaggedError<InternalServerExceptionError>()("InternalServerException", InternalServerException) {};
export class ThrottlingExceptionError extends Schema.TaggedError<ThrottlingExceptionError>()("ThrottlingException", ThrottlingException) {};
export class ValidationExceptionError extends Schema.TaggedError<ValidationExceptionError>()("ValidationException", ValidationException) {};

//# Operations
export const validateFlowDefinition = /*#__PURE__*/ makeOperation(() => Operation({ version: "2023-06-05", uri: "/flows/validate-definition", method: "POST", sdkId: "Bedrock Agent", sigV4ServiceName: "bedrock", name: "AmazonBedrockAgentBuildTimeLambda.ValidateFlowDefinition" }, ValidateFlowDefinitionRequest, ValidateFlowDefinitionResponse, [AccessDeniedExceptionError, InternalServerExceptionError, ThrottlingExceptionError, ValidationExceptionError]), FormatJSONRequest, FormatJSONResponse, FormatAwsRestJSONError);
