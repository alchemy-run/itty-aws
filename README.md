# distilled-aws

An **Effect-native AWS SDK** generated directly from [Smithy](https://smithy.io) specifications. Built with [Effect Schema](https://effect.website/docs/schema/introduction) and [Effect Platform](https://effect.website/docs/platform/introduction), this SDK brings full type-safety, composability, and streaming support to AWS API operations.

## Features

- **Generated from Smithy specs** — Auto-generated from AWS's official [Smithy models](https://github.com/aws/aws-models), ensuring 1:1 compatibility with AWS APIs
- **Effect-native** — Operations return `Effect` computations with typed errors, automatic retries, and interruption support
- **Schema-driven** — All request/response shapes are Effect Schemas with automatic validation and transformation
- **Smithy traits as annotations** — HTTP bindings, XML/JSON serialization, timestamps, and more are modeled as Effect Schema annotations
- **Full protocol support** — Implements all five AWS protocols: REST-XML, REST-JSON, AWS JSON 1.0/1.1, AWS Query, and EC2 Query
- **Streaming support** — First-class support for streaming uploads and downloads via Effect Streams
- **Tree-shakeable** — Protocol implementations are embedded in service annotations for optimal bundle size

## Installation

```bash
bun add distilled-aws-sdk effect
```

## Quick Start

```typescript
import * as Effect from "effect/Effect";
import { S3 } from "distilled-aws-sdk/s3";
import { Credentials, NodeProviderChainCredentialsLive, Region } from "distilled-aws-sdk";

// Call the operation
const program = S3.getObject({
  Bucket: "my-bucket",
  Key: "hello.txt",
});

// Provide required services and run
const result = await program.pipe(
  Effect.provideService(Region, "us-east-1"),
  Effect.provide(NodeProviderChainCredentialsLive),
  Effect.runPromise,
);

console.log(result.ContentType); // "text/plain"
```

## Architecture

### Code Generation

Services are generated by [`scripts/generate-clients.ts`](./scripts/generate-clients.ts) from the [Smithy JSON AST models](./aws-models/models/). The generator:

1. Parses Smithy service shapes (structures, operations, errors)
2. Resolves cyclic dependencies using `S.suspend()`
3. Translates Smithy traits to Effect Schema annotations
4. Outputs TypeScript files to [`src/services/`](./src/services/)

```bash
# Generate a single service
bun generate --sdk s3

# Generate all services
bun generate
```

### Smithy Traits as Annotations

Smithy traits are modeled 1:1 with Effect Schema annotations in [`src/traits.ts`](./src/traits.ts). This allows protocol implementations to introspect schemas and serialize/deserialize correctly.

| Smithy Trait | Effect Annotation | Purpose |
|--------------|-------------------|---------|
| `@httpLabel` | `T.HttpLabel()` | Bind member to URI path parameter |
| `@httpHeader` | `T.HttpHeader("X-Custom")` | Bind member to HTTP header |
| `@httpQuery` | `T.HttpQuery("param")` | Bind member to query string |
| `@httpPayload` | `T.HttpPayload()` | Bind member to request/response body |
| `@httpPrefixHeaders` | `T.HttpPrefixHeaders("x-amz-meta-")` | Bind map to prefixed headers |
| `@xmlName` | `T.XmlName("CustomName")` | Custom XML element name |
| `@xmlFlattened` | `T.XmlFlattened()` | Flatten list/map (no wrapper) |
| `@xmlAttribute` | `T.XmlAttribute()` | Serialize as XML attribute |
| `@xmlNamespace` | `T.XmlNamespace("http://...")` | XML namespace URI |
| `@jsonName` | `T.JsonName("custom_name")` | Custom JSON key (uses `S.fromKey`) |
| `@timestampFormat` | `T.TimestampFormat("http-date")` | Timestamp wire format |
| `@streaming` | `T.Streaming()` | Streaming blob type |
| `@contextParam` | `T.ContextParam("Bucket")` | Endpoint resolution parameter |

## Generated Code Examples

### Request Schema

Request schemas are Effect `S.Class` definitions with HTTP binding annotations:

```typescript
export class GetObjectRequest extends S.Class<GetObjectRequest>(
  "GetObjectRequest",
)(
  {
    // Path parameters
    Bucket: S.String.pipe(T.HttpLabel(), T.ContextParam("Bucket")),
    Key: S.String.pipe(T.HttpLabel(), T.ContextParam("Key")),

    // HTTP headers with timestamp formatting
    IfModifiedSince: S.optional(
      S.Date.pipe(T.TimestampFormat("http-date")),
    ).pipe(T.HttpHeader("If-Modified-Since")),
    IfMatch: S.optional(S.String).pipe(T.HttpHeader("If-Match")),
    Range: S.optional(S.String).pipe(T.HttpHeader("Range")),

    // Query parameters
    VersionId: S.optional(S.String).pipe(T.HttpQuery("versionId")),
    PartNumber: S.optional(S.Number).pipe(T.HttpQuery("partNumber")),
  },
  T.all(
    T.XmlNamespace("http://s3.amazonaws.com/doc/2006-03-01/"),
    T.Http({ method: "GET", uri: "/{Bucket}/{Key+}?x-id=GetObject" }),
    T.AwsApiService({ sdkId: "S3" }),
    T.AwsAuthSigv4({ name: "s3" }),
    T.AwsProtocolsRestXml(),
    T.ServiceVersion("2006-03-01"),
    T.EndpointRuleSet({ /* ... */ }),
  ),
) {}
```

### Output Schema

Response schemas extract data from headers and body:

```typescript
export class GetObjectOutput extends S.Class<GetObjectOutput>(
  "GetObjectOutput",
)(
  {
    // Streaming body payload
    Body: S.optional(T.StreamingOutput).pipe(T.HttpPayload()),

    // Response headers
    ContentLength: S.optional(S.Number).pipe(T.HttpHeader("Content-Length")),
    ContentType: S.optional(S.String).pipe(T.HttpHeader("Content-Type")),
    ETag: S.optional(S.String).pipe(T.HttpHeader("ETag")),
    LastModified: S.optional(
      S.Date.pipe(T.TimestampFormat("http-date"))
    ).pipe(T.HttpHeader("Last-Modified")),
    VersionId: S.optional(S.String).pipe(T.HttpHeader("x-amz-version-id")),
    DeleteMarker: S.optional(S.Boolean).pipe(T.HttpHeader("x-amz-delete-marker")),
  },
) {}
```

### Error Schema

Errors are `S.TaggedError` classes for typed error handling:

```typescript
export class NoSuchKey extends S.TaggedError<NoSuchKey>()("NoSuchKey", {}) {}

export class InvalidObjectState extends S.TaggedError<InvalidObjectState>()(
  "InvalidObjectState",
  {
    StorageClass: S.optional(S.String),
    AccessTier: S.optional(S.String),
  },
) {}
```

### Operation Definition

Operations tie input, output, and errors together:

```typescript
export const getObject = /*@__PURE__*/ API.make(() => ({
  input: GetObjectRequest,
  output: GetObjectOutput,
  errors: [InvalidObjectState, NoSuchKey],
}));
```

The `API.make()` function ([`src/api.ts`](./src/api.ts)) creates an Effect-returning function that:

1. Extracts the protocol from input schema annotations
2. Serializes the request using the protocol
3. Applies middleware (checksums, etc.)
4. Signs the request with AWS SigV4
5. Resolves the endpoint using the rules engine
6. Makes the HTTP request
7. Deserializes the response or error

## Protocols

All AWS protocols are implemented in [`src/protocols/`](./src/protocols/):

### REST-XML (`aws.protocols#restXml`)

Used by: **S3**, **CloudFront**, **Route 53**

- HTTP methods: GET, PUT, POST, DELETE based on `@http` trait
- Request/response bodies serialized as XML
- Supports `@xmlName`, `@xmlFlattened`, `@xmlAttribute`, `@xmlNamespace` traits
- HTTP binding traits for headers, query params, and path labels
- Error responses wrapped in `<ErrorResponse><Error>...</Error></ErrorResponse>`

```typescript
// Request serialization
headers: { "Content-Type": "application/xml" }
body: "<CreateBucketConfiguration xmlns=\"...\">...</CreateBucketConfiguration>"

// Response deserialization
// Parses XML body and extracts header-bound values
```

### REST-JSON (`aws.protocols#restJson1`)

Used by: **Lambda**, **API Gateway**, **DynamoDB Streams**, **Glacier**

- HTTP methods based on `@http` trait
- Request/response bodies serialized as JSON
- `@jsonName` trait for custom property keys (via `S.fromKey`)
- Default timestamp format: `epoch-seconds`
- HTTP binding traits for headers, query params, and path labels
- Error code from `x-amzn-errortype` header or body `__type` field

```typescript
// Request serialization
headers: { "Content-Type": "application/json" }
body: JSON.stringify({ functionName: "my-func", payload: "..." })

// Response deserialization
// Parses JSON body and extracts header-bound values
```

### AWS JSON 1.0 & 1.1 (`aws.protocols#awsJson1_0`, `aws.protocols#awsJson1_1`)

Used by: **DynamoDB** (1.0), **SQS** (1.0), **SNS** (1.0), **STS** (1.1), **KMS** (1.1)

- All requests: `POST /`
- Target operation via `X-Amz-Target: ServiceName.OperationName` header
- Request/response bodies always JSON
- HTTP binding traits are ignored
- Default timestamp format: `epoch-seconds`
- Content-Type: `application/x-amz-json-1.0` or `application/x-amz-json-1.1`

```typescript
// Request serialization
method: "POST"
path: "/"
headers: {
  "Content-Type": "application/x-amz-json-1.1",
  "X-Amz-Target": "DynamoDB_20120810.GetItem"
}
body: JSON.stringify({ TableName: "users", Key: { ... } })
```

### AWS Query (`aws.protocols#awsQuery`)

Used by: **IAM**, **STS**, **SES**, **CloudWatch**, **Auto Scaling**, **Elastic Load Balancing**

- All requests: `POST /` with `application/x-www-form-urlencoded` body
- `Action` and `Version` parameters identify the operation
- Query key names from `@xmlName` trait or member name
- Lists use `.member.N` format by default
- Maps use `.entry.N.key` and `.entry.N.value` format
- Response wrapped in `<{Op}Response><{Op}Result>...</{Op}Result></...>`
- Errors wrapped in `<ErrorResponse><Error><Code>...</Code></Error></ErrorResponse>`

```typescript
// Request serialization
method: "POST"
path: "/"
headers: { "Content-Type": "application/x-www-form-urlencoded" }
body: "Action=GetUser&Version=2010-05-08&UserName=johndoe"

// Response (XML)
<GetUserResponse xmlns="...">
  <GetUserResult>
    <User><UserName>johndoe</UserName>...</User>
  </GetUserResult>
</GetUserResponse>
```

### EC2 Query (`aws.protocols#ec2Query`)

Used by: **EC2**

- Similar to AWS Query but with EC2-specific conventions
- Uses `@ec2QueryName` trait for custom query key names
- All lists are flattened (no `.member.` wrapper)
- Query keys have first letter capitalized
- Response root is `{OperationName}Response` (no result wrapper)
- Errors wrapped in `<Response><Errors><Error>...</Error></Errors></Response>`

```typescript
// Request serialization
method: "POST"
path: "/"
headers: { "Content-Type": "application/x-www-form-urlencoded" }
body: "Action=DescribeInstances&Version=2016-11-15&InstanceId.1=i-12345"
```

## Streaming

The SDK provides first-class streaming support for large payloads:

### Streaming Uploads

```typescript
import * as Stream from "effect/Stream";
import { S3 } from "distilled-aws-sdk/s3";

// Stream from a file
const fileStream = Stream.fromReadableStream(
  () => Bun.file("large-file.zip").stream(),
  () => new Error("Stream error"),
);

await S3.putObject({
  Bucket: "my-bucket",
  Key: "large-file.zip",
  Body: fileStream,
  ContentType: "application/zip",
}).pipe(
  Effect.provideService(Region, "us-east-1"),
  Effect.provide(NodeProviderChainCredentialsLive),
  Effect.runPromise,
);
```

### Streaming Downloads

```typescript
const result = await S3.getObject({
  Bucket: "my-bucket",
  Key: "large-file.zip",
}).pipe(
  Effect.provideService(Region, "us-east-1"),
  Effect.provide(NodeProviderChainCredentialsLive),
  Effect.runPromise,
);

// result.Body is a Stream.Stream<Uint8Array, Error, never>
await Stream.run(
  result.Body!,
  Sink.forEach((chunk) => Effect.sync(() => process.stdout.write(chunk))),
);
```

## Error Handling

All operations return typed errors that can be pattern-matched:

```typescript
import { Effect, Match } from "effect";
import { S3 } from "distilled-aws-sdk/s3";

const program = S3.getObject({
  Bucket: "my-bucket",
  Key: "missing-file.txt",
}).pipe(
  Effect.catchTags({
    NoSuchKey: (error) =>
      Effect.succeed({ found: false, key: "missing-file.txt" }),
    InvalidObjectState: (error) =>
      Effect.fail(new Error(`Object in ${error.StorageClass} storage`)),
  }),
);
```

## Testing

```bash
# Run protocol tests
bun test:protocols

# Run a single protocol test suite
bun vitest run ./test/protocols/rest-xml.test.ts

# Run S3 service tests (requires LocalStack)
bun test:local ./test/services/s3.test.ts

# Run all service tests
bun test:local ./test/services/
```

## License

MIT

